(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["nx-cc"] = factory(require("vue"));
	else
		root["nx-cc"] = factory(root["Vue"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__7203__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9662:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var tryToString = __webpack_require__(6330);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 6077:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 5787:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(7976);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 9670:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(111);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 4019:
/***/ (function(module) {

// eslint-disable-next-line es-x/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ 260:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(4019);
var DESCRIPTORS = __webpack_require__(9781);
var global = __webpack_require__(7854);
var isCallable = __webpack_require__(614);
var isObject = __webpack_require__(111);
var hasOwn = __webpack_require__(2597);
var classof = __webpack_require__(648);
var tryToString = __webpack_require__(6330);
var createNonEnumerableProperty = __webpack_require__(8880);
var defineBuiltIn = __webpack_require__(8052);
var defineProperty = (__webpack_require__(3070).f);
var isPrototypeOf = __webpack_require__(7976);
var getPrototypeOf = __webpack_require__(9518);
var setPrototypeOf = __webpack_require__(7674);
var wellKnownSymbol = __webpack_require__(5112);
var uid = __webpack_require__(9711);
var InternalStateModule = __webpack_require__(9909);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 1318:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(5656);
var toAbsoluteIndex = __webpack_require__(1400);
var lengthOfArrayLike = __webpack_require__(6244);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 9671:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var bind = __webpack_require__(9974);
var IndexedObject = __webpack_require__(8361);
var toObject = __webpack_require__(7908);
var lengthOfArrayLike = __webpack_require__(6244);

// `Array.prototype.{ findLast, findLastIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_FIND_LAST_INDEX = TYPE == 1;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var index = lengthOfArrayLike(self);
    var value, result;
    while (index-- > 0) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (result) switch (TYPE) {
        case 0: return value; // findLast
        case 1: return index; // findLastIndex
      }
    }
    return IS_FIND_LAST_INDEX ? -1 : undefined;
  };
};

module.exports = {
  // `Array.prototype.findLast` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLast: createMethod(0),
  // `Array.prototype.findLastIndex` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLastIndex: createMethod(1)
};


/***/ }),

/***/ 4326:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 648:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(1694);
var isCallable = __webpack_require__(614);
var classofRaw = __webpack_require__(4326);
var wellKnownSymbol = __webpack_require__(5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7741:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ 9920:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasOwn = __webpack_require__(2597);
var ownKeys = __webpack_require__(3887);
var getOwnPropertyDescriptorModule = __webpack_require__(1236);
var definePropertyModule = __webpack_require__(3070);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 8544:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 8880:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var definePropertyModule = __webpack_require__(3070);
var createPropertyDescriptor = __webpack_require__(9114);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 9114:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 8052:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var definePropertyModule = __webpack_require__(3070);
var makeBuiltIn = __webpack_require__(6339);
var defineGlobalProperty = __webpack_require__(3072);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 3072:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 9781:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 317:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var isObject = __webpack_require__(111);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 3678:
/***/ (function(module) {

module.exports = {
  IndexSizeError: { s: 'INDEX_SIZE_ERR', c: 1, m: 1 },
  DOMStringSizeError: { s: 'DOMSTRING_SIZE_ERR', c: 2, m: 0 },
  HierarchyRequestError: { s: 'HIERARCHY_REQUEST_ERR', c: 3, m: 1 },
  WrongDocumentError: { s: 'WRONG_DOCUMENT_ERR', c: 4, m: 1 },
  InvalidCharacterError: { s: 'INVALID_CHARACTER_ERR', c: 5, m: 1 },
  NoDataAllowedError: { s: 'NO_DATA_ALLOWED_ERR', c: 6, m: 0 },
  NoModificationAllowedError: { s: 'NO_MODIFICATION_ALLOWED_ERR', c: 7, m: 1 },
  NotFoundError: { s: 'NOT_FOUND_ERR', c: 8, m: 1 },
  NotSupportedError: { s: 'NOT_SUPPORTED_ERR', c: 9, m: 1 },
  InUseAttributeError: { s: 'INUSE_ATTRIBUTE_ERR', c: 10, m: 1 },
  InvalidStateError: { s: 'INVALID_STATE_ERR', c: 11, m: 1 },
  SyntaxError: { s: 'SYNTAX_ERR', c: 12, m: 1 },
  InvalidModificationError: { s: 'INVALID_MODIFICATION_ERR', c: 13, m: 1 },
  NamespaceError: { s: 'NAMESPACE_ERR', c: 14, m: 1 },
  InvalidAccessError: { s: 'INVALID_ACCESS_ERR', c: 15, m: 1 },
  ValidationError: { s: 'VALIDATION_ERR', c: 16, m: 0 },
  TypeMismatchError: { s: 'TYPE_MISMATCH_ERR', c: 17, m: 1 },
  SecurityError: { s: 'SECURITY_ERR', c: 18, m: 1 },
  NetworkError: { s: 'NETWORK_ERR', c: 19, m: 1 },
  AbortError: { s: 'ABORT_ERR', c: 20, m: 1 },
  URLMismatchError: { s: 'URL_MISMATCH_ERR', c: 21, m: 1 },
  QuotaExceededError: { s: 'QUOTA_EXCEEDED_ERR', c: 22, m: 1 },
  TimeoutError: { s: 'TIMEOUT_ERR', c: 23, m: 1 },
  InvalidNodeTypeError: { s: 'INVALID_NODE_TYPE_ERR', c: 24, m: 1 },
  DataCloneError: { s: 'DATA_CLONE_ERR', c: 25, m: 1 }
};


/***/ }),

/***/ 8113:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(5005);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 7392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var userAgent = __webpack_require__(8113);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 748:
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2914:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);
var createPropertyDescriptor = __webpack_require__(9114);

module.exports = !fails(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es-x/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});


/***/ }),

/***/ 2109:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var getOwnPropertyDescriptor = (__webpack_require__(1236).f);
var createNonEnumerableProperty = __webpack_require__(8880);
var defineBuiltIn = __webpack_require__(8052);
var defineGlobalProperty = __webpack_require__(3072);
var copyConstructorProperties = __webpack_require__(9920);
var isForced = __webpack_require__(4705);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 7293:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 2104:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(4374);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es-x/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 9974:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var aCallable = __webpack_require__(9662);
var NATIVE_BIND = __webpack_require__(4374);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 4374:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 6916:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(4374);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 6530:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var hasOwn = __webpack_require__(2597);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 1702:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(4374);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 5005:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var isCallable = __webpack_require__(614);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 8173:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aCallable = __webpack_require__(9662);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 7854:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 2597:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var toObject = __webpack_require__(7908);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 3501:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 4664:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var fails = __webpack_require__(7293);
var createElement = __webpack_require__(317);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 8361:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var fails = __webpack_require__(7293);
var classof = __webpack_require__(4326);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 9587:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);
var isObject = __webpack_require__(111);
var setPrototypeOf = __webpack_require__(7674);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 2788:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var isCallable = __webpack_require__(614);
var store = __webpack_require__(5465);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 8340:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(111);
var createNonEnumerableProperty = __webpack_require__(8880);

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};


/***/ }),

/***/ 9909:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(8536);
var global = __webpack_require__(7854);
var uncurryThis = __webpack_require__(1702);
var isObject = __webpack_require__(111);
var createNonEnumerableProperty = __webpack_require__(8880);
var hasOwn = __webpack_require__(2597);
var shared = __webpack_require__(5465);
var sharedKey = __webpack_require__(6200);
var hiddenKeys = __webpack_require__(3501);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 614:
/***/ (function(module) {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 4705:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);
var isCallable = __webpack_require__(614);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 111:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(614);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 1913:
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 2190:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(5005);
var isCallable = __webpack_require__(614);
var isPrototypeOf = __webpack_require__(7976);
var USE_SYMBOL_AS_UID = __webpack_require__(3307);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6244:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toLength = __webpack_require__(7466);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 6339:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(7293);
var isCallable = __webpack_require__(614);
var hasOwn = __webpack_require__(2597);
var DESCRIPTORS = __webpack_require__(9781);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(6530).CONFIGURABLE);
var inspectSource = __webpack_require__(2788);
var InternalStateModule = __webpack_require__(9909);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 4758:
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 133:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(7392);
var fails = __webpack_require__(7293);

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 8536:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var isCallable = __webpack_require__(614);
var inspectSource = __webpack_require__(2788);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 6277:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toString = __webpack_require__(1340);

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ 3070:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var IE8_DOM_DEFINE = __webpack_require__(4664);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(3353);
var anObject = __webpack_require__(9670);
var toPropertyKey = __webpack_require__(4948);

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 1236:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var call = __webpack_require__(6916);
var propertyIsEnumerableModule = __webpack_require__(5296);
var createPropertyDescriptor = __webpack_require__(9114);
var toIndexedObject = __webpack_require__(5656);
var toPropertyKey = __webpack_require__(4948);
var hasOwn = __webpack_require__(2597);
var IE8_DOM_DEFINE = __webpack_require__(4664);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8006:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(6324);
var enumBugKeys = __webpack_require__(748);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 5181:
/***/ (function(__unused_webpack_module, exports) {

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 9518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasOwn = __webpack_require__(2597);
var isCallable = __webpack_require__(614);
var toObject = __webpack_require__(7908);
var sharedKey = __webpack_require__(6200);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(8544);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es-x/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 7976:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 6324:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);
var hasOwn = __webpack_require__(2597);
var toIndexedObject = __webpack_require__(5656);
var indexOf = (__webpack_require__(1318).indexOf);
var hiddenKeys = __webpack_require__(3501);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 5296:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 7674:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__(1702);
var anObject = __webpack_require__(9670);
var aPossiblePrototype = __webpack_require__(6077);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(6916);
var isCallable = __webpack_require__(614);
var isObject = __webpack_require__(111);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 3887:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(5005);
var uncurryThis = __webpack_require__(1702);
var getOwnPropertyNamesModule = __webpack_require__(8006);
var getOwnPropertySymbolsModule = __webpack_require__(5181);
var anObject = __webpack_require__(9670);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 2626:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = (__webpack_require__(3070).f);

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),

/***/ 4488:
/***/ (function(module) {

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6200:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(2309);
var uid = __webpack_require__(9711);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5465:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var defineGlobalProperty = __webpack_require__(3072);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 2309:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(1913);
var store = __webpack_require__(5465);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.24.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 1400:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__(9303);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5656:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(8361);
var requireObjectCoercible = __webpack_require__(4488);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 9303:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trunc = __webpack_require__(4758);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 7466:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__(9303);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 7908:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(4488);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 7593:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(6916);
var isObject = __webpack_require__(111);
var isSymbol = __webpack_require__(2190);
var getMethod = __webpack_require__(8173);
var ordinaryToPrimitive = __webpack_require__(2140);
var wellKnownSymbol = __webpack_require__(5112);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 4948:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPrimitive = __webpack_require__(7593);
var isSymbol = __webpack_require__(2190);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 1694:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(5112);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 1340:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(648);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6330:
/***/ (function(module) {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 9711:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(1702);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 3307:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(133);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 3353:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(9781);
var fails = __webpack_require__(7293);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 5112:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(7854);
var shared = __webpack_require__(2309);
var hasOwn = __webpack_require__(2597);
var uid = __webpack_require__(9711);
var NATIVE_SYMBOL = __webpack_require__(133);
var USE_SYMBOL_AS_UID = __webpack_require__(3307);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 9191:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(5005);
var hasOwn = __webpack_require__(2597);
var createNonEnumerableProperty = __webpack_require__(8880);
var isPrototypeOf = __webpack_require__(7976);
var setPrototypeOf = __webpack_require__(7674);
var copyConstructorProperties = __webpack_require__(9920);
var proxyAccessor = __webpack_require__(2626);
var inheritIfRequired = __webpack_require__(9587);
var normalizeStringArgument = __webpack_require__(6277);
var installErrorCause = __webpack_require__(8340);
var clearErrorStack = __webpack_require__(7741);
var ERROR_STACK_INSTALLABLE = __webpack_require__(2914);
var DESCRIPTORS = __webpack_require__(9781);
var IS_PURE = __webpack_require__(1913);

module.exports = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = 'stackTraceLimit';
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path = FULL_NAME.split('.');
  var ERROR_NAME = path[path.length - 1];
  var OriginalError = getBuiltIn.apply(null, path);

  if (!OriginalError) return;

  var OriginalErrorPrototype = OriginalError.prototype;

  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
  if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

  if (!FORCED) return OriginalError;

  var BaseError = getBuiltIn('Error');

  var WrappedError = wrapper(function (a, b) {
    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
    if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(result, 'stack', clearErrorStack(result.stack, 2));
    if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
    return result;
  });

  WrappedError.prototype = OriginalErrorPrototype;

  if (ERROR_NAME !== 'Error') {
    if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
    else copyConstructorProperties(WrappedError, BaseError, { name: true });
  } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
  }

  copyConstructorProperties(WrappedError, OriginalError);

  if (!IS_PURE) try {
    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error) { /* empty */ }

  return WrappedError;
};


/***/ }),

/***/ 1703:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-unused-vars -- required for functions `.length` */
var $ = __webpack_require__(2109);
var global = __webpack_require__(7854);
var apply = __webpack_require__(2104);
var wrapErrorConstructorWithCause = __webpack_require__(9191);

var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = global[WEB_ASSEMBLY];

var FORCED = Error('e', { cause: 7 }).cause !== 7;

var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
  $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
};

var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
    $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
  }
};

// https://github.com/tc39/proposal-error-cause
exportGlobalErrorCauseWrapper('Error', function (init) {
  return function Error(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('EvalError', function (init) {
  return function EvalError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('RangeError', function (init) {
  return function RangeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
  return function ReferenceError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
  return function SyntaxError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('TypeError', function (init) {
  return function TypeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('URIError', function (init) {
  return function URIError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
  return function CompileError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
  return function LinkError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
  return function RuntimeError(message) { return apply(init, this, arguments); };
});


/***/ }),

/***/ 8675:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(260);
var lengthOfArrayLike = __webpack_require__(6244);
var toIntegerOrInfinity = __webpack_require__(9303);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
exportTypedArrayMethod('at', function at(index) {
  var O = aTypedArray(this);
  var len = lengthOfArrayLike(O);
  var relativeIndex = toIntegerOrInfinity(index);
  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
  return (k < 0 || k >= len) ? undefined : O[k];
});


/***/ }),

/***/ 4590:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(260);
var $findLastIndex = (__webpack_require__(9671).findLastIndex);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findLastIndex` method
// https://github.com/tc39/proposal-array-find-from-last
exportTypedArrayMethod('findLastIndex', function findLastIndex(predicate /* , thisArg */) {
  return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3408:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(260);
var $findLast = (__webpack_require__(9671).findLast);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findLast` method
// https://github.com/tc39/proposal-array-find-from-last
exportTypedArrayMethod('findLast', function findLast(predicate /* , thisArg */) {
  return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 1118:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: Remove from `core-js@4`
__webpack_require__(4590);


/***/ }),

/***/ 7380:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: Remove from `core-js@4`
__webpack_require__(3408);


/***/ }),

/***/ 2801:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(2109);
var global = __webpack_require__(7854);
var getBuiltIn = __webpack_require__(5005);
var createPropertyDescriptor = __webpack_require__(9114);
var defineProperty = (__webpack_require__(3070).f);
var hasOwn = __webpack_require__(2597);
var anInstance = __webpack_require__(5787);
var inheritIfRequired = __webpack_require__(9587);
var normalizeStringArgument = __webpack_require__(6277);
var DOMExceptionConstants = __webpack_require__(3678);
var clearErrorStack = __webpack_require__(7741);
var DESCRIPTORS = __webpack_require__(9781);
var IS_PURE = __webpack_require__(1913);

var DOM_EXCEPTION = 'DOMException';
var Error = getBuiltIn('Error');
var NativeDOMException = getBuiltIn(DOM_EXCEPTION);

var $DOMException = function DOMException() {
  anInstance(this, DOMExceptionPrototype);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
  var that = new NativeDOMException(message, name);
  var error = Error(message);
  error.name = DOM_EXCEPTION;
  defineProperty(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
  inheritIfRequired(that, this, $DOMException);
  return that;
};

var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;

var ERROR_HAS_STACK = 'stack' in Error(DOM_EXCEPTION);
var DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(global, DOM_EXCEPTION);

// Bun ~ 0.1.1 DOMException have incorrect descriptor and we can't redefine it
// https://github.com/Jarred-Sumner/bun/issues/399
var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);

var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;

// `DOMException` constructor patch for `.stack` where it's required
// https://webidl.spec.whatwg.org/#es-DOMException-specialness
$({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, { // TODO: fix export logic
  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});

var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;

if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
  if (!IS_PURE) {
    defineProperty(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
  }

  for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
    var constant = DOMExceptionConstants[key];
    var constantName = constant.s;
    if (!hasOwn(PolyfilledDOMException, constantName)) {
      defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
    }
  }
}


/***/ }),

/***/ 8927:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(1703);

__webpack_require__(2801);

/**
 *  =================================================================
 * aegis-web-sdk@1.36.5 (c) 2022 TencentCloud Real User Monitoring.
 * Author pumpkincai.
 * Last Release Time Thu Nov 24 2022 16:10:40 GMT+0800 ().
 * Released under the MIT License.
 * Thanks for supporting RUM & Aegis!
 * =================================================================
 **/
!function (e, n) {
   true ? module.exports = n() : 0;
}(this, function () {
  "use strict";

  var U, _;

  function q(e) {
    this.name = "__st" + (1e9 * Math.random() >>> 0) + U + "__", null != e && e.forEach(this.add, this), U += 1;
  }

  Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
    configurable: !0,
    writable: !0,
    value: function (e) {
      if (null === this) throw new TypeError('"this" is null or not defined');
      var n = Object(this),
          t = n.length >>> 0;
      if ("function" != typeof e) throw new TypeError("predicate must be a function");

      for (var o = arguments[1], i = 0; i < t;) {
        var r = n[i];
        if (e.call(o, r, i, n)) return r;
        i += 1;
      }
    }
  }), String.prototype.startsWith || Object.defineProperty(String.prototype, "startsWith", {
    value: function (e, n) {
      return this.substring(n = !n || n < 0 ? 0 : +n, n + e.length) === e;
    }
  }), window.WeakSet || (U = Date.now() % 1e9, q.prototype.add = function (e) {
    var n = this.name;
    return e[n] || Object.defineProperty(e, n, {
      value: !0,
      writable: !0
    }), this;
  }, q.prototype.delete = function (e) {
    return !!e[this.name] && !(e[this.name] = void 0);
  }, q.prototype.has = function (e) {
    return !!e[this.name];
  }, _ = q, Object.defineProperty(window, "WeakSet", {
    value: function (e) {
      return new _(e);
    }
  })), Object.assign || Object.defineProperty(Object, "assign", {
    enumerable: !1,
    configurable: !0,
    writable: !0,
    value: function (e) {
      if (null == e) throw new TypeError("Cannot convert first argument to object");

      for (var n = Object(e), t = 1; t < arguments.length; t++) if (null != (o = arguments[t])) for (var o = Object(o), i = Object.keys(Object(o)), r = 0, s = i.length; r < s; r++) {
        var a = i[r],
            u = Object.getOwnPropertyDescriptor(o, a);
        null != u && u.enumerable && (n[a] = o[a]);
      }

      return n;
    }
  });

  var D = function (e, n) {
    return (D = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (e, n) {
      e.__proto__ = n;
    } || function (e, n) {
      for (var t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    })(e, n);
  },
      E = function () {
    return (E = Object.assign || function (e) {
      for (var n, t = 1, o = arguments.length; t < o; t++) for (var i in n = arguments[t]) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);

      return e;
    }).apply(this, arguments);
  };

  function u() {
    for (var e = 0, n = 0, t = arguments.length; n < t; n++) e += arguments[n].length;

    for (var o = Array(e), i = 0, n = 0; n < t; n++) for (var r = arguments[n], s = 0, a = r.length; s < a; s++, i++) o[i] = r[s];

    return o;
  }

  function F(n) {
    try {
      return encodeURIComponent(decodeURIComponent(n));
    } catch (e) {
      return n;
    }
  }

  var P,
      B = ["ext1", "ext2", "ext3", "level", "trace", "tag", "seq", "code"],
      M = (e.prototype.indexOf = function (e, n) {
    for (var t = 0; t < e.length; t++) if (e[t].callback === n) return t;

    return -1;
  }, e.prototype.on = function (e, n, t) {
    var o;
    if (void 0 === t && (t = 0), this) return (o = this.eventsList[e]) || (this.eventsList[e] = [], o = this.eventsList[e]), -1 === this.indexOf(o, n) && o.push({
      name: e,
      type: t || 0,
      callback: n
    }), this;
  }, e.prototype.one = function (e, n) {
    this.on(e, n, 1);
  }, e.prototype.remove = function (e, n) {
    if (this) {
      var t = this.eventsList[e];

      if (t) {
        if (n) return t.length && (n = this.indexOf(t, n), t.splice(n, 1)), this;

        try {
          delete this.eventsList[e];
        } catch (e) {}
      }

      return null;
    }
  }, e.prototype.clear = function () {
    this.eventsList = {};
  }, e),
      W = function (e) {
    if (!e || 0 === e.length) return "{}";
    e = Array.isArray(e) ? e : [e];
    var n = Object.keys(e[0]),
        t = {};
    return n.forEach(function (n) {
      t[n] = e.map(function (e) {
        return e[n];
      });
    }), t.count = e.length, re(t);
  };

  function e() {
    var s = this;
    this.emit = function (e, n) {
      if (s) {
        var t;
        if (null != (o = s.eventsList[e]) && o.length) for (var o = o.slice(), i = 0; i < o.length; i++) {
          t = o[i];

          try {
            var r = t.callback.apply(s, [n]);
            if (1 === t.type && s.remove(e, t.callback), !1 === r) break;
          } catch (e) {
            throw e;
          }
        }
        return s;
      }
    }, this.eventsList = {};
  }

  (t = P = P || {})[t.number = -1] = "number", t.string = "";

  function X(e, n) {
    return "number" == typeof e || "string" == typeof e ? e : n ? P.string : P.number;
  }

  function T(e, n) {
    return "string" == typeof e ? e.split("?")[n ? 1 : 0] || "" : e;
  }

  function L(e) {
    return "string" == typeof e && e.startsWith("//") ? "undefined" != typeof location && "https:" === location.protocol : /^https/.test(e);
  }

  function V(e, n, t) {
    var o, i;

    try {
      if ("function" == typeof (null == n ? void 0 : n.retCodeHandler)) return {
        code: void 0 === (r = (i = n.retCodeHandler(e, null == t ? void 0 : t.url, null == t ? void 0 : t.ctx, null == t ? void 0 : t.payload) || {}).code) ? "unknown" : r,
        isErr: i.isErr
      };
      "string" == typeof e && (e = JSON.parse(e)), "function" == typeof (null == (o = null == n ? void 0 : n.ret) ? void 0 : o.join) && (oe = [].concat(n.ret.map(function (e) {
        return e.toLowerCase();
      })));
      var r,
          s = Object.getOwnPropertyNames(e).filter(function (e) {
        return -1 !== oe.indexOf(e.toLowerCase());
      });
      return s.length ? {
        code: "" + (r = e[s[0]]),
        isErr: 0 !== r && "0" !== r
      } : {
        code: "unknown",
        isErr: !1
      };
    } catch (e) {
      return {
        code: "unknown",
        isErr: !1
      };
    }
  }

  function x(e, n, t) {
    try {
      var o = "function" == typeof n ? n(e, null == t ? void 0 : t.url) || "" : e;
      return se(o).slice(0, 102400);
    } catch (e) {
      return "";
    }
  }

  function G(t, o) {
    var i,
        r = [],
        s = t.config;
    return t.lifeCycle.on("destroy", function () {
      r.length = 0;
    }), function (e, n) {
      Array.isArray(e) ? r = r.concat(e) : r.push(e), o && r.length >= o || t.sendNow && 0 < r.length ? (r = ce(r), n(r.splice(0, r.length)), i && clearTimeout(i)) : (i && clearTimeout(i), i = setTimeout(function () {
        i = null, 0 < (r = ce(r)).length && n(r.splice(0, r.length));
      }, s.delay));
    };
  }

  function $(e, n) {
    return Array.isArray(e) ? n(e.map(function (e) {
      return n = E(E({}, e), {
        msg: "string" == typeof e.msg ? e.msg : [].concat(e.msg).map(O).join(" ")
      }), B.forEach(function (e) {
        n[e] || delete n[e];
      }), n;
      var n;
    })) : n([E(E({}, e), {
      msg: "string" == typeof e.msg ? e.msg : O(e.msg)
    })]);
  }

  function J(u, c) {
    return function (e, n) {
      var t,
          o,
          i,
          r = Array.isArray(e),
          s = r ? e : [e],
          a = (u.lifeCycle.emit("beforeRequest", e), u.config.beforeRequest);
      (s = "function" == typeof a ? s.map(function (n) {
        try {
          var e = a({
            logs: n,
            logType: c
          });
          return (null == e ? void 0 : e.logType) === c && null != e && e.logs ? e.logs : !1 !== e && n;
        } catch (e) {
          return n;
        }
      }).filter(function (e) {
        return !1 !== e;
      }) : s).length && (t = s, e = B, !Array.isArray(t) || t.length <= 1 || (o = [], i = [], !(i = "string" == typeof e ? [e] : e) || i.length <= 0 || (i.forEach(function (n) {
        t.forEach(function (e) {
          null != e && e[n] && o.push(n);
        });
      }), 0 < o.length && (t = t.map(function (e) {
        var n = {};
        return o.forEach(function (e) {
          n[e] = "";
        }), E(E({}, n), e);
      })))), s = t, n(r ? s : s[0]));
    };
  }

  function K(i) {
    return function (e, n) {
      i.lifeCycle.emit("modifyRequest", e);
      var t = i.config.modifyRequest;
      if ("function" == typeof t) try {
        var o = t(e);
        "object" == typeof o && "url" in o && (e = o);
      } catch (e) {
        console.error(e);
      }
      n(e);
    };
  }

  function Q(o) {
    return function (e, n) {
      o.lifeCycle.emit("afterRequest", e);
      var t = o.config.afterRequest;
      "function" == typeof t && !1 === t(e) || n(e);
    };
  }

  function v(t) {
    if (t && t.reduce && t.length) return 1 === t.length ? function (e, n) {
      t[0](e, n || pe);
    } : t.reduce(function (t, o) {
      return function (e, n) {
        return void 0 === n && (n = pe), t(e, function (e) {
          return null == o ? void 0 : o(e, n);
        });
      };
    });
    throw new TypeError("createPipeline need at least one function param");
  }

  function Y(n, t) {
    Object.getOwnPropertyNames(n).forEach(function (e) {
      "function" == typeof n[e] && "constructor" !== e && (t ? t[e] = "sendPipeline" === e ? function () {
        return function () {};
      } : function () {} : n[e] = function () {});
    });
  }

  function z() {
    return void 0 !== window.performance && "function" == typeof performance.clearResourceTimings && "function" == typeof performance.getEntriesByType && "function" == typeof performance.now;
  }

  function Z(n, t) {
    function o(e) {
      "pagehide" !== e.type && "hidden" !== document.visibilityState || (n(e), t && (removeEventListener("visibilitychange", o, !0), removeEventListener("pagehide", o, !0)));
    }

    addEventListener("visibilitychange", o, !0), addEventListener("pagehide", o, !0);
  }

  function ee(n) {
    return ge.some(function (e) {
      return -1 < n.indexOf(e);
    });
  }

  function n(e) {
    return -1 !== we.indexOf(e);
  }

  var C,
      R,
      l,
      ne = ["application/xhtml+xml", "application/xml", "application/pdf", "application/pkcs12", "application/javascript", "application/ecmascript", "application/vnd.mspowerpoint", "application/vnd.apple.mpegurl", "application/ogg", "text/css", "text/javascript", "image", "audio", "video"],
      te = /\.(json|js|css|jpg|jpeg|png|svg|apng|webp|gif|bmp|mp4|mp3|mpeg|wav|webm|ogg|flv|m3u8|ttf|woff2|otf|eot|woff|)$/gi,
      oe = ["ret", "retcode", "code", "errcode"],
      ie = function () {
    var t = new WeakSet();
    return function (e, n) {
      if (n instanceof Error) return "Error.message: " + n.message + " \n  Error.stack: " + n.stack;

      if ("object" == typeof n && null !== n) {
        if (t.has(n)) return "[Circular " + (e || "root") + "]";
        t.add(n);
      }

      return n;
    };
  },
      O = function (e) {
    if ("string" == typeof e) return e;

    try {
      return e instanceof Error ? (JSON.stringify(e, ie(), 4) || "undefined").replace(/"/gim, "") : JSON.stringify(e, ie(), 4) || "undefined";
    } catch (e) {
      return "error happen when aegis stringify: \n " + e.message + " \n " + e.stack;
    }
  },
      re = function (e) {
    if ("string" == typeof e) return e;

    try {
      return JSON.stringify(e, ie()) || "undefined";
    } catch (e) {
      return "error happen when aegis stringify: \n " + e.message + " \n " + e.stack;
    }
  },
      se = function (t, o) {
    void 0 === o && (o = 3);
    var i,
        r,
        s,
        a = "";
    return Array.isArray(t) ? (a += "[", i = t.length, t.forEach(function (e, n) {
      a = (a += "object" == typeof e && 1 < o ? se(e, o - 1) : ue(e)) + (n === i - 1 ? "" : ",");
    }), a += "]") : t instanceof Object ? (a = "{", r = Object.keys(t), s = r.length, r.forEach(function (e, n) {
      "object" == typeof t[e] && 1 < o ? a += '"' + e + '":' + se(t[e], o - 1) : a += ae(e, t[e]), a += n === s - 1 || n < s - 1 && void 0 === t[r[n + 1]] ? "" : ",";
    }), a += "}") : a += t, a;
  },
      ae = function (e, n) {
    var t = typeof n,
        o = "";
    return "string" == t || "object" == t ? o += '"' + e + '":"' + n + '"' : "function" == typeof n ? o += '"' + e + '":"function ' + n.name + '"' : "symbol" == typeof n ? o += '"' + e + '":"symbol"' : "number" != typeof n && "boolean" != t || (o += '"' + e + '": ' + n), o;
  },
      ue = function (e) {
    var n = typeof e;
    return "" + ("undefined" == n || "symbol" == n || "function" == n ? "null" : "string" == n || "object" == n ? '"' + e + '"' : e);
  },
      ce = ((t = C = C || {}).INFO_ALL = "-1", t.API_RESPONSE = "1", t.INFO = "2", t.ERROR = "4", t.PROMISE_ERROR = "8", t.AJAX_ERROR = "16", t.SCRIPT_ERROR = "32", t.IMAGE_ERROR = "64", t.CSS_ERROR = "128", t.CONSOLE_ERROR = "256", t.MEDIA_ERROR = "512", t.RET_ERROR = "1024", t.REPORT = "2048", t.PV = "4096", t.EVENT = "8192", t.PAGE_NOT_FOUND_ERROR = "16384", t.WEBSOCKET_ERROR = "32768", t.BRIDGE_ERROR = "65536", (t = R = R || {}).LOG = "log", t.SPEED = "speed", t.PERFORMANCE = "performance", t.OFFLINE = "offline", t.WHITE_LIST = "whiteList", t.VITALS = "vitals", t.PV = "pv", t.CUSTOM_PV = "customPV", t.EVENT = "event", t.CUSTOM = "custom", t.SDK_ERROR = "sdkError", t.SET_DATA = "setData", t.LOAD_PACKAGE = "loadPackage", (t = l = l || {}).production = "production", t.development = "development", t.gray = "gray", t.pre = "pre", t.daily = "daily", t.local = "local", t.test = "test", t.others = "others", function (e) {
    return e.filter(function (t, o) {
      return "static" !== t.type || !e.find(function (e, n) {
        return t.url === e.url && 200 === t.status && o < n;
      });
    });
  }),
      le = function (e) {
    e.level === C.INFO_ALL && (e.level = C.INFO);
  },
      fe = function (e) {
    return (Array.isArray(e) ? e : [e]).map(function (t) {
      return Object.getOwnPropertyNames(t).reduce(function (e, n) {
        return "ctx" !== n && (e[n] = t[n]), e;
      }, {
        level: C.INFO,
        msg: ""
      });
    });
  },
      de = function (o) {
    return function (e) {
      return o.sendPipeline([function (e, t) {
        return t({
          url: o.config.url || "",
          data: W(fe(e)),
          method: "post",
          contentType: "application/json",
          type: R.LOG,
          log: e,
          requestConfig: {
            timeout: 5e3
          },
          success: function () {
            var n = o.config.onReport;
            "function" == typeof n && e.forEach(function (e) {
              n(e);
            }), "function" == typeof t && t([]);
          },
          fail: function (e) {
            "403 forbidden" === e && o.destroy();
          }
        });
      }], R.LOG)(e);
    };
  },
      pe = function () {},
      t = (Object.defineProperty(y.prototype, "__version__", {
    get: function () {
      return console.warn("__version__ has discard, please use version"), "1.36.5";
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(y.prototype, "LogType", {
    get: function () {
      return console.warn("LogType has discard, please use logType"), C;
    },
    enumerable: !1,
    configurable: !0
  }), y.prototype.init = function (e) {
    this.setConfig(e);

    for (var n = 0; n < y.installedPlugins.length; n++) try {
      y.installedPlugins[n].patch(this);
    } catch (e) {
      this.sendSDKError(e);
    }

    this.lifeCycle.emit("onInited");
  }, y.prototype.setConfig = function (e) {
    Object.assign(this.config, e);
    var e = this.config,
        n = e.id,
        t = e.uin,
        o = e.version,
        i = e.ext1,
        r = e.ext2,
        s = e.ext3,
        a = e.aid,
        u = e.env,
        c = void 0 === u ? "production" : u,
        u = e.pageUrl,
        e = this.bean.id !== n || this.bean.uin !== t || this.bean.aid !== a;
    return this.bean.id = n || "", this.bean.uin = t || "", this.bean.version = o || "1.36.5", this.bean.aid = a || "", this.bean.env = function () {
      switch (c) {
        case l.production:
        case l.development:
        case l.gray:
        case l.pre:
        case l.daily:
        case l.local:
        case l.test:
        case l.others:
          return 1;

        default:
          return;
      }
    }() ? c : l.others, u && this.extendBean("from", encodeURIComponent(u)), i && this.extendBean("ext1", encodeURIComponent(i)), r && this.extendBean("ext2", encodeURIComponent(r)), s && this.extendBean("ext3", encodeURIComponent(s)), e && this.lifeCycle.emit("onConfigChange", this.config), this.config;
  }, y.use = function (e) {
    -1 === y.installedPlugins.indexOf(e) && e.aegisPlugin && y.installedPlugins.push(e);
  }, y.unuse = function (e) {
    e = y.installedPlugins.indexOf(e);
    -1 !== e && y.installedPlugins.splice(e, 1);
  }, y.prototype.info = function () {
    for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

    var t = {
      level: C.INFO,
      msg: e
    };
    1 === e.length && e[0].msg && Object.assign(t, E({}, e[0]), {
      level: C.INFO
    }), this.normalLogPipeline(t);
  }, y.prototype.infoAll = function () {
    for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

    var t = {
      level: C.INFO_ALL,
      msg: e
    };
    1 === e.length && e[0].msg && Object.assign(t, E({}, e[0]), {
      level: C.INFO_ALL
    }), this.normalLogPipeline(t);
  }, y.prototype.report = function () {
    for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

    var t = {
      level: C.REPORT,
      msg: e
    };
    1 === e.length && e[0].msg && Object.assign(t, E({}, e[0])), this.normalLogPipeline(t);
  }, y.prototype.error = function () {
    for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

    var t = {
      level: C.ERROR,
      msg: e
    };
    1 === e.length && e[0].msg && Object.assign(t, E({}, e[0]), {
      level: C.ERROR
    }), this.normalLogPipeline(t);
  }, y.prototype.speedLogPipeline = function (e) {
    throw new Error('You need to override "speedLogPipeline" method');
  }, y.prototype.reportPv = function (t) {
    var o,
        i = this;
    t && (console.warn("reportPv is deprecated, please use reportEvent"), o = "" + Object.getOwnPropertyNames(this.bean).filter(function (e) {
      return "id" !== e;
    }).map(function (e) {
      return e + "=" + i.bean[e];
    }).join("&"), this.sendPipeline([function (e, n) {
      n({
        url: i.config.url + "/" + t + "?" + o,
        addBean: !1,
        type: R.CUSTOM_PV,
        fail: function (e) {
          "403 forbidden" === e && i.destroy();
        }
      });
    }], R.CUSTOM_PV)(null));
  }, y.prototype.reportEvent = function (e) {
    e && ((e = "string" == typeof e ? {
      name: e,
      ext1: this.config.ext1 || "",
      ext2: this.config.ext2 || "",
      ext3: this.config.ext3 || ""
    } : e).name ? this.eventPipeline(e) : console.warn("reportEvent params error"));
  }, y.prototype.reportTime = function (e, n) {
    if ("object" == typeof e) return this.reportT(e);
    "string" == typeof e ? "number" == typeof n ? n < 0 || 6e4 < n ? console.warn("reportTime: duration must between 0 and 60000") : this.submitCustomTime(e, n) : console.warn("reportTime: second param must be number") : console.warn("reportTime: first param must be a string");
  }, y.prototype.reportT = function (e) {
    var n = e.name,
        t = e.duration,
        o = e.ext1,
        o = void 0 === o ? "" : o,
        i = e.ext2,
        i = void 0 === i ? "" : i,
        r = e.ext3,
        r = void 0 === r ? "" : r,
        e = e.from;

    if ("string" == typeof n && "number" == typeof t && "string" == typeof o && "string" == typeof i && "string" == typeof r) {
      if (!(t < 0 || 6e4 < t)) return this.submitCustomTime(n, t, o, i, r, void 0 === e ? "" : e);
      console.warn("reportTime: duration must between 0 and 60000");
    } else console.warn("reportTime: params error");
  }, y.prototype.time = function (e) {
    "string" == typeof e ? this.timeMap[e] ? console.warn("Timer " + e + " already exists") : this.timeMap[e] = Date.now() : console.warn("time: first param must be a string");
  }, y.prototype.timeEnd = function (e) {
    "string" == typeof e ? this.timeMap[e] ? (this.submitCustomTime(e, Date.now() - this.timeMap[e]), delete this.timeMap[e]) : console.warn("Timer " + e + " does not exist") : console.warn("timeEnd: first param must be a string");
  }, y.prototype.submitCustomTime = function (e, n, t, o, i, r) {
    this.customTimePipeline({
      name: e,
      duration: n,
      ext1: t || this.config.ext1,
      ext2: o || this.config.ext2,
      ext3: i || this.config.ext3,
      from: r || void 0
    });
  }, y.prototype.extendBean = function (e, n) {
    this.bean[e] = n;
  }, y.prototype.sendPipeline = function (e, n) {
    var t,
        r = this;
    return v(u([function (e, n) {
      if ("number" != typeof t.config.random && (console.warn("random must in [0, 1], default is 1."), t.config.random = 1), !t.isHidden || !t.isGetSample) if (t.isGetSample) t.isHidden || n(e);else {
        if (t.isGetSample = !0, Math.random() < t.config.random) return t.isHidden = !1, n(e);
        t.isHidden = !0;
      }
    }, J(t = this, n)], e, [K(this), function (o, i) {
      r.request(o, function () {
        for (var e, n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];

        r.failRequestCount = 0, i({
          isErr: !1,
          result: n,
          logType: null == o ? void 0 : o.type,
          logs: null == o ? void 0 : o.log
        }), null != (e = null == o ? void 0 : o.success) && e.call.apply(e, u([o], n));
      }, function () {
        for (var e, n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];

        10 <= ++r.failRequestCount && r.destroy(), i({
          isErr: !0,
          result: n,
          logType: null == o ? void 0 : o.type,
          logs: null == o ? void 0 : o.log
        }), null != (e = null == o ? void 0 : o.fail) && e.call.apply(e, u([o], n));
      });
    }, Q(this)]));
  }, y.prototype.send = function (e, i, r) {
    var n = this;
    return v([K(this), function (t, o) {
      n.request(t, function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

        o({
          isErr: !1,
          result: e,
          logType: t.type,
          logs: t.log
        }), null != i && i.apply(void 0, e);
      }, function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

        o({
          isErr: !0,
          result: e,
          logType: t.type,
          logs: t.log
        }), null != r && r.apply(void 0, e);
      });
    }, Q(this)])(e);
  }, y.prototype.ready = function (e, n, t) {
    throw new Error('You need to override "ready" method');
  }, y.prototype.request = function (e, n, t) {
    throw new Error('You need to override "request" method');
  }, y.prototype.sendSDKError = function (e) {
    var t = this;
    this.sendPipeline([function (e, n) {
      n({
        url: t.config.url + "?id=1085&msg[0]=" + encodeURIComponent(O(e)) + "&level[0]=2&from=" + t.config.id + "&count=1&version=" + t.config.id + "(1.36.5)",
        addBean: !1,
        method: "get",
        type: R.SDK_ERROR,
        log: e
      });
    }], R.SDK_ERROR)(e);
  }, y.prototype.destroy = function (e) {
    void 0 === e && (e = !1);
    var n,
        t,
        o = y.instances.indexOf(this);
    -1 !== o && y.instances.splice(o, 1);

    for (var i = y.installedPlugins.length - 1; 0 <= i; i--) try {
      y.installedPlugins[i].unpatch(this);
    } catch (e) {
      this.sendSDKError(e);
    }

    if (this.lifeCycle.emit("destroy"), this.lifeCycle.clear(), e) n = this, t = Object.getOwnPropertyDescriptors(n), Object.keys(t).forEach(function (e) {
      t[e].writable && (n[e] = null);
    }), Object.setPrototypeOf(this, null);else {
      for (var r = this; r.constructor !== Object && Y(r, this), r = Object.getPrototypeOf(r););

      0 === y.instances.length && (o = Object.getPrototypeOf(this).constructor, Y(o), Y(y));
    }
  }, y.version = "1.36.5", y.instances = [], y.logType = C, y.environment = l, y.installedPlugins = [], y),
      o = (r.prototype.patch = function (e) {
    this.canUse(e) && this.exist(e) && (this.instances.push(e), this.triggerInit(e), this.triggerOnNewAegis(e));
  }, r.prototype.unpatch = function (e) {
    e = this.instances.indexOf(e);
    -1 !== e && (this.instances.splice(e, 1), 0 === this.instances.length && this.uninstall());
  }, r.prototype.countInstance = function () {
    return this.instances.length;
  }, r.prototype.uninstall = function () {
    var e;
    null != (e = null == (e = this.option) ? void 0 : e.destroy) && e.apply(this);
  }, r.prototype.walk = function (t) {
    var o = this;
    this.instances.forEach(function (e) {
      var n = o.canUse(e);
      n && t(e, n);
    });
  }, r.prototype.canUse = function (e) {
    e = this.getConfig(e);
    return !(!e || "object" != typeof e) || !!e;
  }, r.prototype.getConfig = function (e) {
    return null == (e = e.config) ? void 0 : e[this.name];
  }, r.prototype.exist = function (e) {
    return -1 === this.instances.indexOf(e);
  }, r.prototype.triggerInit = function (e) {
    var n;
    this.inited || (this.inited = !0, null != (n = null == (n = this.option) ? void 0 : n.init) && n.call(this.option, this.getConfig(e)));
  }, r.prototype.triggerOnNewAegis = function (e) {
    var n;
    null != (n = null == (n = this.option) ? void 0 : n.onNewAegis) && n.call(this.option, e, this.getConfig(e));
  }, r),
      he = new o({
    name: "aid",
    aid: "",
    init: function (e) {
      try {
        var n = !0 !== e && e || window.localStorage.getItem("AEGIS_ID");
        n || (n = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (e) {
          var n = 16 * Math.random() | 0;
          return ("x" === e ? n : 3 & n | 8).toString(16);
        }), window.localStorage.setItem("AEGIS_ID", n)), this.aid = n;
      } catch (e) {}
    },
    onNewAegis: function (e) {
      e.bean.aid = this.aid, e.config.aid = this.aid;
    }
  }),
      ge = ["/collect/offlineAuto", "/aegis-sdk", "/flog.core.min.js"],
      me = function (n) {
    var t;
    return n.payload ? (t = {}, Object.keys(n).forEach(function (e) {
      "payload" !== e && (t[e] = n[e]);
    }), t) : n;
  },
      ve = new o({
    name: "reportAssetSpeed"
  }),
      ye = ve = new o({
    name: "reportAssetSpeed",
    collectCur: 0,
    collectEntryType: "resource",
    ASSETS_INITIATOR_TYPE: ["img", "css", "script", "link", "audio", "video"],
    onNewAegis: function (e) {
      var n = this;
      z() && (this.collectSuccessLog(e), this.collectFailLog(e), performance.onresourcetimingbufferfull = function () {
        n.collectCur = 0, performance.clearResourceTimings();
      });
    },
    publish: function (n) {
      this.$walk(function (e) {
        e.speedLogPipeline(n);
      });
    },
    publishMany: function (e, n) {
      for (var t = n.config, o = 0, i = e.length; o < i; o++) {
        var r = e[o];
        -1 === this.ASSETS_INITIATOR_TYPE.indexOf(r.initiatorType) || ee(r.name) || this.publish(this.generateLog(r, t));
      }
    },
    collectSuccessLog: function (t) {
      var e,
          n,
          o = this;
      "function" == typeof window.PerformanceObserver ? (this.publishMany(performance.getEntriesByType(this.collectEntryType), t), (e = new window.PerformanceObserver(function (e) {
        o.publishMany(e.getEntries(), t);
      })).observe({
        entryTypes: [this.collectEntryType]
      }), t.lifeCycle.on("destroy", function () {
        0 === ve.countInstance() && e.disconnect();
      })) : (n = setInterval(function () {
        var e = performance.getEntriesByType(o.collectEntryType),
            n = e.slice(o.collectCur);
        o.collectCur = e.length, o.publishMany(n, t);
      }, 3e3), t.lifeCycle.on("destroy", function () {
        0 === ve.countInstance() && clearInterval(n);
      }));
    },
    collectFailLog: function (e) {
      function n(e) {
        var n, t;
        e && (e = e.target || e.srcElement, !(n = (null == e ? void 0 : e.src) || (null == e ? void 0 : e.href)) || "string" != typeof n || -1 < window.location.href.indexOf(n) || (e = "function" == typeof (null == (e = i.api) ? void 0 : e.resourceTypeHandler) ? null == (e = i.api) ? void 0 : e.resourceTypeHandler(n) : "", t = performance.getEntriesByType(o.collectEntryType).find(function (e) {
          return e.name === n;
        }), ee(n) || (t = {
          url: T(n),
          status: 400,
          duration: Number(((null == t ? void 0 : t.duration) || 0).toFixed(2)),
          method: "get",
          type: e || "static",
          isHttps: L(n),
          urlQuery: T(n, !0),
          nextHopProtocol: "",
          domainLookup: 0,
          connectTime: 0
        }, o.publish(t))));
      }

      var o = this,
          i = e.config;
      window.document.addEventListener("error", n, !0), e.lifeCycle.on("destroy", function () {
        0 === ve.countInstance() && window.document.removeEventListener("error", n, !0);
      });
    },
    generateLog: function (e, n) {
      var t,
          n = "function" == typeof (null == (t = n.api) ? void 0 : t.resourceTypeHandler) ? null == (t = n.api) ? void 0 : t.resourceTypeHandler(e.name) : "";
      return {
        url: T(e.name),
        method: "get",
        duration: Number(e.duration.toFixed(2)),
        status: 200,
        type: n || "static",
        isHttps: L(e.name),
        nextHopProtocol: e.nextHopProtocol || "",
        urlQuery: T(e.name, !0),
        domainLookup: X(e.domainLookupEnd - e.domainLookupStart),
        connectTime: X(e.connectEnd - e.connectStart)
      };
    },
    collectNotReportedLog: function (e) {
      var n, t;
      z() && (n = (t = performance.getEntriesByType(this.collectEntryType)).length, "function" != typeof window.PerformanceObserver && this.collectCur !== n && (t = t.slice(this.collectCur), this.collectCur = n, this.publishMany(t, e, !0)));
    },
    destroy: function () {
      this.option.publish = function () {};
    }
  }),
      we = window.navigator.userAgent.toLowerCase(),
      i = {};

  function r(e) {
    this.aegisPlugin = !0, this.name = "", this.instances = [], this.inited = !1, e.$walk = this.walk.bind(this), e.$getConfig = this.getConfig.bind(this), this.option = e, this.name = e.name;
  }

  function y(e) {
    var t,
        n,
        o,
        i,
        s,
        r,
        a,
        u,
        c,
        l,
        f,
        d,
        p,
        h,
        g,
        m = this;
    this.isGetSample = !1, this.isHidden = !1, this.config = {
      version: 0,
      delay: 1e3,
      onError: !0,
      repeat: 5,
      random: 1,
      aid: !0,
      device: !0,
      pagePerformance: !0,
      webVitals: !0,
      speedSample: !0,
      onClose: !0,
      hostUrl: "https://aegis.qq.com",
      websocketHack: !1,
      env: "production",
      url: "",
      offlineUrl: "",
      whiteListUrl: "",
      pvUrl: "",
      speedUrl: "",
      customTimeUrl: "",
      performanceUrl: "",
      webVitalsUrl: "",
      eventUrl: "",
      setDataReportUrl: "",
      reportImmediately: !0
    }, this.isWhiteList = !1, this.lifeCycle = new M(), this.bean = {}, this.normalLogPipeline = v([G(this, 5), $, function (e, n) {
      var o = t.config;
      n(e = e.map(function (e) {
        var n,
            t = o.maxLength || 102400;

        try {
          if (!e.msg || e.msg.length <= t) return e;
          e.msg = null == (n = e.msg) ? void 0 : n.substring(0, t);
        } catch (n) {
          e.msg = O(e.msg).substring(0, o.maxLength);
        }

        return e;
      }));
    }, (h = (t = this).config, g = {}, function (e, n) {
      var t = "number" == typeof h.repeat ? h.repeat : 5;
      if (0 === t) return n(e);
      n(e.filter(function (e) {
        return e.level !== C.ERROR && e.level !== C.PROMISE_ERROR && e.level !== C.AJAX_ERROR && e.level !== C.SCRIPT_ERROR && e.level !== C.IMAGE_ERROR && e.level !== C.CSS_ERROR && e.level !== C.MEDIA_ERROR || (g[e.msg] = g[e.msg] || 0, g[e.msg] += 1, !(g[e.msg] > t));
      }));
    }), (d = this.lifeCycle.emit, p = this.config, function (e, n) {
      var t,
          o = p.logCreated;
      return "function" == typeof o ? (t = e.filter(function (e) {
        return !1 !== o(e);
      }), d("beforeWrite", t), n(t)) : (d("beforeWrite", e), n(e));
    }), (f = this, setTimeout(function () {
      var e = f.config.pvUrl,
          t = void 0 === e ? "" : e;
      t && f.sendPipeline([function (e, n) {
        n({
          url: t,
          type: R.PV,
          fail: function (e) {
            "403 forbidden" === e && f.destroy();
          }
        });
      }], R.PV)(null);
    }, 100), function (e, n) {
      n(e);
    }), (c = u = a = !1, l = [], (s = this).lifeCycle.on("onConfigChange", function () {
      r && clearTimeout(r), r = setTimeout(function () {
        var e, t;
        !c && s.config && (c = !0, e = s.config.whiteListUrl, (t = void 0 === e ? "" : e) && s.sendPipeline([function (e, n) {
          n({
            url: t,
            type: R.WHITE_LIST,
            success: function (e) {
              u = !0;

              try {
                var n = e.data || JSON.parse(e),
                    t = n.retcode,
                    o = n.result,
                    i = void 0 === o ? {} : o;

                if (0 === t) {
                  if (a = i.is_in_white_list, s.isWhiteList = a, i.shutdown) return void s.destroy();
                  0 <= i.rate && i.rate <= 1 && (s.config.random = i.rate, s.isGetSample = !1);
                }

                s.isWhiteList && l.length ? de(s)(l.splice(0), function () {}) : !s.isWhiteList && l.length && (l.length = 0);
                var r = s.config.onWhitelist;
                "function" == typeof r && r(a);
              } catch (e) {}
            },
            fail: function (e) {
              "403 forbidden" === e && s.destroy(), u = !0;
            }
          });
        }], R.WHITE_LIST)(null), c = !1);
      }, s.config.uin ? 50 : 500);
    }), s.lifeCycle.on("destroy", function () {
      l.length = 0;
    }), function (e, n) {
      var t;
      a || null != (t = null == (t = s.config) ? void 0 : t.api) && t.reportRequest ? n(e.concat(l.splice(0)).map(function (e) {
        return le(e), e;
      })) : (t = e.filter(function (e) {
        return e.level !== C.INFO && e.level !== C.API_RESPONSE ? (le(e), !0) : (u || (l.push(e), 200 <= l.length && (l.length = 200)), !1);
      })).length && n(t);
    }), function (e, n) {
      try {
        var t = JSON.parse(JSON.stringify(e)),
            o = (m.lifeCycle.emit("beforeReport", t), m.config.beforeReport);
        (e = "function" == typeof o ? e.filter(function (e) {
          return !1 !== o(e);
        }) : e).length && n(e);
      } catch (e) {}
    }, de(this)]), this.eventPipeline = v([G(this, 10), (i = this, function (e) {
      i.sendPipeline([function (e, n) {
        var t = e.map(function (e) {
          return {
            name: e.name,
            ext1: e.ext1 || i.config.ext1 || "",
            ext2: e.ext2 || i.config.ext2 || "",
            ext3: e.ext3 || i.config.ext3 || ""
          };
        });
        n({
          url: i.config.eventUrl + "?payload=" + encodeURIComponent(JSON.stringify(t)),
          type: R.EVENT,
          log: e,
          fail: function (e) {
            "403 forbidden" === e && i.destroy();
          }
        });
      }], R.EVENT)(e);
    })]), this.timeMap = {}, this.failRequestCount = 0, this.customTimePipeline = v([G(this, 10), (o = this, function (e) {
      return o.sendPipeline([function (e, n) {
        n({
          url: o.config.customTimeUrl + "?payload=" + encodeURIComponent(JSON.stringify({
            custom: e
          })),
          type: R.CUSTOM,
          log: e,
          fail: function (e) {
            "403 forbidden" === e && o.destroy();
          }
        });
      }], R.CUSTOM)(e);
    })]), this.config = (n = this.config, void 0 === (e = e.hostUrl) && (e = "https://aegis.qq.com"), n.url = n.url || e + "/collect", n.offlineUrl = n.offlineUrl || e + "/offline", n.whiteListUrl = n.whiteListUrl || e + "/collect/whitelist", n.pvUrl = n.pvUrl || e + "/collect/pv", n.eventUrl = n.eventUrl || e + "/collect/events", n.speedUrl = n.speedUrl || e + "/speed", n.customTimeUrl = n.customTimeUrl || e + "/speed/custom", n.performanceUrl = n.performanceUrl || e + "/speed/performance", n.webVitalsUrl = n.webVitalsUrl || e + "/speed/webvitals", n.setDataReportUrl = n.SetDataReportUrl || e + "/speed/miniProgramData", n), y.instances.push(this);
  }

  i.macos = function () {
    return n("mac");
  }, i.ios = function () {
    return i.iphone() || i.ipod() || i.ipad();
  }, i.iphone = function () {
    return !i.windows() && n("iphone");
  }, i.ipod = function () {
    return n("ipod");
  }, i.ipad = function () {
    var e = "MacIntel" === navigator.platform && 1 < navigator.maxTouchPoints;
    return n("ipad") || e;
  }, i.android = function () {
    return !i.windows() && n("android");
  }, i.androidPhone = function () {
    return i.android() && n("mobile");
  }, i.androidTablet = function () {
    return i.android() && !n("mobile");
  }, i.blackberry = function () {
    return n("blackberry") || n("bb10");
  }, i.blackberryPhone = function () {
    return i.blackberry() && !n("tablet");
  }, i.blackberryTablet = function () {
    return i.blackberry() && n("tablet");
  }, i.windows = function () {
    return n("windows");
  }, i.windowsPhone = function () {
    return i.windows() && n("phone");
  }, i.windowsTablet = function () {
    return i.windows() && n("touch") && !i.windowsPhone();
  }, i.fxos = function () {
    return (n("(mobile") || n("(tablet")) && n(" rv:");
  }, i.fxosPhone = function () {
    return i.fxos() && n("mobile");
  }, i.fxosTablet = function () {
    return i.fxos() && n("tablet");
  }, i.meego = function () {
    return n("meego");
  }, i.cordova = function () {
    return window.cordova && "file:" === location.protocol;
  }, i.nodeWebkit = function () {
    return "object" == typeof window.process;
  }, i.mobile = function () {
    return i.androidPhone() || i.iphone() || i.ipod() || i.windowsPhone() || i.blackberryPhone() || i.fxosPhone() || i.meego();
  }, i.tablet = function () {
    return i.ipad() || i.androidTablet() || i.blackberryTablet() || i.windowsTablet() || i.fxosTablet();
  }, i.desktop = function () {
    return !i.tablet() && !i.mobile();
  };

  function be(n) {
    a.find(function (e) {
      return e.name === n.name;
    }) || (a.push(n), !Te && window.XMLHttpRequest && (Te = !0, window.XMLHttpRequest.prototype.open = function () {
      if (this.aegisMethod = arguments[0], this.aegisUrl = arguments[1], this.aegisXhrStartTime = Date.now(), this.sendByAegis) i.isIE() || (this.timeout = 5e3);else for (var e = 0; e < a.length; e++) {
        var n = a[e];

        try {
          "function" == typeof n.open && n.open(this);
        } catch (e) {}
      }
      return xe.apply(this, arguments);
    }, window.XMLHttpRequest.prototype.setRequestHeader = function () {
      var e = arguments[0],
          n = arguments[1];
      return this.aegisXhrReqHeader = this.aegisXhrReqHeader || {}, this.aegisXhrReqHeader[e] = n, Ce.apply(this, arguments);
    }, window.XMLHttpRequest.prototype.send = function () {
      if (!this.sendByAegis) for (var e = 0; e < a.length; e++) {
        var n = a[e];

        try {
          "function" == typeof n.send && n.send(this, arguments[0]);
        } catch (e) {}
      }
      return Le.apply(this, arguments);
    }));
  }

  function Ee(n) {
    var e = a.findIndex(function (e) {
      return e.name === n.name;
    });
    -1 !== e && a.splice(e, 1), window.XMLHttpRequest.prototype.send = Le, window.XMLHttpRequest.prototype.open = xe, window.XMLHttpRequest.prototype.setRequestHeader = Ce;
  }

  function Re(e) {
    return e.split("\r\n").reduce(function (e, n) {
      n = n.split(": ");
      return n[0] && n[1] && (e[n[0]] = n[1]), e;
    }, {});
  }

  function k(o, e, i) {
    return null != e && e.length && "object" == typeof o ? e.reduce(function (e, n) {
      var t = o instanceof Headers ? o.get(n) : o[n];
      return t ? e + ("" === e ? "\n" : "\n\n") + i + " header " + n + ": " + t : e;
    }, "") : "";
  }

  function Oe(e) {
    var n,
        t = "";
    return "object" == typeof e && (n = (e = function (e, n) {
      for (var t = 0; t < n.length; t++) {
        var o = n[t],
            i = e[o] || "function" == typeof e.get && e.get(o);
        if (i) return [o, i];
      }

      return ["", ""];
    }(e, Object.keys(Ae)))[0], e = e[1], n && (t = Ae[n](e))), t;
  }

  var s,
      Se,
      Pe,
      Te = !(i.isIE = function () {
    return "ActiveXObject" in window;
  }),
      a = [],
      Le = window.XMLHttpRequest.prototype.send,
      xe = window.XMLHttpRequest.prototype.open,
      Ce = window.XMLHttpRequest.prototype.setRequestHeader,
      ke = window.fetch,
      Ie = !1,
      c = [],
      Ae = {
    sw8: function (e) {
      e = e.split("-")[1];
      return e ? atob(e) : "";
    },
    traceparent: function (e) {
      return e.split("-")[1];
    },
    "sentry-trace": function (e) {
      return e.split("-")[0];
    }
  },
      Ne = (new o({
    name: "reportApiSpeed"
  }), new o({
    name: "reportApiSpeed",
    override: !1,
    onNewAegis: function (e) {
      this.override || (this.override = !0, this.overrideFetch(e.config), this.overrideXhr(e.config));
    },
    getRequestType: function (e, n, t) {
      void 0 === n && (n = "");
      var o,
          i,
          e = "function" == typeof (null == (i = e.api) ? void 0 : i.resourceTypeHandler) ? null == (i = e.api) ? void 0 : i.resourceTypeHandler(t) : "";
      return "fetch" === e && "static" === e || (o = void 0 === n ? "" : n, i = (void 0 === t ? "" : t).split("?")[0], e = te.test(i) || ne.some(function (e) {
        return -1 !== String(o).indexOf(e);
      }) ? "static" : "fetch"), e;
    },
    overrideFetch: function (h) {
      var g = this,
          e = {
        name: this.name,
        then: function (c, l, f, d) {
          var e, p;
          h.hostUrl && -1 < f.indexOf(h.hostUrl) || (e = c.headers ? c.headers.get("content-type") : "", e = g.getRequestType(h, e, c.url), p = {
            url: c.url,
            isHttps: L(c.url),
            method: (null == d ? void 0 : d.method) || "get",
            duration: l,
            type: e,
            nextHopProtocol: "",
            status: c.status || 0
          }, "fetch" === e ? c.clone().text().then(function (e) {
            var n = c.status <= 0 || 400 <= c.status,
                t = (null == (t = h.api) ? void 0 : t.reqHeaders) || [],
                t = k(null == d ? void 0 : d.headers, t, "req"),
                o = (null == (o = h.api) ? void 0 : o.resHeaders) || [],
                o = k(c.headers, o, "res"),
                i = Oe(null == d ? void 0 : d.headers),
                r = V(e, h.api, {
              url: f,
              ctx: c,
              payload: null == d ? void 0 : d.body
            }),
                s = r.code,
                r = r.isErr,
                a = null == (a = h.api) ? void 0 : a.apiDetail,
                u = a ? x(null == d ? void 0 : d.body, null == (u = h.api) ? void 0 : u.reqParamHandler, {
              url: f
            }) : "",
                a = a ? x(e, null == (a = h.api) ? void 0 : a.resBodyHandler, {
              url: f,
              ctx: c
            }) : "",
                e = (n ? "FETCH_ERROR: " + e + " \n\n" : "") + "fetch req url: " + f + " \n                                \nres status: " + (c.status || 0) + " \n                                \nres duration: " + l + "ms \n                                \nreq method: " + ((null == d ? void 0 : d.method) || "get") + " \n                                \nres retcode: " + s + "\n                                \nreq param: " + u + "\n                                \nres data: " + a + "\n                                " + t + "\n                                " + o;
            p.payload = null == d ? void 0 : d.body, p.ret = s, p.isErr = +r, g.publishNormalLog({
              msg: e,
              level: n ? C.AJAX_ERROR : r ? C.RET_ERROR : C.API_RESPONSE,
              code: s,
              trace: i
            }), g.publishSpeed(p);
          }) : (Object.assign(p, {
            type: "static",
            urlQuery: T(c.url, !0),
            domainLookup: P.number,
            connectTime: P.number
          }), g.publishSpeed(p)));
        },
        catch: function (e, n, t, o) {
          var i, r, s;
          if (!(h.hostUrl && -1 < t.indexOf(h.hostUrl))) throw i = g.getRequestType(h, "", t), i = {
            url: t,
            isHttps: L(t),
            method: (null == o ? void 0 : o.method) || "get",
            duration: n,
            nextHopProtocol: "",
            type: i,
            status: 0
          }, g.publishSpeed(i), i = (null == (i = h.api) ? void 0 : i.reqHeaders) || [], i = k(null == o ? void 0 : o.headers, i, "req"), r = Oe(null == o ? void 0 : o.headers), s = null != (s = h.api) && s.apiDetail ? x(null == o ? void 0 : o.body, null == (s = h.api) ? void 0 : s.reqParamHandler, {
            url: t
          }) : "", t = "AJAX_ERROR: " + e + "\n                          \nreq url: " + t + "\n                          \nres status: 0\n                          \nres duration: " + n + "ms\n                          \nreq method: " + ((null == o ? void 0 : o.method) || "get") + "\n                          \nreq param:" + s + "\n                          " + i, g.publishNormalLog({
            msg: t,
            level: C.AJAX_ERROR,
            code: -400,
            trace: r
          }), e;
        }
      },
          n = (this.hackFetchOptions = e, this.hackFetchOptions);
      if (c.find(function (e) {
        return e.name === n.name;
      })) throw new Error("name '" + n.name + "' is already in hackFetch option list");
      c.push(n), !Ie && window.fetch && (Ie = !0, window.fetch = function (e, o) {
        void 0 === o && (o = {});

        for (var i = "string" == typeof e ? e : e.url, n = 0; n < c.length; n++) {
          var t = c[n];

          try {
            "function" == typeof t.beforeFetch && t.beforeFetch(i, o);
          } catch (e) {}
        }

        var r = Date.now();
        return ke(e, o).then(function (e) {
          for (var n = 0; n < c.length; n++) {
            var t = c[n];

            try {
              "function" == typeof t.then && t.then(e, Date.now() - r, i, o);
            } catch (e) {}
          }

          return e;
        }).catch(function (e) {
          for (var n = 0; n < c.length; n++) {
            var t = c[n];

            try {
              "function" == typeof t.catch && t.catch(e, Date.now() - r, i, o);
            } catch (e) {}
          }

          throw e;
        });
      });
    },
    overrideXhr: function (O) {
      var S = this,
          e = {
        name: this.name,
        send: function (b, E) {
          var R = Date.now();
          b.addEventListener("loadend", function () {
            var o = b.aegisUrl || "";

            if (o && !(O.hostUrl && -1 < o.indexOf(O.hostUrl))) {
              var i = Date.now() - R,
                  e = b.getResponseHeader("content-type"),
                  e = S.getRequestType(O, e, o),
                  r = {
                url: o,
                isHttps: L(o),
                status: b.status || 0,
                method: b.aegisMethod || "get",
                type: e,
                nextHopProtocol: "",
                duration: i
              },
                  n = (null == (n = O.api) ? void 0 : n.reqHeaders) || [],
                  s = k(b.aegisXhrReqHeader, n, "req"),
                  n = (null == (n = O.api) ? void 0 : n.resHeaders) || [],
                  t = Re(b.getAllResponseHeaders()),
                  a = k(t, n, "res"),
                  u = Oe(b.aegisXhrReqHeader),
                  n = null == (t = O.api) ? void 0 : t.apiDetail,
                  c = n ? x(E, null == (t = O.api) ? void 0 : t.reqParamHandler, {
                url: o
              }) : "",
                  l = n ? x(b.response, null == (t = O.api) ? void 0 : t.resBodyHandler, {
                url: o
              }) : "";
              if ("fetch" === e) try {
                var f,
                    d,
                    p,
                    h,
                    g = b.response,
                    m = O.api,
                    v = {
                  url: o,
                  ctx: b,
                  payload: E
                },
                    y = function (e) {
                  var n = e.code,
                      e = e.isErr,
                      t = "xhr req url: " + o + "\n                    \nres status: " + r.status + "\n                    \nres duration: " + i + "ms\n                    \nreq method: " + r.method + "\n                    \nres retcode: " + n + "\n                    \nreq param: " + c + "\n                    \nres data: " + l + "\n                    " + s + "\n                    " + a;
                  r.ret = n, r.isErr = +e, r.payload = E, S.publishNormalLog({
                    msg: t,
                    level: e ? C.RET_ERROR : C.API_RESPONSE,
                    code: n,
                    trace: u
                  }), S.publishSpeed(r);
                };

                try {
                  if ("function" == typeof (null == m ? void 0 : m.retCodeHandlerAsync)) return void m.retCodeHandlerAsync(g, null == v ? void 0 : v.url, null == v ? void 0 : v.ctx, function (e) {
                    var n = e.code,
                        e = e.isErr;
                    null != y && y({
                      code: void 0 === n ? "unknown" : n,
                      isErr: e
                    });
                  });
                  if ("function" == typeof (null == m ? void 0 : m.retCodeHandler)) return void (p = (d = m.retCodeHandler(g, null == v ? void 0 : v.url, null == v ? void 0 : v.ctx, null == v ? void 0 : v.payload) || {}).code, h = d.isErr, null != y && y({
                    code: void 0 === p ? "unknown" : p,
                    isErr: h
                  }));
                  "string" == typeof g && (g = JSON.parse(g)), "function" == typeof (null == (f = null == m ? void 0 : m.ret) ? void 0 : f.join) && (oe = [].concat(m.ret.map(function (e) {
                    return e.toLowerCase();
                  })));
                  var w = Object.getOwnPropertyNames(g).filter(function (e) {
                    return -1 !== oe.indexOf(e.toLowerCase());
                  });
                  if (w.length) return void (p = g[w[0]], null != y && y({
                    code: "" + p,
                    isErr: 0 !== p && "0" !== p
                  }));
                  null != y && y({
                    code: "unknown",
                    isErr: !1
                  });
                } catch (g) {
                  null != y && y({
                    code: "unknown",
                    isErr: !1
                  });
                }
              } catch (e) {
                r.ret = "unknown", S.publishSpeed(r);
              } else Object.assign(r, {
                type: "static",
                urlQuery: T(o, !0),
                domainLookup: P.number,
                connectTime: P.number
              }), S.publishSpeed(r);
            }
          });
        }
      };
      this.hackXHROptions = e, be(this.hackXHROptions);
    },
    publishSpeed: function (t) {
      var o = this;
      this.$walk(function (e) {
        var n = o.$getConfig(e);
        "fetch" === t.type && n && "function" == typeof n.urlHandler ? e.speedLogPipeline(E(E({}, t), {
          url: T(n.urlHandler(t.url, t.payload))
        })) : (t.url = T(t.url), e.speedLogPipeline(t));
      });
    },
    publishNormalLog: function (n) {
      this.$walk(function (e) {
        e.normalLogPipeline(n);
      });
    },
    destroy: function () {
      var n, e;
      this.option.publishSpeed = function () {}, this.option.publishNormalLog = function () {}, this.option.hackXHROptions && Ee(this.option.hackXHROptions), this.option.hackFetchOptions && (n = this.option.hackFetchOptions, -1 !== (e = c.findIndex(function (e) {
        return e.name === n.name;
      })) && c.splice(e, 1), window.fetch = ke);
    }
  })),
      je = new o({
    name: "reportBridgeSpeed",
    override: !1,
    onNewAegis: function (e) {
      this.override || (this.override = !0, this.overrideBridge(e));
    },
    publishSpeed: function (n) {
      this.$walk(function (e) {
        e.speedLogPipeline(n);
      });
    },
    overrideBridge: function (e) {
      var a = this,
          u = Date.now(),
          c = e.config;
      c.reportBridgeSpeed && c.h5Bridge && c.h5BridgeFunc.length && c.h5BridgeFunc.forEach(function (e) {
        var s = c.h5Bridge[e];

        c.h5Bridge[e] = function () {
          for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

          var o = e[0],
              i = e[1],
              t = e[2],
              r = e[3];
          s(o, i, t, function (e) {
            var n = V(e, c.api),
                t = n.code,
                n = n.isErr,
                t = {
              url: o + "-" + i,
              name: o + "-" + i,
              duration: Date.now() - u,
              type: "bridge",
              ret: t,
              isErr: +n
            };
            a.publishSpeed(t), r(e);
          });
        };
      });
    }
  });
  (m = s = s || {})[m.unknown = 100] = "unknown", m[m.wifi = 1] = "wifi", m[m.net2g = 2] = "net2g", m[m.net3g = 3] = "net3g", m[m.net4g = 4] = "net4g", m[m.net5g = 5] = "net5g", m[m.net6g = 6] = "net6g", (m = Se = Se || {})[m.android = 1] = "android", m[m.ios = 2] = "ios", m[m.windows = 3] = "windows", m[m.macos = 4] = "macos", m[m.linux = 5] = "linux", m[m.other = 100] = "other", (m = Pe = Pe || {})[m.unknown = 100] = "unknown", m[m.normal = 0] = "normal", m[m.weak = 1] = "weak", m[m.disconnected = 2] = "disconnected";

  function f(e, n, t, o) {
    return void 0 === t && (t = 3e4), void 0 === o && (o = 0), (n = void 0 === n ? 0 : n) <= e && e <= t ? e : o;
  }

  var d,
      p,
      h,
      He,
      Ue,
      g,
      _e,
      qe,
      De,
      m = new o({
    name: "device",
    onNewAegis: function (e) {
      e.extendBean("platform", this.getPlatform()), e.extendBean("netType", s.unknown), this.getDpi(e), this.refreshNetworkTypeToBean(e), this.refreshNetworkStatusToBean(e);
    },
    getDpi: function (e) {
      e.extendBean("vp", Math.round(window.innerWidth) + " * " + Math.round(window.innerHeight)), window.screen && e.extendBean("sr", Math.round(window.screen.width) + " * " + Math.round(window.screen.height));
    },
    getPlatform: function () {
      var n = {
        android: /\bAndroid\s*([^;]+)/,
        ios: /\b(iPad|iPhone|iPod)\b.*? OS ([\d_]+)/,
        windows: /\b(Windows NT)/,
        macos: /\b(Mac OS)/,
        linux: /\b(Linux)/i
      },
          e = Object.keys(n).find(function (e) {
        return n[e].test(navigator.userAgent);
      });
      return e ? Se[e] : Se.other;
    },
    refreshNetworkTypeToBean: function (n) {
      var t = this,
          e = n.config;
      e && ("function" == typeof e.getNetworkType ? e.getNetworkType : Fe)(function (e) {
        s[e] || (e = s.unknown), n.extendBean("netType", e), t.NetworkRefreshTimer = setTimeout(function () {
          t.refreshNetworkTypeToBean(n), clearTimeout(t.NetworkRefreshTimer);
        }, 1e4);
      });
    },
    refreshNetworkStatusToBean: function (n) {
      var e,
          t = this,
          o = n.config;
      !o || null != (e = "function" == typeof o.getNetworkStatus ? o.getNetworkStatus : e) && e(function (e) {
        void 0 === Pe[e] && (e = Pe.unknown), n.extendBean("netStatus", e), t.NetworkStatusRefreshTimer = setTimeout(function () {
          t.refreshNetworkStatusToBean(n), clearTimeout(t.NetworkStatusRefreshTimer);
        }, 1e4);
      });
    }
  }),
      Fe = function (e) {
    var n = "",
        t = navigator.userAgent.match(/NetType\/(\w+)/);
    t ? n = t[1] : navigator.connection && (n = navigator.connection.effectiveType || navigator.connection.type), e((t = n = n || "unknown", 0 <= (t = String(t).toLowerCase()).indexOf("4g") ? s.net4g : 0 <= t.indexOf("wifi") ? s.wifi : 0 <= t.indexOf("5g") ? s.net5g : 0 <= t.indexOf("6g") ? s.net6g : 0 <= t.indexOf("3g") ? s.net3g : 0 <= t.indexOf("2g") ? s.net2g : s.unknown));
  },
      Be = window.WebSocket,
      w = [],
      Me = {
    construct: function (e, n) {
      var s = new e(n[0], n[1]);
      return s.originSend = s.send, s.addEventListener("error", function (e) {
        var e = (null == e ? void 0 : e.currentTarget) || {},
            n = e.url,
            t = e.readyState;
        null != w && w.forEach(function (e) {
          e = e.onErr;
          null != e && e({
            msg: "",
            readyState: t,
            connectUrl: n
          });
        });
      }), Object.defineProperty(s, "send", {
        get: function () {
          return function (e) {
            null != (n = s.originSend) && n.call(s, e);
            var n = s.readyState,
                e = WebSocket.OPEN,
                t = WebSocket.CLOSED,
                o = WebSocket.CONNECTING,
                i = WebSocket.CLOSING;

            if (n !== e) {
              var r = {
                readyState: n,
                connectUrl: s.url
              };

              switch (n) {
                case t:
                  w.forEach(function (e) {
                    e = e.sendErr;
                    null != e && e(E({
                      msg: ""
                    }, r));
                  });
                  break;

                case o:
                  w.forEach(function (e) {
                    (0, e.sendErr)(E({
                      msg: ""
                    }, r));
                  });
                  break;

                case i:
                  w.forEach(function (e) {
                    (0, e.sendErr)(E({
                      msg: ""
                    }, r));
                  });
              }
            }
          };
        }
      }), s;
    }
  },
      We = new o({
    name: "onError"
  }),
      Xe = We = new o({
    name: "onError",
    onNewAegis: function (e) {
      this.startListen(e);
    },
    startListen: function (l) {
      function e(e) {
        e = e && O(e.reason), r.publishErrorLog({
          msg: "PROMISE_ERROR: " + e,
          level: C.PROMISE_ERROR
        });
      }

      function n(e) {
        if (e = (null == e ? void 0 : e.target) || (null == e ? void 0 : e.srcElement)) {
          var n = e.src || e.href,
              e = e.tagName;

          if ("string" == typeof n && e && !(-1 < window.location.href.indexOf(n))) {
            var t = {
              msg: e + " load fail: " + n,
              level: C.INFO
            };
            if (/\.js$/.test(n)) t.level = C.SCRIPT_ERROR;else if (/\.css$/.test(n)) t.level = C.CSS_ERROR;else switch (e.toLowerCase()) {
              case "script":
                t.level = C.SCRIPT_ERROR;
                break;

              case "link":
                t.level = C.CSS_ERROR;
                break;

              case "img":
                t.level = C.IMAGE_ERROR;
                break;

              case "audio":
              case "video":
                t.level = C.MEDIA_ERROR;
                break;

              default:
                return;
            }
            r.publishErrorLog(t);
          }
        }
      }

      var t,
          o,
          i,
          r = this,
          s = window.onerror,
          f = (window.onerror = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

        r.publishErrorLog({
          msg: (O(e[0]) || "") + " @ (" + (O(e[1]) || "") + ":" + (e[2] || 0) + ":" + (e[3] || 0) + ")\n          \n" + O(e[4] || ""),
          level: C.ERROR
        }), null != s && s.call.apply(s, u([window], e));
      }, window.addEventListener("unhandledrejection", e), window.document.addEventListener("error", n, !0), l.lifeCycle.on("destroy", function () {
        0 === We.countInstance() && (window.document.removeEventListener("unhandledrejection", e), window.document.removeEventListener("error", n, !0));
      }), this),
          a = {
        name: this.name,
        send: function (u, c) {
          u.addEventListener("loadend", function () {
            var e,
                n,
                t,
                o,
                i,
                r,
                s,
                a = "";
            this.failType ? a = this.failType : this.status ? 400 <= this.status && (a = "error") : a = "failed", l.config.hostUrl && this.aegisUrl && -1 < this.aegisUrl.indexOf(l.config.hostUrl) || !a || (e = u.aegisUrl, n = (null == (n = l.config.api) ? void 0 : n.reqHeaders) || [], n = k(u.aegisXhrReqHeader, n, "req"), o = (null == (o = l.config.api) ? void 0 : o.resHeaders) || [], t = Re(u.getAllResponseHeaders()), t = k(t, o, "res"), o = Oe(u.aegisXhrReqHeader), i = V(u.response, l.config.api, {
              url: e,
              ctx: u,
              payload: c
            }).code, r = (s = null == (s = l.config.api) ? void 0 : s.apiDetail) ? x(c, null == (r = l.config.api) ? void 0 : r.reqParamHandler, {
              url: e
            }) : "", s = s ? x(u.responseType && "text" !== u.responseType && "json" !== u.responseType ? "" : se(u.response), null == (s = l.config.api) ? void 0 : s.resBodyHandler, {
              url: e
            }) : "", f.publishErrorLog({
              msg: "AJAX_ERROR: request " + a + "\n                      \nreq url: " + this.aegisUrl + "\n                      \nres status: " + (this.status || 0) + "\n                      \nres duration: " + (Date.now() - u.aegisXhrStartTime) + "ms\n                      \nres retcode: " + i + "\n                      \nreq method: " + this.aegisMethod + "\n                      \nreq param: " + r + "\n                      \nres data: " + s + "\n                      " + n + "\n                      " + t,
              level: C.AJAX_ERROR,
              trace: o
            }));
          }), u.addEventListener("timeout", function () {
            u.failType = "timeout";
          }), u.addEventListener("error", function () {
            u.failType = "error";
          }), u.addEventListener("abort", function () {
            u.failType = "abort";
          });
        }
      };
      this.hackXHROptions = a, be(this.hackXHROptions), l.config.websocketHack && (a = {
        key: l.config.id + "-" + this.name,
        onErr: function (e) {
          var n;
          null != (n = r.publishWsErrorLog) && n.call(r, e);
        },
        sendErr: function (e) {
          var n;
          null != (n = r.publishWsErrorLog) && n.call(r, e);
        }
      }, this.hackWebsocketConfig = a, a = this.hackWebsocketConfig, window.Proxy && window.WebSocket && (t = window.WebSocket, window && !t.isHack && (o = new Proxy(WebSocket, Me), t.isHack = !0, window.WebSocket = o), i = a, w.find(function (e) {
        return e.key === i.key;
      }) || i && w.push(i)));
    },
    publishErrorLog: function (n) {
      this.$walk(function (e) {
        e.normalLogPipeline(n);
      });
    },
    publishWsErrorLog: function (e) {
      var n = e.connectUrl,
          t = e.msg,
          e = e.readyState;
      this.publishErrorLog({
        msg: "WEBSOCKET_ERROR: \n              connect: " + n + "\n              readyState: " + e + "\n              msg: " + t,
        level: C.WEBSOCKET_ERROR
      });
    },
    destroy: function () {
      var n, e;
      this.option.publishErrorLog = function () {}, this.option.hackXHROptions && Ee(this.option.hackXHROptions), this.option.hackWebsocketConfig && (n = this.option.hackWebsocketConfig, window.WebSocket = Be, -1 !== (e = w.findIndex(function (e) {
        return e.key === n.key;
      })) && w.splice(e, 1));
    }
  }),
      Ve = (new o({
    name: "pagePerformance"
  }), 3),
      Ge = new o({
    name: "pagePerformance",
    onNewAegis: function (e) {
      z() && (d ? this.publish(d, e) : this.startCalcPerformance(e));
    },
    publish: function (e, s) {
      var a = this;
      s.sendPipeline([function (e, n) {
        var t,
            o = [];

        for (t in e) o.push(t + "=" + e[t]);

        var i,
            r = a.$getConfig(s);
        if (r) return i = -1 === s.config.performanceUrl.indexOf("?") ? "?" : "&", "function" == typeof r.urlHandler ? n({
          url: s.config.performanceUrl + i + o.join("&") + "&from=" + (encodeURIComponent(r.urlHandler()) || window.location.href),
          beanFilter: ["from"],
          type: R.PERFORMANCE,
          log: e
        }) : n({
          url: s.config.performanceUrl + i + o.join("&"),
          type: R.PERFORMANCE,
          log: e
        });
      }], R.PERFORMANCE)(e);
    },
    startCalcPerformance: function (t) {
      var o = this;

      try {
        this.getFirstScreenTiming(t, function (e) {
          var n = performance.timing;
          n && (d = {
            dnsLookup: f(n.domainLookupEnd - n.domainLookupStart),
            tcp: f(n.connectEnd - n.connectStart),
            ssl: f(0 === n.secureConnectionStart ? 0 : n.requestStart - n.secureConnectionStart),
            ttfb: f(n.responseStart - n.requestStart),
            contentDownload: f(n.responseEnd - n.responseStart),
            domParse: f(n.domInteractive - n.domLoading, 0, 3e4, 1070),
            resourceDownload: f(n.loadEventStart - n.domInteractive, 0, 3e4, 1070),
            firstScreenTiming: f(Math.floor(e), 0, 6e4)
          }, (n = t.config).extraPerformanceData && "{}" !== JSON.stringify(n.extraPerformanceData) && (n = (e = n.extraPerformanceData).engineInit, e = e.bundleLoad, d = E(E({}, d), {
            engineInit: f(n, 0, 1e4),
            bundleLoad: f(e, 0, 1e4)
          })), o.publish(d, t));
        });
      } catch (t) {}
    },
    getFirstScreenTiming: function (a, u) {
      a.lifeCycle.on("destroy", function () {
        h && clearTimeout(h);
      });
      var c = this,
          t = ["script", "style", "link", "br"],
          l = [],
          f = {},
          d = new MutationObserver(function (e) {
        var n = {
          roots: [],
          rootsDomNum: [],
          time: performance.now()
        };
        e.forEach(function (e) {
          e && e.addedNodes && e.addedNodes.forEach && e.addedNodes.forEach(function (e) {
            1 === e.nodeType && (e.hasAttribute("AEGIS-FIRST-SCREEN-TIMING") || e.querySelector("[AEGIS-FIRST-SCREEN-TIMING]")) ? (Object.prototype.hasOwnProperty.apply(f, [n.time]) || (f[n.time] = []), f[n.time].push(e)) : 1 !== e.nodeType || -1 !== t.indexOf(e.nodeName.toLocaleLowerCase()) || c.isEleInArray(e, n.roots) || e.hasAttribute("AEGIS-IGNORE-FIRST-SCREEN-TIMING") || (n.roots.push(e), n.rootsDomNum.push(c.walkAndCount(e) || 0));
          });
        }), n.roots.length && l.push(n);
      }),
          p = (d.observe(document, {
        childList: !0,
        subtree: !0
      }), function (o) {
        (o = void 0 === o ? 0 : o) || (i = 0, (e = Object.keys(f).filter(function (e) {
          return f[+e].find(function (e) {
            return c.isInFirstScreen(e);
          });
        })).length ? (o = Math.max.apply(null, e), ("object" != typeof (null == (e = a.config) ? void 0 : e.pagePerformance) || null != (e = a.config.pagePerformance) && e.firstScreenInfo) && (a.firstScreenInfo = {
          element: null == (e = f[o]) ? void 0 : e[0],
          timing: o,
          markDoms: f
        })) : l.forEach(function (e) {
          for (var n, t = 0; t < e.roots.length; t++) e.rootsDomNum[t] > i && c.isInFirstScreen(e.roots[t]) && (i = e.rootsDomNum[t], o = e.time, ("object" != typeof (null == (n = a.config) ? void 0 : n.pagePerformance) || null != (n = a.config.pagePerformance) && n.firstScreenInfo) && (a.firstScreenInfo = {
            element: e.roots[t],
            timing: o
          }));
        }), l.length = 0, Object.keys(f).forEach(function (e) {
          f[e] = f[e].map(function (e) {
            var n = {
              tagName: e.tagName
            },
                t = e.attributes;
            if (!t) return e;

            for (var o = 0; o < t.length; o++) {
              var i = t[o];
              i.name && (n[i.name] = e.getAttribute(i.name));
            }

            return n;
          });
        }));
        var i,
            e = performance.timing,
            n = e.domInteractive - e.domLoading,
            e = e.loadEventStart - e.domInteractive,
            t = o;
        h = null;

        for (var r = 0, s = [n, e, t]; r < s.length; r++) if (s[r] <= 0 && 0 < Ve) {
          h = setTimeout(function () {
            return p(t);
          }, 3e3);
          break;
        }

        h ? --Ve : (d.disconnect(), null != u && u(o));
      }),
          h = setTimeout(function () {
        return p();
      }, 3e3);
    },
    isEleInArray: function (e, n) {
      return !(!e || e === document.documentElement) && (-1 !== n.indexOf(e) || this.isEleInArray(e.parentElement, n));
    },
    isInFirstScreen: function (e) {
      var n, t;
      return !(!e || "function" != typeof e.getBoundingClientRect) && (e = e.getBoundingClientRect(), n = window.innerHeight, t = window.innerWidth, 0 <= e.left && e.left < t && 0 <= e.top && e.top < n && 0 < e.width && 0 < e.height);
    },
    walkAndCount: function (e) {
      var n = 0;

      if (e && 1 === e.nodeType) {
        n += 1;
        var t = e.children;
        if (null != t && t.length) for (var o = 0; o < t.length; o++) n += this.walkAndCount(t[o]);
      }

      return n;
    }
  });

  function $e() {
    Ue = [], h = -1, p = null, Qe(addEventListener);
  }

  function Je(e, n) {
    p || (p = n, h = e, He = new Date(), Qe(removeEventListener), Ke());
  }

  function Ke() {
    var n;
    0 <= h && h < He - _e && (n = {
      entryType: "first-input",
      name: p.type,
      target: p.target,
      cancelable: p.cancelable,
      startTime: p.timeStamp,
      processingStart: p.timeStamp + h
    }, Ue.forEach(function (e) {
      e(n);
    }), Ue = []);
  }

  function Qe(n) {
    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function (e) {
      return n(e, qe, g);
    });
  }

  g = {
    passive: !0,
    capture: !0
  }, _e = new Date(), qe = function (e) {
    var n, t, o, i;

    function r() {
      Je(t, o), i();
    }

    function s() {
      i();
    }

    e.cancelable && (n = (1e12 < e.timeStamp ? new Date() : performance.now()) - e.timeStamp, "pointerdown" == e.type ? (t = n, o = e, i = function () {
      removeEventListener("pointerup", r, g), removeEventListener("pointercancel", s, g);
    }, addEventListener("pointerup", r, g), addEventListener("pointercancel", s, g)) : Je(n, e));
  }, De = "hidden" === document.visibilityState ? 0 : 1 / 0, addEventListener("visibilitychange", function e(n) {
    "hidden" === document.visibilityState && (De = n.timeStamp, removeEventListener("visibilitychange", e, !0));
  }, !0), $e(), self.webVitals = {
    firstInputPolyfill: function (e) {
      Ue.push(e), Ke();
    },
    resetFirstInputPolyfill: $e,

    get firstHiddenTime() {
      return De;
    }

  };

  function I(e, n) {
    return {
      name: e,
      value: void 0 === n ? -1 : n,
      delta: 0,
      entries: [],
      id: "v1-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12)
    };
  }

  function Ye(e, n) {
    try {
      var t;
      if (PerformanceObserver.supportedEntryTypes.includes(e)) if ("first-input" !== e || "PerformanceEventTiming" in self) return (t = new PerformanceObserver(function (e) {
        return e.getEntries().map(n);
      })).observe({
        type: e,
        buffered: !0
      }), t;
    } catch (e) {}
  }

  function A(n) {
    addEventListener("pageshow", function (e) {
      e.persisted && n(e);
    }, !0);
  }

  function N(e, n, t) {
    var o;
    return function () {
      0 <= n.value && (t || j.has(n) || "hidden" === document.visibilityState) && (n.delta = n.value - (o || 0), !n.delta && void 0 !== o || (o = n.value, e(n)));
    };
  }

  function ze() {
    rn(function (e) {
      e = e.timeStamp;
      b = e;
    }, !0);
  }

  function Ze() {
    return b < 0 && ((b = self.webVitals.firstHiddenTime) === 1 / 0 && ze(), A(function () {
      setTimeout(function () {
        b = "hidden" === document.visibilityState ? 0 : 1 / 0, ze();
      }, 0);
    })), {
      get timeStamp() {
        return b;
      }

    };
  }

  function en(e) {
    var n = e.name,
        e = e.value;
    sn[n] = e;
  }

  function nn(e, h) {
    function g(e) {
      b = e;
    }

    function m(e) {
      y = y.concat(e);
    }

    function v(e, n) {
      w = {
        conds: e = void 0 === e ? {} : e,
        params: n = void 0 === n ? {} : n
      };
    }

    var y = [],
        w = null,
        b = null;
    S.useAsyncPlugin(e, {
      exportsConstructor: "Flog",
      onAegisInit: function (e) {
        e.lifeCycle.on("beforeWrite", m), e.lifeCycle.on("uploadLogs", v), e.lifeCycle.on("onConfigChange", g);
      },
      onAegisInitAndPluginLoaded: function (o, e) {
        var n,
            t,
            i,
            r,
            s,
            a,
            u = h.dbConfig,
            u = void 0 === u ? {} : u,
            c = h.url,
            c = void 0 === c ? S.urls.aegisCollect : c,
            l = h.offlineLogExp,
            l = void 0 === l ? 3 : l,
            f = h.id,
            d = h.uin,
            c = (null != (n = o.lifeCycle) && n.remove("beforeWrite", m), null != (n = o.lifeCycle) && n.remove("uploadLogs", v), null != (n = o.lifeCycle) && n.remove("onConfigChange", g), Object.assign({
          lookupUrl: c + "/offlineAuto?id=" + f,
          preservedDay: l,
          id: f,
          uin: d,
          aid: (null == (n = o.bean) ? void 0 : n.aid) || "",
          beforeRequest: o.config.beforeRequest,
          afterRequest: o.config.afterRequest
        }, u, {
          sessionId: S.sessionID
        }));

        try {
          var p = new e(c);
          y.forEach(function (e) {
            p.add(E(E({}, e), {
              level: e.level === C.INFO_ALL ? C.INFO : e.level
            }));
          }), null != (t = o.lifeCycle) && t.on("beforeWrite", function (e) {
            (e = void 0 === e ? [] : e).forEach(function (e) {
              p.add(E(E({}, e), {
                level: e.level === C.INFO_ALL ? C.INFO : e.level
              }));
            });
          }), null != (i = o.lifeCycle) && i.on("uploadLogs", function (e, n) {
            var t;
            void 0 === e && (e = {}), void 0 === n && (n = {}), p.uploadLogs(Object.assign({
              id: h.id,
              uin: h.uin,
              aid: null == (t = o.bean) ? void 0 : t.aid
            }, e), n);
          }), null != (r = o.lifeCycle) && r.on("onConfigChange", function (e) {
            p.setConfig(e);
          }), null != (s = o.lifeCycle) && s.on("destroy", function () {
            0 === cn.countInstance() && (y.length = 0, "function" == typeof ((w = null) == p ? void 0 : p.destroy) && p.destroy());
          }), p.on("PERREVENT", function (e) {
            o.sendPipeline([function (e, n) {
              t = {
                msg: O(e),
                level: C.INFO
              };
              var t = (t = Array.isArray(t) ? t : [t]).map(function (n, t) {
                return Object.getOwnPropertyNames(n).map(function (e) {
                  return F(e) + "[" + t + "]=" + (void 0 === n[e] ? "" : F(n[e]));
                }).join("&");
              }).join("&") + (t.length ? "&count=" + t.length : "");
              n({
                type: R.OFFLINE,
                data: t,
                contentType: "application/x-www-form-urlencoded",
                method: "post",
                addBean: !1,
                url: h.url + "?id=893&sessionId=" + S.sessionID + "&uin=" + h.uin + "&from=" + h.id + "&count=1&version=1.36.5",
                log: e
              });
            }], R.OFFLINE)(e);
          }), b && (p.setConfig(b), b = null), w && (null != (a = o.lifeCycle) && a.emit("uploadLogs", w.conds, w.params), w = null), o.flog = p;
        } catch (o) {
          console.log(o);
        }
      }
    });
  }

  var tn,
      on,
      rn = function (n, t) {
    function o(e) {
      "pagehide" !== e.type && "hidden" !== document.visibilityState || (n(e), t && (removeEventListener("visibilitychange", o, !0), removeEventListener("pagehide", o, !0)));
    }

    addEventListener("visibilitychange", o, !0), addEventListener("pagehide", o, !0);
  },
      j = new ("function" == typeof WeakSet ? WeakSet : Set)(),
      b = -1,
      sn = (new o({
    name: "webVitals"
  }), {
    FCP: -1,
    LCP: -1,
    FID: -1,
    CLS: -1
  }),
      an = new o({
    name: "webVitals",
    onNewAegis: function (e) {
      if (z() && "function" == typeof window.PerformanceObserver && "function" == typeof performance.getEntriesByName) try {
        v = en, w = Ze(), b = I("FCP"), E = performance.getEntriesByName("first-contentful-paint")[0], R = E ? null : Ye("paint", P), (E || R) && (y = N(v, b, void 0), E && P(E), A(function (e) {
          b = I("FCP"), y = N(v, b, void 0), requestAnimationFrame(function () {
            requestAnimationFrame(function () {
              b.value = performance.now() - e.timeStamp, j.add(b), y();
            });
          });
        })), f = en, h = Ze(), g = I("LCP"), (m = Ye("largest-contentful-paint", S)) && (d = N(f, g, void 0), p = function () {
          j.has(g) || (m.takeRecords().map(S), m.disconnect(), j.add(g), d());
        }, ["keydown", "click"].forEach(function (e) {
          addEventListener(e, p, {
            once: !0,
            capture: !0
          });
        }), rn(p, !0), A(function (e) {
          g = I("LCP"), d = N(f, g, void 0), requestAnimationFrame(function () {
            requestAnimationFrame(function () {
              g.value = performance.now() - e.timeStamp, j.add(g), d();
            });
          });
        })), s = en, a = Ze(), u = I("FID"), c = Ye("first-input", O), l = N(s, u, void 0), c && rn(function () {
          c.takeRecords().map(O), c.disconnect();
        }, !0), c || window.webVitals.firstInputPolyfill(O), A(function () {
          u = I("FID"), l = N(s, u, void 0), window.webVitals.resetFirstInputPolyfill(), window.webVitals.firstInputPolyfill(O);
        }), t = en, i = I("CLS", 0), (r = Ye("layout-shift", n)) && (o = N(t, i, void 0), rn(function () {
          r.takeRecords().map(n), o();
        }), A(function () {
          i = I("CLS", 0), o = N(t, i, void 0);
        })), Z(this.publish.bind(this, e), !0);
      } catch (e) {}

      function n(e) {
        e.hadRecentInput || (i.value += e.value, i.entries.push(e), o());
      }

      var t, o, i, r, s, a, u, c, l, f, d, p, h, g, m, v, y, w, b, E, R;

      function O(e) {
        e.startTime < a.timeStamp && (u.value = e.processingStart - e.startTime, u.entries.push(e), j.add(u), l());
      }

      function S(e) {
        var n = e.startTime;
        n < h.timeStamp && (g.value = n, g.entries.push(e)), d();
      }

      function P(e) {
        "first-contentful-paint" === e.name && (R && R.disconnect(), e.startTime < w.timeStamp && (b.value = e.startTime, b.entries.push(e), j.add(b), y()));
      }
    },
    publish: function (r) {
      r.sendPipeline([function (e, n) {
        var t,
            o = [];

        for (t in e) o.push(t + "=" + e[t]);

        var i = -1 === r.config.performanceUrl.indexOf("?") ? "?" : "&";
        n({
          url: r.config.webVitalsUrl + i + o.join("&"),
          type: R.VITALS,
          log: e,
          sendBeacon: !0
        });
      }], R.VITALS)(sn);
    },
    destroy: function () {
      this.option.publish = function () {};
    }
  }),
      un = 0,
      S = (D(on = H, t = tn = t), on.prototype = null === t ? Object.create(t) : (fn.prototype = t.prototype, new fn()), H.prototype.getBean = function (n) {
    var t = this;
    return void 0 === n && (n = []), "" + Object.getOwnPropertyNames(this.bean).filter(function (e) {
      return -1 === n.indexOf(e);
    }).map(function (e) {
      return "from" === e ? "from=" + t.getCurrentPageUrl() : e + "=" + t.bean[e];
    }).join("&");
  }, H.prototype.getCurrentPageUrl = function () {
    var e = this.config.pageUrl || location.href;
    return "function" == typeof this.config.urlHandler && (e = this.config.urlHandler()), encodeURIComponent(e);
  }, H.prototype.ready = function () {
    function r() {
      var e, t, o, i;
      n.reportRequestQueue.length && (e = n.reportRequestQueue.splice(0, 1)[0], t = e.options, o = e.success, i = e.fail, n.$request(t, function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

        try {
          return null == o ? void 0 : o.apply(t, e);
        } finally {
          r();
        }
      }, function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

        try {
          return null == i ? void 0 : i.apply(t, e);
        } finally {
          r();
        }
      }));
    }

    var n = this;
    r(), this.isReportReady = !0;
  }, H.prototype.request = function (e, n, t) {
    this.config.reportImmediately || this.isReportReady ? this.$request(e, n, t) : this.reportRequestQueue.push({
      options: e,
      success: n,
      fail: t
    });
  }, H.prototype.$request = function (e, n, t) {
    var o, i, r, s;
    if (e && "string" == typeof e.url && "" !== e.url && this.bean.id) return s = e.url, !1 !== e.addBean && (s = s + (-1 === s.indexOf("?") ? "?" : "&") + this.getBean(e.beanFilter)), e.url = s, s = e.method || "get", (e = (i = this.config.onBeforeRequest) ? i(e, this) : e) ? e.url ? void ((null != e && e.sendBeacon || this.sendNow) && "function" == typeof (null === navigator || void 0 === navigator ? void 0 : navigator.sendBeacon) ? navigator.sendBeacon(e.url, e.data) : ((o = new XMLHttpRequest()).sendByAegis = !0, o.addEventListener("readystatechange", function () {
      4 === o.readyState && (400 <= o.status || 0 === o.status ? null != t && t(o.response) : null != n && n(o.response));
    }), "get" === s.toLocaleLowerCase() ? (o.open("get", (i = e.url, r = e.data, "string" != typeof i ? "" : "object" == typeof r && r ? (s = Object.getOwnPropertyNames(r).map(function (e) {
      var n = r[e];
      return e + "=" + ("string" == typeof n ? encodeURIComponent(n) : encodeURIComponent(JSON.stringify(n)));
    }).join("&").replace(/eval/gi, "evaI"), i + (-1 === i.indexOf("?") ? "?" : "&") + s) : i)), o.send()) : (o.open("post", e.url), e.contentType && o.setRequestHeader("Content-Type", e.contentType), "string" == typeof e.data && (e.data = e.data.replace(/eval/gi, "evaI")), o.send(e.data)))) : console.warn("Please handle the parameters reasonably, options.url is necessary") : console.warn("Sending request blocked");
  }, H.useAsyncPlugin = function (s, e) {
    var n = (e = void 0 === e ? {} : e).exportsConstructor,
        a = void 0 === n ? "aegis-plugin-" + un : n,
        n = e.onAegisInit,
        u = void 0 === n ? function () {} : n,
        n = e.onAegisInitAndPluginLoaded,
        c = void 0 === n ? function () {} : n;
    if (un += 1, "string" != typeof s) throw new TypeError("useAsyncPlugin first param must be string");
    if ("function" != typeof u || "function" != typeof c) throw new TypeError("onAegisInit and onAegisInitAndPluginLoaded must be function");
    this.use(new o({
      name: "asyncPlugin",
      onNewAegis: function (n) {
        try {
          u(n), H.asyncPlugin[s] ? c(n, window[H.asyncPlugin[s]]) : (e = s, t = a, o = function (e) {
            e || (H.asyncPlugin[s] = a, e = window[a], c(n, e));
          }, i = document.createElement("script"), r = document.head, "function" == typeof t && (o = t, t = ""), i.src = e, i.setAttribute("name", t), i.name = t, i.setAttribute("crossorigin", "anonymous"), i.crossorigin = "anonymous", i.defer = !0, i.hasLoaded = !1, i.onreadystatechange = function () {
            i.hasLoaded || i.readyState && "loaded" !== i.readyState && "complete" !== i.readyState || (i.hasLoaded = !0, "function" == typeof o && o(!1), setTimeout(function () {
              r.contains(i) && r.removeChild(i);
            }));
          }, i.onload = i.onreadystatechange, i.onerror = function () {
            "function" == typeof o && o(!0), setTimeout(function () {
              r.contains(i) && r.removeChild(i);
            });
          }, "complete" === document.readyState ? r.appendChild(i) : window.addEventListener("load", function () {
            r.appendChild(i);
          }));
        } catch (e) {
          console.log("error on below is caused by " + s + " "), console.error(e);
        }

        var e, t, o, i, r;
      }
    }));
  }, H.prototype.publishPluginsLogs = function () {
    var e = H.installedPlugins.find(function (e) {
      return "reportAssetSpeed" === e.name;
    });
    null != e && e.option.collectNotReportedLog(this);
  }, H.prototype.uploadLogs = function (e, n) {
    this.lifeCycle.emit("uploadLogs", e = void 0 === e ? {} : e, n = void 0 === n ? {} : n);
  }, H.sessionID = "session-" + Date.now(), H.asyncPlugin = {}, H.urls = {
    aegisCollect: "https://aegis.qq.com/collect",
    flog: "https://cdn-go.cn/vasdev/web_webpersistance_v2/v1.8.2/flog.core.min.js"
  }, H),
      cn = new o({
    name: "offlineLog"
  }),
      t = cn = new o({
    name: "offlineLog",
    onNewAegis: function (e) {
      nn(S.urls.flog, e.config);
    }
  }),
      ln = (new o({
    name: "spa"
  }), new o({
    name: "spa",
    init: function () {
      history.pushState = this.wr("pushState") || history.pushState, history.replaceState = this.wr("replaceState") || history.replaceState;
      var e = (null == (e = location.href) ? void 0 : e.split("?"))[0];
      this.$fireUrl = e, this.sendPv = this.sendPv.bind(this), this.onPageChange();
    },
    onPageChange: function () {
      window.addEventListener("replaceState", this.sendPv), window.addEventListener("pushState", this.sendPv), window.addEventListener("popstate", this.sendPv);
    },
    wr: function (t) {
      var o = history[t],
          e = "__" + t + "__hasWrittenByTamSpa";
      return "function" == typeof o && !history[e] && (Object.defineProperty(history, e, {
        value: !0,
        enumerable: !1
      }), function () {
        var e = o.apply(this, arguments),
            n = null;
        return "function" == typeof Event ? n = new Event(t) : (n = document.createEvent("HTMLEvents")).initEvent(t, !1, !0), window.dispatchEvent(n), e;
      });
    },
    sendPv: function () {
      var n = this;
      setTimeout(function () {
        var o = location.href,
            e = (null == (e = location.href) ? void 0 : e.split("?"))[0];
        e && e !== n.$fireUrl && (n.$walk(function (t) {
          t.sendPipeline([function (e, n) {
            n({
              url: t.config.pvUrl + "?from=" + encodeURIComponent(o),
              beanFilter: ["from"],
              type: R.PV
            });
          }], R.PV)(null);
        }), n.$fireUrl = e);
      }, 0);
    },
    destroy: function () {
      window.removeEventListener("replaceState", this.option.sendPv), window.removeEventListener("pushState", this.option.sendPv), window.removeEventListener("popstate", this.option.sendPv);
    }
  }));

  function H(e) {
    var n,
        t,
        o,
        i,
        r,
        s = tn.call(this, e) || this;
    s.sendNow = !1, s.isReportReady = !1, s.reportRequestQueue = [], s.speedLogPipeline = v([G(s), (i = s.config, r = {}, function (e, n) {
      var t, o;
      i.speedSample ? (o = "object" == typeof i.repeat ? i.repeat : {
        repeat: i.repeat
      }, t = +o.speed || +o.repeat || 5, Array.isArray(e) ? (o = e.filter(function (e) {
        var n = !r[e.url] || r[e.url] < t;
        return r[e.url] = 1 + ~~r[e.url], n;
      })).length && n(o) : (!r[e.url] || r[e.url] < t) && (r[e.url] = 1 + ~~r[e.url], n(e))) : n(e);
    }), (o = s, function (n, t) {
      Fe(function (e) {
        o.extendBean("netType", e), t(n);
      });
    }), function (e, n) {
      s.lifeCycle.emit("beforeReportSpeed", e);
      var t = s.config.beforeReportSpeed;
      if ((e = "function" == typeof t ? e.filter(function (e) {
        return !1 !== t(e);
      }) : e).length) return n(e);
    }, function (e) {
      return s.sendPipeline([function (e, n) {
        var t, o, i, r;
        n({
          type: R.SPEED,
          url: "" + s.config.speedUrl,
          method: "post",
          data: (n = e, t = E(E({}, s.bean), {
            from: s.getCurrentPageUrl()
          }), i = {
            fetch: [],
            static: [],
            bridge: []
          }, r = new FormData(), Array.isArray(n) ? n.forEach(function (e) {
            var n = me(e);
            i[e.type].push(n);
          }) : (o = me(n), i[n.type].push(o)), r.append("payload", re(E({
            duration: i
          }, t))), r),
          log: e
        });
      }], R.SPEED)(e);
    }]), e.asyncPlugin = !0;

    try {
      "undefined" != typeof document && (e.uin = e.uin || (null != (n = document.cookie.match(/\buin=\D+(\d*)/)) ? n : [])[1] || (null != (t = document.cookie.match(/\bilive_uin=\D*(\d+)/)) ? t : [])[1] || ""), s.init(e), s.extendBean("sessionId", H.sessionID), s.extendBean("from", s.getCurrentPageUrl()), "undefined" != typeof document && s.extendBean("referer", encodeURIComponent(document.referrer || "")), e.ext1 && s.extendBean("ext1", encodeURIComponent(e.ext1)), e.ext2 && s.extendBean("ext2", encodeURIComponent(e.ext2)), e.ext3 && s.extendBean("ext3", encodeURIComponent(e.ext3));
    } catch (e) {
      console.warn(e), console.log("%cThe above error occurred in the process of initializing Aegis, which will affect your normal use of Aegis.\nIt is recommended that you contact us for feedback and thank you for your support.", "color: red"), s.sendSDKError(e);
    }

    return s;
  }

  function fn() {
    this.constructor = on;
  }

  new o({
    name: "ie"
  }), new o({
    name: "onClose"
  });
  var dn = new o({
    name: "onClose",
    onNewAegis: function () {
      var t,
          o = this;
      i.desktop() ? (t = window.onunload, window.onunload = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];

        o.publishNotReportedLog(), null != t && t.call.apply(t, u([window], e));
      }) : Z(this.publishNotReportedLog.bind(this), !0);
    },
    publishNotReportedLog: function () {
      var n = this;
      this.$walk(function (e) {
        e.sendNow = !0, e.publishPluginsLogs(), n.publishThrottlePipeLogs(e);
      });
    },
    publishThrottlePipeLogs: function (e) {
      null != e && e.speedLogPipeline([]), null != e && e.eventPipeline([]), null != e && e.customTimePipeline([]), null != e && e.normalLogPipeline([]);
    }
  });
  return new o({
    name: "aid"
  }), S.use(Xe), S.use(Ne), S.use(ye), S.use(Ge), S.use(an), S.use(he), S.use(m), S.use(t), S.use(ln), S.use(dn), S.use(je), S;
});

/***/ }),

/***/ 2084:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(4637);

/***/ }),

/***/ 2627:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(2801);

var utils = __webpack_require__(9962);

var settle = __webpack_require__(8312);

var cookies = __webpack_require__(4937);

var buildURL = __webpack_require__(9862);

var buildFullPath = __webpack_require__(6536);

var parseHeaders = __webpack_require__(1119);

var isURLSameOrigin = __webpack_require__(9155);

var transitionalDefaults = __webpack_require__(3695);

var AxiosError = __webpack_require__(8625);

var CanceledError = __webpack_require__(9255);

var parseProtocol = __webpack_require__(4117);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;

    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response); // Clean up request

      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'


        setTimeout(onloadend);
      };
    } // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function (cancel) {
        if (!request) {
          return;
        }

        reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);

      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && ['http', 'https', 'file'].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ 4637:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

var bind = __webpack_require__(6781);

var Axios = __webpack_require__(551);

var mergeConfig = __webpack_require__(1279);

var defaults = __webpack_require__(2403);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context); // Factory for creating new instances

  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Expose Cancel & CancelToken

axios.CanceledError = __webpack_require__(9255);
axios.CancelToken = __webpack_require__(9904);
axios.isCancel = __webpack_require__(5475);
axios.VERSION = (__webpack_require__(5606).version);
axios.toFormData = __webpack_require__(1326); // Expose AxiosError class

axios.AxiosError = __webpack_require__(8625); // alias for CanceledError for backward compatibility

axios.Cancel = axios.CanceledError; // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(2526); // Expose isAxiosError

axios.isAxiosError = __webpack_require__(2767);
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

/***/ }),

/***/ 9904:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(1703);

var CanceledError = __webpack_require__(9255);
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this; // eslint-disable-next-line func-names

  this.promise.then(function (cancel) {
    if (!token._listeners) return;
    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }

    token._listeners = null;
  }); // eslint-disable-next-line func-names

  this.promise.then = function (onfulfilled) {
    var _resolve; // eslint-disable-next-line func-names


    var promise = new Promise(function (resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `CanceledError` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Subscribe to the cancel signal
 */


CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};
/**
 * Unsubscribe from the cancel signal
 */


CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }

  var index = this._listeners.indexOf(listener);

  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ 9255:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var AxiosError = __webpack_require__(8625);

var utils = __webpack_require__(9962);
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */


function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
module.exports = CanceledError;

/***/ }),

/***/ 5475:
/***/ (function(module) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ 551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

var buildURL = __webpack_require__(9862);

var InterceptorManager = __webpack_require__(7370);

var dispatchRequest = __webpack_require__(5994);

var mergeConfig = __webpack_require__(1279);

var buildFullPath = __webpack_require__(6536);

var validator = __webpack_require__(2877);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */

function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  } // filter out skipped interceptors


  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }

  var newConfig = config;

  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();

    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
module.exports = Axios;

/***/ }),

/***/ 8625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(1703);

var utils = __webpack_require__(9962);
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED' // eslint-disable-next-line func-names
].forEach(function (code) {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {
  value: true
}); // eslint-disable-next-line func-names

AxiosError.from = function (error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);
  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};

module.exports = AxiosError;

/***/ }),

/***/ 7370:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ 6536:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(3497);

var combineURLs = __webpack_require__(9604);
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),

/***/ 5994:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

var transformData = __webpack_require__(4600);

var isCancel = __webpack_require__(5475);

var defaults = __webpack_require__(2403);

var CanceledError = __webpack_require__(9255);
/**
 * Throws a `CanceledError` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ 1279:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  } // eslint-disable-next-line consistent-return


  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  } // eslint-disable-next-line consistent-return


  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  } // eslint-disable-next-line consistent-return


  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  } // eslint-disable-next-line consistent-return


  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};

/***/ }),

/***/ 8312:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var AxiosError = __webpack_require__(8625);
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
};

/***/ }),

/***/ 4600:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

var defaults = __webpack_require__(2403);
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/

  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });
  return data;
};

/***/ }),

/***/ 2403:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

var normalizeHeaderName = __webpack_require__(1954);

var AxiosError = __webpack_require__(8625);

var transitionalDefaults = __webpack_require__(3695);

var toFormData = __webpack_require__(1326);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(2627);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(2627);
  }

  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];
    var isFileList;

    if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === 'multipart/form-data') {
      var _FormData = this.env && this.env.FormData;

      return toFormData(isFileList ? {
        'files[]': data
      } : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }

          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: __webpack_require__(4953)
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ 3695:
/***/ (function(module) {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

/***/ }),

/***/ 5606:
/***/ (function(module) {

module.exports = {
  "version": "0.27.2"
};

/***/ }),

/***/ 6781:
/***/ (function(module) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ 9862:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ 9604:
/***/ (function(module) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ 4937:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ 3497:
/***/ (function(module) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ 2767:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);
/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */


module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
};

/***/ }),

/***/ 9155:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ 1954:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ 4953:
/***/ (function(module) {

// eslint-disable-next-line strict
module.exports = null;

/***/ }),

/***/ 1119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(9962); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ 4117:
/***/ (function(module) {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};

/***/ }),

/***/ 2526:
/***/ (function(module) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ 1326:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(1703);

var utils = __webpack_require__(9962);
/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/


function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();
  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);
      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function (el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);
  return formData;
}

module.exports = toFormData;

/***/ }),

/***/ 2877:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var VERSION = (__webpack_require__(5606).version);

var AxiosError = __webpack_require__(8625);

var validators = {}; // eslint-disable-next-line func-names

['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
var deprecatedWarnings = {};
/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */

validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  } // eslint-disable-next-line func-names


  return function (value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console

      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }

    return validator ? validator(value, opt, opts) : true;
  };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */


function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }

  var keys = Object.keys(options);
  var i = keys.length;

  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];

    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);

      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }

      continue;
    }

    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

/***/ }),

/***/ 9962:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(8675);

__webpack_require__(7380);

__webpack_require__(1118);

var bind = __webpack_require__(6781); // utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString; // eslint-disable-next-line func-names

var kindOf = function (cache) {
  // eslint-disable-next-line func-names
  return function (thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */


function isArray(val) {
  return Array.isArray(val);
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


var isArrayBuffer = kindOfTest('ArrayBuffer');
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */

function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


var isDate = kindOfTest('Date');
/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */

var isFile = kindOfTest('File');
/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */

var isBlob = kindOfTest('Blob');
/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */

var isFileList = kindOfTest('FileList');
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */

function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
}
/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


var isURLSearchParams = kindOfTest('URLSearchParams');
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */

function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function
  /* obj1, obj2, obj3, ... */
merge() {
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */


function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */


function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};
  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;

    while (i-- > 0) {
      prop = props[i];

      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }

    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}
/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */


function endsWith(str, searchString, position) {
  str = String(str);

  if (position === undefined || position > str.length) {
    position = str.length;
  }

  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */


function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);

  while (i-- > 0) {
    arr[i] = thing[i];
  }

  return arr;
} // eslint-disable-next-line func-names


var isTypedArray = function (TypedArray) {
  // eslint-disable-next-line func-names
  return function (thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

/***/ }),

/***/ 7013:
/***/ (function(module) {

!function (t, e) {
   true ? module.exports = e() : 0;
}(this, function () {
  "use strict";

  var t = 1e3,
      e = 6e4,
      n = 36e5,
      r = "millisecond",
      i = "second",
      s = "minute",
      u = "hour",
      a = "day",
      o = "week",
      f = "month",
      h = "quarter",
      c = "year",
      d = "date",
      $ = "Invalid Date",
      l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      M = {
    name: "en",
    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
  },
      m = function (t, e, n) {
    var r = String(t);
    return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
  },
      g = {
    s: m,
    z: function (t) {
      var e = -t.utcOffset(),
          n = Math.abs(e),
          r = Math.floor(n / 60),
          i = n % 60;
      return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
    },
    m: function t(e, n) {
      if (e.date() < n.date()) return -t(n, e);
      var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
          i = e.clone().add(r, f),
          s = n - i < 0,
          u = e.clone().add(r + (s ? -1 : 1), f);
      return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
    },
    a: function (t) {
      return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
    },
    p: function (t) {
      return {
        M: f,
        y: c,
        w: o,
        d: a,
        D: d,
        h: u,
        m: s,
        s: i,
        ms: r,
        Q: h
      }[t] || String(t || "").toLowerCase().replace(/s$/, "");
    },
    u: function (t) {
      return void 0 === t;
    }
  },
      v = "en",
      D = {};

  D[v] = M;

  var p = function (t) {
    return t instanceof _;
  },
      S = function t(e, n, r) {
    var i;
    if (!e) return v;

    if ("string" == typeof e) {
      var s = e.toLowerCase();
      D[s] && (i = s), n && (D[s] = n, i = s);
      var u = e.split("-");
      if (!i && u.length > 1) return t(u[0]);
    } else {
      var a = e.name;
      D[a] = e, i = a;
    }

    return !r && i && (v = i), i || !r && v;
  },
      w = function (t, e) {
    if (p(t)) return t.clone();
    var n = "object" == typeof e ? e : {};
    return n.date = t, n.args = arguments, new _(n);
  },
      O = g;

  O.l = S, O.i = p, O.w = function (t, e) {
    return w(t, {
      locale: e.$L,
      utc: e.$u,
      x: e.$x,
      $offset: e.$offset
    });
  };

  var _ = function () {
    function M(t) {
      this.$L = S(t.locale, null, !0), this.parse(t);
    }

    var m = M.prototype;
    return m.parse = function (t) {
      this.$d = function (t) {
        var e = t.date,
            n = t.utc;
        if (null === e) return new Date(NaN);
        if (O.u(e)) return new Date();
        if (e instanceof Date) return new Date(e);

        if ("string" == typeof e && !/Z$/i.test(e)) {
          var r = e.match(l);

          if (r) {
            var i = r[2] - 1 || 0,
                s = (r[7] || "0").substring(0, 3);
            return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
          }
        }

        return new Date(e);
      }(t), this.$x = t.x || {}, this.init();
    }, m.init = function () {
      var t = this.$d;
      this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
    }, m.$utils = function () {
      return O;
    }, m.isValid = function () {
      return !(this.$d.toString() === $);
    }, m.isSame = function (t, e) {
      var n = w(t);
      return this.startOf(e) <= n && n <= this.endOf(e);
    }, m.isAfter = function (t, e) {
      return w(t) < this.startOf(e);
    }, m.isBefore = function (t, e) {
      return this.endOf(e) < w(t);
    }, m.$g = function (t, e, n) {
      return O.u(t) ? this[e] : this.set(n, t);
    }, m.unix = function () {
      return Math.floor(this.valueOf() / 1e3);
    }, m.valueOf = function () {
      return this.$d.getTime();
    }, m.startOf = function (t, e) {
      var n = this,
          r = !!O.u(e) || e,
          h = O.p(t),
          $ = function (t, e) {
        var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
        return r ? i : i.endOf(a);
      },
          l = function (t, e) {
        return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
      },
          y = this.$W,
          M = this.$M,
          m = this.$D,
          g = "set" + (this.$u ? "UTC" : "");

      switch (h) {
        case c:
          return r ? $(1, 0) : $(31, 11);

        case f:
          return r ? $(1, M) : $(0, M + 1);

        case o:
          var v = this.$locale().weekStart || 0,
              D = (y < v ? y + 7 : y) - v;
          return $(r ? m - D : m + (6 - D), M);

        case a:
        case d:
          return l(g + "Hours", 0);

        case u:
          return l(g + "Minutes", 1);

        case s:
          return l(g + "Seconds", 2);

        case i:
          return l(g + "Milliseconds", 3);

        default:
          return this.clone();
      }
    }, m.endOf = function (t) {
      return this.startOf(t, !1);
    }, m.$set = function (t, e) {
      var n,
          o = O.p(t),
          h = "set" + (this.$u ? "UTC" : ""),
          $ = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o],
          l = o === a ? this.$D + (e - this.$W) : e;

      if (o === f || o === c) {
        var y = this.clone().set(d, 1);
        y.$d[$](l), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
      } else $ && this.$d[$](l);

      return this.init(), this;
    }, m.set = function (t, e) {
      return this.clone().$set(t, e);
    }, m.get = function (t) {
      return this[O.p(t)]();
    }, m.add = function (r, h) {
      var d,
          $ = this;
      r = Number(r);

      var l = O.p(h),
          y = function (t) {
        var e = w($);
        return O.w(e.date(e.date() + Math.round(t * r)), $);
      };

      if (l === f) return this.set(f, this.$M + r);
      if (l === c) return this.set(c, this.$y + r);
      if (l === a) return y(1);
      if (l === o) return y(7);
      var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[l] || 1,
          m = this.$d.getTime() + r * M;
      return O.w(m, this);
    }, m.subtract = function (t, e) {
      return this.add(-1 * t, e);
    }, m.format = function (t) {
      var e = this,
          n = this.$locale();
      if (!this.isValid()) return n.invalidDate || $;

      var r = t || "YYYY-MM-DDTHH:mm:ssZ",
          i = O.z(this),
          s = this.$H,
          u = this.$m,
          a = this.$M,
          o = n.weekdays,
          f = n.months,
          h = function (t, n, i, s) {
        return t && (t[n] || t(e, r)) || i[n].slice(0, s);
      },
          c = function (t) {
        return O.s(s % 12 || 12, t, "0");
      },
          d = n.meridiem || function (t, e, n) {
        var r = t < 12 ? "AM" : "PM";
        return n ? r.toLowerCase() : r;
      },
          l = {
        YY: String(this.$y).slice(-2),
        YYYY: this.$y,
        M: a + 1,
        MM: O.s(a + 1, 2, "0"),
        MMM: h(n.monthsShort, a, f, 3),
        MMMM: h(f, a),
        D: this.$D,
        DD: O.s(this.$D, 2, "0"),
        d: String(this.$W),
        dd: h(n.weekdaysMin, this.$W, o, 2),
        ddd: h(n.weekdaysShort, this.$W, o, 3),
        dddd: o[this.$W],
        H: String(s),
        HH: O.s(s, 2, "0"),
        h: c(1),
        hh: c(2),
        a: d(s, u, !0),
        A: d(s, u, !1),
        m: String(u),
        mm: O.s(u, 2, "0"),
        s: String(this.$s),
        ss: O.s(this.$s, 2, "0"),
        SSS: O.s(this.$ms, 3, "0"),
        Z: i
      };

      return r.replace(y, function (t, e) {
        return e || l[t] || i.replace(":", "");
      });
    }, m.utcOffset = function () {
      return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
    }, m.diff = function (r, d, $) {
      var l,
          y = O.p(d),
          M = w(r),
          m = (M.utcOffset() - this.utcOffset()) * e,
          g = this - M,
          v = O.m(this, M);
      return v = (l = {}, l[c] = v / 12, l[f] = v, l[h] = v / 3, l[o] = (g - m) / 6048e5, l[a] = (g - m) / 864e5, l[u] = g / n, l[s] = g / e, l[i] = g / t, l)[y] || g, $ ? v : O.a(v);
    }, m.daysInMonth = function () {
      return this.endOf(f).$D;
    }, m.$locale = function () {
      return D[this.$L];
    }, m.locale = function (t, e) {
      if (!t) return this.$L;
      var n = this.clone(),
          r = S(t, e, !0);
      return r && (n.$L = r), n;
    }, m.clone = function () {
      return O.w(this.$d, this);
    }, m.toDate = function () {
      return new Date(this.valueOf());
    }, m.toJSON = function () {
      return this.isValid() ? this.toISOString() : null;
    }, m.toISOString = function () {
      return this.$d.toISOString();
    }, m.toString = function () {
      return this.$d.toUTCString();
    }, M;
  }(),
      T = _.prototype;

  return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function (t) {
    T[t[1]] = function (e) {
      return this.$g(e, t[0], t[1]);
    };
  }), w.extend = function (t, e) {
    return t.$i || (t(e, _, w), t.$i = !0), w;
  }, w.locale = S, w.isDayjs = p, w.unix = function (t) {
    return w(1e3 * t);
  }, w.en = D[v], w.Ls = D, w.p = {}, w;
});

/***/ }),

/***/ 9840:
/***/ (function(module) {

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  return function (e, t, r) {
    var n = t.prototype,
        s = n.format;
    r.en.ordinal = function (e) {
      var t = ["th", "st", "nd", "rd"],
          r = e % 100;
      return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
    }, n.format = function (e) {
      var t = this,
          r = this.$locale();
      if (!this.isValid()) return s.bind(this)(e);
      var n = this.$utils(),
          a = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function (e) {
        switch (e) {
          case "Q":
            return Math.ceil((t.$M + 1) / 3);

          case "Do":
            return r.ordinal(t.$D);

          case "gggg":
            return t.weekYear();

          case "GGGG":
            return t.isoWeekYear();

          case "wo":
            return r.ordinal(t.week(), "W");

          case "w":
          case "ww":
            return n.s(t.week(), "w" === e ? 1 : 2, "0");

          case "W":
          case "WW":
            return n.s(t.isoWeek(), "W" === e ? 1 : 2, "0");

          case "k":
          case "kk":
            return n.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");

          case "X":
            return Math.floor(t.$d.getTime() / 1e3);

          case "x":
            return t.$d.getTime();

          case "z":
            return "[" + t.offsetName() + "]";

          case "zzz":
            return "[" + t.offsetName("long") + "]";

          default:
            return e;
        }
      });
      return s.bind(this)(a);
    };
  };
});

/***/ }),

/***/ 4032:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(1703);

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  var e = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  },
      t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
      n = /\d\d/,
      r = /\d\d?/,
      i = /\d*[^-_:/,()\s\d]+/,
      o = {},
      s = function (e) {
    return (e = +e) + (e > 68 ? 1900 : 2e3);
  };

  var a = function (e) {
    return function (t) {
      this[e] = +t;
    };
  },
      f = [/[+-]\d\d:?(\d\d)?|Z/, function (e) {
    (this.zone || (this.zone = {})).offset = function (e) {
      if (!e) return 0;
      if ("Z" === e) return 0;
      var t = e.match(/([+-]|\d\d)/g),
          n = 60 * t[1] + (+t[2] || 0);
      return 0 === n ? 0 : "+" === t[0] ? -n : n;
    }(e);
  }],
      h = function (e) {
    var t = o[e];
    return t && (t.indexOf ? t : t.s.concat(t.f));
  },
      u = function (e, t) {
    var n,
        r = o.meridiem;

    if (r) {
      for (var i = 1; i <= 24; i += 1) if (e.indexOf(r(i, 0, t)) > -1) {
        n = i > 12;
        break;
      }
    } else n = e === (t ? "pm" : "PM");

    return n;
  },
      d = {
    A: [i, function (e) {
      this.afternoon = u(e, !1);
    }],
    a: [i, function (e) {
      this.afternoon = u(e, !0);
    }],
    S: [/\d/, function (e) {
      this.milliseconds = 100 * +e;
    }],
    SS: [n, function (e) {
      this.milliseconds = 10 * +e;
    }],
    SSS: [/\d{3}/, function (e) {
      this.milliseconds = +e;
    }],
    s: [r, a("seconds")],
    ss: [r, a("seconds")],
    m: [r, a("minutes")],
    mm: [r, a("minutes")],
    H: [r, a("hours")],
    h: [r, a("hours")],
    HH: [r, a("hours")],
    hh: [r, a("hours")],
    D: [r, a("day")],
    DD: [n, a("day")],
    Do: [i, function (e) {
      var t = o.ordinal,
          n = e.match(/\d+/);
      if (this.day = n[0], t) for (var r = 1; r <= 31; r += 1) t(r).replace(/\[|\]/g, "") === e && (this.day = r);
    }],
    M: [r, a("month")],
    MM: [n, a("month")],
    MMM: [i, function (e) {
      var t = h("months"),
          n = (h("monthsShort") || t.map(function (e) {
        return e.slice(0, 3);
      })).indexOf(e) + 1;
      if (n < 1) throw new Error();
      this.month = n % 12 || n;
    }],
    MMMM: [i, function (e) {
      var t = h("months").indexOf(e) + 1;
      if (t < 1) throw new Error();
      this.month = t % 12 || t;
    }],
    Y: [/[+-]?\d+/, a("year")],
    YY: [n, function (e) {
      this.year = s(e);
    }],
    YYYY: [/\d{4}/, a("year")],
    Z: f,
    ZZ: f
  };

  function c(n) {
    var r, i;
    r = n, i = o && o.formats;

    for (var s = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (t, n, r) {
      var o = r && r.toUpperCase();
      return n || i[r] || e[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (e, t, n) {
        return t || n.slice(1);
      });
    })).match(t), a = s.length, f = 0; f < a; f += 1) {
      var h = s[f],
          u = d[h],
          c = u && u[0],
          l = u && u[1];
      s[f] = l ? {
        regex: c,
        parser: l
      } : h.replace(/^\[|\]$/g, "");
    }

    return function (e) {
      for (var t = {}, n = 0, r = 0; n < a; n += 1) {
        var i = s[n];
        if ("string" == typeof i) r += i.length;else {
          var o = i.regex,
              f = i.parser,
              h = e.slice(r),
              u = o.exec(h)[0];
          f.call(t, u), e = e.replace(u, "");
        }
      }

      return function (e) {
        var t = e.afternoon;

        if (void 0 !== t) {
          var n = e.hours;
          t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
        }
      }(t), t;
    };
  }

  return function (e, t, n) {
    n.p.customParseFormat = !0, e && e.parseTwoDigitYear && (s = e.parseTwoDigitYear);
    var r = t.prototype,
        i = r.parse;

    r.parse = function (e) {
      var t = e.date,
          r = e.utc,
          s = e.args;
      this.$u = r;
      var a = s[1];

      if ("string" == typeof a) {
        var f = !0 === s[2],
            h = !0 === s[3],
            u = f || h,
            d = s[2];
        h && (d = s[2]), o = this.$locale(), !f && d && (o = n.Ls[d]), this.$d = function (e, t, n) {
          try {
            if (["x", "X"].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
            var r = c(t)(e),
                i = r.year,
                o = r.month,
                s = r.day,
                a = r.hours,
                f = r.minutes,
                h = r.seconds,
                u = r.milliseconds,
                d = r.zone,
                l = new Date(),
                m = s || (i || o ? 1 : l.getDate()),
                M = i || l.getFullYear(),
                Y = 0;
            i && !o || (Y = o > 0 ? o - 1 : l.getMonth());
            var p = a || 0,
                v = f || 0,
                D = h || 0,
                g = u || 0;
            return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
          } catch (e) {
            return new Date("");
          }
        }(t, a, r), this.init(), d && !0 !== d && (this.$L = this.locale(d).$L), u && t != this.format(a) && (this.$d = new Date("")), o = {};
      } else if (a instanceof Array) for (var l = a.length, m = 1; m <= l; m += 1) {
        s[1] = a[m - 1];
        var M = n.apply(this, s);

        if (M.isValid()) {
          this.$d = M.$d, this.$L = M.$L, this.init();
          break;
        }

        m === l && (this.$d = new Date(""));
      } else i.call(this, e);
    };
  };
});

/***/ }),

/***/ 6295:
/***/ (function(module) {

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  return function (e, t, n) {
    t.prototype.dayOfYear = function (e) {
      var t = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
      return null == e ? t : this.add(e - t, "day");
    };
  };
});

/***/ }),

/***/ 5929:
/***/ (function(module) {

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  return function (e, t) {
    t.prototype.isSameOrAfter = function (e, t) {
      return this.isSame(e, t) || this.isAfter(e, t);
    };
  };
});

/***/ }),

/***/ 5444:
/***/ (function(module) {

!function (e, i) {
   true ? module.exports = i() : 0;
}(this, function () {
  "use strict";

  return function (e, i) {
    i.prototype.isSameOrBefore = function (e, i) {
      return this.isSame(e, i) || this.isBefore(e, i);
    };
  };
});

/***/ }),

/***/ 4427:
/***/ (function(module) {

!function (n, e) {
   true ? module.exports = e() : 0;
}(this, function () {
  "use strict";

  return function (n, e, t) {
    var r = e.prototype,
        o = function (n) {
      return n && (n.indexOf ? n : n.s);
    },
        u = function (n, e, t, r, u) {
      var i = n.name ? n : n.$locale(),
          a = o(i[e]),
          s = o(i[t]),
          f = a || s.map(function (n) {
        return n.slice(0, r);
      });
      if (!u) return f;
      var d = i.weekStart;
      return f.map(function (n, e) {
        return f[(e + (d || 0)) % 7];
      });
    },
        i = function () {
      return t.Ls[t.locale()];
    },
        a = function (n, e) {
      return n.formats[e] || function (n) {
        return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (n, e, t) {
          return e || t.slice(1);
        });
      }(n.formats[e.toUpperCase()]);
    },
        s = function () {
      var n = this;
      return {
        months: function (e) {
          return e ? e.format("MMMM") : u(n, "months");
        },
        monthsShort: function (e) {
          return e ? e.format("MMM") : u(n, "monthsShort", "months", 3);
        },
        firstDayOfWeek: function () {
          return n.$locale().weekStart || 0;
        },
        weekdays: function (e) {
          return e ? e.format("dddd") : u(n, "weekdays");
        },
        weekdaysMin: function (e) {
          return e ? e.format("dd") : u(n, "weekdaysMin", "weekdays", 2);
        },
        weekdaysShort: function (e) {
          return e ? e.format("ddd") : u(n, "weekdaysShort", "weekdays", 3);
        },
        longDateFormat: function (e) {
          return a(n.$locale(), e);
        },
        meridiem: this.$locale().meridiem,
        ordinal: this.$locale().ordinal
      };
    };

    r.localeData = function () {
      return s.bind(this)();
    }, t.localeData = function () {
      var n = i();
      return {
        firstDayOfWeek: function () {
          return n.weekStart || 0;
        },
        weekdays: function () {
          return t.weekdays();
        },
        weekdaysShort: function () {
          return t.weekdaysShort();
        },
        weekdaysMin: function () {
          return t.weekdaysMin();
        },
        months: function () {
          return t.months();
        },
        monthsShort: function () {
          return t.monthsShort();
        },
        longDateFormat: function (e) {
          return a(n, e);
        },
        meridiem: n.meridiem,
        ordinal: n.ordinal
      };
    }, t.months = function () {
      return u(i(), "months");
    }, t.monthsShort = function () {
      return u(i(), "monthsShort", "months", 3);
    }, t.weekdays = function (n) {
      return u(i(), "weekdays", null, null, n);
    }, t.weekdaysShort = function (n) {
      return u(i(), "weekdaysShort", "weekdays", 3, n);
    }, t.weekdaysMin = function (n) {
      return u(i(), "weekdaysMin", "weekdays", 2, n);
    };
  };
});

/***/ }),

/***/ 2598:
/***/ (function(module) {

!function (t, i) {
   true ? module.exports = i() : 0;
}(this, function () {
  "use strict";

  var t = "minute",
      i = /[+-]\d\d(?::?\d\d)?/g,
      e = /([+-]|\d\d)/g;
  return function (s, f, n) {
    var u = f.prototype;
    n.utc = function (t) {
      var i = {
        date: t,
        utc: !0,
        args: arguments
      };
      return new f(i);
    }, u.utc = function (i) {
      var e = n(this.toDate(), {
        locale: this.$L,
        utc: !0
      });
      return i ? e.add(this.utcOffset(), t) : e;
    }, u.local = function () {
      return n(this.toDate(), {
        locale: this.$L,
        utc: !1
      });
    };
    var o = u.parse;

    u.parse = function (t) {
      t.utc && (this.$u = !0), this.$utils().u(t.$offset) || (this.$offset = t.$offset), o.call(this, t);
    };

    var r = u.init;

    u.init = function () {
      if (this.$u) {
        var t = this.$d;
        this.$y = t.getUTCFullYear(), this.$M = t.getUTCMonth(), this.$D = t.getUTCDate(), this.$W = t.getUTCDay(), this.$H = t.getUTCHours(), this.$m = t.getUTCMinutes(), this.$s = t.getUTCSeconds(), this.$ms = t.getUTCMilliseconds();
      } else r.call(this);
    };

    var a = u.utcOffset;

    u.utcOffset = function (s, f) {
      var n = this.$utils().u;
      if (n(s)) return this.$u ? 0 : n(this.$offset) ? a.call(this) : this.$offset;
      if ("string" == typeof s && (s = function (t) {
        void 0 === t && (t = "");
        var s = t.match(i);
        if (!s) return null;
        var f = ("" + s[0]).match(e) || ["-", 0, 0],
            n = f[0],
            u = 60 * +f[1] + +f[2];
        return 0 === u ? 0 : "+" === n ? u : -u;
      }(s), null === s)) return this;
      var u = Math.abs(s) <= 16 ? 60 * s : s,
          o = this;
      if (f) return o.$offset = u, o.$u = 0 === s, o;

      if (0 !== s) {
        var r = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
        (o = this.local().add(u + r, t)).$offset = u, o.$x.$localOffset = r;
      } else o = this.utc();

      return o;
    };

    var h = u.format;
    u.format = function (t) {
      var i = t || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
      return h.call(this, i);
    }, u.valueOf = function () {
      var t = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
      return this.$d.valueOf() - 6e4 * t;
    }, u.isUTC = function () {
      return !!this.$u;
    }, u.toISOString = function () {
      return this.toDate().toISOString();
    }, u.toString = function () {
      return this.toDate().toUTCString();
    };
    var l = u.toDate;

    u.toDate = function (t) {
      return "s" === t && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
    };

    var c = u.diff;

    u.diff = function (t, i, e) {
      if (t && this.$u === t.$u) return c.call(this, t, i, e);
      var s = this.local(),
          f = n(t).local();
      return c.call(s, f, i, e);
    };
  };
});

/***/ }),

/***/ 6611:
/***/ (function(module) {

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  var e = "week",
      t = "year";
  return function (i, n, r) {
    var f = n.prototype;
    f.week = function (i) {
      if (void 0 === i && (i = null), null !== i) return this.add(7 * (i - this.week()), "day");
      var n = this.$locale().yearStart || 1;

      if (11 === this.month() && this.date() > 25) {
        var f = r(this).startOf(t).add(1, t).date(n),
            s = r(this).endOf(e);
        if (f.isBefore(s)) return 1;
      }

      var a = r(this).startOf(t).date(n).startOf(e).subtract(1, "millisecond"),
          o = this.diff(a, e, !0);
      return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
    }, f.weeks = function (e) {
      return void 0 === e && (e = null), this.week(e);
    };
  };
});

/***/ }),

/***/ 9053:
/***/ (function(module) {

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  return function (e, t) {
    t.prototype.weekYear = function () {
      var e = this.month(),
          t = this.week(),
          n = this.year();
      return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n;
    };
  };
});

/***/ }),

/***/ 5085:
/***/ (function(module) {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;
/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;
/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;

      case 38:
        // &
        escape = '&amp;';
        break;

      case 39:
        // '
        escape = '&#39;';
        break;

      case 60:
        // <
        escape = '&lt;';
        break;

      case 62:
        // >
        escape = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}

/***/ }),

/***/ 6655:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(8675);

__webpack_require__(7380);

__webpack_require__(1118);

/**
 * [js-md5]{@link https://github.com/emn178/js-md5}
 *
 * @namespace md5
 * @version 0.7.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};

  if (root.JS_MD5_NO_WINDOW) {
    WINDOW = false;
  }

  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;

  if (NODE_JS) {
    root = __webpack_require__.g;
  } else if (WEB_WORKER) {
    root = self;
  }

  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [128, 32768, 8388608, -2147483648];
  var SHIFT = [0, 8, 16, 24];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  var blocks = [],
      buffer8;

  if (ARRAY_BUFFER) {
    var buffer = new ArrayBuffer(68);
    buffer8 = new Uint8Array(buffer);
    blocks = new Uint32Array(buffer);
  }

  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }
  /**
   * @method hex
   * @memberof md5
   * @description Output hash as hex string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} Hex string
   * @example
   * md5.hex('The quick brown fox jumps over the lazy dog');
   * // equal to
   * md5('The quick brown fox jumps over the lazy dog');
   */

  /**
   * @method digest
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.digest('The quick brown fox jumps over the lazy dog');
   */

  /**
   * @method array
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.array('The quick brown fox jumps over the lazy dog');
   */

  /**
   * @method arrayBuffer
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
   */

  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.buffer('The quick brown fox jumps over the lazy dog');
   */

  /**
   * @method base64
   * @memberof md5
   * @description Output hash as base64 string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} base64 string
   * @example
   * md5.base64('The quick brown fox jumps over the lazy dog');
   */


  var createOutputMethod = function (outputType) {
    return function (message) {
      return new Md5(true).update(message)[outputType]();
    };
  };
  /**
   * @method create
   * @memberof md5
   * @description Create Md5 object
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.create();
   */

  /**
   * @method update
   * @memberof md5
   * @description Create and update Md5 object
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.update('The quick brown fox jumps over the lazy dog');
   * // equal to
   * var hash = md5.create();
   * hash.update('The quick brown fox jumps over the lazy dog');
   */


  var createMethod = function () {
    var method = createOutputMethod('hex');

    if (NODE_JS) {
      method = nodeWrap(method);
    }

    method.create = function () {
      return new Md5();
    };

    method.update = function (message) {
      return method.create().update(message);
    };

    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }

    return method;
  };

  var nodeWrap = function (method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");

    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash('md5').update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw ERROR;
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }

      if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
        return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };

    return nodeMethod;
  };
  /**
   * Md5 class
   * @class Md5
   * @description This is internal class.
   * @see {@link md5.create}
   */


  function Md5(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
      this.buffer8 = buffer8;
    } else {
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        this.buffer8 = new Uint8Array(buffer);
        this.blocks = new Uint32Array(buffer);
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
    }

    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */


  Md5.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }

    var notString,
        type = typeof message;

    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw ERROR;
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw ERROR;
          }
        }
      } else {
        throw ERROR;
      }

      notString = true;
    }

    var code,
        index = 0,
        i,
        length = message.length,
        blocks = this.blocks;
    var buffer8 = this.buffer8;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        if (ARRAY_BUFFER) {
          for (i = this.start; index < length && i < 64; ++index) {
            buffer8[i++] = message[index];
          }
        } else {
          for (i = this.start; index < length && i < 64; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        }
      } else {
        if (ARRAY_BUFFER) {
          for (i = this.start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);

            if (code < 0x80) {
              buffer8[i++] = code;
            } else if (code < 0x800) {
              buffer8[i++] = 0xc0 | code >> 6;
              buffer8[i++] = 0x80 | code & 0x3f;
            } else if (code < 0xd800 || code >= 0xe000) {
              buffer8[i++] = 0xe0 | code >> 12;
              buffer8[i++] = 0x80 | code >> 6 & 0x3f;
              buffer8[i++] = 0x80 | code & 0x3f;
            } else {
              code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
              buffer8[i++] = 0xf0 | code >> 18;
              buffer8[i++] = 0x80 | code >> 12 & 0x3f;
              buffer8[i++] = 0x80 | code >> 6 & 0x3f;
              buffer8[i++] = 0x80 | code & 0x3f;
            }
          }
        } else {
          for (i = this.start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);

            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
              blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
            }
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;

      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }

    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }

    return this;
  };

  Md5.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }

    this.finalized = true;
    var blocks = this.blocks,
        i = this.lastByteIndex;
    blocks[i >> 2] |= EXTRA[i & 3];

    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }

      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }

    blocks[14] = this.bytes << 3;
    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
    this.hash();
  };

  Md5.prototype.hash = function () {
    var a,
        b,
        c,
        d,
        bc,
        da,
        blocks = this.blocks;

    if (this.first) {
      a = blocks[0] - 680876937;
      a = (a << 7 | a >>> 25) - 271733879 << 0;
      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
      d = (d << 12 | d >>> 20) + a << 0;
      c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
      c = (c << 17 | c >>> 15) + d << 0;
      b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
      b = (b << 22 | b >>> 10) + c << 0;
    } else {
      a = this.h0;
      b = this.h1;
      c = this.h2;
      d = this.h3;
      a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
      b = (b << 22 | b >>> 10) + c << 0;
    }

    a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
    b = (b << 20 | b >>> 12) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[5] - 378558;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[8] - 2022574463;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[11] + 1839030562;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[14] - 35309556;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[1] - 1530992060;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[4] + 1272893353;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[7] - 155497632;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[10] - 1094730640;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[13] + 681279174;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[0] - 358537222;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[3] - 722521979;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[6] + 76029189;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[9] - 640364487;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[12] - 421815835;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[15] + 530742520;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[2] - 995338651;
    b = (b << 23 | b >>> 9) + c << 0;
    a += (c ^ (b | ~d)) + blocks[0] - 198630844;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[5] - 57434055;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[10] - 1051523;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[15] - 30611744;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[4] - 145523070;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[2] + 718787259;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[9] - 343485551;
    b = (b << 21 | b >>> 11) + c << 0;

    if (this.first) {
      this.h0 = a + 1732584193 << 0;
      this.h1 = b - 271733879 << 0;
      this.h2 = c - 1732584194 << 0;
      this.h3 = d + 271733878 << 0;
      this.first = false;
    } else {
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
    }
  };
  /**
   * @method hex
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.hex();
   */


  Md5.prototype.hex = function () {
    this.finalize();
    var h0 = this.h0,
        h1 = this.h1,
        h2 = this.h2,
        h3 = this.h3;
    return HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F];
  };
  /**
   * @method toString
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.toString();
   */


  Md5.prototype.toString = Md5.prototype.hex;
  /**
   * @method digest
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.digest}
   * @example
   * hash.digest();
   */

  Md5.prototype.digest = function () {
    this.finalize();
    var h0 = this.h0,
        h1 = this.h1,
        h2 = this.h2,
        h3 = this.h3;
    return [h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >> 24 & 0xFF];
  };
  /**
   * @method array
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.array}
   * @example
   * hash.array();
   */


  Md5.prototype.array = Md5.prototype.digest;
  /**
   * @method arrayBuffer
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.arrayBuffer}
   * @example
   * hash.arrayBuffer();
   */

  Md5.prototype.arrayBuffer = function () {
    this.finalize();
    var buffer = new ArrayBuffer(16);
    var blocks = new Uint32Array(buffer);
    blocks[0] = this.h0;
    blocks[1] = this.h1;
    blocks[2] = this.h2;
    blocks[3] = this.h3;
    return buffer;
  };
  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.buffer}
   * @example
   * hash.buffer();
   */


  Md5.prototype.buffer = Md5.prototype.arrayBuffer;
  /**
   * @method base64
   * @memberof Md5
   * @instance
   * @description Output hash as base64 string
   * @returns {String} base64 string
   * @see {@link md5.base64}
   * @example
   * hash.base64();
   */

  Md5.prototype.base64 = function () {
    var v1,
        v2,
        v3,
        base64Str = '',
        bytes = this.array();

    for (var i = 0; i < 15;) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
    }

    v1 = bytes[i];
    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + '==';
    return base64Str;
  };

  var exports = createMethod();

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    /**
     * @method md5
     * @description Md5 hash function, export to global in browsers.
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} md5 hashes
     * @example
     * md5(''); // d41d8cd98f00b204e9800998ecf8427e
     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
     *
     * // It also supports UTF-8 encoding
     * md5(''); // a7bac2239fcdcb3a067903d8077c4a07
     *
     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
     * md5([]); // d41d8cd98f00b204e9800998ecf8427e
     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
     */
    root.md5 = exports;

    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();

/***/ }),

/***/ 1620:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
}); // runtime helper for setting properties on components
// in a tree-shakable way

exports.Z = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;

  for (const [key, val] of props) {
    target[key] = val;
  }

  return target;
};

/***/ }),

/***/ 491:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(1703);

__webpack_require__(2801);

__webpack_require__(8675);

__webpack_require__(7380);

__webpack_require__(1118);

!function (e, t) {
   true ? module.exports = t() : 0;
}(window, function () {
  return function (e) {
    var t = {};

    function s(i) {
      if (t[i]) return t[i].exports;
      var r = t[i] = {
        i: i,
        l: !1,
        exports: {}
      };
      return e[i].call(r.exports, r, r.exports, s), r.l = !0, r.exports;
    }

    return s.m = e, s.c = t, s.d = function (e, t, i) {
      s.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: i
      });
    }, s.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, s.t = function (e, t) {
      if (1 & t && (e = s(e)), 8 & t) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var i = Object.create(null);
      if (s.r(i), Object.defineProperty(i, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e) for (var r in e) s.d(i, r, function (t) {
        return e[t];
      }.bind(null, r));
      return i;
    }, s.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return s.d(t, "a", t), t;
    }, s.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, s.p = "", s(s.s = "./dist/index.js");
  }({
    "./dist/NxwStatic.js":
    /*!***************************!*\
      !*** ./dist/NxwStatic.js ***!
      \***************************/

    /*! exports provided: default */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "default", function () {
        return r;
      });
      var i = s(
      /*! . */
      "./dist/index.js");

      class r {
        constructor(e, t, s = 3) {
          let n = {
            nxuser: e,
            nxpass: t,
            nxtype: s
          };
          r.nxwCall = new i.default(n), console.log("NxwStatic inited!!!");
        }

        static placeCall(e, t) {
          return r.nxwCall.placeCall(e, t);
        }

        static hangupCall() {
          return r.nxwCall.hangupCall();
        }

        static answerCall(e) {
          return r.nxwCall.answerCall(e);
        }

        static holdCall(e) {
          return r.nxwCall.holdCall(e);
        }

        static sendDTMF(e) {
          return r.nxwCall.sendDTMF(e);
        }

        static setVolume(e) {
          return r.nxwCall.setVolume(e);
        }

        static muteCall(e) {
          return r.nxwCall.muteCall(e);
        }

        static silentCall(e) {
          return r.nxwCall.silentCall(e);
        }

        static disconnect() {
          return r.nxwCall.disconnect();
        }

      }
    },
    "./dist/index.js":
    /*!***********************!*\
      !*** ./dist/index.js ***!
      \***********************/

    /*! exports provided: default, NxwStatic, ToneFlag, delay, getAudio, getButton, getButtons, getDiv, getInput, setInput, getSpan, getVideo, getUrlParam, getJsSrcParam, assignStream, getIP, objectId */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "objectId", function () {
        return h;
      });
      var i = s(
      /*! ./nxwCall */
      "./dist/nxwCall.js"),
          r = s(
      /*! ./NxwStatic */
      "./dist/NxwStatic.js");
      s.d(t, "NxwStatic", function () {
        return r.default;
      });
      var n = s(
      /*! ./nxw-types */
      "./dist/nxw-types.js");
      s.d(t, "ToneFlag", function () {
        return n.ToneFlag;
      });
      var o = s(
      /*! ./nxw-utils */
      "./dist/nxw-utils.js");
      s.d(t, "delay", function () {
        return o.delay;
      }), s.d(t, "getAudio", function () {
        return o.getAudio;
      }), s.d(t, "getButton", function () {
        return o.getButton;
      }), s.d(t, "getButtons", function () {
        return o.getButtons;
      }), s.d(t, "getDiv", function () {
        return o.getDiv;
      }), s.d(t, "getInput", function () {
        return o.getInput;
      }), s.d(t, "setInput", function () {
        return o.setInput;
      }), s.d(t, "getSpan", function () {
        return o.getSpan;
      }), s.d(t, "getVideo", function () {
        return o.getVideo;
      }), s.d(t, "getUrlParam", function () {
        return o.getUrlParam;
      }), s.d(t, "getJsSrcParam", function () {
        return o.getJsSrcParam;
      }), s.d(t, "assignStream", function () {
        return o.assignStream;
      }), s.d(t, "getIP", function () {
        return o.getIP;
      }), t.default = i.default;
      const a = Object(o.getJsSrcParam)("nxuser"),
            c = Object(o.getJsSrcParam)("nxpass"),
            d = Object(o.getJsSrcParam)("nxtype") || "3";
      console.log("NXW1: nxuser=", a, "nxpass=", c, "nxtype=", d);
      let l = null;
      a && c && (l = new r.default(a, c, parseInt(d)), console.log("x=", l));
      let u = new Date().getTime() % 1e6;

      function h(e) {
        return null == e ? null : (null == e.__obj_id && (e.__obj_id = u++), e.__obj_id);
      }
    },
    "./dist/nxw-types.js":
    /*!***************************!*\
      !*** ./dist/nxw-types.js ***!
      \***************************/

    /*! exports provided: ToneFlag */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "ToneFlag", function () {
        return i;
      }), function (e) {
        e[e.RINGIN = 1] = "RINGIN", e[e.RINGOUT = 2] = "RINGOUT", e[e.CONNECTED = 4] = "CONNECTED", e[e.HANGUP = 8] = "HANGUP", e[e.ONLINE = 16] = "ONLINE", e[e.OFFLINE = 32] = "OFFLINE", e[e.CUSTOM = 128] = "CUSTOM";
      }(i || (i = {}));
    },
    "./dist/nxw-utils.js":
    /*!***************************!*\
      !*** ./dist/nxw-utils.js ***!
      \***************************/

    /*! exports provided: delay, getAudio, getButton, getButtons, getDiv, getInput, setInput, getSpan, getVideo, getUrlParam, getJsSrcParam, assignStream, getIP */
    function (e, t, s) {
      "use strict";

      function i(e) {
        return new Promise(t => setTimeout(t, e));
      }

      function r(e) {
        const t = document.getElementById(e);
        if (!(t instanceof HTMLAudioElement)) throw new Error(`Element "${e}" not found or not an audio element.`);
        return t;
      }

      function n(e) {
        const t = document.getElementById(e);
        if (!(t instanceof HTMLButtonElement)) throw new Error(`Element "${e}" not found or not a button element.`);
        return t;
      }

      function o(e) {
        const t = document.getElementsByClassName(e);
        if (!t.length) throw new Error(`Elements "${e}" not found.`);
        const s = [];

        for (let i = 0; i < t.length; i++) {
          const r = t[i];
          if (!(r instanceof HTMLButtonElement)) throw new Error(`Element ${i} of "${e}" not a button element.`);
          s.push(r);
        }

        return s;
      }

      function a(e) {
        const t = document.getElementById(e);
        if (!(t instanceof HTMLDivElement)) throw new Error(`Element "${e}" not found or not a div element.`);
        return t;
      }

      function c(e) {
        const t = document.getElementById(e);
        if (!(t instanceof HTMLInputElement)) throw new Error(`Element "${e}" not found or not an input element.`);
        return t;
      }

      function d(e, t) {
        c(e).value = t || "";
      }

      function l(e) {
        const t = document.getElementById(e);
        if (!(t instanceof HTMLSpanElement)) throw new Error(`Element "${e}" not found or not a span element.`);
        return t;
      }

      function u(e) {
        const t = document.getElementById(e);
        if (!(t instanceof HTMLVideoElement)) throw new Error(`Element "${e}" not found or not a video element.`);
        return t;
      }

      function h(e) {
        var t = new RegExp("(^|&)" + e + "=([^&]*)(&|$)"),
            s = window.location.search.substr(1).match(t);
        return null != s ? decodeURI(s[2]) : "";
      }

      function g(e) {
        var t = document.getElementsByTagName("script"),
            s = t[t.length - 1],
            i = s.src.indexOf("?"),
            r = new RegExp("(^|&)" + e + "=([^&]*)(&|$)"),
            n = s.src.substr(i + 1).match(r);
        return null != n ? decodeURI(n[2]) : "";
      }

      function p(e, t) {
        t.autoplay = !0, t.srcObject = e, t.play().catch(e => {
          console.error("Failed to play media"), console.error(e);
        }), e.onaddtrack = () => {
          t.load(), t.play().catch(e => {
            console.error("Failed to play remote media on add track"), console.error(e);
          });
        }, e.onremovetrack = () => {
          t.load(), t.play().catch(e => {
            console.error("Failed to play remote media on remove track"), console.error(e);
          });
        };
      }

      function m(e, t) {
        let s = {},
            i = new (0, window.RTCPeerConnection)();

        function r(t) {
          let i = t.split(" ")[4];
          i && !s[i] && "172.2" != i.substring(0, 5) && (e(i), s[i] = !0);
        }

        i.onicecandidate = e => {
          e.candidate && r(e.candidate.candidate);
        }, i.createDataChannel(""), i.createOffer(e => {
          i.setLocalDescription(e);
        }, () => {}), setTimeout(() => {
          i.localDescription.sdp.split("\n").forEach(e => {
            0 === e.indexOf("a=candidate:") && r(e);
          }), t();
        }, 5e3);
      }

      s.r(t), s.d(t, "delay", function () {
        return i;
      }), s.d(t, "getAudio", function () {
        return r;
      }), s.d(t, "getButton", function () {
        return n;
      }), s.d(t, "getButtons", function () {
        return o;
      }), s.d(t, "getDiv", function () {
        return a;
      }), s.d(t, "getInput", function () {
        return c;
      }), s.d(t, "setInput", function () {
        return d;
      }), s.d(t, "getSpan", function () {
        return l;
      }), s.d(t, "getVideo", function () {
        return u;
      }), s.d(t, "getUrlParam", function () {
        return h;
      }), s.d(t, "getJsSrcParam", function () {
        return g;
      }), s.d(t, "assignStream", function () {
        return p;
      }), s.d(t, "getIP", function () {
        return m;
      });
    },
    "./dist/nxwCall.js":
    /*!*************************!*\
      !*** ./dist/nxwCall.js ***!
      \*************************/

    /*! exports provided: default */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "default", function () {
        return l;
      });

      var i,
          r = s(
      /*! sip.js */
      "./node_modules/sip.js/lib/index.js"),
          n = s(
      /*! events */
      "./node_modules/events/events.js"),
          o = s(
      /*! ./nxw-types */
      "./dist/nxw-types.js"),
          a = s(
      /*! ./nxw-utils */
      "./dist/nxw-utils.js"),
          c = s(
      /*! . */
      "./dist/index.js"),
          d = function (e, t, s, i) {
        return new (s || (s = Promise))(function (r, n) {
          function o(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }

          function a(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }

          function c(e) {
            var t;
            e.done ? r(e.value) : (t = e.value, t instanceof s ? t : new s(function (e) {
              e(t);
            })).then(o, a);
          }

          c((i = i.apply(e, t || [])).next());
        });
      };

      !function (e) {
        e[e.UA_INIT = 0] = "UA_INIT", e[e.UA_NXAPI = 1] = "UA_NXAPI", e[e.UA_CONNECTING = 2] = "UA_CONNECTING", e[e.UA_CONNECTED = 3] = "UA_CONNECTED", e[e.UA_REGISTERING = 4] = "UA_REGISTERING", e[e.UA_READY = 5] = "UA_READY", e[e.UA_CALLING_OUT = 6] = "UA_CALLING_OUT", e[e.UA_CALLING_CREATED = 7] = "UA_CALLING_CREATED", e[e.UA_INCOMING = 8] = "UA_INCOMING", e[e.UA_ANSWERING = 9] = "UA_ANSWERING", e[e.UA_TALKING = 10] = "UA_TALKING", e[e.UA_CALL_ENDING = 11] = "UA_CALL_ENDING", e[e.UA_CALL_END = 12] = "UA_CALL_END", e[e.UA_DISCONNECTED = 13] = "UA_DISCONNECTED", e[e.UA_ERROR = 14] = "UA_ERROR", e[e.UA_REINIT = 15] = "UA_REINIT";
      }(i || (i = {}));

      class l {
        get mySimpleUser() {
          return this.simpleUser;
        }

        set mySimpleUser(e) {
          this.simpleUser = e;
        }

        get lastRequest() {
          return this.request;
        }

        get lastResponse() {
          return this.response;
        }

        get myDisplayName() {
          return this.displayName;
        }

        get mySipId() {
          return this.sipId;
        }

        get isRegistered() {
          return this.registered > 0;
        }

        get lastCcCode() {
          return this.ccCode;
        }

        get lastCallId() {
          return this.callId;
        }

        get lastCcCallId() {
          return this.ccCallId;
        }

        get mySimpleUserId() {
          return this.simpleUser ? this.simpleUser.id : "_SIMPLE_";
        }

        get myEvents() {
          return this.events;
        }

        get remoteName() {
          if (this.simpleUser && this.simpleUser.activeSession) {
            return this.simpleUser.activeSession.remoteIdentity.uri.aor;
          }

          return "";
        }

        get talkingTime() {
          if (this.state == i.UA_TALKING && this.confirmTs) {
            return new Date().valueOf() - this.confirmTs.valueOf();
          }

          return 0;
        }

        get myDataHdrs() {
          return this.dataHdrs;
        }

        get myOrderId() {
          return this.orderId;
        }

        set myOrderId(e) {
          this.orderId = e;
        }

        get comingOrderId() {
          return this.orderIdComing;
        }

        set comingOrderId(e) {
          this.orderIdComing = e;
        }

        get nxRealPhone() {
          return this._nxRealPhone;
        }

        set nxRealPhone(e) {
          this._nxRealPhone = e;
        }

        get isdid() {
          return this._isdid;
        }

        set isdid(e) {
          this._isdid = e;
        }

        get isSendSMS() {
          return this._sendsms;
        }

        get myState() {
          return this.state.toString();
        }

        get callStatusInfo() {
          return this.statusInfo;
        }

        updateLastSessionTrying() {
          if (this.simpleUser) {
            let e = this.simpleUser.activeSession;
            null != e && (this.lastSessionTrying = e);
          }
        }

        setAutoAnswer(e) {
          this.autoAnswer = e;
        }

        setVideo(e) {
          e != this.video && (console.log("SORRY!!! not support yet!"), this.video = e);
        }

        get activeSessionState() {
          return this.simpleUser && this.simpleUser.activeSession ? this.simpleUser.activeSession.state.toString() : "";
        }

        get activeCallId() {
          if (this.simpleUser && this.simpleUser.activeSession) {
            let e = this.simpleUser.activeSession.id;
            return e.length > 36 ? e.substring(0, 36) : e.substring(0, 20);
          }

          return "";
        }

        get getInfoSample() {
          return "sipid=" + this.mySipId + " state=" + this.state + " remote=" + this.remoteName + " state=" + this.activeSessionState;
        }

        checkAndRun() {
          this.invalid || (this.state == i.UA_ERROR ? (console.log("checkAndRun state ERROR!!!!"), this.mark++, this.mark > 1 && (this.state = i.UA_REINIT)) : this.state == i.UA_TALKING || this.state == i.UA_CALLING_OUT || this.state == i.UA_CALLING_CREATED || this.state == i.UA_INCOMING || this.state == i.UA_CALL_ENDING ? this.fails = 0 : this.state == i.UA_READY || this.state == i.UA_INIT || (this.state == i.UA_CALL_END ? (console.log("UA_CALL_END to UA_READY"), console.log("mark=", this.mark, "nextTarget=", this.nextTarget), this.state = i.UA_READY) : (console.log("checkAndRun state=", this.state, "fails=", this.fails), this.fails++, this.fails > 4 && (this.events.emit("error", "fails too much " + this.state), this.state = i.UA_ERROR, this.fails = 0))), this.mark > 0 && (this.state == i.UA_REINIT ? (this.deleteOldSimpleUser(), this.state = i.UA_INIT, this.mark--, setTimeout(() => {
            console.log("checkAndRun begin NXgetUserInfo"), this.NXgetUserInfo(this.config);
          }, 10)) : this.state == i.UA_READY && this.nextTarget.length > 0 && (console.log("begin placeCall to", this.nextTarget, this.nextHdrs), this.placeCall(this.nextTarget, this.nextHdrs))));
        }

        constructor(e) {
          this._userDelegate = {
            onCallReceived: () => d(this, void 0, void 0, function* () {
              if (console.log(`[${this.simpleUser.id}] Call received`, this.simpleUser), this.updateLastSessionTrying(), this.state = i.UA_INCOMING, this.statusInfo = "", this.ccCode = "", this.simpleUser && this.simpleUser.activeSession) {
                let e = this.simpleUser.activeSession;
                console.log("call-id in is " + e.dialog.callId), this.callId = e.dialog.callId, this.ccCallId = e.request.getHeader("X-NXCC-Call-ID"), console.log("incoming nxcc-call-id is " + this.ccCallId);
                let t = e.request.getHeader("X-ORDERID");
                this.orderIdComing = t, console.log("orderIdComing X-ORDERID=" + t);
                let s = e.request.getHeader("X-NX-REALPHONE");
                this._nxRealPhone = s || "", this.request = e.request;
              }

              this.events.emit("onCallReceived", this.remoteName), this.autoAnswer ? (console.log("try autoAnswer await"), this.answerCall()) : this.play("start", "ringin.wav");
            }),
            onCallCreated: () => {
              this.simpleUser && this.simpleUser.activeSession && (console.log(`[${this.simpleUser.id}] Call created`), this.state = i.UA_CALLING_CREATED, this.statusInfo = "", 2 == this.retries && "" != this.nextTarget && (console.log("onCallCreated, set nextTarget empty!"), this.nextTarget = ""), this.events.emit("onCallCreated", this.remoteName));
            },
            onCallAnswered: () => {
              this.updateLastSessionTrying(), this.play("end", ""), console.log(`[${this.simpleUser.id}] Call answered`, this.simpleUser.activeSession), this.state = i.UA_TALKING, this.statusInfo = "200 OK", this.confirmTs = new Date(), 1 == this.retries && "" != this.nextTarget && (console.log("onCallAnswered, set nextTarget empty!"), this.nextTarget = ""), console.log("onCallAnswered really!"), this.play("start", "connected.wav"), this.events.emit("onCallAnswered", this.remoteName);
            },
            onCallHangup: () => {
              this.play("end", ""), this.play("start", "hangup.wav"), console.log(`[${this.simpleUser.id}] Call hangup`), this.mark = 1, this.state = i.UA_CALL_END, this.request = null, this.response = null, 0 == this.retries && "" != this.nextTarget && (console.log("onCallHangup, set nextTarget empty!"), this.nextTarget = ""), this.events.emit("onCallHangup", this.statusInfo), "" == this.nextTarget && (this.state = i.UA_READY);
            },
            onRegistered: () => {
              this.state = i.UA_READY, this.mark++, this.registered = 1, console.log(`[${this.displayName}] user registered, mark=${this.mark},nextTarget=${this.nextTarget}`), this.play("start", "online.wav"), setTimeout(() => {
                this.play("cache", "offline.wav"), this.play("cache", "ringin.wav"), this.play("cache", "ringout.wav"), this.play("cache", "hangup.wav"), this.play("cache", "connected.wav");
              }, 500), this.events.emit("onRegistered", this.displayName), this.nextTarget && this.nextTarget.length > 0 && (console.log("begin placeCall to", this.nextTarget, this.nextHdrs), this.placeCall(this.nextTarget, this.nextHdrs));
            },
            onUnregistered: e => {
              console.log(`[${this.displayName}] user unregistered ${e}`), this.registered && (this.registered = 0, this.play("start", "offline.wav")), this.events.emit("onUnregistered", e);
            },
            onServerConnect: () => {
              console.log(`[${this.displayName}] server connected`), this.state = i.UA_CONNECTED, this.events.emit("onServerConnect", "");
              let e = ["X-NX-RemotePubIP: " + (this.cip || "0.0.0.0")];
              7 == this.config.nxtype && (e.push("X-NXCC-Agent: " + (this.config.ccAgent || "NA")), e.push("X-NXCC-Token: " + (this.config.ccToken || "NA")), e.push("X-NXCC-Queue: " + (this.config.ccQueue || "NA")));
              let t = this;
              setTimeout(() => {
                console.log("state ready register state=" + t.state), t.state == i.UA_CONNECTED && (t.simpleUser.register({
                  requestDelegate: {
                    onReject: e => {
                      console.warn(`[${this.displayName}] REGISTER rejected`);
                    }
                  },
                  requestOptions: {
                    extraHeaders: e
                  }
                }), t.state = i.UA_REGISTERING);
              }, 99);
            },
            onServerDisconnect: e => {
              console.log(`[${this.displayName}] server disconnected ${e}`), this.simpleUser == l.lastInstance && (this.state = i.UA_DISCONNECTED, this.events.emit("onServerDisconnect", ""));
            },
            onCallHold: e => {
              console.log(`[${this.simpleUser.id}] Call hold ${e}`), this.events.emit("onCallHold", "");
            },
            onMessageReceived: e => {
              console.log(`[${this.simpleUser.id}] recv message ${e}`), this.handleMessage(e), this.events.emit("onMessageReceived", e);
            },
            onCallDTMFReceived: (e, t) => {
              console.log(`[${this.simpleUser.id}] Call DTMFReceived ${e}:${t} `), this.events.emit("dtmf_recv", e + ":" + t);
            }
          }, this.initByConfig(e), setInterval(() => {
            this.checkFlag && this.checkAndRun();
          }, 5e3);
        }

        initByConfig(e) {
          l.lastInstance && (console.log("already has lastInstance. Free it"), l.lastInstance.unregister().finally(() => {
            l.lastInstance.disconnect(), l.lastInstance = null;
          })), this.config = e, this.simpleUser = null, this.checkFlag = !0, this.invalid = !1, e.audioElementId ? (this.audioElement = Object(a.getAudio)(e.audioElementId), console.log("Using Page Audio HTMLAudioElement", this.audioElement)) : (console.log("New Audio HTMLAudioElement"), this.audioElement = new Audio()), e.playElementId ? (this.playElement = Object(a.getAudio)(e.playElementId), console.log("Using Page Play HTMLAudioElement", this.playElement)) : (console.log("New Play HTMLAudioElement"), this.playElement = new Audio()), e.video ? (console.log("config.video enabled"), this.video = e.video, this.videoLocalElement = Object(c.getVideo)(e.videoLocalElementId), this.videoRemoteElement = Object(c.getVideo)(e.videoRemoteElementId)) : (this.video = !1, this.videoLocalElement = void 0, this.videoRemoteElement = void 0), this.events = new n.EventEmitter(), this.displayName = "NA", this.state = i.UA_INIT, this.nextTarget = "", this.fails = 0, this.mark = 0, this.logLevel = void 0 === e.logLevel ? "warn" : e.logLevel, this.retries = void 0 === e.retries ? 0 : e.retries, this.playTone = null == e.playTone ? 0 : Number(e.playTone), this.sipId = "", this.confirmTs = null, this.lastSessionTrying = null, this.statusInfo = "", this.orderId = null, this.nextHdrs = null, this.dataHdrs = null, this._nxRealPhone = "", this._isdid = 0, this._sendsms = !1, this.ccCode = "", this.callId = "", this.musicBuffer = new Map(), this.autoAnswer = void 0 !== e.autoAnswer && e.autoAnswer, this.delegate = this._userDelegate, this.mark++, this.localIPs = "_", this.cip = "_";
          var t = this;
          Object(a.getIP)(function (e) {
            console.log("localIp=", e), e.length <= 16 && e.length >= 7 && (t.localIPs = t.localIPs + e + "_"), t.state == i.UA_INIT && (console.log("begin NXgetUserInfo"), t.NXgetUserInfo(t.config));
          }, () => {});
        }

        NXgetUserInfo(e) {
          let t = new XMLHttpRequest();
          console.log("NXgetUserInfo config=", e), this.state = i.UA_NXAPI;
          let s = e.nxtype ? e.nxtype : 0;
          if (6 != e.nxtype) return void this.initNxwCall(s, e);
          t.withCredentials = !1, t.open("GET", "/api/userinfo");
          const r = e.nxuser + ":" + e.nxpass,
                n = "Basic " + window.btoa(r);
          t.setRequestHeader("Content-Type", "application/json"), t.setRequestHeader("Authorization", n);
          let o = this;
          t.onreadystatechange = function () {
            if (4 === t.readyState) if (200 == t.status && t.responseText.length > 0) {
              const e = JSON.parse(t.responseText);
              o.initNxwCall(s, e);
            } else console.log("userfinfo status=" + t.status), o.state = i.UA_ERROR;
          }, t.onerror = function (e) {
            console.log("xhr.onerror"), console.log(e), o.state = i.UA_ERROR;
          }, t.setRequestHeader("Cache-Control", "no-cache"), t.send();
        }

        deleteOldSimpleUser() {
          this.simpleUser && (console.log("delete old simpleUser!!", this.simpleUser), this.simpleUser.disconnect().finally(() => {
            console.log("delete old simpleUser done!!");
          }), l.lastInstance = null, this.simpleUser = null);
        }

        initNxwCall(e, t) {
          let s = {};

          if (console.log("initNxwCall type=", e, " param=", typeof t, t), 0 == e && (e = 3), e <= 5) {
            let i = t;
            s.authName = i.nxuser, s.displayName = i.nxuser, s.userName = i.nxuser, s.nxUserName = i.nxuser, s.secret = i.nxpass, 1 == e ? (s.domain = "nxrtc1.nxcloud.com", s.wssServer = "wss://nxrtc1.nxcloud.com:7443") : 2 == e ? (s.domain = "cs.gate110.com", s.wssServer = "wss://cs.gate110.com:4442") : 3 == e ? (s.domain = "nxrtc1.nxcloud.com", s.wssServer = "wss://nxrtc1.nxcloud.com:8089") : 4 == e ? (s.domain = "ucloud.arya.top", s.wssServer = "wss://ucloud.arya.top:7443") : 5 == e && (s.domain = "nxcs50.nxcloud.com", s.wssServer = "wss://nxcs50.nxcloud.com:7443"), s.aor = "sip:" + s.userName + "@" + s.domain, s.forceRport = !0, console.log("wssServer " + s.wssServer);
          } else if (7 == e) {
            let e = t;
            s.authName = e.nxuser, s.displayName = e.nxuser, s.userName = e.nxuser, s.nxUserName = e.nxuser, s.secret = e.nxpass, s.domain = e.domain, s.wssServer = e.wssurl, s.ccAgent = e.ccAgent, s.ccToken = e.ccToken, s.ccQueue = e.ccQueue, s.aor = "sip:" + s.userName + "@" + s.domain, s.forceRport = !0;
          } else if (6 == e) {
            let e = t;
            s.displayName = e.username, s.domain = e.sipdomain, s.userName = e.sipaccount, s.nxUserName = e.username, s.authName = e.sipaccount, s.secret = e.sippassword, s.cip = e.cip, s.isdid = Number(e.isdid), s.sendsms = e.sendsms, console.log("resp= ", e), null != e.wssserver ? (e.wssport = 443, s.wssServer = "wss://" + e.wssserver + ":" + e.wssport + "/wss", this.config.wssurl && this.config.wssurl.startsWith("wss://") && (console.log("force using wssServer= " + this.config.wssurl), s.wssServer = this.config.wssurl), console.log("wssServer= " + s.wssServer + " flushreg=" + e.flushreg)) : console.log("FIXME: no wssServer "), s.aor = "sip:" + s.userName + "@" + s.domain, s.forceRport = !0;
          } else if (8 == e) return;

          this.simpleUser && this.state >= i.UA_CONNECTED && this.deleteOldSimpleUser(), this.cip = s.cip, this.displayName = s.displayName ? s.displayName : "NA", this.sipId = s.authName, this._isdid = s.isdid, this._sendsms = s.sendsms, this.simpleUser = this.buildSimpleUser(s), l.lastInstance = this.simpleUser, this.state = i.UA_CONNECTING, this.simpleUser.connect().catch(e => {
            this.events.emit("error", e), this.state = i.UA_ERROR, console.error(`[${this.sipId}] failed to connect`), console.error(e);
          });
        }

        leftpad(e, t = 2, s = "0") {
          return (String(s).repeat(t) + String(e)).slice(String(e).length);
        }

        buildSimpleUser(e) {
          let t = null;
          console.log("displayName=" + e.displayName + " username=" + e.userName + " aor=" + e.aor);
          const s = new Date(),
                [i, n, o, a, c] = [s.getMonth() + 1, this.leftpad(s.getDate(), 2), this.leftpad(s.getHours(), 2), this.leftpad(s.getMinutes(), 2), this.leftpad(s.getSeconds(), 2)];
          let d = "230509_" + i + n + o + a + c;
          t = this.video ? {
            delegate: this.delegate,
            aor: e.aor,
            media: {
              constraints: {
                audio: !0,
                video: !0
              },
              local: {
                video: this.videoLocalElement
              },
              remote: {
                video: this.videoRemoteElement,
                audio: this.audioElement
              }
            },
            userAgentOptions: {
              logLevel: this.logLevel,
              displayName: e.displayName,
              contactName: e.userName,
              viaHost: e.domain,
              contactParams: {
                transport: "wss",
                nxuser: e.nxUserName,
                nxw: "V" + d,
                ips: this.localIPs,
                cip: this.cip
              },
              userAgentString: "NXW/" + e.nxUserName,
              authorizationPassword: e.secret,
              authorizationUsername: e.authName,
              sipExtension100rel: r.SIPExtension.Supported,
              transportOptions: {
                server: e.wssServer,
                keepAliveInterval: 20,
                connectionTimeout: 35
              },
              forceRport: e.forceRport,
              sessionDescriptionHandlerFactoryOptions: {
                alwaysAcquireMediaFirst: !0
              }
            },
            registererOptions: {
              expires: 300,
              refreshFrequency: 70
            }
          } : {
            delegate: this.delegate,
            aor: e.aor,
            media: {
              constraints: {
                audio: !0,
                video: !1
              },
              remote: {
                audio: this.audioElement
              }
            },
            userAgentOptions: {
              logLevel: this.logLevel,
              displayName: e.displayName,
              contactName: e.userName,
              viaHost: e.domain,
              contactParams: {
                transport: "wss",
                nxuser: e.nxUserName,
                nxw: "v" + d,
                ips: this.localIPs,
                cip: this.cip
              },
              userAgentString: "NXW/" + e.nxUserName,
              authorizationPassword: e.secret,
              authorizationUsername: e.authName,
              sipExtension100rel: r.SIPExtension.Supported,
              transportOptions: {
                server: e.wssServer,
                keepAliveInterval: 20,
                connectionTimeout: 35
              },
              forceRport: e.forceRport,
              sessionDescriptionHandlerFactoryOptions: {
                alwaysAcquireMediaFirst: !0
              }
            },
            registererOptions: {
              expires: 36e3,
              refreshFrequency: 99
            }
          }, this.registered = 0;
          const l = new r.Web.SimpleUser(e.wssServer, t);
          return console.log("new simpleUser = ", l), l;
        }

        isConnected() {
          return !!this.simpleUser && this.simpleUser.isConnected();
        }

        isBusy() {
          return !(!this.simpleUser || !this.simpleUser.activeSession);
        }

        isReady() {
          return this.state == i.UA_READY;
        }

        cacheMusic(e) {
          let t = new (0, window.AudioContext)();
          t.resume();
          let s = this;
          fetch(e, {
            method: "GET",
            mode: "cors"
          }).then(e => e.arrayBuffer()).then(e => t.decodeAudioData(e)).then(i => {
            s.musicBuffer.set(e, i), t.close(), t = null;
          }).catch(e => {
            console.log("error ", e);
          });
        }

        playSync(e, t) {
          if (console.log(">>>play: action=" + e, "type=" + t, "playTone=" + this.playTone), "begin" == e || "start" == e || "cache" == e) {
            let s = "",
                i = !1,
                r = 0;

            if (s = t, "ringin.wav" == t ? (r = o.ToneFlag.RINGIN, i = !0) : "ringout.wav" == t ? (r = o.ToneFlag.RINGOUT, i = !0) : "connected.wav" == t ? (r = o.ToneFlag.CONNECTED, i = !1) : "hangup.wav" == t ? (r = o.ToneFlag.HANGUP, i = !1) : "online.wav" == t ? (r = o.ToneFlag.ONLINE, i = !1) : "offline.wav" == t ? (r = o.ToneFlag.OFFLINE, i = !0) : (r = o.ToneFlag.CUSTOM, i = !1), console.log(">>> play ", r, t, s, i), "" != t && this.playTone & r) {
              console.log("start play ", r, t, s, i), this.playElement && this.playElement.played && this.playElement.played.length > 0 && this.playElement.pause();
              let n = this.config.audioSrcPath;
              null == n && (n = "audio");
              let o = n + "/" + s;
              if ((s.startsWith(".") || s.startsWith("/")) && (o = s), "cache" == e) return console.log("cacheMusic only  " + o), void this.cacheMusic(o);
              let a = this.musicBuffer.get(o);
              this.track && (this.track.stop(), this.track.disconnect(), this.track = null), l.audioCtx && (l.audioCtx.destination.disconnect(), l.audioCtx.close().catch(e => {
                console.log(e);
              }), l.audioCtx = null);
              const c = window.AudioContext;

              if (l.audioCtx = new c(), a) {
                console.log("using cache for " + o), this.track = l.audioCtx.createBufferSource();
                const e = l.audioCtx.createMediaStreamDestination();
                this.track.buffer = a, this.track.loop = i, this.track.connect(l.audioCtx.destination), this.track.start(0), this.playElement.srcObject = e.stream, this.playElement.loop = i;
              } else console.log("cacheMusic for first use  " + o), this.cacheMusic(o), this.playElement && (this.playElement.loop = !1, this.playElement.pause(), this.playElement = null), this.playElement = new Audio(o), this.playElement.loop = i;

              this.playElement.muted = !0, l.audioCtx.resume().then(() => {
                this.playElement.play();
              }).then(() => {
                this.playElement.muted = !1, this.playElement.currentTime = 0;
              }).catch(e => {
                console.log("play error:", e);
              });
            }
          } else "end" != e && "stop" != e || (this.playElement && (this.playElement.src = "", this.playElement.loop = !1, this.playElement.pause()), this.track && (this.track.stop(), this.track.disconnect(), this.track = null), l.audioCtx && (l.audioCtx.destination.disconnect(), l.audioCtx.close().catch(e => {
            console.log(e);
          }), l.audioCtx = null));
        }

        play(e, t) {
          setTimeout(() => {
            this.playSync(e, t);
          }, 1);
        }

        placeCall(e, t) {
          if (console.log("placeCall state=" + this.state, e, t), !this.simpleUser) return !1;

          if (this.state == i.UA_READY) {
            this.state = i.UA_CALLING_OUT, this.events.emit("placeCall", e), "sip:" != e.substr(0, 4) && (e = "sip:" + e), -1 == e.indexOf("@") && (e += "@nxcloud.com"), console.log("pacecall with earlymedia");
            var s = this;
            s.ccCode = "", s.earlyAnswer = !1;
            var r = {
              requestDelegate: {
                onAccept: t => {
                  console.log("Positive response = ", t), s.callId = t.message.callId, s.statusInfo = "200 OK";
                  let {
                    message: i
                  } = t;
                  s.response = i, s.ccCode = i.getHeader("X-NXCC-CODE"), console.log("onAccept ccCode=", s.ccCode), s.ccCallId = i.getHeader("X-NXCC-Call-ID"), console.log("onAccept ccCallId=", s.ccCallId), s.events.emit("onAccept", e);
                },
                onReject: t => {
                  console.log("Negative response = ", t);
                  let {
                    message: i
                  } = t;
                  s.response = i, s.statusInfo = i.statusCode.toString() + " " + i.reasonPhrase, s.callId = t.message.callId;
                  let r = i.getHeader("X-NXCC-CODE");
                  r && (s.ccCode = r, s.events.emit("onReject", e));
                },
                onProgress: t => {
                  console.log("onProgress response = ", typeof t, t), s.callId = t.message.callId;
                  let {
                    message: i
                  } = t;
                  s.response = i, s.statusInfo = i.statusCode.toString() + " " + i.reasonPhrase;
                  let r = t.session;
                  if (console.log("onProgress session=", r), s.ccCode = i.getHeader("X-NXCC-CODE"), s.ccCallId = i.getHeader("X-NXCC-Call-ID"), s.events.emit("onProgress", e), 100 == i.statusCode) console.log("onProgress 100 trying");else if (i.statusCode >= 180 && i.statusCode < 190) {
                    console.log("onProgress statusCode= ${message.statusCode} ");
                    let e = i.getHeader("Content-Type");
                    e && "application/sdp" == e.toLowerCase() && (s.earlyAnswer = !0, s.play("end", "ringout.wav"));
                  } else console.log("onProgress others ", i.statusCode);
                }
              },
              sessionDescriptionHandlerOptions: {
                constraints: {
                  audio: !0,
                  video: this.video
                }
              }
            };
            return t || (t = []), this.cip && this.cip.length > 0 && t.push("X-NX-RemotePubIP: " + this.cip), this.orderId && this.orderId.length > 0 && t.push("X-ORDERID: " + this.orderId), 6 == this.config.nxtype ? t.push("X-actiontype: 7") : 7 == this.config.nxtype && (t.push("X-NXCC-Agent: " + (this.config.ccAgent || "NA")), t.push("X-NXCC-Token: " + (this.config.ccToken || "NA")), t.push("X-NXCC-Queue: " + (this.config.ccQueue || "NA")), t.push("X-actiontype: 7")), this.dataHdrs = t, this.simpleUser.call(e, {
              inviteWithoutSdp: !1,
              earlyMedia: !0,
              extraHeaders: t
            }, r).then(() => {
              this.play("start", "ringout.wav"), this.events.emit("placeCallOK", e);
            }).catch(e => {
              console.error(`[${this.simpleUser.id}] failed to place call`), console.error(e), this.state = i.UA_READY;
            }), !0;
          }

          return 0 == this.config.retries ? (console.log("Please wait state=", this.state), !1) : (this.nextTarget = e, this.nextHdrs = t, this.mark++, console.log("placeCallWait nextTarget=", this.nextTarget), this.events.emit("placeCallWait", e), !0);
        }

        answerCall(e) {
          if (console.log("answerCall now ... ", this.simpleUser), this.state == i.UA_INCOMING && this.simpleUser) {
            null == this.simpleUser.activeSession && console.log("FIXME: answerCall with undefined activeSession!"), e || (e = []), this.orderId && this.orderId.length > 0 && e.push("X-ORDERID: " + this.orderId), this.dataHdrs = e;
            let t = {};
            t.extraHeaders = e, t.sessionDescriptionHandlerOptions = {
              iceGatheringTimeout: 500
            }, this.state = i.UA_ANSWERING, this.simpleUser.answer(t).then(() => {
              this.state = i.UA_TALKING, this.events.emit("answer", "");
            }).catch(e => {
              console.error(`[${this.simpleUser.id}] failed to answer call`), console.error(e);
            });
          } else console.log("FIXME: force answerCall!"), this.state = i.UA_ANSWERING, this.simpleUser.answer().then(() => {
            this.state = i.UA_TALKING, this.events.emit("answer", "");
          }).catch(e => {
            console.error(`[${this.simpleUser.id}] failed to answer call`), console.error(e);
          });
        }

        declineCall() {
          console.log("declineCall now ... ", this.simpleUser), this.state == i.UA_INCOMING && this.simpleUser && this.simpleUser.activeSession && this.simpleUser.decline().then(() => {
            this.state = i.UA_READY, this.events.emit("decline", "");
          }).catch(e => {
            this.events.emit("error", e), this.state = i.UA_ERROR, console.error(`[${this.simpleUser.id}] failed to decline call`), console.error(e);
          });
        }

        hangupCall() {
          if (console.log("hangupCall try... ", this.simpleUser, this.state, this.lastSessionTrying), this.simpleUser) {
            let e = "",
                t = 0;
            if (this.state == i.UA_INCOMING) return void this.declineCall();

            if (this.simpleUser.activeSession && this.state > i.UA_READY) {
              for (; this.state == i.UA_ANSWERING && t < 100;) t++;

              e = this.simpleUser.activeSession.id, this.state = i.UA_CALL_ENDING, this.simpleUser.hangup().then(() => {
                this.events.emit("hangup", "");
              }).catch(e => {
                this.events.emit("error", e), console.error(`[${this.simpleUser.id}] failed to hangup call`), console.error(e);
              });
            }

            e.length > 0 && this.lastSessionTrying && this.lastSessionTrying.id == e && (console.log("hangup OK. clear lastSessionTrying " + e), this.lastSessionTrying = null), this.lastSessionTrying && (console.log("fixme: try lastSessionTrying... ", this.lastSessionTrying.state), this.lastSessionTrying.state != r.SessionState.Terminated && this.lastSessionTrying.bye().catch(e => {
              console.warn("!!!!! BYE lastSessionTrying error" + e);
            }), this.lastSessionTrying = null);
          }
        }

        cleanupMedia() {
          this.audioElement && (this.audioElement.srcObject = null, this.audioElement.pause()), this.videoRemoteElement && (this.videoRemoteElement.srcObject = null, this.videoRemoteElement.pause()), this.videoLocalElement && (this.videoLocalElement.srcObject = null, this.videoLocalElement.pause());
        }

        disconnect(e = !0) {
          if (this.simpleUser) {
            var t = this.simpleUser;
            this.simpleUser = null, t.disconnect().then(() => {
              this.events.emit("disconnect", ""), this.state = i.UA_INIT;
            }).catch(e => {
              this.events.emit("error", e), this.state = i.UA_ERROR, console.error(`[${this.simpleUser.id}] failed to disconnect`);
            });
          }

          e && (this.events.emit("disconnect", "invalid"), this.invalid = !0, this.simpleUser = null, l.lastInstance = null);
        }

        unregister() {
          this.simpleUser && this.simpleUser.unregister().finally(() => {
            console.log("unregister start!");
          });
        }

        register() {
          this.simpleUser && this.simpleUser.register().finally(() => {
            console.log("register start!");
          });
        }

        handleMessage(e) {
          try {
            let t = JSON.parse(e);

            if (t.cmd = "unreg") {
              let e = t.delay || 100;
              console.log("begin unregister! delay=" + e), setTimeout(() => {
                this.unregister();
              }, e);
            }
          } catch (e) {
            console.log(e);
          }
        }

        sendDTMF(e) {
          if (e && e.length > 0) for (let t = 0; t < e.length; t++) {
            let s = e[t];
            console.log("try sendDTMF " + s), this.simpleUser.sendDTMF(s).then(() => {
              this.events.emit("dtmf", s);
            }).catch(e => {
              console.log("sendDTMF err:" + s), this.events.emit("error", e), console.error(e);
            });
          }
        }

        holdCall(e) {
          console.log("holdCall" + e + " for session", this.simpleUser.activeSession), this.simpleUser.activeSession && (e ? (this.events.emit("hold", "try"), this.simpleUser.hold().then(() => {
            this.events.emit("hold", "ok");
          }).catch(e => {
            this.events.emit("error", e), this.state = i.UA_ERROR, console.error(`[${this.simpleUser.id}] failed to hold call`), console.error(e);
          })) : (this.events.emit("unhold", "try"), this.simpleUser.unhold().then(() => {
            this.events.emit("unhold", "ok");
          }).catch(e => {
            this.events.emit("error", e), this.state = i.UA_ERROR, console.error(`[${this.simpleUser.id}] failed to unhold call`), console.error(e);
          })));
        }

        muteCall(e) {
          console.log("muteCall" + e + " for session", this.simpleUser.activeSession), this.simpleUser.activeSession && (e ? (this.events.emit("mute", "on"), this.simpleUser.mute(), !1 === this.simpleUser.isMuted() && (this.state = i.UA_ERROR, console.error(`[${this.simpleUser.id}] failed to mute call`))) : (this.events.emit("mute", "off"), this.simpleUser.unmute(), !0 === this.simpleUser.isMuted() && (this.state = i.UA_ERROR, console.error(`[${this.simpleUser.id}] failed to unmute call`))));
        }

        silentCall(e) {
          console.log("silentCall" + e + " for session", this.simpleUser.activeSession), this.simpleUser.activeSession && this.audioElement && (this.events.emit("silent", e ? "on" : "off"), this.audioElement.muted = e);
        }

        setVolume(e) {
          if ((e = Math.abs(e)) > 100 ? e = 1 : e > 1 && (e /= 100), this.audioElement) {
            if (console.log("set Volume=" + e), !this.simpleUser.activeSession) return;
            this.events.emit("volume", e), this.audioElement.volume = e;
          }
        }

        clearException() {
          console.log("clearException"), this.state != i.UA_TALKING && (this.lastSessionTrying && this.lastSessionTrying.bye().finally(() => {
            console.log("bye lastSessionTrying"), this.lastSessionTrying = null;
          }), setTimeout(() => d(this, void 0, void 0, function* () {
            this.simpleUser.disconnect();
          }), 10));
        }

      }
    },
    "./node_modules/events/events.js":
    /*!***************************************!*\
      !*** ./node_modules/events/events.js ***!
      \***************************************/

    /*! no static exports found */
    function (e, t, s) {
      "use strict";

      var i,
          r = "object" == typeof Reflect ? Reflect : null,
          n = r && "function" == typeof r.apply ? r.apply : function (e, t, s) {
        return Function.prototype.apply.call(e, t, s);
      };
      i = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function (e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
      } : function (e) {
        return Object.getOwnPropertyNames(e);
      };

      var o = Number.isNaN || function (e) {
        return e != e;
      };

      function a() {
        a.init.call(this);
      }

      e.exports = a, e.exports.once = function (e, t) {
        return new Promise(function (s, i) {
          function r(s) {
            e.removeListener(t, n), i(s);
          }

          function n() {
            "function" == typeof e.removeListener && e.removeListener("error", r), s([].slice.call(arguments));
          }

          f(e, t, n, {
            once: !0
          }), "error" !== t && function (e, t, s) {
            "function" == typeof e.on && f(e, "error", t, s);
          }(e, r, {
            once: !0
          });
        });
      }, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
      var c = 10;

      function d(e) {
        if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
      }

      function l(e) {
        return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners;
      }

      function u(e, t, s, i) {
        var r, n, o, a;
        if (d(s), void 0 === (n = e._events) ? (n = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== n.newListener && (e.emit("newListener", t, s.listener ? s.listener : s), n = e._events), o = n[t]), void 0 === o) o = n[t] = s, ++e._eventsCount;else if ("function" == typeof o ? o = n[t] = i ? [s, o] : [o, s] : i ? o.unshift(s) : o.push(s), (r = l(e)) > 0 && o.length > r && !o.warned) {
          o.warned = !0;
          var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = o.length, a = c, console && console.warn && console.warn(a);
        }
        return e;
      }

      function h(e, t, s) {
        var i = {
          fired: !1,
          wrapFn: void 0,
          target: e,
          type: t,
          listener: s
        },
            r = function () {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }.bind(i);

        return r.listener = s, i.wrapFn = r, r;
      }

      function g(e, t, s) {
        var i = e._events;
        if (void 0 === i) return [];
        var r = i[t];
        return void 0 === r ? [] : "function" == typeof r ? s ? [r.listener || r] : [r] : s ? function (e) {
          for (var t = new Array(e.length), s = 0; s < t.length; ++s) t[s] = e[s].listener || e[s];

          return t;
        }(r) : m(r, r.length);
      }

      function p(e) {
        var t = this._events;

        if (void 0 !== t) {
          var s = t[e];
          if ("function" == typeof s) return 1;
          if (void 0 !== s) return s.length;
        }

        return 0;
      }

      function m(e, t) {
        for (var s = new Array(t), i = 0; i < t; ++i) s[i] = e[i];

        return s;
      }

      function f(e, t, s, i) {
        if ("function" == typeof e.on) i.once ? e.once(t, s) : e.on(t, s);else {
          if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
          e.addEventListener(t, function r(n) {
            i.once && e.removeEventListener(t, r), s(n);
          });
        }
      }

      Object.defineProperty(a, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return c;
        },
        set: function (e) {
          if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
          c = e;
        }
      }), a.init = function () {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, a.prototype.setMaxListeners = function (e) {
        if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this;
      }, a.prototype.getMaxListeners = function () {
        return l(this);
      }, a.prototype.emit = function (e) {
        for (var t = [], s = 1; s < arguments.length; s++) t.push(arguments[s]);

        var i = "error" === e,
            r = this._events;
        if (void 0 !== r) i = i && void 0 === r.error;else if (!i) return !1;

        if (i) {
          var o;
          if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
          var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
          throw a.context = o, a;
        }

        var c = r[e];
        if (void 0 === c) return !1;
        if ("function" == typeof c) n(c, this, t);else {
          var d = c.length,
              l = m(c, d);

          for (s = 0; s < d; ++s) n(l[s], this, t);
        }
        return !0;
      }, a.prototype.addListener = function (e, t) {
        return u(this, e, t, !1);
      }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function (e, t) {
        return u(this, e, t, !0);
      }, a.prototype.once = function (e, t) {
        return d(t), this.on(e, h(this, e, t)), this;
      }, a.prototype.prependOnceListener = function (e, t) {
        return d(t), this.prependListener(e, h(this, e, t)), this;
      }, a.prototype.removeListener = function (e, t) {
        var s, i, r, n, o;
        if (d(t), void 0 === (i = this._events)) return this;
        if (void 0 === (s = i[e])) return this;
        if (s === t || s.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, s.listener || t));else if ("function" != typeof s) {
          for (r = -1, n = s.length - 1; n >= 0; n--) if (s[n] === t || s[n].listener === t) {
            o = s[n].listener, r = n;
            break;
          }

          if (r < 0) return this;
          0 === r ? s.shift() : function (e, t) {
            for (; t + 1 < e.length; t++) e[t] = e[t + 1];

            e.pop();
          }(s, r), 1 === s.length && (i[e] = s[0]), void 0 !== i.removeListener && this.emit("removeListener", e, o || t);
        }
        return this;
      }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function (e) {
        var t, s, i;
        if (void 0 === (s = this._events)) return this;
        if (void 0 === s.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== s[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete s[e]), this;

        if (0 === arguments.length) {
          var r,
              n = Object.keys(s);

          for (i = 0; i < n.length; ++i) "removeListener" !== (r = n[i]) && this.removeAllListeners(r);

          return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
        }

        if ("function" == typeof (t = s[e])) this.removeListener(e, t);else if (void 0 !== t) for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
        return this;
      }, a.prototype.listeners = function (e) {
        return g(this, e, !0);
      }, a.prototype.rawListeners = function (e) {
        return g(this, e, !1);
      }, a.listenerCount = function (e, t) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t);
      }, a.prototype.listenerCount = p, a.prototype.eventNames = function () {
        return this._eventsCount > 0 ? i(this._events) : [];
      };
    },
    "./node_modules/sip.js/lib/api/ack.js":
    /*!********************************************!*\
      !*** ./node_modules/sip.js/lib/api/ack.js ***!
      \********************************************/

    /*! exports provided: Ack */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Ack", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.incomingAckRequest = e;
        }

        get request() {
          return this.incomingAckRequest.message;
        }

      }
    },
    "./node_modules/sip.js/lib/api/bye.js":
    /*!********************************************!*\
      !*** ./node_modules/sip.js/lib/api/bye.js ***!
      \********************************************/

    /*! exports provided: Bye */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Bye", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.incomingByeRequest = e;
        }

        get request() {
          return this.incomingByeRequest.message;
        }

        accept(e) {
          return this.incomingByeRequest.accept(e), Promise.resolve();
        }

        reject(e) {
          return this.incomingByeRequest.reject(e), Promise.resolve();
        }

      }
    },
    "./node_modules/sip.js/lib/api/cancel.js":
    /*!***********************************************!*\
      !*** ./node_modules/sip.js/lib/api/cancel.js ***!
      \***********************************************/

    /*! exports provided: Cancel */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Cancel", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.incomingCancelRequest = e;
        }

        get request() {
          return this.incomingCancelRequest;
        }

      }
    },
    "./node_modules/sip.js/lib/api/emitter.js":
    /*!************************************************!*\
      !*** ./node_modules/sip.js/lib/api/emitter.js ***!
      \************************************************/

    /*! exports provided: EmitterImpl */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "EmitterImpl", function () {
        return i;
      });

      class i {
        constructor() {
          this.listeners = new Array();
        }

        addListener(e, t) {
          const s = t => {
            this.removeListener(s), e(t);
          };

          !0 === (null == t ? void 0 : t.once) ? this.listeners.push(s) : this.listeners.push(e);
        }

        emit(e) {
          this.listeners.slice().forEach(t => t(e));
        }

        removeAllListeners() {
          this.listeners = [];
        }

        removeListener(e) {
          this.listeners = this.listeners.filter(t => t !== e);
        }

        on(e) {
          return this.addListener(e);
        }

        off(e) {
          return this.removeListener(e);
        }

        once(e) {
          return this.addListener(e, {
            once: !0
          });
        }

      }
    },
    "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js ***!
      \****************************************************************************/

    /*! exports provided: ContentTypeUnsupportedError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ContentTypeUnsupportedError", function () {
        return r;
      });
      var i = s(
      /*! ../../core/exceptions/exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor(e) {
          super(e || "Unsupported content type.");
        }

      }
    },
    "./node_modules/sip.js/lib/api/exceptions/index.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/exceptions/index.js ***!
      \*********************************************************/

    /*! exports provided: ContentTypeUnsupportedError, RequestPendingError, SessionDescriptionHandlerError, SessionTerminatedError, StateTransitionError */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./content-type-unsupported.js */
      "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js");
      s.d(t, "ContentTypeUnsupportedError", function () {
        return i.ContentTypeUnsupportedError;
      });
      var r = s(
      /*! ./request-pending.js */
      "./node_modules/sip.js/lib/api/exceptions/request-pending.js");
      s.d(t, "RequestPendingError", function () {
        return r.RequestPendingError;
      });
      var n = s(
      /*! ./session-description-handler.js */
      "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js");
      s.d(t, "SessionDescriptionHandlerError", function () {
        return n.SessionDescriptionHandlerError;
      });
      var o = s(
      /*! ./session-terminated.js */
      "./node_modules/sip.js/lib/api/exceptions/session-terminated.js");
      s.d(t, "SessionTerminatedError", function () {
        return o.SessionTerminatedError;
      });
      var a = s(
      /*! ./state-transition.js */
      "./node_modules/sip.js/lib/api/exceptions/state-transition.js");
      s.d(t, "StateTransitionError", function () {
        return a.StateTransitionError;
      });
    },
    "./node_modules/sip.js/lib/api/exceptions/request-pending.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/exceptions/request-pending.js ***!
      \*******************************************************************/

    /*! exports provided: RequestPendingError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "RequestPendingError", function () {
        return r;
      });
      var i = s(
      /*! ../../core/exceptions/exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor(e) {
          super(e || "Request pending.");
        }

      }
    },
    "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/exceptions/session-description-handler.js ***!
      \*******************************************************************************/

    /*! exports provided: SessionDescriptionHandlerError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SessionDescriptionHandlerError", function () {
        return r;
      });
      var i = s(
      /*! ../../core/exceptions/exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor(e) {
          super(e || "Unspecified session description handler error.");
        }

      }
    },
    "./node_modules/sip.js/lib/api/exceptions/session-terminated.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/exceptions/session-terminated.js ***!
      \**********************************************************************/

    /*! exports provided: SessionTerminatedError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SessionTerminatedError", function () {
        return r;
      });
      var i = s(
      /*! ../../core/exceptions/exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor() {
          super("The session has terminated.");
        }

      }
    },
    "./node_modules/sip.js/lib/api/exceptions/state-transition.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/exceptions/state-transition.js ***!
      \********************************************************************/

    /*! exports provided: StateTransitionError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "StateTransitionError", function () {
        return r;
      });
      var i = s(
      /*! ../../core/exceptions/exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor(e) {
          super(e || "An error occurred during state transition.");
        }

      }
    },
    "./node_modules/sip.js/lib/api/index.js":
    /*!**********************************************!*\
      !*** ./node_modules/sip.js/lib/api/index.js ***!
      \**********************************************/

    /*! exports provided: ContentTypeUnsupportedError, RequestPendingError, SessionDescriptionHandlerError, SessionTerminatedError, StateTransitionError, Ack, Bye, Cancel, EmitterImpl, Info, Invitation, Inviter, Message, Messager, Notification, PublisherState, Publisher, Referral, RegistererState, Registerer, SessionState, Session, Subscriber, SubscriptionState, Subscription, TransportState, SIPExtension, UserAgentRegisteredOptionTags, UserAgentState, UserAgent */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./exceptions/index.js */
      "./node_modules/sip.js/lib/api/exceptions/index.js");
      s.d(t, "ContentTypeUnsupportedError", function () {
        return i.ContentTypeUnsupportedError;
      }), s.d(t, "RequestPendingError", function () {
        return i.RequestPendingError;
      }), s.d(t, "SessionDescriptionHandlerError", function () {
        return i.SessionDescriptionHandlerError;
      }), s.d(t, "SessionTerminatedError", function () {
        return i.SessionTerminatedError;
      }), s.d(t, "StateTransitionError", function () {
        return i.StateTransitionError;
      });
      var r = s(
      /*! ./ack.js */
      "./node_modules/sip.js/lib/api/ack.js");
      s.d(t, "Ack", function () {
        return r.Ack;
      });
      var n = s(
      /*! ./bye.js */
      "./node_modules/sip.js/lib/api/bye.js");
      s.d(t, "Bye", function () {
        return n.Bye;
      });
      var o = s(
      /*! ./cancel.js */
      "./node_modules/sip.js/lib/api/cancel.js");
      s.d(t, "Cancel", function () {
        return o.Cancel;
      });
      var a = s(
      /*! ./emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js");
      s.d(t, "EmitterImpl", function () {
        return a.EmitterImpl;
      });
      var c = s(
      /*! ./info.js */
      "./node_modules/sip.js/lib/api/info.js");
      s.d(t, "Info", function () {
        return c.Info;
      });
      s(
      /*! ./invitation-accept-options.js */
      "./node_modules/sip.js/lib/api/invitation-accept-options.js"), s(
      /*! ./invitation-progress-options.js */
      "./node_modules/sip.js/lib/api/invitation-progress-options.js"), s(
      /*! ./invitation-reject-options.js */
      "./node_modules/sip.js/lib/api/invitation-reject-options.js");
      var d = s(
      /*! ./invitation.js */
      "./node_modules/sip.js/lib/api/invitation.js");
      s.d(t, "Invitation", function () {
        return d.Invitation;
      });
      s(
      /*! ./inviter-cancel-options.js */
      "./node_modules/sip.js/lib/api/inviter-cancel-options.js"), s(
      /*! ./inviter-invite-options.js */
      "./node_modules/sip.js/lib/api/inviter-invite-options.js"), s(
      /*! ./inviter-options.js */
      "./node_modules/sip.js/lib/api/inviter-options.js");
      var l = s(
      /*! ./inviter.js */
      "./node_modules/sip.js/lib/api/inviter.js");
      s.d(t, "Inviter", function () {
        return l.Inviter;
      });
      var u = s(
      /*! ./message.js */
      "./node_modules/sip.js/lib/api/message.js");
      s.d(t, "Message", function () {
        return u.Message;
      });
      s(
      /*! ./messager-message-options.js */
      "./node_modules/sip.js/lib/api/messager-message-options.js"), s(
      /*! ./messager-options.js */
      "./node_modules/sip.js/lib/api/messager-options.js");
      var h = s(
      /*! ./messager.js */
      "./node_modules/sip.js/lib/api/messager.js");
      s.d(t, "Messager", function () {
        return h.Messager;
      });
      var g = s(
      /*! ./notification.js */
      "./node_modules/sip.js/lib/api/notification.js");
      s.d(t, "Notification", function () {
        return g.Notification;
      });
      s(
      /*! ./publisher-options.js */
      "./node_modules/sip.js/lib/api/publisher-options.js"), s(
      /*! ./publisher-publish-options.js */
      "./node_modules/sip.js/lib/api/publisher-publish-options.js");
      var p = s(
      /*! ./publisher-state.js */
      "./node_modules/sip.js/lib/api/publisher-state.js");
      s.d(t, "PublisherState", function () {
        return p.PublisherState;
      });
      s(
      /*! ./publisher-unpublish-options.js */
      "./node_modules/sip.js/lib/api/publisher-unpublish-options.js");
      var m = s(
      /*! ./publisher.js */
      "./node_modules/sip.js/lib/api/publisher.js");
      s.d(t, "Publisher", function () {
        return m.Publisher;
      });
      var f = s(
      /*! ./referral.js */
      "./node_modules/sip.js/lib/api/referral.js");
      s.d(t, "Referral", function () {
        return f.Referral;
      });
      s(
      /*! ./registerer-options.js */
      "./node_modules/sip.js/lib/api/registerer-options.js"), s(
      /*! ./registerer-register-options.js */
      "./node_modules/sip.js/lib/api/registerer-register-options.js");
      var v = s(
      /*! ./registerer-state.js */
      "./node_modules/sip.js/lib/api/registerer-state.js");
      s.d(t, "RegistererState", function () {
        return v.RegistererState;
      });
      s(
      /*! ./registerer-unregister-options.js */
      "./node_modules/sip.js/lib/api/registerer-unregister-options.js");
      var b = s(
      /*! ./registerer.js */
      "./node_modules/sip.js/lib/api/registerer.js");
      s.d(t, "Registerer", function () {
        return b.Registerer;
      });
      s(
      /*! ./session-bye-options.js */
      "./node_modules/sip.js/lib/api/session-bye-options.js"), s(
      /*! ./session-delegate.js */
      "./node_modules/sip.js/lib/api/session-delegate.js"), s(
      /*! ./session-description-handler-factory.js */
      "./node_modules/sip.js/lib/api/session-description-handler-factory.js"), s(
      /*! ./session-description-handler.js */
      "./node_modules/sip.js/lib/api/session-description-handler.js"), s(
      /*! ./session-info-options.js */
      "./node_modules/sip.js/lib/api/session-info-options.js"), s(
      /*! ./session-invite-options.js */
      "./node_modules/sip.js/lib/api/session-invite-options.js"), s(
      /*! ./session-message-options.js */
      "./node_modules/sip.js/lib/api/session-message-options.js"), s(
      /*! ./session-options.js */
      "./node_modules/sip.js/lib/api/session-options.js"), s(
      /*! ./session-refer-options.js */
      "./node_modules/sip.js/lib/api/session-refer-options.js");
      var S = s(
      /*! ./session-state.js */
      "./node_modules/sip.js/lib/api/session-state.js");
      s.d(t, "SessionState", function () {
        return S.SessionState;
      });
      var j = s(
      /*! ./session.js */
      "./node_modules/sip.js/lib/api/session.js");
      s.d(t, "Session", function () {
        return j.Session;
      });
      s(
      /*! ./subscriber-options.js */
      "./node_modules/sip.js/lib/api/subscriber-options.js"), s(
      /*! ./subscriber-subscribe-options.js */
      "./node_modules/sip.js/lib/api/subscriber-subscribe-options.js");
      var w = s(
      /*! ./subscriber.js */
      "./node_modules/sip.js/lib/api/subscriber.js");
      s.d(t, "Subscriber", function () {
        return w.Subscriber;
      });
      s(
      /*! ./subscription-delegate.js */
      "./node_modules/sip.js/lib/api/subscription-delegate.js"), s(
      /*! ./subscription-options.js */
      "./node_modules/sip.js/lib/api/subscription-options.js");
      var T = s(
      /*! ./subscription-state.js */
      "./node_modules/sip.js/lib/api/subscription-state.js");
      s.d(t, "SubscriptionState", function () {
        return T.SubscriptionState;
      });
      s(
      /*! ./subscription-subscribe-options.js */
      "./node_modules/sip.js/lib/api/subscription-subscribe-options.js"), s(
      /*! ./subscription-unsubscribe-options.js */
      "./node_modules/sip.js/lib/api/subscription-unsubscribe-options.js");
      var y = s(
      /*! ./subscription.js */
      "./node_modules/sip.js/lib/api/subscription.js");
      s.d(t, "Subscription", function () {
        return y.Subscription;
      });
      s(
      /*! ./transport.js */
      "./node_modules/sip.js/lib/api/transport.js");

      var _ = s(
      /*! ./transport-state.js */
      "./node_modules/sip.js/lib/api/transport-state.js");

      s.d(t, "TransportState", function () {
        return _.TransportState;
      });
      s(
      /*! ./user-agent-delegate.js */
      "./node_modules/sip.js/lib/api/user-agent-delegate.js");
      var R = s(
      /*! ./user-agent-options.js */
      "./node_modules/sip.js/lib/api/user-agent-options.js");
      s.d(t, "SIPExtension", function () {
        return R.SIPExtension;
      }), s.d(t, "UserAgentRegisteredOptionTags", function () {
        return R.UserAgentRegisteredOptionTags;
      });
      var C = s(
      /*! ./user-agent-state.js */
      "./node_modules/sip.js/lib/api/user-agent-state.js");
      s.d(t, "UserAgentState", function () {
        return C.UserAgentState;
      });
      var E = s(
      /*! ./user-agent.js */
      "./node_modules/sip.js/lib/api/user-agent.js");
      s.d(t, "UserAgent", function () {
        return E.UserAgent;
      });
    },
    "./node_modules/sip.js/lib/api/info.js":
    /*!*********************************************!*\
      !*** ./node_modules/sip.js/lib/api/info.js ***!
      \*********************************************/

    /*! exports provided: Info */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Info", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.incomingInfoRequest = e;
        }

        get request() {
          return this.incomingInfoRequest.message;
        }

        accept(e) {
          return this.incomingInfoRequest.accept(e), Promise.resolve();
        }

        reject(e) {
          return this.incomingInfoRequest.reject(e), Promise.resolve();
        }

      }
    },
    "./node_modules/sip.js/lib/api/invitation-accept-options.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/invitation-accept-options.js ***!
      \******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/invitation-progress-options.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/invitation-progress-options.js ***!
      \********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/invitation-reject-options.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/invitation-reject-options.js ***!
      \******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/invitation.js":
    /*!***************************************************!*\
      !*** ./node_modules/sip.js/lib/api/invitation.js ***!
      \***************************************************/

    /*! exports provided: Invitation */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Invitation", function () {
        return f;
      });
      var i = s(
      /*! ../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ../core/messages/body.js */
      "./node_modules/sip.js/lib/core/messages/body.js"),
          n = s(
      /*! ../core/session/session.js */
      "./node_modules/sip.js/lib/core/session/session.js"),
          o = s(
      /*! ../core/timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          a = s(
      /*! ../core/exceptions/transaction-state-error.js */
      "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js"),
          c = s(
      /*! ../core/messages/utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js"),
          d = s(
      /*! ./cancel.js */
      "./node_modules/sip.js/lib/api/cancel.js"),
          l = s(
      /*! ./exceptions/content-type-unsupported.js */
      "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js"),
          u = s(
      /*! ./exceptions/session-description-handler.js */
      "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js"),
          h = s(
      /*! ./exceptions/session-terminated.js */
      "./node_modules/sip.js/lib/api/exceptions/session-terminated.js"),
          g = s(
      /*! ./session.js */
      "./node_modules/sip.js/lib/api/session.js"),
          p = s(
      /*! ./session-state.js */
      "./node_modules/sip.js/lib/api/session-state.js"),
          m = s(
      /*! ./user-agent-options.js */
      "./node_modules/sip.js/lib/api/user-agent-options.js");

      class f extends g.Session {
        constructor(e, t) {
          super(e), this.incomingInviteRequest = t, this.disposed = !1, this.expiresTimer = void 0, this.isCanceled = !1, this.rel100 = "none", this.rseq = Math.floor(1e4 * Math.random()), this.userNoAnswerTimer = void 0, this.waitingForPrack = !1, this.logger = e.getLogger("sip.Invitation");
          const s = this.incomingInviteRequest.message,
                r = s.getHeader("require");
          r && r.toLowerCase().includes("100rel") && (this.rel100 = "required");
          const n = s.getHeader("supported");
          if (n && n.toLowerCase().includes("100rel") && (this.rel100 = "supported"), s.toTag = t.toTag, "string" != typeof s.toTag) throw new TypeError("toTag should have been a string.");

          if (this.userNoAnswerTimer = setTimeout(() => {
            t.reject({
              statusCode: 480
            }), this.stateTransition(p.SessionState.Terminated);
          }, this.userAgent.configuration.noAnswerTimeout ? 1e3 * this.userAgent.configuration.noAnswerTimeout : 6e4), s.hasHeader("expires")) {
            const e = 1e3 * Number(s.getHeader("expires") || 0);
            this.expiresTimer = setTimeout(() => {
              this.state === p.SessionState.Initial && (t.reject({
                statusCode: 487
              }), this.stateTransition(p.SessionState.Terminated));
            }, e);
          }

          const o = this.request.getHeader("P-Asserted-Identity");
          o && (this._assertedIdentity = i.Grammar.nameAddrHeaderParse(o)), this._contact = this.userAgent.contact.toString();
          const a = s.parseHeader("Content-Disposition");
          a && "render" === a.type && (this._renderbody = s.body, this._rendertype = s.getHeader("Content-Type")), this._id = s.callId + s.fromTag, this.userAgent._sessions[this._id] = this;
        }

        dispose() {
          if (this.disposed) return Promise.resolve();

          switch (this.disposed = !0, this.expiresTimer && (clearTimeout(this.expiresTimer), this.expiresTimer = void 0), this.userNoAnswerTimer && (clearTimeout(this.userNoAnswerTimer), this.userNoAnswerTimer = void 0), this.prackNeverArrived(), this.state) {
            case p.SessionState.Initial:
            case p.SessionState.Establishing:
              return this.reject().then(() => super.dispose());

            case p.SessionState.Established:
            case p.SessionState.Terminating:
            case p.SessionState.Terminated:
              return super.dispose();

            default:
              throw new Error("Unknown state.");
          }
        }

        get autoSendAnInitialProvisionalResponse() {
          return "required" !== this.rel100 && this.userAgent.configuration.sendInitialProvisionalResponse;
        }

        get body() {
          return this.incomingInviteRequest.message.body;
        }

        get localIdentity() {
          return this.request.to;
        }

        get remoteIdentity() {
          return this.request.from;
        }

        get request() {
          return this.incomingInviteRequest.message;
        }

        accept(e = {}) {
          if (this.logger.log("Invitation.accept"), this.state !== p.SessionState.Initial) {
            const e = new Error(`Invalid session state ${this.state}`);
            return this.logger.error(e.message), Promise.reject(e);
          }

          return e.sessionDescriptionHandlerModifiers && (this.sessionDescriptionHandlerModifiers = e.sessionDescriptionHandlerModifiers), e.sessionDescriptionHandlerOptions && (this.sessionDescriptionHandlerOptions = e.sessionDescriptionHandlerOptions), this.stateTransition(p.SessionState.Establishing), this.sendAccept(e).then(({
            message: e,
            session: t
          }) => {
            t.delegate = {
              onAck: e => this.onAckRequest(e),
              onAckTimeout: () => this.onAckTimeout(),
              onBye: e => this.onByeRequest(e),
              onInfo: e => this.onInfoRequest(e),
              onInvite: e => this.onInviteRequest(e),
              onMessage: e => this.onMessageRequest(e),
              onNotify: e => this.onNotifyRequest(e),
              onPrack: e => this.onPrackRequest(e),
              onRefer: e => this.onReferRequest(e)
            }, this._dialog = t, this.stateTransition(p.SessionState.Established), this._replacee && this._replacee._bye();
          }).catch(e => this.handleResponseError(e));
        }

        progress(e = {}) {
          if (this.logger.log("Invitation.progress"), this.state !== p.SessionState.Initial) {
            const e = new Error(`Invalid session state ${this.state}`);
            return this.logger.error(e.message), Promise.reject(e);
          }

          const t = e.statusCode || 180;
          if (t < 100 || t > 199) throw new TypeError("Invalid statusCode: " + t);
          return e.sessionDescriptionHandlerModifiers && (this.sessionDescriptionHandlerModifiers = e.sessionDescriptionHandlerModifiers), e.sessionDescriptionHandlerOptions && (this.sessionDescriptionHandlerOptions = e.sessionDescriptionHandlerOptions), this.waitingForPrack ? (this.logger.warn("Unexpected call for progress while waiting for prack, ignoring"), Promise.resolve()) : 100 === e.statusCode ? this.sendProgressTrying().then(() => {}).catch(e => this.handleResponseError(e)) : "required" === this.rel100 || "supported" === this.rel100 && e.rel100 || "supported" === this.rel100 && this.userAgent.configuration.sipExtension100rel === m.SIPExtension.Required ? this.sendProgressReliableWaitForPrack(e).then(() => {}).catch(e => this.handleResponseError(e)) : this.sendProgress(e).then(() => {}).catch(e => this.handleResponseError(e));
        }

        reject(e = {}) {
          if (this.logger.log("Invitation.reject"), this.state !== p.SessionState.Initial && this.state !== p.SessionState.Establishing) {
            const e = new Error(`Invalid session state ${this.state}`);
            return this.logger.error(e.message), Promise.reject(e);
          }

          const t = e.statusCode || 480,
                s = e.reasonPhrase ? e.reasonPhrase : Object(c.getReasonPhrase)(t),
                i = e.extraHeaders || [];
          if (t < 300 || t > 699) throw new TypeError("Invalid statusCode: " + t);
          const n = e.body ? Object(r.fromBodyLegacy)(e.body) : void 0;
          return t < 400 ? this.incomingInviteRequest.redirect([], {
            statusCode: t,
            reasonPhrase: s,
            extraHeaders: i,
            body: n
          }) : this.incomingInviteRequest.reject({
            statusCode: t,
            reasonPhrase: s,
            extraHeaders: i,
            body: n
          }), this.stateTransition(p.SessionState.Terminated), Promise.resolve();
        }

        _onCancel(e) {
          if (this.logger.log("Invitation._onCancel"), this.state === p.SessionState.Initial || this.state === p.SessionState.Establishing) {
            if (this.delegate && this.delegate.onCancel) {
              const t = new d.Cancel(e);
              this.delegate.onCancel(t);
            }

            this.isCanceled = !0, this.incomingInviteRequest.reject({
              statusCode: 487
            }), this.stateTransition(p.SessionState.Terminated);
          } else this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);
        }

        handlePrackOfferAnswer(e) {
          if (!this.dialog) throw new Error("Dialog undefined.");
          const t = Object(r.getBody)(e.message);
          if (!t || "session" !== t.contentDisposition) return Promise.resolve(void 0);
          const s = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
          };

          switch (this.dialog.signalingState) {
            case n.SignalingState.Initial:
              throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);

            case n.SignalingState.Stable:
              return this.setAnswer(t, s).then(() => void 0);

            case n.SignalingState.HaveLocalOffer:
              throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);

            case n.SignalingState.HaveRemoteOffer:
              return this.setOfferAndGetAnswer(t, s);

            case n.SignalingState.Closed:
            default:
              throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
          }
        }

        handleResponseError(e) {
          let t = 480;
          if (e instanceof Error ? this.logger.error(e.message) : this.logger.error(e), e instanceof l.ContentTypeUnsupportedError ? (this.logger.error("A session description handler occurred while sending response (content type unsupported"), t = 415) : e instanceof u.SessionDescriptionHandlerError ? this.logger.error("A session description handler occurred while sending response") : e instanceof h.SessionTerminatedError ? this.logger.error("Session ended before response could be formulated and sent (while waiting for PRACK)") : e instanceof a.TransactionStateError && this.logger.error("Session changed state before response could be formulated and sent"), this.state === p.SessionState.Initial || this.state === p.SessionState.Establishing) try {
            this.incomingInviteRequest.reject({
              statusCode: t
            }), this.stateTransition(p.SessionState.Terminated);
          } catch (e) {
            throw this.logger.error("An error occurred attempting to reject the request while handling another error"), e;
          }
          if (!this.isCanceled) throw e;
          this.logger.warn("An error occurred while attempting to formulate and send a response to an incoming INVITE. However a CANCEL was received and processed while doing so which can (and often does) result in errors occurring as the session terminates in the meantime. Said error is being ignored.");
        }

        onAckTimeout() {
          if (this.logger.log("Invitation.onAckTimeout"), !this.dialog) throw new Error("Dialog undefined.");
          this.logger.log("No ACK received for an extended period of time, terminating session"), this.dialog.bye(), this.stateTransition(p.SessionState.Terminated);
        }

        sendAccept(e = {}) {
          const t = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
          },
                s = e.extraHeaders || [];
          return this.waitingForPrack ? this.waitForArrivalOfPrack().then(() => clearTimeout(this.userNoAnswerTimer)).then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, t)).then(e => this.incomingInviteRequest.accept({
            statusCode: 200,
            body: e,
            extraHeaders: s
          })) : (clearTimeout(this.userNoAnswerTimer), this.generateResponseOfferAnswer(this.incomingInviteRequest, t).then(e => this.incomingInviteRequest.accept({
            statusCode: 200,
            body: e,
            extraHeaders: s
          })));
        }

        sendProgress(e = {}) {
          const t = e.statusCode || 180,
                s = e.reasonPhrase,
                i = (e.extraHeaders || []).slice(),
                n = e.body ? Object(r.fromBodyLegacy)(e.body) : void 0;
          if (183 === t && !n) return this.sendProgressWithSDP(e);

          try {
            const e = this.incomingInviteRequest.progress({
              statusCode: t,
              reasonPhrase: s,
              extraHeaders: i,
              body: n
            });
            return this._dialog = e.session, Promise.resolve(e);
          } catch (e) {
            return Promise.reject(e);
          }
        }

        sendProgressWithSDP(e = {}) {
          const t = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
          },
                s = e.statusCode || 183,
                i = e.reasonPhrase,
                r = (e.extraHeaders || []).slice();
          return this.generateResponseOfferAnswer(this.incomingInviteRequest, t).then(e => this.incomingInviteRequest.progress({
            statusCode: s,
            reasonPhrase: i,
            extraHeaders: r,
            body: e
          })).then(e => (this._dialog = e.session, e));
        }

        sendProgressReliable(e = {}) {
          return e.extraHeaders = (e.extraHeaders || []).slice(), e.extraHeaders.push("Require: 100rel"), e.extraHeaders.push("RSeq: " + Math.floor(1e4 * Math.random())), this.sendProgressWithSDP(e);
        }

        sendProgressReliableWaitForPrack(e = {}) {
          const t = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
          },
                s = e.statusCode || 183,
                i = e.reasonPhrase,
                r = (e.extraHeaders || []).slice();
          let n;
          return r.push("Require: 100rel"), r.push("RSeq: " + this.rseq++), new Promise((e, a) => {
            this.waitingForPrack = !0, this.generateResponseOfferAnswer(this.incomingInviteRequest, t).then(e => (n = e, this.incomingInviteRequest.progress({
              statusCode: s,
              reasonPhrase: i,
              extraHeaders: r,
              body: n
            }))).then(t => {
              let c, d;
              this._dialog = t.session, t.session.delegate = {
                onPrack: s => {
                  c = s, clearTimeout(l), clearTimeout(p), this.waitingForPrack && (this.waitingForPrack = !1, this.handlePrackOfferAnswer(c).then(s => {
                    try {
                      d = c.accept({
                        statusCode: 200,
                        body: s
                      }), this.prackArrived(), e({
                        prackRequest: c,
                        prackResponse: d,
                        progressResponse: t
                      });
                    } catch (e) {
                      a(e);
                    }
                  }).catch(e => a(e)));
                }
              };

              const l = setTimeout(() => {
                this.waitingForPrack && (this.waitingForPrack = !1, this.logger.warn("No PRACK received, rejecting INVITE."), clearTimeout(p), this.reject({
                  statusCode: 504
                }).then(() => a(new h.SessionTerminatedError())).catch(e => a(e)));
              }, 64 * o.Timers.T1),
                    u = () => {
                try {
                  this.incomingInviteRequest.progress({
                    statusCode: s,
                    reasonPhrase: i,
                    extraHeaders: r,
                    body: n
                  });
                } catch (e) {
                  return this.waitingForPrack = !1, void a(e);
                }

                p = setTimeout(u, g *= 2);
              };

              let g = o.Timers.T1,
                  p = setTimeout(u, g);
            }).catch(e => {
              this.waitingForPrack = !1, a(e);
            });
          });
        }

        sendProgressTrying() {
          try {
            const e = this.incomingInviteRequest.trying();
            return Promise.resolve(e);
          } catch (e) {
            return Promise.reject(e);
          }
        }

        waitForArrivalOfPrack() {
          if (this.waitingForPrackPromise) throw new Error("Already waiting for PRACK");
          return this.waitingForPrackPromise = new Promise((e, t) => {
            this.waitingForPrackResolve = e, this.waitingForPrackReject = t;
          }), this.waitingForPrackPromise;
        }

        prackArrived() {
          this.waitingForPrackResolve && this.waitingForPrackResolve(), this.waitingForPrackPromise = void 0, this.waitingForPrackResolve = void 0, this.waitingForPrackReject = void 0;
        }

        prackNeverArrived() {
          this.waitingForPrackReject && this.waitingForPrackReject(new h.SessionTerminatedError()), this.waitingForPrackPromise = void 0, this.waitingForPrackResolve = void 0, this.waitingForPrackReject = void 0;
        }

      }
    },
    "./node_modules/sip.js/lib/api/inviter-cancel-options.js":
    /*!***************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/inviter-cancel-options.js ***!
      \***************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/inviter-invite-options.js":
    /*!***************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/inviter-invite-options.js ***!
      \***************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/inviter-options.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/inviter-options.js ***!
      \********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/inviter.js":
    /*!************************************************!*\
      !*** ./node_modules/sip.js/lib/api/inviter.js ***!
      \************************************************/

    /*! exports provided: Inviter */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Inviter", function () {
        return l;
      });
      var i = s(
      /*! ../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ../core/messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          n = s(
      /*! ../core/session/session.js */
      "./node_modules/sip.js/lib/core/session/session.js"),
          o = s(
      /*! ../core/messages/utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js"),
          a = s(
      /*! ./session.js */
      "./node_modules/sip.js/lib/api/session.js"),
          c = s(
      /*! ./session-state.js */
      "./node_modules/sip.js/lib/api/session-state.js"),
          d = s(
      /*! ./user-agent-options.js */
      "./node_modules/sip.js/lib/api/user-agent-options.js");

      class l extends a.Session {
        constructor(e, t, s = {}) {
          super(e, s), this.disposed = !1, this.earlyMedia = !1, this.earlyMediaSessionDescriptionHandlers = new Map(), this.isCanceled = !1, this.inviteWithoutSdp = !1, this.logger = e.getLogger("sip.Inviter"), this.earlyMedia = void 0 !== s.earlyMedia ? s.earlyMedia : this.earlyMedia, this.fromTag = Object(o.newTag)(), this.inviteWithoutSdp = void 0 !== s.inviteWithoutSdp ? s.inviteWithoutSdp : this.inviteWithoutSdp;
          const n = Object.assign({}, s);
          n.params = Object.assign({}, s.params);
          const a = s.anonymous || !1,
                c = e.contact.toString({
            anonymous: a,
            outbound: a ? !e.contact.tempGruu : !e.contact.pubGruu
          });
          a && e.configuration.uri && (n.params.fromDisplayName = "Anonymous", n.params.fromUri = "sip:anonymous@anonymous.invalid");
          let l = e.userAgentCore.configuration.aor;
          if (n.params.fromUri && (l = "string" == typeof n.params.fromUri ? i.Grammar.URIParse(n.params.fromUri) : n.params.fromUri), !l) throw new TypeError("Invalid from URI: " + n.params.fromUri);
          let u = t;
          if (n.params.toUri && (u = "string" == typeof n.params.toUri ? i.Grammar.URIParse(n.params.toUri) : n.params.toUri), !u) throw new TypeError("Invalid to URI: " + n.params.toUri);
          const h = Object.assign({}, n.params);
          h.fromTag = this.fromTag;
          const g = (n.extraHeaders || []).slice();
          a && e.configuration.uri && (g.push("P-Preferred-Identity: " + e.configuration.uri.toString()), g.push("Privacy: id")), g.push("Contact: " + c), g.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString()), e.configuration.sipExtension100rel === d.SIPExtension.Required && g.push("Require: 100rel"), e.configuration.sipExtensionReplaces === d.SIPExtension.Required && g.push("Require: replaces"), n.extraHeaders = g;
          this.outgoingRequestMessage = e.userAgentCore.makeOutgoingRequestMessage(r.C.INVITE, t, l, u, h, g, void 0), this._contact = c, this._referralInviterOptions = n, this._renderbody = s.renderbody, this._rendertype = s.rendertype, s.sessionDescriptionHandlerModifiers && (this.sessionDescriptionHandlerModifiers = s.sessionDescriptionHandlerModifiers), s.sessionDescriptionHandlerOptions && (this.sessionDescriptionHandlerOptions = s.sessionDescriptionHandlerOptions), s.sessionDescriptionHandlerModifiersReInvite && (this.sessionDescriptionHandlerModifiersReInvite = s.sessionDescriptionHandlerModifiersReInvite), s.sessionDescriptionHandlerOptionsReInvite && (this.sessionDescriptionHandlerOptionsReInvite = s.sessionDescriptionHandlerOptionsReInvite), this._id = this.outgoingRequestMessage.callId + this.fromTag, this.userAgent._sessions[this._id] = this;
        }

        dispose() {
          if (this.disposed) return Promise.resolve();

          switch (this.disposed = !0, this.disposeEarlyMedia(), this.state) {
            case c.SessionState.Initial:
            case c.SessionState.Establishing:
              return this.cancel().then(() => super.dispose());

            case c.SessionState.Established:
            case c.SessionState.Terminating:
            case c.SessionState.Terminated:
              return super.dispose();

            default:
              throw new Error("Unknown state.");
          }
        }

        get body() {
          return this.outgoingRequestMessage.body;
        }

        get localIdentity() {
          return this.outgoingRequestMessage.from;
        }

        get remoteIdentity() {
          return this.outgoingRequestMessage.to;
        }

        get request() {
          return this.outgoingRequestMessage;
        }

        cancel(e = {}) {
          if (this.logger.log("Inviter.cancel"), this.state !== c.SessionState.Initial && this.state !== c.SessionState.Establishing) {
            const e = new Error(`Invalid session state ${this.state}`);
            return this.logger.error(e.message), Promise.reject(e);
          }

          if (this.isCanceled = !0, this.stateTransition(c.SessionState.Terminating), this.outgoingInviteRequest) {
            let t;
            e.statusCode && e.reasonPhrase && (t = function (e, t) {
              if (e && e < 200 || e > 699) throw new TypeError("Invalid statusCode: " + e);
              if (e) return "SIP;cause=" + e + ';text="' + (Object(o.getReasonPhrase)(e) || t) + '"';
            }(e.statusCode, e.reasonPhrase)), this.outgoingInviteRequest.cancel(t, e);
          } else this.logger.warn("Canceled session before INVITE was sent"), this.stateTransition(c.SessionState.Terminated);

          return Promise.resolve();
        }

        invite(e = {}) {
          if (this.logger.log("Inviter.invite"), this.state !== c.SessionState.Initial) return super.invite(e);
          if (e.sessionDescriptionHandlerModifiers && (this.sessionDescriptionHandlerModifiers = e.sessionDescriptionHandlerModifiers), e.sessionDescriptionHandlerOptions && (this.sessionDescriptionHandlerOptions = e.sessionDescriptionHandlerOptions), e.withoutSdp || this.inviteWithoutSdp) return this._renderbody && this._rendertype && (this.outgoingRequestMessage.body = {
            contentType: this._rendertype,
            body: this._renderbody
          }), this.stateTransition(c.SessionState.Establishing), Promise.resolve(this.sendInvite(e));
          const t = {
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
          };
          return this.getOffer(t).then(t => (this.outgoingRequestMessage.body = {
            body: t.content,
            contentType: t.contentType
          }, this.stateTransition(c.SessionState.Establishing), this.sendInvite(e))).catch(e => {
            throw this.logger.log(e.message), this.state !== c.SessionState.Terminated && this.stateTransition(c.SessionState.Terminated), e;
          });
        }

        sendInvite(e = {}) {
          return this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {
            onAccept: t => this.dialog ? (this.logger.log("Additional confirmed dialog, sending ACK and BYE"), void this.ackAndBye(t)) : this.isCanceled ? (this.logger.log("Canceled session accepted, sending ACK and BYE"), this.ackAndBye(t), void this.stateTransition(c.SessionState.Terminated)) : (this.notifyReferer(t), void this.onAccept(t).then(() => {
              this.disposeEarlyMedia();
            }).catch(() => {
              this.disposeEarlyMedia();
            }).then(() => {
              e.requestDelegate && e.requestDelegate.onAccept && e.requestDelegate.onAccept(t);
            })),
            onProgress: t => {
              this.isCanceled || (this.notifyReferer(t), this.onProgress(t).catch(() => {
                this.disposeEarlyMedia();
              }).then(() => {
                e.requestDelegate && e.requestDelegate.onProgress && e.requestDelegate.onProgress(t);
              }));
            },
            onRedirect: t => {
              this.notifyReferer(t), this.onRedirect(t), e.requestDelegate && e.requestDelegate.onRedirect && e.requestDelegate.onRedirect(t);
            },
            onReject: t => {
              this.notifyReferer(t), this.onReject(t), e.requestDelegate && e.requestDelegate.onReject && e.requestDelegate.onReject(t);
            },
            onTrying: t => {
              this.notifyReferer(t), this.onTrying(t), e.requestDelegate && e.requestDelegate.onTrying && e.requestDelegate.onTrying(t);
            }
          }), this.outgoingInviteRequest;
        }

        disposeEarlyMedia() {
          this.earlyMediaSessionDescriptionHandlers.forEach(e => {
            e.close();
          }), this.earlyMediaSessionDescriptionHandlers.clear();
        }

        notifyReferer(e) {
          if (!this._referred) return;
          if (!(this._referred instanceof a.Session)) throw new Error("Referred session not instance of session");
          if (!this._referred.dialog) return;
          if (!e.message.statusCode) throw new Error("Status code undefined.");
          if (!e.message.reasonPhrase) throw new Error("Reason phrase undefined.");
          const t = `SIP/2.0 ${e.message.statusCode} ${e.message.reasonPhrase}`.trim();
          this._referred.dialog.notify(void 0, {
            extraHeaders: ["Event: refer", "Subscription-State: terminated"],
            body: {
              contentDisposition: "render",
              contentType: "message/sipfrag",
              content: t
            }
          }).delegate = {
            onReject: () => {
              this._referred = void 0;
            }
          };
        }

        onAccept(e) {
          if (this.logger.log("Inviter.onAccept"), this.state !== c.SessionState.Establishing) return this.logger.error(`Accept received while in state ${this.state}, dropping response`), Promise.reject(new Error(`Invalid session state ${this.state}`));
          const t = e.message,
                s = e.session;

          switch (t.hasHeader("P-Asserted-Identity") && (this._assertedIdentity = i.Grammar.nameAddrHeaderParse(t.getHeader("P-Asserted-Identity"))), s.delegate = {
            onAck: e => this.onAckRequest(e),
            onBye: e => this.onByeRequest(e),
            onInfo: e => this.onInfoRequest(e),
            onInvite: e => this.onInviteRequest(e),
            onMessage: e => this.onMessageRequest(e),
            onNotify: e => this.onNotifyRequest(e),
            onPrack: e => this.onPrackRequest(e),
            onRefer: e => this.onReferRequest(e)
          }, this._dialog = s, s.signalingState) {
            case n.SignalingState.Initial:
            case n.SignalingState.HaveLocalOffer:
              return this.logger.error("Received 2xx response to INVITE without a session description"), this.ackAndBye(e, 400, "Missing session description"), this.stateTransition(c.SessionState.Terminated), Promise.reject(new Error("Bad Media Description"));

            case n.SignalingState.HaveRemoteOffer:
              {
                if (!this._dialog.offer) throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);
                const t = {
                  sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
                  sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
                };
                return this.setOfferAndGetAnswer(this._dialog.offer, t).then(t => {
                  e.ack({
                    body: t
                  }), this.stateTransition(c.SessionState.Established);
                }).catch(t => {
                  throw this.ackAndBye(e, 488, "Invalid session description"), this.stateTransition(c.SessionState.Terminated), t;
                });
              }

            case n.SignalingState.Stable:
              {
                if (this.earlyMediaSessionDescriptionHandlers.size > 0) {
                  const t = this.earlyMediaSessionDescriptionHandlers.get(s.id);
                  if (!t) throw new Error("Session description handler undefined.");
                  return this.setSessionDescriptionHandler(t), this.earlyMediaSessionDescriptionHandlers.delete(s.id), e.ack(), this.stateTransition(c.SessionState.Established), Promise.resolve();
                }

                if (this.earlyMediaDialog) {
                  if (this.earlyMediaDialog !== s) {
                    if (this.earlyMedia) {
                      const e = "You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly the end point which accepted the INVITE (confirmed dialog) does not match the end point with which early media has been setup (early dialog) and thus this session is unable to proceed. In accordance with the SIP specifications, the SIP servers your end point is connected to determine if an INVITE forks and the forking behavior of those servers cannot be controlled by this library. If you wish to use early media with this library you must configure those servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow this library to function with any INVITE requests which do fork.";
                      this.logger.error(e);
                    }

                    const t = new Error("Early media dialog does not equal confirmed dialog, terminating session");
                    return this.logger.error(t.message), this.ackAndBye(e, 488, "Not Acceptable Here"), this.stateTransition(c.SessionState.Terminated), Promise.reject(t);
                  }

                  return e.ack(), this.stateTransition(c.SessionState.Established), Promise.resolve();
                }

                const t = s.answer;
                if (!t) throw new Error("Answer is undefined.");
                const i = {
                  sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
                  sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
                };
                return this.setAnswer(t, i).then(() => {
                  let t;
                  this._renderbody && this._rendertype && (t = {
                    body: {
                      contentDisposition: "render",
                      contentType: this._rendertype,
                      content: this._renderbody
                    }
                  }), e.ack(t), this.stateTransition(c.SessionState.Established);
                }).catch(t => {
                  throw this.logger.error(t.message), this.ackAndBye(e, 488, "Not Acceptable Here"), this.stateTransition(c.SessionState.Terminated), t;
                });
              }

            case n.SignalingState.Closed:
              return Promise.reject(new Error("Terminated."));

            default:
              throw new Error("Unknown session signaling state.");
          }
        }

        onProgress(e) {
          var t;
          if (this.logger.log("Inviter.onProgress"), this.state !== c.SessionState.Establishing) return this.logger.error(`Progress received while in state ${this.state}, dropping response`), Promise.reject(new Error(`Invalid session state ${this.state}`));
          if (!this.outgoingInviteRequest) throw new Error("Outgoing INVITE request undefined.");
          const s = e.message,
                r = e.session;
          s.hasHeader("P-Asserted-Identity") && (this._assertedIdentity = i.Grammar.nameAddrHeaderParse(s.getHeader("P-Asserted-Identity")));
          const o = s.getHeader("require"),
                a = s.getHeader("rseq"),
                d = !!(o && o.includes("100rel") && a ? Number(a) : void 0),
                l = [];

          switch (d && l.push("RAck: " + s.getHeader("rseq") + " " + s.getHeader("cseq")), r.signalingState) {
            case n.SignalingState.Initial:
              return d && (this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer."), e.prack({
                extraHeaders: l
              })), Promise.resolve();

            case n.SignalingState.HaveLocalOffer:
              return d && e.prack({
                extraHeaders: l
              }), Promise.resolve();

            case n.SignalingState.HaveRemoteOffer:
              if (!d) return this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response."), Promise.resolve();
              {
                const i = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});
                return (null === (t = this.delegate) || void 0 === t ? void 0 : t.onSessionDescriptionHandler) && this.delegate.onSessionDescriptionHandler(i, !0), this.earlyMediaSessionDescriptionHandlers.set(r.id, i), i.setDescription(s.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(() => i.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)).then(t => {
                  const s = {
                    contentDisposition: "session",
                    contentType: t.contentType,
                    content: t.body
                  };
                  e.prack({
                    extraHeaders: l,
                    body: s
                  });
                }).catch(e => {
                  throw this.stateTransition(c.SessionState.Terminated), e;
                });
              }

            case n.SignalingState.Stable:
              if (d && e.prack({
                extraHeaders: l
              }), this.earlyMedia && !this.earlyMediaDialog) {
                this.earlyMediaDialog = r;
                const e = r.answer;
                if (!e) throw new Error("Answer is undefined.");
                const t = {
                  sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
                  sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
                };
                return this.setAnswer(e, t).catch(e => {
                  throw this.stateTransition(c.SessionState.Terminated), e;
                });
              }

              return Promise.resolve();

            case n.SignalingState.Closed:
              return Promise.reject(new Error("Terminated."));

            default:
              throw new Error("Unknown session signaling state.");
          }
        }

        onRedirect(e) {
          this.logger.log("Inviter.onRedirect"), this.state === c.SessionState.Establishing || this.state === c.SessionState.Terminating ? this.stateTransition(c.SessionState.Terminated) : this.logger.error(`Redirect received while in state ${this.state}, dropping response`);
        }

        onReject(e) {
          this.logger.log("Inviter.onReject"), this.state === c.SessionState.Establishing || this.state === c.SessionState.Terminating ? this.stateTransition(c.SessionState.Terminated) : this.logger.error(`Reject received while in state ${this.state}, dropping response`);
        }

        onTrying(e) {
          this.logger.log("Inviter.onTrying"), this.state === c.SessionState.Establishing || this.logger.error(`Trying received while in state ${this.state}, dropping response`);
        }

      }
    },
    "./node_modules/sip.js/lib/api/message.js":
    /*!************************************************!*\
      !*** ./node_modules/sip.js/lib/api/message.js ***!
      \************************************************/

    /*! exports provided: Message */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Message", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.incomingMessageRequest = e;
        }

        get request() {
          return this.incomingMessageRequest.message;
        }

        accept(e) {
          return this.incomingMessageRequest.accept(e), Promise.resolve();
        }

        reject(e) {
          return this.incomingMessageRequest.reject(e), Promise.resolve();
        }

      }
    },
    "./node_modules/sip.js/lib/api/messager-message-options.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/messager-message-options.js ***!
      \*****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/messager-options.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/messager-options.js ***!
      \*********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/messager.js":
    /*!*************************************************!*\
      !*** ./node_modules/sip.js/lib/api/messager.js ***!
      \*************************************************/

    /*! exports provided: Messager */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Messager", function () {
        return n;
      });
      var i = s(
      /*! ../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ../core/messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js");

      class n {
        constructor(e, t, s, n = "text/plain", o = {}) {
          this.logger = e.getLogger("sip.Messager"), o.params = o.params || {};
          let a = e.userAgentCore.configuration.aor;
          if (o.params.fromUri && (a = "string" == typeof o.params.fromUri ? i.Grammar.URIParse(o.params.fromUri) : o.params.fromUri), !a) throw new TypeError("Invalid from URI: " + o.params.fromUri);
          let c = t;
          if (o.params.toUri && (c = "string" == typeof o.params.toUri ? i.Grammar.URIParse(o.params.toUri) : o.params.toUri), !c) throw new TypeError("Invalid to URI: " + o.params.toUri);
          const d = o.params ? Object.assign({}, o.params) : {},
                l = (o.extraHeaders || []).slice(),
                u = {
            contentDisposition: "render",
            contentType: n,
            content: s
          };
          this.request = e.userAgentCore.makeOutgoingRequestMessage(r.C.MESSAGE, t, a, c, d, l, u), this.userAgent = e;
        }

        message(e = {}) {
          return this.userAgent.userAgentCore.request(this.request, e.requestDelegate), Promise.resolve();
        }

      }
    },
    "./node_modules/sip.js/lib/api/notification.js":
    /*!*****************************************************!*\
      !*** ./node_modules/sip.js/lib/api/notification.js ***!
      \*****************************************************/

    /*! exports provided: Notification */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Notification", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.incomingNotifyRequest = e;
        }

        get request() {
          return this.incomingNotifyRequest.message;
        }

        accept(e) {
          return this.incomingNotifyRequest.accept(e), Promise.resolve();
        }

        reject(e) {
          return this.incomingNotifyRequest.reject(e), Promise.resolve();
        }

      }
    },
    "./node_modules/sip.js/lib/api/publisher-options.js":
    /*!**********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/publisher-options.js ***!
      \**********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/publisher-publish-options.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/publisher-publish-options.js ***!
      \******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/publisher-state.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/publisher-state.js ***!
      \********************************************************/

    /*! exports provided: PublisherState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "PublisherState", function () {
        return i;
      }), function (e) {
        e.Initial = "Initial", e.Published = "Published", e.Unpublished = "Unpublished", e.Terminated = "Terminated";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/api/publisher-unpublish-options.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/publisher-unpublish-options.js ***!
      \********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/publisher.js":
    /*!**************************************************!*\
      !*** ./node_modules/sip.js/lib/api/publisher.js ***!
      \**************************************************/

    /*! exports provided: Publisher */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Publisher", function () {
        return a;
      });
      var i = s(
      /*! ../core/messages/body.js */
      "./node_modules/sip.js/lib/core/messages/body.js"),
          r = s(
      /*! ../core/messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          n = s(
      /*! ./emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js"),
          o = s(
      /*! ./publisher-state.js */
      "./node_modules/sip.js/lib/api/publisher-state.js");

      class a {
        constructor(e, t, s, i = {}) {
          this.disposed = !1, this._state = o.PublisherState.Initial, this._stateEventEmitter = new n.EmitterImpl(), this.userAgent = e, i.extraHeaders = (i.extraHeaders || []).slice(), i.contentType = i.contentType || "text/plain", "number" != typeof i.expires || i.expires % 1 != 0 ? i.expires = 3600 : i.expires = Number(i.expires), "boolean" != typeof i.unpublishOnClose && (i.unpublishOnClose = !0), this.target = t, this.event = s, this.options = i, this.pubRequestExpires = i.expires, this.logger = e.getLogger("sip.Publisher");
          const a = i.params || {},
                c = a.fromUri ? a.fromUri : e.userAgentCore.configuration.aor,
                d = a.toUri ? a.toUri : t;
          let l;

          if (i.body && i.contentType) {
            l = {
              contentDisposition: "render",
              contentType: i.contentType,
              content: i.body
            };
          }

          const u = (i.extraHeaders || []).slice();
          this.request = e.userAgentCore.makeOutgoingRequestMessage(r.C.PUBLISH, t, c, d, a, u, l), this.id = this.target.toString() + ":" + this.event, this.userAgent._publishers[this.id] = this;
        }

        dispose() {
          return this.disposed ? Promise.resolve() : (this.disposed = !0, this.logger.log(`Publisher ${this.id} in state ${this.state} is being disposed`), delete this.userAgent._publishers[this.id], this.options.unpublishOnClose && this.state === o.PublisherState.Published ? this.unpublish() : (this.publishRefreshTimer && (clearTimeout(this.publishRefreshTimer), this.publishRefreshTimer = void 0), this.pubRequestBody = void 0, this.pubRequestExpires = 0, this.pubRequestEtag = void 0, Promise.resolve()));
        }

        get state() {
          return this._state;
        }

        get stateChange() {
          return this._stateEventEmitter;
        }

        publish(e, t = {}) {
          if (this.publishRefreshTimer && (clearTimeout(this.publishRefreshTimer), this.publishRefreshTimer = void 0), this.options.body = e, this.pubRequestBody = this.options.body, 0 === this.pubRequestExpires) {
            if (void 0 === this.options.expires) throw new Error("Expires undefined.");
            this.pubRequestExpires = this.options.expires, this.pubRequestEtag = void 0;
          }

          return this.sendPublishRequest(), Promise.resolve();
        }

        unpublish(e = {}) {
          return this.publishRefreshTimer && (clearTimeout(this.publishRefreshTimer), this.publishRefreshTimer = void 0), this.pubRequestBody = void 0, this.pubRequestExpires = 0, void 0 !== this.pubRequestEtag && this.sendPublishRequest(), Promise.resolve();
        }

        receiveResponse(e) {
          const t = e.statusCode || 0;

          switch (!0) {
            case /^1[0-9]{2}$/.test(t.toString()):
              break;

            case /^2[0-9]{2}$/.test(t.toString()):
              if (e.hasHeader("SIP-ETag") ? this.pubRequestEtag = e.getHeader("SIP-ETag") : this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH"), e.hasHeader("Expires")) {
                const t = Number(e.getHeader("Expires"));
                "number" == typeof t && t >= 0 && t <= this.pubRequestExpires ? this.pubRequestExpires = t : this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
              } else this.logger.warn("Expires header missing in a 200-class response to PUBLISH");

              0 !== this.pubRequestExpires ? (this.publishRefreshTimer = setTimeout(() => this.refreshRequest(), 900 * this.pubRequestExpires), this._state !== o.PublisherState.Published && this.stateTransition(o.PublisherState.Published)) : this.stateTransition(o.PublisherState.Unpublished);
              break;

            case /^412$/.test(t.toString()):
              if (void 0 !== this.pubRequestEtag && 0 !== this.pubRequestExpires) {
                if (this.logger.warn("412 response to PUBLISH, recovering"), this.pubRequestEtag = void 0, void 0 === this.options.body) throw new Error("Body undefined.");
                this.publish(this.options.body);
              } else this.logger.warn("412 response to PUBLISH, recovery failed"), this.pubRequestExpires = 0, this.stateTransition(o.PublisherState.Unpublished), this.stateTransition(o.PublisherState.Terminated);

              break;

            case /^423$/.test(t.toString()):
              if (0 !== this.pubRequestExpires && e.hasHeader("Min-Expires")) {
                const t = Number(e.getHeader("Min-Expires"));

                if ("number" == typeof t || t > this.pubRequestExpires) {
                  if (this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover"), this.pubRequestExpires = t, void 0 === this.options.body) throw new Error("Body undefined.");
                  this.publish(this.options.body);
                } else this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH"), this.pubRequestExpires = 0, this.stateTransition(o.PublisherState.Unpublished), this.stateTransition(o.PublisherState.Terminated);
              } else this.logger.warn("423 response to PUBLISH, recovery failed"), this.pubRequestExpires = 0, this.stateTransition(o.PublisherState.Unpublished), this.stateTransition(o.PublisherState.Terminated);

              break;

            default:
              this.pubRequestExpires = 0, this.stateTransition(o.PublisherState.Unpublished), this.stateTransition(o.PublisherState.Terminated);
          }

          0 === this.pubRequestExpires && (this.publishRefreshTimer && (clearTimeout(this.publishRefreshTimer), this.publishRefreshTimer = void 0), this.pubRequestBody = void 0, this.pubRequestEtag = void 0);
        }

        send() {
          return this.userAgent.userAgentCore.publish(this.request, {
            onAccept: e => this.receiveResponse(e.message),
            onProgress: e => this.receiveResponse(e.message),
            onRedirect: e => this.receiveResponse(e.message),
            onReject: e => this.receiveResponse(e.message),
            onTrying: e => this.receiveResponse(e.message)
          });
        }

        refreshRequest() {
          if (this.publishRefreshTimer && (clearTimeout(this.publishRefreshTimer), this.publishRefreshTimer = void 0), this.pubRequestBody = void 0, void 0 === this.pubRequestEtag) throw new Error("Etag undefined");
          if (0 === this.pubRequestExpires) throw new Error("Expires zero");
          this.sendPublishRequest();
        }

        sendPublishRequest() {
          const e = Object.assign({}, this.options);
          e.extraHeaders = (this.options.extraHeaders || []).slice(), e.extraHeaders.push("Event: " + this.event), e.extraHeaders.push("Expires: " + this.pubRequestExpires), void 0 !== this.pubRequestEtag && e.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
          const t = this.target,
                s = this.options.params || {};
          let n, o;

          if (void 0 !== this.pubRequestBody) {
            if (void 0 === this.options.contentType) throw new Error("Content type undefined.");
            n = {
              body: this.pubRequestBody,
              contentType: this.options.contentType
            };
          }

          return n && (o = Object(i.fromBodyLegacy)(n)), this.request = this.userAgent.userAgentCore.makeOutgoingRequestMessage(r.C.PUBLISH, t, s.fromUri ? s.fromUri : this.userAgent.userAgentCore.configuration.aor, s.toUri ? s.toUri : this.target, s, e.extraHeaders, o), this.send();
        }

        stateTransition(e) {
          const t = () => {
            throw new Error(`Invalid state transition from ${this._state} to ${e}`);
          };

          switch (this._state) {
            case o.PublisherState.Initial:
              e !== o.PublisherState.Published && e !== o.PublisherState.Unpublished && e !== o.PublisherState.Terminated && t();
              break;

            case o.PublisherState.Published:
              e !== o.PublisherState.Unpublished && e !== o.PublisherState.Terminated && t();
              break;

            case o.PublisherState.Unpublished:
              e !== o.PublisherState.Published && e !== o.PublisherState.Terminated && t();
              break;

            case o.PublisherState.Terminated:
              t();
              break;

            default:
              throw new Error("Unrecognized state.");
          }

          this._state = e, this.logger.log(`Publication transitioned to state ${this._state}`), this._stateEventEmitter.emit(this._state), e === o.PublisherState.Terminated && this.dispose();
        }

      }
    },
    "./node_modules/sip.js/lib/api/referral.js":
    /*!*************************************************!*\
      !*** ./node_modules/sip.js/lib/api/referral.js ***!
      \*************************************************/

    /*! exports provided: Referral */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Referral", function () {
        return r;
      });
      var i = s(
      /*! ../grammar/name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js");

      class r {
        constructor(e, t) {
          this.incomingReferRequest = e, this.session = t;
        }

        get referTo() {
          const e = this.incomingReferRequest.message.parseHeader("refer-to");
          if (!(e instanceof i.NameAddrHeader)) throw new Error("Failed to parse Refer-To header.");
          return e;
        }

        get referredBy() {
          return this.incomingReferRequest.message.getHeader("referred-by");
        }

        get replaces() {
          const e = this.referTo.uri.getHeader("replaces");
          return e instanceof Array ? e[0] : e;
        }

        get request() {
          return this.incomingReferRequest.message;
        }

        accept(e = {
          statusCode: 202
        }) {
          return this.incomingReferRequest.accept(e), Promise.resolve();
        }

        reject(e) {
          return this.incomingReferRequest.reject(e), Promise.resolve();
        }

        makeInviter(e) {
          if (this.inviter) return this.inviter;
          const t = this.referTo.uri.clone();
          t.clearHeaders();
          const s = ((e = e || {}).extraHeaders || []).slice(),
                i = this.replaces;
          i && s.push("Replaces: " + decodeURIComponent(i));
          const r = this.referredBy;
          return r && s.push("Referred-By: " + r), e.extraHeaders = s, this.inviter = this.session.userAgent._makeInviter(t, e), this.inviter._referred = this.session, this.session._referral = this.inviter, this.inviter;
        }

      }
    },
    "./node_modules/sip.js/lib/api/registerer-options.js":
    /*!***********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/registerer-options.js ***!
      \***********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/registerer-register-options.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/registerer-register-options.js ***!
      \********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/registerer-state.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/registerer-state.js ***!
      \*********************************************************/

    /*! exports provided: RegistererState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "RegistererState", function () {
        return i;
      }), function (e) {
        e.Initial = "Initial", e.Registered = "Registered", e.Unregistered = "Unregistered", e.Terminated = "Terminated";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/api/registerer-unregister-options.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/registerer-unregister-options.js ***!
      \**********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/registerer.js":
    /*!***************************************************!*\
      !*** ./node_modules/sip.js/lib/api/registerer.js ***!
      \***************************************************/

    /*! exports provided: Registerer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Registerer", function () {
        return d;
      });
      var i = s(
      /*! ../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ../grammar/uri.js */
      "./node_modules/sip.js/lib/grammar/uri.js"),
          n = s(
      /*! ../core/messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          o = s(
      /*! ./emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js"),
          a = s(
      /*! ./exceptions/request-pending.js */
      "./node_modules/sip.js/lib/api/exceptions/request-pending.js"),
          c = s(
      /*! ./registerer-state.js */
      "./node_modules/sip.js/lib/api/registerer-state.js");

      class d {
        constructor(e, t = {}) {
          this.disposed = !1, this._contacts = [], this._retryAfter = void 0, this._state = c.RegistererState.Initial, this._statusCode = 0, this._waiting = !1, this._stateEventEmitter = new o.EmitterImpl(), this._waitingEventEmitter = new o.EmitterImpl(), this.userAgent = e;
          const s = e.configuration.uri.clone();
          if (s.user = void 0, this.options = Object.assign(Object.assign(Object.assign({}, d.defaultOptions()), {
            registrar: s
          }), d.stripUndefinedProperties(t)), this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice(), this.options.extraHeaders = (this.options.extraHeaders || []).slice(), !this.options.registrar) throw new Error("Registrar undefined.");
          if (this.options.registrar = this.options.registrar.clone(), this.options.regId && !this.options.instanceId ? this.options.instanceId = this.userAgent.instanceId : !this.options.regId && this.options.instanceId && (this.options.regId = 1), this.options.instanceId && -1 === i.Grammar.parse(this.options.instanceId, "uuid")) throw new Error("Invalid instanceId.");
          if (this.options.regId && this.options.regId < 0) throw new Error("Invalid regId.");
          const r = this.options.registrar,
                a = this.options.params && this.options.params.fromUri || e.userAgentCore.configuration.aor,
                l = this.options.params && this.options.params.toUri || e.configuration.uri,
                u = this.options.params || {},
                h = (t.extraHeaders || []).slice();
          if (this.request = e.userAgentCore.makeOutgoingRequestMessage(n.C.REGISTER, r, a, l, u, h, void 0), this.expires = this.options.expires || d.defaultExpires, this.expires < 0) throw new Error("Invalid expires.");
          if (this.refreshFrequency = this.options.refreshFrequency || d.defaultRefreshFrequency, this.refreshFrequency < 50 || this.refreshFrequency > 99) throw new Error("Invalid refresh frequency. The value represents a percentage of the expiration time and should be between 50 and 99.");
          this.logger = e.getLogger("sip.Registerer"), this.options.logConfiguration && (this.logger.log("Configuration:"), Object.keys(this.options).forEach(e => {
            const t = this.options[e];

            switch (e) {
              case "registrar":
                this.logger.log(" " + e + ": " + t);
                break;

              default:
                this.logger.log(" " + e + ": " + JSON.stringify(t));
            }
          })), this.id = this.request.callId + this.request.from.parameters.tag, this.userAgent._registerers[this.id] = this;
        }

        static defaultOptions() {
          return {
            expires: d.defaultExpires,
            extraContactHeaderParams: [],
            extraHeaders: [],
            logConfiguration: !0,
            instanceId: "",
            params: {},
            regId: 0,
            registrar: new r.URI("sip", "anonymous", "anonymous.invalid"),
            refreshFrequency: d.defaultRefreshFrequency
          };
        }

        static stripUndefinedProperties(e) {
          return Object.keys(e).reduce((t, s) => (void 0 !== e[s] && (t[s] = e[s]), t), {});
        }

        get contacts() {
          return this._contacts.slice();
        }

        get retryAfter() {
          return this._retryAfter;
        }

        get state() {
          return this._state;
        }

        get statusCode() {
          return this._statusCode;
        }

        get stateChange() {
          return this._stateEventEmitter;
        }

        dispose() {
          return this.disposed ? Promise.resolve() : (this.disposed = !0, this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`), delete this.userAgent._registerers[this.id], new Promise(e => {
            const t = () => {
              if (!this.waiting && this._state === c.RegistererState.Registered) return this.stateChange.addListener(() => {
                this.terminated(), e();
              }, {
                once: !0
              }), void this.unregister();
              this.terminated(), e();
            };

            this.waiting ? this.waitingChange.addListener(() => {
              t();
            }, {
              once: !0
            }) : t();
          }));
        }

        register(e = {}) {
          if (this.state === c.RegistererState.Terminated) throw this.stateError(), new Error("Registerer terminated. Unable to register.");
          if (this.disposed) throw this.stateError(), new Error("Registerer disposed. Unable to register.");

          if (this.waiting) {
            this.waitingWarning();
            const e = new a.RequestPendingError("REGISTER request already in progress, waiting for final response");
            return Promise.reject(e);
          }

          e.requestOptions && (this.options = Object.assign(Object.assign({}, this.options), e.requestOptions));
          const t = (this.options.extraHeaders || []).slice();
          t.push("Contact: " + this.generateContactHeader(this.expires)), t.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString()), this.request.cseq++, this.request.setHeader("cseq", this.request.cseq + " REGISTER"), this.request.extraHeaders = t, this.waitingToggle(!0);
          const s = this.userAgent.userAgentCore.register(this.request, {
            onAccept: t => {
              let s;
              this._statusCode = t.message.statusCode, t.message.hasHeader("expires") && (s = Number(t.message.getHeader("expires"))), this._contacts = t.message.getHeaders("contact");
              let n,
                  o = this._contacts.length;
              if (!o) return this.logger.error("No Contact header in response to REGISTER, dropping response."), void this.unregistered();

              for (; o--;) {
                if (!(n = t.message.parseHeader("contact", o))) throw new Error("Contact undefined");

                if (this.userAgent.contact.pubGruu && Object(r.equivalentURI)(n.uri, this.userAgent.contact.pubGruu)) {
                  s = Number(n.getParam("expires"));
                  break;
                }

                if ("" === this.userAgent.configuration.contactName) {
                  if (n.uri.user === this.userAgent.contact.uri.user) {
                    s = Number(n.getParam("expires"));
                    break;
                  }
                } else if (Object(r.equivalentURI)(n.uri, this.userAgent.contact.uri)) {
                  s = Number(n.getParam("expires"));
                  break;
                }

                n = void 0;
              }

              if (void 0 === n) return this.logger.error("No Contact header pointing to us, dropping response"), this.unregistered(), void this.waitingToggle(!1);
              if (void 0 === s) return this.logger.error("Contact pointing to us is missing expires parameter, dropping response"), this.unregistered(), void this.waitingToggle(!1);

              if (n.hasParam("temp-gruu")) {
                const e = n.getParam("temp-gruu");
                e && (this.userAgent.contact.tempGruu = i.Grammar.URIParse(e.replace(/"/g, "")));
              }

              if (n.hasParam("pub-gruu")) {
                const e = n.getParam("pub-gruu");
                e && (this.userAgent.contact.pubGruu = i.Grammar.URIParse(e.replace(/"/g, "")));
              }

              this.registered(s), e.requestDelegate && e.requestDelegate.onAccept && e.requestDelegate.onAccept(t), this.waitingToggle(!1);
            },
            onProgress: t => {
              e.requestDelegate && e.requestDelegate.onProgress && e.requestDelegate.onProgress(t);
            },
            onRedirect: t => {
              this.logger.error("Redirect received. Not supported."), this.unregistered(), e.requestDelegate && e.requestDelegate.onRedirect && e.requestDelegate.onRedirect(t), this.waitingToggle(!1);
            },
            onReject: t => {
              if (this._statusCode = t.message.statusCode, 423 === t.message.statusCode) return t.message.hasHeader("min-expires") ? (this.expires = Number(t.message.getHeader("min-expires")), this.waitingToggle(!1), void this.register()) : (this.logger.error("423 response received for REGISTER without Min-Expires, dropping response"), this.unregistered(), void this.waitingToggle(!1));
              this.logger.warn(`Failed to register, status code ${t.message.statusCode}`);
              let s = NaN;

              if (500 === t.message.statusCode || 503 === t.message.statusCode) {
                const e = t.message.getHeader("retry-after");
                e && (s = Number.parseInt(e, void 0));
              }

              this._retryAfter = isNaN(s) ? void 0 : s, this.unregistered(), e.requestDelegate && e.requestDelegate.onReject && e.requestDelegate.onReject(t), this._retryAfter = void 0, this.waitingToggle(!1);
            },
            onTrying: t => {
              e.requestDelegate && e.requestDelegate.onTrying && e.requestDelegate.onTrying(t);
            }
          });
          return Promise.resolve(s);
        }

        unregister(e = {}) {
          if (this.state === c.RegistererState.Terminated) throw this.stateError(), new Error("Registerer terminated. Unable to register.");
          if (this.disposed && this.state !== c.RegistererState.Registered) throw this.stateError(), new Error("Registerer disposed. Unable to register.");

          if (this.waiting) {
            this.waitingWarning();
            const e = new a.RequestPendingError("REGISTER request already in progress, waiting for final response");
            return Promise.reject(e);
          }

          this._state === c.RegistererState.Registered || e.all || this.logger.warn("Not currently registered, but sending an unregister anyway.");
          const t = (e.requestOptions && e.requestOptions.extraHeaders || []).slice();
          this.request.extraHeaders = t, e.all ? (t.push("Contact: *"), t.push("Expires: 0")) : t.push("Contact: " + this.generateContactHeader(0)), this.request.cseq++, this.request.setHeader("cseq", this.request.cseq + " REGISTER"), void 0 !== this.registrationTimer && (clearTimeout(this.registrationTimer), this.registrationTimer = void 0), this.waitingToggle(!0);
          const s = this.userAgent.userAgentCore.register(this.request, {
            onAccept: t => {
              this._statusCode = t.message.statusCode, this._contacts = t.message.getHeaders("contact"), this.unregistered(), e.requestDelegate && e.requestDelegate.onAccept && e.requestDelegate.onAccept(t), this.waitingToggle(!1);
            },
            onProgress: t => {
              e.requestDelegate && e.requestDelegate.onProgress && e.requestDelegate.onProgress(t);
            },
            onRedirect: t => {
              this.logger.error("Unregister redirected. Not currently supported."), this.unregistered(), e.requestDelegate && e.requestDelegate.onRedirect && e.requestDelegate.onRedirect(t), this.waitingToggle(!1);
            },
            onReject: t => {
              this.logger.error(`Unregister rejected with status code ${t.message.statusCode}`), this._statusCode = t.message.statusCode, this.unregistered(), e.requestDelegate && e.requestDelegate.onReject && e.requestDelegate.onReject(t), this.waitingToggle(!1);
            },
            onTrying: t => {
              e.requestDelegate && e.requestDelegate.onTrying && e.requestDelegate.onTrying(t);
            }
          });
          return Promise.resolve(s);
        }

        clearTimers() {
          void 0 !== this.registrationTimer && (clearTimeout(this.registrationTimer), this.registrationTimer = void 0), void 0 !== this.registrationExpiredTimer && (clearTimeout(this.registrationExpiredTimer), this.registrationExpiredTimer = void 0);
        }

        generateContactHeader(e) {
          let t = this.userAgent.contact.toString({
            register: !0
          });
          return this.options.regId && this.options.instanceId && (t += ";reg-id=" + this.options.regId, t += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"'), this.options.extraContactHeaderParams && this.options.extraContactHeaderParams.forEach(e => {
            t += ";" + e;
          }), t += ";expires=" + e;
        }

        registered(e) {
          this.clearTimers(), this.registrationTimer = setTimeout(() => {
            this.registrationTimer = void 0, this.register();
          }, this.refreshFrequency / 100 * e * 1e3), this.registrationExpiredTimer = setTimeout(() => {
            this.logger.warn("Registration expired"), this.unregistered();
          }, 1e3 * e), this._state !== c.RegistererState.Registered && this.stateTransition(c.RegistererState.Registered);
        }

        unregistered() {
          this.clearTimers(), this._state !== c.RegistererState.Unregistered && this.stateTransition(c.RegistererState.Unregistered);
        }

        terminated() {
          this.clearTimers(), this._state !== c.RegistererState.Terminated && this.stateTransition(c.RegistererState.Terminated);
        }

        stateTransition(e) {
          const t = () => {
            throw new Error(`Invalid state transition from ${this._state} to ${e}`);
          };

          switch (this._state) {
            case c.RegistererState.Initial:
              e !== c.RegistererState.Registered && e !== c.RegistererState.Unregistered && e !== c.RegistererState.Terminated && t();
              break;

            case c.RegistererState.Registered:
              e !== c.RegistererState.Unregistered && e !== c.RegistererState.Terminated && t();
              break;

            case c.RegistererState.Unregistered:
              e !== c.RegistererState.Registered && e !== c.RegistererState.Terminated && t();
              break;

            case c.RegistererState.Terminated:
              t();
              break;

            default:
              throw new Error("Unrecognized state.");
          }

          this._state = e, this.logger.log(`Registration transitioned to state ${this._state}`), this._stateEventEmitter.emit(this._state), e === c.RegistererState.Terminated && this.dispose();
        }

        get waiting() {
          return this._waiting;
        }

        get waitingChange() {
          return this._waitingEventEmitter;
        }

        waitingToggle(e) {
          if (this._waiting === e) throw new Error(`Invalid waiting transition from ${this._waiting} to ${e}`);
          this._waiting = e, this.logger.log(`Waiting toggled to ${this._waiting}`), this._waitingEventEmitter.emit(this._waiting);
        }

        waitingWarning() {
          let e = "An attempt was made to send a REGISTER request while a prior one was still in progress.";
          e += " RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response", e += " from the registrar for the previous one or the previous REGISTER request has timed out.", e += " Note that if the transport disconnects, you still must wait for the prior request to time out before", e += " sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.", this.logger.warn("An attempt was made to send a REGISTER request while a prior one was still in progress. RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response from the registrar for the previous one or the previous REGISTER request has timed out. Note that if the transport disconnects, you still must wait for the prior request to time out before sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.");
        }

        stateError() {
          let e = `An attempt was made to send a REGISTER request when the Registerer ${this.state === c.RegistererState.Terminated ? "is in 'Terminated' state" : "has been disposed"}.`;
          e += " The Registerer transitions to 'Terminated' when Registerer.dispose() is called.", e += " Perhaps you called UserAgent.stop() which dipsoses of all Registerers?", this.logger.error(e);
        }

      }

      d.defaultExpires = 600, d.defaultRefreshFrequency = 99;
    },
    "./node_modules/sip.js/lib/api/session-bye-options.js":
    /*!************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-bye-options.js ***!
      \************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-delegate.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-delegate.js ***!
      \*********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-description-handler-factory.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-description-handler-factory.js ***!
      \****************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-description-handler.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-description-handler.js ***!
      \********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-info-options.js":
    /*!*************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-info-options.js ***!
      \*************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-invite-options.js":
    /*!***************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-invite-options.js ***!
      \***************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-message-options.js":
    /*!****************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-message-options.js ***!
      \****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-options.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-options.js ***!
      \********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-refer-options.js":
    /*!**************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-refer-options.js ***!
      \**************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/session-state.js":
    /*!******************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session-state.js ***!
      \******************************************************/

    /*! exports provided: SessionState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "SessionState", function () {
        return i;
      }), function (e) {
        e.Initial = "Initial", e.Establishing = "Establishing", e.Established = "Established", e.Terminating = "Terminating", e.Terminated = "Terminated";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/api/session.js":
    /*!************************************************!*\
      !*** ./node_modules/sip.js/lib/api/session.js ***!
      \************************************************/

    /*! exports provided: Session */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Session", function () {
        return S;
      });
      var i = s(
      /*! ../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ../grammar/uri.js */
      "./node_modules/sip.js/lib/grammar/uri.js"),
          n = s(
      /*! ../core/messages/body.js */
      "./node_modules/sip.js/lib/core/messages/body.js"),
          o = s(
      /*! ../core/session/session.js */
      "./node_modules/sip.js/lib/core/session/session.js"),
          a = s(
      /*! ../core/messages/utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js"),
          c = s(
      /*! ../core/user-agent-core/allowed-methods.js */
      "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js"),
          d = s(
      /*! ./ack.js */
      "./node_modules/sip.js/lib/api/ack.js"),
          l = s(
      /*! ./bye.js */
      "./node_modules/sip.js/lib/api/bye.js"),
          u = s(
      /*! ./emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js"),
          h = s(
      /*! ./exceptions/content-type-unsupported.js */
      "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js"),
          g = s(
      /*! ./exceptions/request-pending.js */
      "./node_modules/sip.js/lib/api/exceptions/request-pending.js"),
          p = s(
      /*! ./info.js */
      "./node_modules/sip.js/lib/api/info.js"),
          m = s(
      /*! ./message.js */
      "./node_modules/sip.js/lib/api/message.js"),
          f = s(
      /*! ./notification.js */
      "./node_modules/sip.js/lib/api/notification.js"),
          v = s(
      /*! ./referral.js */
      "./node_modules/sip.js/lib/api/referral.js"),
          b = s(
      /*! ./session-state.js */
      "./node_modules/sip.js/lib/api/session-state.js");

      class S {
        constructor(e, t = {}) {
          this.pendingReinvite = !1, this.pendingReinviteAck = !1, this._state = b.SessionState.Initial, this.delegate = t.delegate, this._stateEventEmitter = new u.EmitterImpl(), this._userAgent = e;
        }

        dispose() {
          switch (this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`), delete this.userAgent._sessions[this.id], this._sessionDescriptionHandler && this._sessionDescriptionHandler.close(), this.state) {
            case b.SessionState.Initial:
            case b.SessionState.Establishing:
              break;

            case b.SessionState.Established:
              return new Promise(e => {
                this._bye({
                  onAccept: () => e(),
                  onRedirect: () => e(),
                  onReject: () => e()
                });
              });

            case b.SessionState.Terminating:
            case b.SessionState.Terminated:
              break;

            default:
              throw new Error("Unknown state.");
          }

          return Promise.resolve();
        }

        get assertedIdentity() {
          return this._assertedIdentity;
        }

        get dialog() {
          return this._dialog;
        }

        get id() {
          return this._id;
        }

        get replacee() {
          return this._replacee;
        }

        get sessionDescriptionHandler() {
          return this._sessionDescriptionHandler;
        }

        get sessionDescriptionHandlerFactory() {
          return this.userAgent.configuration.sessionDescriptionHandlerFactory;
        }

        get sessionDescriptionHandlerModifiers() {
          return this._sessionDescriptionHandlerModifiers || [];
        }

        set sessionDescriptionHandlerModifiers(e) {
          this._sessionDescriptionHandlerModifiers = e.slice();
        }

        get sessionDescriptionHandlerOptions() {
          return this._sessionDescriptionHandlerOptions || {};
        }

        set sessionDescriptionHandlerOptions(e) {
          this._sessionDescriptionHandlerOptions = Object.assign({}, e);
        }

        get sessionDescriptionHandlerModifiersReInvite() {
          return this._sessionDescriptionHandlerModifiersReInvite || [];
        }

        set sessionDescriptionHandlerModifiersReInvite(e) {
          this._sessionDescriptionHandlerModifiersReInvite = e.slice();
        }

        get sessionDescriptionHandlerOptionsReInvite() {
          return this._sessionDescriptionHandlerOptionsReInvite || {};
        }

        set sessionDescriptionHandlerOptionsReInvite(e) {
          this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, e);
        }

        get state() {
          return this._state;
        }

        get stateChange() {
          return this._stateEventEmitter;
        }

        get userAgent() {
          return this._userAgent;
        }

        bye(e = {}) {
          let t = "Session.bye() may only be called if established session.";

          switch (this.state) {
            case b.SessionState.Initial:
              "function" == typeof this.cancel ? (t += " However Inviter.invite() has not yet been called.", t += " Perhaps you should have called Inviter.cancel()?") : "function" == typeof this.reject && (t += " However Invitation.accept() has not yet been called.", t += " Perhaps you should have called Invitation.reject()?");
              break;

            case b.SessionState.Establishing:
              "function" == typeof this.cancel ? (t += " However a dialog does not yet exist.", t += " Perhaps you should have called Inviter.cancel()?") : "function" == typeof this.reject && (t += " However Invitation.accept() has not yet been called (or not yet resolved).", t += " Perhaps you should have called Invitation.reject()?");
              break;

            case b.SessionState.Established:
              {
                const t = e.requestDelegate,
                      s = this.copyRequestOptions(e.requestOptions);
                return this._bye(t, s);
              }

            case b.SessionState.Terminating:
              t += " However this session is already terminating.", "function" == typeof this.cancel ? t += " Perhaps you have already called Inviter.cancel()?" : "function" == typeof this.reject && (t += " Perhaps you have already called Session.bye()?");
              break;

            case b.SessionState.Terminated:
              t += " However this session is already terminated.";
              break;

            default:
              throw new Error("Unknown state");
          }

          return this.logger.error(t), Promise.reject(new Error(`Invalid session state ${this.state}`));
        }

        info(e = {}) {
          if (this.state !== b.SessionState.Established) {
            const e = "Session.info() may only be called if established session.";
            return this.logger.error(e), Promise.reject(new Error(`Invalid session state ${this.state}`));
          }

          const t = e.requestDelegate,
                s = this.copyRequestOptions(e.requestOptions);
          return this._info(t, s);
        }

        invite(e = {}) {
          if (this.logger.log("Session.invite"), this.state !== b.SessionState.Established) return Promise.reject(new Error(`Invalid session state ${this.state}`));
          if (this.pendingReinvite) return Promise.reject(new g.RequestPendingError("Reinvite in progress. Please wait until complete, then try again."));
          this.pendingReinvite = !0, e.sessionDescriptionHandlerModifiers && (this.sessionDescriptionHandlerModifiersReInvite = e.sessionDescriptionHandlerModifiers), e.sessionDescriptionHandlerOptions && (this.sessionDescriptionHandlerOptionsReInvite = e.sessionDescriptionHandlerOptions);
          const t = {
            onAccept: t => {
              const s = Object(n.getBody)(t.message);
              if (!s) return this.logger.error("Received 2xx response to re-INVITE without a session description"), this.ackAndBye(t, 400, "Missing session description"), this.stateTransition(b.SessionState.Terminated), void (this.pendingReinvite = !1);

              if (e.withoutSdp) {
                const i = {
                  sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
                  sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
                };
                this.setOfferAndGetAnswer(s, i).then(e => {
                  t.ack({
                    body: e
                  });
                }).catch(e => {
                  this.logger.error("Failed to handle offer in 2xx response to re-INVITE"), this.logger.error(e.message), this.state === b.SessionState.Terminated ? t.ack() : (this.ackAndBye(t, 488, "Bad Media Description"), this.stateTransition(b.SessionState.Terminated));
                }).then(() => {
                  this.pendingReinvite = !1, e.requestDelegate && e.requestDelegate.onAccept && e.requestDelegate.onAccept(t);
                });
              } else {
                const i = {
                  sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
                  sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
                };
                this.setAnswer(s, i).then(() => {
                  t.ack();
                }).catch(e => {
                  this.logger.error("Failed to handle answer in 2xx response to re-INVITE"), this.logger.error(e.message), this.state !== b.SessionState.Terminated ? (this.ackAndBye(t, 488, "Bad Media Description"), this.stateTransition(b.SessionState.Terminated)) : t.ack();
                }).then(() => {
                  this.pendingReinvite = !1, e.requestDelegate && e.requestDelegate.onAccept && e.requestDelegate.onAccept(t);
                });
              }
            },
            onProgress: e => {},
            onRedirect: e => {},
            onReject: t => {
              this.logger.warn("Received a non-2xx response to re-INVITE"), this.pendingReinvite = !1, e.withoutSdp ? e.requestDelegate && e.requestDelegate.onReject && e.requestDelegate.onReject(t) : this.rollbackOffer().catch(e => {
                if (this.logger.error("Failed to rollback offer on non-2xx response to re-INVITE"), this.logger.error(e.message), this.state !== b.SessionState.Terminated) {
                  if (!this.dialog) throw new Error("Dialog undefined.");
                  const e = [];
                  e.push("Reason: " + this.getReasonHeaderValue(500, "Internal Server Error")), this.dialog.bye(void 0, {
                    extraHeaders: e
                  }), this.stateTransition(b.SessionState.Terminated);
                }
              }).then(() => {
                e.requestDelegate && e.requestDelegate.onReject && e.requestDelegate.onReject(t);
              });
            },
            onTrying: e => {}
          },
                s = e.requestOptions || {};

          if (s.extraHeaders = (s.extraHeaders || []).slice(), s.extraHeaders.push("Allow: " + c.AllowedMethods.toString()), s.extraHeaders.push("Contact: " + this._contact), e.withoutSdp) {
            if (!this.dialog) throw this.pendingReinvite = !1, new Error("Dialog undefined.");
            return Promise.resolve(this.dialog.invite(t, s));
          }

          const i = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
          };
          return this.getOffer(i).then(e => {
            if (!this.dialog) throw this.pendingReinvite = !1, new Error("Dialog undefined.");
            return s.body = e, this.dialog.invite(t, s);
          }).catch(e => {
            throw this.logger.error(e.message), this.logger.error("Failed to send re-INVITE"), this.pendingReinvite = !1, e;
          });
        }

        message(e = {}) {
          if (this.state !== b.SessionState.Established) {
            const e = "Session.message() may only be called if established session.";
            return this.logger.error(e), Promise.reject(new Error(`Invalid session state ${this.state}`));
          }

          const t = e.requestDelegate,
                s = this.copyRequestOptions(e.requestOptions);
          return this._message(t, s);
        }

        refer(e, t = {}) {
          if (this.state !== b.SessionState.Established) {
            const e = "Session.refer() may only be called if established session.";
            return this.logger.error(e), Promise.reject(new Error(`Invalid session state ${this.state}`));
          }

          if (e instanceof S && !e.dialog) {
            const e = "Session.refer() may only be called with session which is established. You are perhaps attempting to attended transfer to a target for which there is not dialog yet established. Perhaps you are attempting a 'semi-attended' tansfer? Regardless, this is not supported. The recommended approached is to check to see if the target Session is in the Established state before calling refer(); if the state is not Established you may proceed by falling back using a URI as the target (blind transfer).";
            return this.logger.error(e), Promise.reject(new Error(`Invalid session state ${this.state}`));
          }

          const s = t.requestDelegate,
                i = this.copyRequestOptions(t.requestOptions);
          return i.extraHeaders = i.extraHeaders ? i.extraHeaders.concat(this.referExtraHeaders(this.referToString(e))) : this.referExtraHeaders(this.referToString(e)), this._refer(t.onNotify, s, i);
        }

        _bye(e, t) {
          if (!this.dialog) return Promise.reject(new Error("Session dialog undefined."));
          const s = this.dialog;

          switch (s.sessionState) {
            case o.SessionState.Initial:
            case o.SessionState.Early:
              throw new Error(`Invalid dialog state ${s.sessionState}`);

            case o.SessionState.AckWait:
              return this.stateTransition(b.SessionState.Terminating), new Promise(i => {
                s.delegate = {
                  onAck: () => {
                    const r = s.bye(e, t);
                    return this.stateTransition(b.SessionState.Terminated), i(r), Promise.resolve();
                  },
                  onAckTimeout: () => {
                    const r = s.bye(e, t);
                    this.stateTransition(b.SessionState.Terminated), i(r);
                  }
                };
              });

            case o.SessionState.Confirmed:
              {
                const i = s.bye(e, t);
                return this.stateTransition(b.SessionState.Terminated), Promise.resolve(i);
              }

            case o.SessionState.Terminated:
              throw new Error(`Invalid dialog state ${s.sessionState}`);

            default:
              throw new Error("Unrecognized state.");
          }
        }

        _info(e, t) {
          return this.dialog ? Promise.resolve(this.dialog.info(e, t)) : Promise.reject(new Error("Session dialog undefined."));
        }

        _message(e, t) {
          return this.dialog ? Promise.resolve(this.dialog.message(e, t)) : Promise.reject(new Error("Session dialog undefined."));
        }

        _refer(e, t, s) {
          return this.dialog ? (this.onNotify = e, Promise.resolve(this.dialog.refer(t, s))) : Promise.reject(new Error("Session dialog undefined."));
        }

        ackAndBye(e, t, s) {
          e.ack();
          const i = [];
          t && i.push("Reason: " + this.getReasonHeaderValue(t, s)), e.session.bye(void 0, {
            extraHeaders: i
          });
        }

        onAckRequest(e) {
          if (this.logger.log("Session.onAckRequest"), this.state !== b.SessionState.Established && this.state !== b.SessionState.Terminating) return this.logger.error(`ACK received while in state ${this.state}, dropping request`), Promise.resolve();
          const t = this.dialog;
          if (!t) throw new Error("Dialog undefined.");
          const s = {
            sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers
          };

          if (this.delegate && this.delegate.onAck) {
            const t = new d.Ack(e);
            this.delegate.onAck(t);
          }

          switch (this.pendingReinviteAck = !1, t.signalingState) {
            case o.SignalingState.Initial:
              {
                this.logger.error(`Invalid signaling state ${t.signalingState}.`);
                const e = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                return t.bye(void 0, {
                  extraHeaders: e
                }), this.stateTransition(b.SessionState.Terminated), Promise.resolve();
              }

            case o.SignalingState.Stable:
              {
                const i = Object(n.getBody)(e.message);
                return i ? "render" === i.contentDisposition ? (this._renderbody = i.content, this._rendertype = i.contentType, Promise.resolve()) : "session" !== i.contentDisposition ? Promise.resolve() : this.setAnswer(i, s).catch(e => {
                  this.logger.error(e.message);
                  const s = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                  t.bye(void 0, {
                    extraHeaders: s
                  }), this.stateTransition(b.SessionState.Terminated);
                }) : Promise.resolve();
              }

            case o.SignalingState.HaveLocalOffer:
            case o.SignalingState.HaveRemoteOffer:
              {
                this.logger.error(`Invalid signaling state ${t.signalingState}.`);
                const e = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                return t.bye(void 0, {
                  extraHeaders: e
                }), this.stateTransition(b.SessionState.Terminated), Promise.resolve();
              }

            case o.SignalingState.Closed:
            default:
              throw new Error(`Invalid signaling state ${t.signalingState}.`);
          }
        }

        onByeRequest(e) {
          if (this.logger.log("Session.onByeRequest"), this.state === b.SessionState.Established) {
            if (this.delegate && this.delegate.onBye) {
              const t = new l.Bye(e);
              this.delegate.onBye(t);
            } else e.accept();

            this.stateTransition(b.SessionState.Terminated);
          } else this.logger.error(`BYE received while in state ${this.state}, dropping request`);
        }

        onInfoRequest(e) {
          if (this.logger.log("Session.onInfoRequest"), this.state === b.SessionState.Established) {
            if (this.delegate && this.delegate.onInfo) {
              const t = new p.Info(e);
              this.delegate.onInfo(t);
            } else e.accept();
          } else this.logger.error(`INFO received while in state ${this.state}, dropping request`);
        }

        onInviteRequest(e) {
          if (this.logger.log("Session.onInviteRequest"), this.state !== b.SessionState.Established) return void this.logger.error(`INVITE received while in state ${this.state}, dropping request`);
          this.pendingReinviteAck = !0;
          const t = ["Contact: " + this._contact];

          if (e.message.hasHeader("P-Asserted-Identity")) {
            const t = e.message.getHeader("P-Asserted-Identity");
            if (!t) throw new Error("Header undefined.");
            this._assertedIdentity = i.Grammar.nameAddrHeaderParse(t);
          }

          const s = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
          };
          this.generateResponseOfferAnswerInDialog(s).then(s => {
            const i = e.accept({
              statusCode: 200,
              extraHeaders: t,
              body: s
            });
            this.delegate && this.delegate.onInvite && this.delegate.onInvite(e.message, i.message, 200);
          }).catch(t => {
            if (this.logger.error(t.message), this.logger.error("Failed to handle to re-INVITE request"), !this.dialog) throw new Error("Dialog undefined.");
            if (this.logger.error(this.dialog.signalingState), this.dialog.signalingState !== o.SignalingState.Stable) this.rollbackOffer().then(() => {
              const t = e.reject({
                statusCode: 488
              });
              this.delegate && this.delegate.onInvite && this.delegate.onInvite(e.message, t.message, 488);
            }).catch(t => {
              this.logger.error(t.message), this.logger.error("Failed to rollback offer on re-INVITE request");
              const s = e.reject({
                statusCode: 488
              });

              if (this.state !== b.SessionState.Terminated) {
                if (!this.dialog) throw new Error("Dialog undefined.");
                const e = [];
                e.push("Reason: " + this.getReasonHeaderValue(500, "Internal Server Error")), this.dialog.bye(void 0, {
                  extraHeaders: e
                }), this.stateTransition(b.SessionState.Terminated);
              }

              this.delegate && this.delegate.onInvite && this.delegate.onInvite(e.message, s.message, 488);
            });else {
              const t = e.reject({
                statusCode: 488
              });
              this.delegate && this.delegate.onInvite && this.delegate.onInvite(e.message, t.message, 488);
            }
          });
        }

        onMessageRequest(e) {
          if (this.logger.log("Session.onMessageRequest"), this.state === b.SessionState.Established) {
            if (this.delegate && this.delegate.onMessage) {
              const t = new m.Message(e);
              this.delegate.onMessage(t);
            } else e.accept();
          } else this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);
        }

        onNotifyRequest(e) {
          if (this.logger.log("Session.onNotifyRequest"), this.state === b.SessionState.Established) {
            if (this.onNotify) {
              const t = new f.Notification(e);
              this.onNotify(t);
            } else if (this.delegate && this.delegate.onNotify) {
              const t = new f.Notification(e);
              this.delegate.onNotify(t);
            } else e.accept();
          } else this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);
        }

        onPrackRequest(e) {
          if (this.logger.log("Session.onPrackRequest"), this.state === b.SessionState.Established) throw new Error("Unimplemented.");
          this.logger.error(`PRACK received while in state ${this.state}, dropping request`);
        }

        onReferRequest(e) {
          if (this.logger.log("Session.onReferRequest"), this.state !== b.SessionState.Established) return void this.logger.error(`REFER received while in state ${this.state}, dropping request`);
          if (!e.message.hasHeader("refer-to")) return this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting."), void e.reject();
          const t = new v.Referral(e, this);
          this.delegate && this.delegate.onRefer ? this.delegate.onRefer(t) : (this.logger.log("No delegate available to handle REFER, automatically accepting and following."), t.accept().then(() => t.makeInviter(this._referralInviterOptions).invite()).catch(e => {
            this.logger.error(e.message);
          }));
        }

        generateResponseOfferAnswer(e, t) {
          if (this.dialog) return this.generateResponseOfferAnswerInDialog(t);
          const s = Object(n.getBody)(e.message);
          return s && "session" === s.contentDisposition ? this.setOfferAndGetAnswer(s, t) : this.getOffer(t);
        }

        generateResponseOfferAnswerInDialog(e) {
          if (!this.dialog) throw new Error("Dialog undefined.");

          switch (this.dialog.signalingState) {
            case o.SignalingState.Initial:
              return this.getOffer(e);

            case o.SignalingState.HaveLocalOffer:
              return Promise.resolve(void 0);

            case o.SignalingState.HaveRemoteOffer:
              if (!this.dialog.offer) throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);
              return this.setOfferAndGetAnswer(this.dialog.offer, e);

            case o.SignalingState.Stable:
              return this.state !== b.SessionState.Established ? Promise.resolve(void 0) : this.getOffer(e);

            case o.SignalingState.Closed:
            default:
              throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
          }
        }

        getOffer(e) {
          const t = this.setupSessionDescriptionHandler(),
                s = e.sessionDescriptionHandlerOptions,
                i = e.sessionDescriptionHandlerModifiers;

          try {
            return t.getDescription(s, i).then(e => Object(n.fromBodyLegacy)(e)).catch(e => {
              this.logger.error("Session.getOffer: SDH getDescription rejected...");
              const t = e instanceof Error ? e : new Error("Session.getOffer unknown error.");
              throw this.logger.error(t.message), t;
            });
          } catch (e) {
            this.logger.error("Session.getOffer: SDH getDescription threw...");
            const t = e instanceof Error ? e : new Error(e);
            return this.logger.error(t.message), Promise.reject(t);
          }
        }

        rollbackOffer() {
          const e = this.setupSessionDescriptionHandler();
          if (void 0 === e.rollbackDescription) return Promise.resolve();

          try {
            return e.rollbackDescription().catch(e => {
              this.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");
              const t = e instanceof Error ? e : new Error("Session.rollbackOffer unknown error.");
              throw this.logger.error(t.message), t;
            });
          } catch (e) {
            this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
            const t = e instanceof Error ? e : new Error(e);
            return this.logger.error(t.message), Promise.reject(t);
          }
        }

        setAnswer(e, t) {
          const s = this.setupSessionDescriptionHandler(),
                i = t.sessionDescriptionHandlerOptions,
                r = t.sessionDescriptionHandlerModifiers;

          try {
            if (!s.hasDescription(e.contentType)) return Promise.reject(new h.ContentTypeUnsupportedError());
          } catch (e) {
            this.logger.error("Session.setAnswer: SDH hasDescription threw...");
            const t = e instanceof Error ? e : new Error(e);
            return this.logger.error(t.message), Promise.reject(t);
          }

          try {
            return s.setDescription(e.content, i, r).catch(e => {
              this.logger.error("Session.setAnswer: SDH setDescription rejected...");
              const t = e instanceof Error ? e : new Error("Session.setAnswer unknown error.");
              throw this.logger.error(t.message), t;
            });
          } catch (e) {
            this.logger.error("Session.setAnswer: SDH setDescription threw...");
            const t = e instanceof Error ? e : new Error(e);
            return this.logger.error(t.message), Promise.reject(t);
          }
        }

        setOfferAndGetAnswer(e, t) {
          const s = this.setupSessionDescriptionHandler(),
                i = t.sessionDescriptionHandlerOptions,
                r = t.sessionDescriptionHandlerModifiers;

          try {
            if (!s.hasDescription(e.contentType)) return Promise.reject(new h.ContentTypeUnsupportedError());
          } catch (e) {
            this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
            const t = e instanceof Error ? e : new Error(e);
            return this.logger.error(t.message), Promise.reject(t);
          }

          try {
            return s.setDescription(e.content, i, r).then(() => s.getDescription(i, r)).then(e => Object(n.fromBodyLegacy)(e)).catch(e => {
              this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");
              const t = e instanceof Error ? e : new Error("Session.setOfferAndGetAnswer unknown error.");
              throw this.logger.error(t.message), t;
            });
          } catch (e) {
            this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");
            const t = e instanceof Error ? e : new Error(e);
            return this.logger.error(t.message), Promise.reject(t);
          }
        }

        setSessionDescriptionHandler(e) {
          if (this._sessionDescriptionHandler) throw new Error("Session description handler defined.");
          this._sessionDescriptionHandler = e;
        }

        setupSessionDescriptionHandler() {
          var e;
          return this._sessionDescriptionHandler ? this._sessionDescriptionHandler : (this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions), (null === (e = this.delegate) || void 0 === e ? void 0 : e.onSessionDescriptionHandler) && this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, !1), this._sessionDescriptionHandler);
        }

        stateTransition(e) {
          const t = () => {
            throw new Error(`Invalid state transition from ${this._state} to ${e}`);
          };

          switch (this._state) {
            case b.SessionState.Initial:
              e !== b.SessionState.Establishing && e !== b.SessionState.Established && e !== b.SessionState.Terminating && e !== b.SessionState.Terminated && t();
              break;

            case b.SessionState.Establishing:
              e !== b.SessionState.Established && e !== b.SessionState.Terminating && e !== b.SessionState.Terminated && t();
              break;

            case b.SessionState.Established:
              e !== b.SessionState.Terminating && e !== b.SessionState.Terminated && t();
              break;

            case b.SessionState.Terminating:
              e !== b.SessionState.Terminated && t();
              break;

            case b.SessionState.Terminated:
              t();
              break;

            default:
              throw new Error("Unrecognized state.");
          }

          this._state = e, this.logger.log(`Session ${this.id} transitioned to state ${this._state}`), this._stateEventEmitter.emit(this._state), e === b.SessionState.Terminated && this.dispose();
        }

        copyRequestOptions(e = {}) {
          return {
            extraHeaders: e.extraHeaders ? e.extraHeaders.slice() : void 0,
            body: e.body ? {
              contentDisposition: e.body.contentDisposition || "render",
              contentType: e.body.contentType || "text/plain",
              content: e.body.content || ""
            } : void 0
          };
        }

        getReasonHeaderValue(e, t) {
          const s = e;
          let i = Object(a.getReasonPhrase)(e);
          return !i && t && (i = t), "SIP;cause=" + s + ';text="' + i + '"';
        }

        referExtraHeaders(e) {
          const t = [];
          return t.push("Referred-By: <" + this.userAgent.configuration.uri + ">"), t.push("Contact: " + this._contact), t.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString()), t.push("Refer-To: " + e), t;
        }

        referToString(e) {
          let t;
          if (e instanceof r.URI) t = e.toString();else {
            if (!e.dialog) throw new Error("Dialog undefined.");
            const s = e.remoteIdentity.friendlyName,
                  i = e.dialog.remoteTarget.toString(),
                  r = e.dialog.callId,
                  n = e.dialog.remoteTag,
                  o = e.dialog.localTag;
            t = `"${s}" <${i}?Replaces=${encodeURIComponent(`${r};to-tag=${n};from-tag=${o}`)}>`;
          }
          return t;
        }

      }
    },
    "./node_modules/sip.js/lib/api/subscriber-options.js":
    /*!***********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscriber-options.js ***!
      \***********************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/subscriber-subscribe-options.js":
    /*!*********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscriber-subscribe-options.js ***!
      \*********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/subscriber.js":
    /*!***************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscriber.js ***!
      \***************************************************/

    /*! exports provided: Subscriber */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Subscriber", function () {
        return l;
      });
      var i = s(
      /*! ../core/messages/body.js */
      "./node_modules/sip.js/lib/core/messages/body.js"),
          r = s(
      /*! ../core/messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          n = s(
      /*! ../core/subscription/subscription.js */
      "./node_modules/sip.js/lib/core/subscription/subscription.js"),
          o = s(
      /*! ../core/user-agent-core/allowed-methods.js */
      "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js"),
          a = s(
      /*! ./notification.js */
      "./node_modules/sip.js/lib/api/notification.js"),
          c = s(
      /*! ./subscription.js */
      "./node_modules/sip.js/lib/api/subscription.js"),
          d = s(
      /*! ./subscription-state.js */
      "./node_modules/sip.js/lib/api/subscription-state.js");

      class l extends c.Subscription {
        constructor(e, t, s, i = {}) {
          super(e, i), this.body = void 0, this.logger = e.getLogger("sip.Subscriber"), i.body && (this.body = {
            body: i.body,
            contentType: i.contentType ? i.contentType : "application/sdp"
          }), this.targetURI = t, this.event = s, void 0 === i.expires ? this.expires = 3600 : "number" != typeof i.expires ? (this.logger.warn('Option "expires" must be a number. Using default of 3600.'), this.expires = 3600) : this.expires = i.expires, this.extraHeaders = (i.extraHeaders || []).slice(), this.subscriberRequest = this.initSubscriberRequest(), this.outgoingRequestMessage = this.subscriberRequest.message, this.id = this.outgoingRequestMessage.callId + this.outgoingRequestMessage.from.parameters.tag + this.event, this._userAgent._subscriptions[this.id] = this;
        }

        dispose() {
          return this.disposed ? Promise.resolve() : (this.logger.log(`Subscription ${this.id} in state ${this.state} is being disposed`), delete this._userAgent._subscriptions[this.id], this.retryAfterTimer && (clearTimeout(this.retryAfterTimer), this.retryAfterTimer = void 0), this.subscriberRequest.dispose(), super.dispose().then(() => {
            if (this.state === d.SubscriptionState.Subscribed) {
              if (!this._dialog) throw new Error("Dialog undefined.");

              if (this._dialog.subscriptionState === n.SubscriptionState.Pending || this._dialog.subscriptionState === n.SubscriptionState.Active) {
                const e = this._dialog;
                return new Promise((t, s) => {
                  e.delegate = {
                    onTerminated: () => t()
                  }, e.unsubscribe();
                });
              }
            }
          }));
        }

        subscribe(e = {}) {
          switch (this.subscriberRequest.state) {
            case n.SubscriptionState.Initial:
              this.state === d.SubscriptionState.Initial && this.stateTransition(d.SubscriptionState.NotifyWait), this.subscriberRequest.subscribe().then(e => {
                e.success ? (e.success.subscription && (this._dialog = e.success.subscription, this._dialog.delegate = {
                  onNotify: e => this.onNotify(e),
                  onRefresh: e => this.onRefresh(e),
                  onTerminated: () => {
                    this.state !== d.SubscriptionState.Terminated && this.stateTransition(d.SubscriptionState.Terminated);
                  }
                }), this.onNotify(e.success.request)) : e.failure && this.unsubscribe();
              });
              break;

            case n.SubscriptionState.NotifyWait:
            case n.SubscriptionState.Pending:
              break;

            case n.SubscriptionState.Active:
              if (this._dialog) {
                this._dialog.refresh().delegate = {
                  onAccept: e => this.onAccepted(e),
                  onRedirect: e => this.unsubscribe(),
                  onReject: e => this.unsubscribe()
                };
              }

              break;

            case n.SubscriptionState.Terminated:
          }

          return Promise.resolve();
        }

        unsubscribe(e = {}) {
          if (this.disposed) return Promise.resolve();

          switch (this.subscriberRequest.state) {
            case n.SubscriptionState.Initial:
            case n.SubscriptionState.NotifyWait:
              break;

            case n.SubscriptionState.Pending:
            case n.SubscriptionState.Active:
              this._dialog && this._dialog.unsubscribe();
              break;

            case n.SubscriptionState.Terminated:
              break;

            default:
              throw new Error("Unknown state.");
          }

          return this.stateTransition(d.SubscriptionState.Terminated), Promise.resolve();
        }

        _refresh() {
          return this.subscriberRequest.state === n.SubscriptionState.Active ? this.subscribe() : Promise.resolve();
        }

        onAccepted(e) {}

        onNotify(e) {
          if (this.disposed) return void e.accept();

          if (this.state !== d.SubscriptionState.Subscribed && this.stateTransition(d.SubscriptionState.Subscribed), this.delegate && this.delegate.onNotify) {
            const t = new a.Notification(e);
            this.delegate.onNotify(t);
          } else e.accept();

          const t = e.message.parseHeader("Subscription-State");
          if (t && t.state) switch (t.state) {
            case "terminated":
              if (t.reason) switch (this.logger.log(`Terminated subscription with reason ${t.reason}`), t.reason) {
                case "deactivated":
                case "timeout":
                  return this.initSubscriberRequest(), void this.subscribe();

                case "probation":
                case "giveup":
                  return this.initSubscriberRequest(), void (t.params && t.params["retry-after"] ? this.retryAfterTimer = setTimeout(() => {
                    this.subscribe();
                  }, t.params["retry-after"]) : this.subscribe());
              }
              this.unsubscribe();
          }
        }

        onRefresh(e) {
          e.delegate = {
            onAccept: e => this.onAccepted(e)
          };
        }

        initSubscriberRequest() {
          const e = {
            extraHeaders: this.extraHeaders,
            body: this.body ? Object(i.fromBodyLegacy)(this.body) : void 0
          };
          return this.subscriberRequest = new u(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, e), this.subscriberRequest.delegate = {
            onAccept: e => this.onAccepted(e)
          }, this.subscriberRequest;
        }

      }

      class u {
        constructor(e, t, s, i, n, a) {
          this.core = e, this.target = t, this.event = s, this.expires = i, this.subscribed = !1, this.logger = e.loggerFactory.getLogger("sip.Subscriber"), this.delegate = a;
          const c = "Allow: " + o.AllowedMethods.toString(),
                d = (n && n.extraHeaders || []).slice();
          d.push(c), d.push("Event: " + this.event), d.push("Expires: " + this.expires), d.push("Contact: " + this.core.configuration.contact.toString());
          const l = n && n.body;
          this.message = e.makeOutgoingRequestMessage(r.C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, d, l);
        }

        dispose() {
          this.request && (this.request.waitNotifyStop(), this.request.dispose(), this.request = void 0);
        }

        get state() {
          return this.subscription ? this.subscription.subscriptionState : this.subscribed ? n.SubscriptionState.NotifyWait : n.SubscriptionState.Initial;
        }

        subscribe() {
          return this.subscribed ? Promise.reject(new Error("Not in initial state. Did you call subscribe more than once?")) : (this.subscribed = !0, new Promise(e => {
            if (!this.message) throw new Error("Message undefined.");
            this.request = this.core.subscribe(this.message, {
              onAccept: e => {
                this.delegate && this.delegate.onAccept && this.delegate.onAccept(e);
              },
              onNotify: t => {
                this.subscription = t.subscription, this.subscription && (this.subscription.autoRefresh = !0), e({
                  success: t
                });
              },
              onNotifyTimeout: () => {
                e({
                  failure: {}
                });
              },
              onRedirect: t => {
                e({
                  failure: {
                    response: t
                  }
                });
              },
              onReject: t => {
                e({
                  failure: {
                    response: t
                  }
                });
              }
            });
          }));
        }

      }
    },
    "./node_modules/sip.js/lib/api/subscription-delegate.js":
    /*!**************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscription-delegate.js ***!
      \**************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/subscription-options.js":
    /*!*************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscription-options.js ***!
      \*************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/subscription-state.js":
    /*!***********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscription-state.js ***!
      \***********************************************************/

    /*! exports provided: SubscriptionState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "SubscriptionState", function () {
        return i;
      }), function (e) {
        e.Initial = "Initial", e.NotifyWait = "NotifyWait", e.Subscribed = "Subscribed", e.Terminated = "Terminated";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/api/subscription-subscribe-options.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscription-subscribe-options.js ***!
      \***********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/subscription-unsubscribe-options.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscription-unsubscribe-options.js ***!
      \*************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/subscription.js":
    /*!*****************************************************!*\
      !*** ./node_modules/sip.js/lib/api/subscription.js ***!
      \*****************************************************/

    /*! exports provided: Subscription */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Subscription", function () {
        return n;
      });
      var i = s(
      /*! ./emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js"),
          r = s(
      /*! ./subscription-state.js */
      "./node_modules/sip.js/lib/api/subscription-state.js");

      class n {
        constructor(e, t = {}) {
          this._disposed = !1, this._state = r.SubscriptionState.Initial, this._logger = e.getLogger("sip.Subscription"), this._stateEventEmitter = new i.EmitterImpl(), this._userAgent = e, this.delegate = t.delegate;
        }

        dispose() {
          return this._disposed ? Promise.resolve() : (this._disposed = !0, this._stateEventEmitter.removeAllListeners(), Promise.resolve());
        }

        get dialog() {
          return this._dialog;
        }

        get disposed() {
          return this._disposed;
        }

        get state() {
          return this._state;
        }

        get stateChange() {
          return this._stateEventEmitter;
        }

        stateTransition(e) {
          const t = () => {
            throw new Error(`Invalid state transition from ${this._state} to ${e}`);
          };

          switch (this._state) {
            case r.SubscriptionState.Initial:
              e !== r.SubscriptionState.NotifyWait && e !== r.SubscriptionState.Terminated && t();
              break;

            case r.SubscriptionState.NotifyWait:
              e !== r.SubscriptionState.Subscribed && e !== r.SubscriptionState.Terminated && t();
              break;

            case r.SubscriptionState.Subscribed:
              e !== r.SubscriptionState.Terminated && t();
              break;

            case r.SubscriptionState.Terminated:
              t();
              break;

            default:
              throw new Error("Unrecognized state.");
          }

          this._state !== e && (this._state = e, this._logger.log(`Subscription ${this._dialog ? this._dialog.id : void 0} transitioned to ${this._state}`), this._stateEventEmitter.emit(this._state), e === r.SubscriptionState.Terminated && this.dispose());
        }

      }
    },
    "./node_modules/sip.js/lib/api/transport-state.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/transport-state.js ***!
      \********************************************************/

    /*! exports provided: TransportState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "TransportState", function () {
        return i;
      }), function (e) {
        e.Connecting = "Connecting", e.Connected = "Connected", e.Disconnecting = "Disconnecting", e.Disconnected = "Disconnected";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/api/transport.js":
    /*!**************************************************!*\
      !*** ./node_modules/sip.js/lib/api/transport.js ***!
      \**************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/user-agent-delegate.js":
    /*!************************************************************!*\
      !*** ./node_modules/sip.js/lib/api/user-agent-delegate.js ***!
      \************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/api/user-agent-options.js":
    /*!***********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/user-agent-options.js ***!
      \***********************************************************/

    /*! exports provided: SIPExtension, UserAgentRegisteredOptionTags */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "SIPExtension", function () {
        return i;
      }), s.d(t, "UserAgentRegisteredOptionTags", function () {
        return r;
      }), function (e) {
        e.Required = "Required", e.Supported = "Supported", e.Unsupported = "Unsupported";
      }(i = i || (i = {}));
      const r = {
        "100rel": !0,
        199: !0,
        answermode: !0,
        "early-session": !0,
        eventlist: !0,
        explicitsub: !0,
        "from-change": !0,
        "geolocation-http": !0,
        "geolocation-sip": !0,
        gin: !0,
        gruu: !0,
        histinfo: !0,
        ice: !0,
        join: !0,
        "multiple-refer": !0,
        norefersub: !0,
        nosub: !0,
        outbound: !0,
        path: !0,
        policy: !0,
        precondition: !0,
        pref: !0,
        privacy: !0,
        "recipient-list-invite": !0,
        "recipient-list-message": !0,
        "recipient-list-subscribe": !0,
        replaces: !0,
        "resource-priority": !0,
        "sdp-anat": !0,
        "sec-agree": !0,
        tdialog: !0,
        timer: !0,
        uui: !0
      };
    },
    "./node_modules/sip.js/lib/api/user-agent-state.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/api/user-agent-state.js ***!
      \*********************************************************/

    /*! exports provided: UserAgentState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "UserAgentState", function () {
        return i;
      }), function (e) {
        e.Started = "Started", e.Stopped = "Stopped";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/api/user-agent.js":
    /*!***************************************************!*\
      !*** ./node_modules/sip.js/lib/api/user-agent.js ***!
      \***************************************************/

    /*! exports provided: UserAgent */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "UserAgent", function () {
        return y;
      });
      var i = s(
      /*! ../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ../grammar/uri.js */
      "./node_modules/sip.js/lib/grammar/uri.js"),
          n = s(
      /*! ../core/messages/digest-authentication.js */
      "./node_modules/sip.js/lib/core/messages/digest-authentication.js"),
          o = s(
      /*! ../core/messages/incoming-request-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-request-message.js"),
          a = s(
      /*! ../core/messages/incoming-response-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response-message.js"),
          c = s(
      /*! ../core/log/levels.js */
      "./node_modules/sip.js/lib/core/log/levels.js"),
          d = s(
      /*! ../core/log/logger-factory.js */
      "./node_modules/sip.js/lib/core/log/logger-factory.js"),
          l = s(
      /*! ../core/messages/parser.js */
      "./node_modules/sip.js/lib/core/messages/parser.js"),
          u = s(
      /*! ../core/user-agent-core/user-agent-core.js */
      "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js"),
          h = s(
      /*! ../core/messages/utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js"),
          g = s(
      /*! ../platform/web/session-description-handler/session-description-handler-factory-default.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-default.js"),
          p = s(
      /*! ../platform/web/transport/transport.js */
      "./node_modules/sip.js/lib/platform/web/transport/transport.js"),
          m = s(
      /*! ../version.js */
      "./node_modules/sip.js/lib/version.js"),
          f = s(
      /*! ./emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js"),
          v = s(
      /*! ./invitation.js */
      "./node_modules/sip.js/lib/api/invitation.js"),
          b = s(
      /*! ./inviter.js */
      "./node_modules/sip.js/lib/api/inviter.js"),
          S = s(
      /*! ./message.js */
      "./node_modules/sip.js/lib/api/message.js"),
          j = s(
      /*! ./notification.js */
      "./node_modules/sip.js/lib/api/notification.js"),
          w = s(
      /*! ./user-agent-options.js */
      "./node_modules/sip.js/lib/api/user-agent-options.js"),
          T = s(
      /*! ./user-agent-state.js */
      "./node_modules/sip.js/lib/api/user-agent-state.js");

      class y {
        constructor(e = {}) {
          if (this._publishers = {}, this._registerers = {}, this._sessions = {}, this._subscriptions = {}, this._state = T.UserAgentState.Stopped, this._stateEventEmitter = new f.EmitterImpl(), this.delegate = e.delegate, this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, y.defaultOptions()), {
            sipjsId: Object(h.createRandomToken)(5)
          }), {
            uri: new r.URI("sip", "anonymous." + Object(h.createRandomToken)(6), "anonymous.invalid")
          }), {
            viaHost: Object(h.createRandomToken)(12) + ".invalid"
          }), y.stripUndefinedProperties(e)), this.options.hackIpInContact) if ("boolean" == typeof this.options.hackIpInContact && this.options.hackIpInContact) {
            const e = 1,
                  t = 254,
                  s = Math.floor(Math.random() * (t - e + 1) + e);
            this.options.viaHost = "192.0.2." + s;
          } else this.options.hackIpInContact && (this.options.viaHost = this.options.hackIpInContact);

          switch (this.loggerFactory = new d.LoggerFactory(), this.logger = this.loggerFactory.getLogger("sip.UserAgent"), this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled, this.loggerFactory.connector = this.options.logConnector, this.options.logLevel) {
            case "error":
              this.loggerFactory.level = c.Levels.error;
              break;

            case "warn":
              this.loggerFactory.level = c.Levels.warn;
              break;

            case "log":
              this.loggerFactory.level = c.Levels.log;
              break;

            case "debug":
              this.loggerFactory.level = c.Levels.debug;
          }

          if (this.options.logConfiguration && (this.logger.log("Configuration:"), Object.keys(this.options).forEach(e => {
            const t = this.options[e];

            switch (e) {
              case "uri":
              case "sessionDescriptionHandlerFactory":
                this.logger.log(" " + e + ": " + t);
                break;

              case "authorizationPassword":
                this.logger.log(" " + e + ": NOT SHOWN");
                break;

              case "transportConstructor":
                this.logger.log(" " + e + ": " + t.name);
                break;

              default:
                this.logger.log(" " + e + ": " + JSON.stringify(t));
            }
          })), this.options.transportOptions) {
            const t = this.options.transportOptions,
                  s = t.maxReconnectionAttempts,
                  i = t.reconnectionTimeout;

            if (void 0 !== s) {
              const e = 'The transport option "maxReconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.';
              this.logger.warn(e);
            }

            if (void 0 !== i) {
              const e = 'The transport option "reconnectionTimeout" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.';
              this.logger.warn(e);
            }

            void 0 === e.reconnectionDelay && void 0 !== i && (this.options.reconnectionDelay = i), void 0 === e.reconnectionAttempts && void 0 !== s && (this.options.reconnectionAttempts = s);
          }

          if (void 0 !== e.reconnectionDelay) {
            const e = 'The user agent option "reconnectionDelay" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.';
            this.logger.warn(e);
          }

          if (void 0 !== e.reconnectionAttempts) {
            const e = 'The user agent option "reconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.';
            this.logger.warn(e);
          }

          if (this._transport = new this.options.transportConstructor(this.getLogger("sip.Transport"), this.options.transportOptions), this.initTransportCallbacks(), this._contact = this.initContact(), this._instanceId = this.options.instanceId ? this.options.instanceId : y.newUUID(), -1 === i.Grammar.parse(this._instanceId, "uuid")) throw new Error("Invalid instanceId.");
          this._userAgentCore = this.initCore();
        }

        static makeURI(e) {
          return i.Grammar.URIParse(e);
        }

        static defaultOptions() {
          return {
            allowLegacyNotifications: !1,
            authorizationHa1: "",
            authorizationPassword: "",
            authorizationUsername: "",
            delegate: {},
            contactName: "",
            contactParams: {
              transport: "ws"
            },
            displayName: "",
            forceRport: !1,
            gracefulShutdown: !0,
            hackAllowUnregisteredOptionTags: !1,
            hackIpInContact: !1,
            hackViaTcp: !1,
            instanceId: "",
            instanceIdAlwaysAdded: !1,
            logBuiltinEnabled: !0,
            logConfiguration: !0,
            logConnector: () => {},
            logLevel: "log",
            noAnswerTimeout: 60,
            preloadedRouteSet: [],
            reconnectionAttempts: 0,
            reconnectionDelay: 4,
            sendInitialProvisionalResponse: !0,
            sessionDescriptionHandlerFactory: Object(g.defaultSessionDescriptionHandlerFactory)(),
            sessionDescriptionHandlerFactoryOptions: {},
            sipExtension100rel: w.SIPExtension.Unsupported,
            sipExtensionReplaces: w.SIPExtension.Unsupported,
            sipExtensionExtraSupported: [],
            sipjsId: "",
            transportConstructor: p.Transport,
            transportOptions: {},
            uri: new r.URI("sip", "anonymous", "anonymous.invalid"),
            userAgentString: "SIP.js/" + m.LIBRARY_VERSION,
            viaHost: ""
          };
        }

        static newUUID() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => {
            const t = Math.floor(16 * Math.random());
            return ("x" === e ? t : t % 4 + 8).toString(16);
          });
        }

        static stripUndefinedProperties(e) {
          return Object.keys(e).reduce((t, s) => (void 0 !== e[s] && (t[s] = e[s]), t), {});
        }

        get configuration() {
          return this.options;
        }

        get contact() {
          return this._contact;
        }

        get instanceId() {
          return this._instanceId;
        }

        get state() {
          return this._state;
        }

        get stateChange() {
          return this._stateEventEmitter;
        }

        get transport() {
          return this._transport;
        }

        get userAgentCore() {
          return this._userAgentCore;
        }

        getLogger(e, t) {
          return this.loggerFactory.getLogger(e, t);
        }

        getLoggerFactory() {
          return this.loggerFactory;
        }

        isConnected() {
          return this.transport.isConnected();
        }

        reconnect() {
          return this.state === T.UserAgentState.Stopped ? Promise.reject(new Error("User agent stopped.")) : Promise.resolve().then(() => this.transport.connect());
        }

        start() {
          return this.state === T.UserAgentState.Started ? (this.logger.warn("User agent already started"), Promise.resolve()) : (this.logger.log(`Starting ${this.configuration.uri}`), this.transitionState(T.UserAgentState.Started), this.transport.connect());
        }

        async stop() {
          if (this.state === T.UserAgentState.Stopped) return this.logger.warn("User agent already stopped"), Promise.resolve();
          if (this.logger.log(`Stopping ${this.configuration.uri}`), !this.options.gracefulShutdown) return this.logger.log("Dispose of transport"), this.transport.dispose().catch(e => {
            throw this.logger.error(e.message), e;
          }), this.logger.log("Dispose of core"), this.userAgentCore.dispose(), this._publishers = {}, this._registerers = {}, this._sessions = {}, this._subscriptions = {}, this.transitionState(T.UserAgentState.Stopped), Promise.resolve();
          const e = Object.assign({}, this._publishers),
                t = Object.assign({}, this._registerers),
                s = Object.assign({}, this._sessions),
                i = Object.assign({}, this._subscriptions),
                r = this.transport,
                n = this.userAgentCore;
          this.logger.log("Dispose of registerers");

          for (const e in t) t[e] && (await t[e].dispose().catch(t => {
            throw this.logger.error(t.message), delete this._registerers[e], t;
          }));

          this.logger.log("Dispose of sessions");

          for (const e in s) s[e] && (await s[e].dispose().catch(t => {
            throw this.logger.error(t.message), delete this._sessions[e], t;
          }));

          this.logger.log("Dispose of subscriptions");

          for (const e in i) i[e] && (await i[e].dispose().catch(t => {
            throw this.logger.error(t.message), delete this._subscriptions[e], t;
          }));

          this.logger.log("Dispose of publishers");

          for (const t in e) e[t] && (await e[t].dispose().catch(e => {
            throw this.logger.error(e.message), delete this._publishers[t], e;
          }));

          this.logger.log("Dispose of transport"), await r.dispose().catch(e => {
            throw this.logger.error(e.message), e;
          }), this.logger.log("Dispose of core"), n.dispose(), this.transitionState(T.UserAgentState.Stopped);
        }

        _makeInviter(e, t) {
          return new b.Inviter(this, e, t);
        }

        attemptReconnection(e = 1) {
          const t = this.options.reconnectionAttempts,
                s = this.options.reconnectionDelay;
          e > t ? this.logger.log("Maximum reconnection attempts reached") : (this.logger.log(`Reconnection attempt ${e} of ${t} - trying`), setTimeout(() => {
            this.reconnect().then(() => {
              this.logger.log(`Reconnection attempt ${e} of ${t} - succeeded`);
            }).catch(s => {
              this.logger.error(s.message), this.logger.log(`Reconnection attempt ${e} of ${t} - failed`), this.attemptReconnection(++e);
            });
          }, 1 === e ? 0 : 1e3 * s));
        }

        initContact() {
          const e = "" !== this.options.contactName ? this.options.contactName : Object(h.createRandomToken)(8),
                t = this.options.contactParams;
          return {
            pubGruu: void 0,
            tempGruu: void 0,
            uri: new r.URI("sip", e, this.options.viaHost, void 0, t),
            toString: (e = {}) => {
              const s = e.anonymous || !1,
                    i = e.outbound || !1,
                    r = e.register || !1;
              let n = "<";
              return n += s ? this.contact.tempGruu || `sip:anonymous@anonymous.invalid;transport=${t.transport ? t.transport : "ws"}` : r ? this.contact.uri : this.contact.pubGruu || this.contact.uri, i && (n += ";ob"), n += ">", this.options.instanceIdAlwaysAdded && (n += ';+sip.instance="<urn:uuid:' + this._instanceId + '>"'), n;
            }
          };
        }

        initCore() {
          let e = [];
          e.push("outbound"), this.options.sipExtension100rel === w.SIPExtension.Supported && e.push("100rel"), this.options.sipExtensionReplaces === w.SIPExtension.Supported && e.push("replaces"), this.options.sipExtensionExtraSupported && e.push(...this.options.sipExtensionExtraSupported), this.options.hackAllowUnregisteredOptionTags || (e = e.filter(e => w.UserAgentRegisteredOptionTags[e]));
          const t = (e = Array.from(new Set(e))).slice();
          (this.contact.pubGruu || this.contact.tempGruu) && t.push("gruu");
          const s = {
            aor: this.options.uri,
            contact: this.contact,
            displayName: this.options.displayName,
            loggerFactory: this.loggerFactory,
            hackViaTcp: this.options.hackViaTcp,
            routeSet: this.options.preloadedRouteSet,
            supportedOptionTags: e,
            supportedOptionTagsResponse: t,
            sipjsId: this.options.sipjsId,
            userAgentHeaderFieldValue: this.options.userAgentString,
            viaForceRport: this.options.forceRport,
            viaHost: this.options.viaHost,
            authenticationFactory: () => {
              const e = this.options.authorizationUsername ? this.options.authorizationUsername : this.options.uri.user,
                    t = this.options.authorizationPassword ? this.options.authorizationPassword : void 0,
                    s = this.options.authorizationHa1 ? this.options.authorizationHa1 : void 0;
              return new n.DigestAuthentication(this.getLoggerFactory(), s, e, t);
            },
            transportAccessor: () => this.transport
          },
                i = {
            onInvite: e => {
              var t;
              const s = new v.Invitation(this, e);

              if (e.delegate = {
                onCancel: e => {
                  s._onCancel(e);
                },
                onTransportError: e => {
                  this.logger.error("A transport error has occurred while handling an incoming INVITE request.");
                }
              }, e.trying(), this.options.sipExtensionReplaces !== w.SIPExtension.Unsupported) {
                const t = e.message.parseHeader("replaces");

                if (t) {
                  const e = t.call_id;
                  if ("string" != typeof e) throw new Error("Type of call id is not string");
                  const i = t.replaces_to_tag;
                  if ("string" != typeof i) throw new Error("Type of to tag is not string");
                  const r = t.replaces_from_tag;
                  if ("string" != typeof r) throw new Error("type of from tag is not string");
                  const n = e + i + r,
                        o = this.userAgentCore.dialogs.get(n);
                  if (!o) return void s.reject({
                    statusCode: 481
                  });
                  if (!o.early && !0 === t.early_only) return void s.reject({
                    statusCode: 486
                  });
                  const a = this._sessions[e + r] || this._sessions[e + i] || void 0;
                  if (!a) throw new Error("Session does not exist.");
                  s._replacee = a;
                }
              }

              if (null === (t = this.delegate) || void 0 === t ? void 0 : t.onInvite) return s.autoSendAnInitialProvisionalResponse ? void s.progress().then(() => {
                var e;
                if (void 0 === (null === (e = this.delegate) || void 0 === e ? void 0 : e.onInvite)) throw new Error("onInvite undefined.");
                this.delegate.onInvite(s);
              }) : void this.delegate.onInvite(s);
              s.reject({
                statusCode: 486
              });
            },
            onMessage: e => {
              if (this.delegate && this.delegate.onMessage) {
                const t = new S.Message(e);
                this.delegate.onMessage(t);
              } else e.accept();
            },
            onNotify: e => {
              if (this.delegate && this.delegate.onNotify) {
                const t = new j.Notification(e);
                this.delegate.onNotify(t);
              } else this.options.allowLegacyNotifications ? e.accept() : e.reject({
                statusCode: 481
              });
            },
            onRefer: e => {
              this.logger.warn("Received an out of dialog REFER request"), this.delegate && this.delegate.onReferRequest ? this.delegate.onReferRequest(e) : e.reject({
                statusCode: 405
              });
            },
            onRegister: e => {
              this.logger.warn("Received an out of dialog REGISTER request"), this.delegate && this.delegate.onRegisterRequest ? this.delegate.onRegisterRequest(e) : e.reject({
                statusCode: 405
              });
            },
            onSubscribe: e => {
              this.logger.warn("Received an out of dialog SUBSCRIBE request"), this.delegate && this.delegate.onSubscribeRequest ? this.delegate.onSubscribeRequest(e) : e.reject({
                statusCode: 405
              });
            }
          };
          return new u.UserAgentCore(s, i);
        }

        initTransportCallbacks() {
          this.transport.onConnect = () => this.onTransportConnect(), this.transport.onDisconnect = e => this.onTransportDisconnect(e), this.transport.onMessage = e => this.onTransportMessage(e);
        }

        onTransportConnect() {
          this.state !== T.UserAgentState.Stopped && this.delegate && this.delegate.onConnect && this.delegate.onConnect();
        }

        onTransportDisconnect(e) {
          this.state !== T.UserAgentState.Stopped && (this.delegate && this.delegate.onDisconnect && this.delegate.onDisconnect(e), e && this.options.reconnectionAttempts > 0 && this.attemptReconnection());
        }

        onTransportMessage(e) {
          const t = l.Parser.parseMessage(e, this.getLogger("sip.Parser"));
          if (!t) return void this.logger.warn("Failed to parse incoming message. Dropping.");
          if (this.state === T.UserAgentState.Stopped && t instanceof o.IncomingRequestMessage) return void this.logger.warn(`Received ${t.method} request while stopped. Dropping.`);

          const s = () => {
            const e = ["from", "to", "call_id", "cseq", "via"];

            for (const s of e) if (!t.hasHeader(s)) return this.logger.warn(`Missing mandatory header field : ${s}.`), !1;

            return !0;
          };

          if (t instanceof o.IncomingRequestMessage) {
            if (!s()) return void this.logger.warn("Request missing mandatory header field. Dropping.");
            if (!t.toTag && t.callId.substr(0, 5) === this.options.sipjsId) return void this.userAgentCore.replyStateless(t, {
              statusCode: 482
            });
            const e = Object(h.utf8Length)(t.body),
                  i = t.getHeader("content-length");
            if (i && e < Number(i)) return void this.userAgentCore.replyStateless(t, {
              statusCode: 400
            });
          }

          if (t instanceof a.IncomingResponseMessage) {
            if (!s()) return void this.logger.warn("Response missing mandatory header field. Dropping.");
            if (t.getHeaders("via").length > 1) return void this.logger.warn("More than one Via header field present in the response. Dropping.");
            if (t.via.host !== this.options.viaHost || void 0 !== t.via.port) return void this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
            const e = Object(h.utf8Length)(t.body),
                  i = t.getHeader("content-length");
            if (i && e < Number(i)) return void this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
          }

          if (t instanceof o.IncomingRequestMessage) this.userAgentCore.receiveIncomingRequestFromTransport(t);else {
            if (!(t instanceof a.IncomingResponseMessage)) throw new Error("Invalid message type.");
            this.userAgentCore.receiveIncomingResponseFromTransport(t);
          }
        }

        transitionState(e, t) {
          const s = () => {
            throw new Error(`Invalid state transition from ${this._state} to ${e}`);
          };

          switch (this._state) {
            case T.UserAgentState.Started:
              e !== T.UserAgentState.Stopped && s();
              break;

            case T.UserAgentState.Stopped:
              e !== T.UserAgentState.Started && s();
              break;

            default:
              throw new Error("Unknown state.");
          }

          this.logger.log(`Transitioned from ${this._state} to ${e}`), this._state = e, this._stateEventEmitter.emit(this._state);
        }

      }
    },
    "./node_modules/sip.js/lib/core/dialogs/dialog-state.js":
    /*!**************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/dialogs/dialog-state.js ***!
      \**************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/dialogs/dialog.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/dialogs/dialog.js ***!
      \********************************************************/

    /*! exports provided: Dialog */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Dialog", function () {
        return n;
      });
      var i = s(
      /*! ../../grammar/name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js"),
          r = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js");

      class n {
        constructor(e, t) {
          this.core = e, this.dialogState = t, this.core.dialogs.set(this.id, this);
        }

        static initialDialogStateForUserAgentClient(e, t) {
          const s = t.getHeaders("record-route").reverse(),
                r = t.parseHeader("contact");
          if (!r) throw new Error("Contact undefined.");
          if (!(r instanceof i.NameAddrHeader)) throw new Error("Contact not instance of NameAddrHeader.");
          const n = r.uri,
                o = e.cseq,
                a = e.callId,
                c = e.fromTag,
                d = t.toTag;
          if (!a) throw new Error("Call id undefined.");
          if (!c) throw new Error("From tag undefined.");
          if (!d) throw new Error("To tag undefined.");
          if (!e.from) throw new Error("From undefined.");
          if (!e.to) throw new Error("To undefined.");
          const l = e.from.uri,
                u = e.to.uri;
          if (!t.statusCode) throw new Error("Incoming response status code undefined.");
          return {
            id: a + c + d,
            early: t.statusCode < 200,
            callId: a,
            localTag: c,
            remoteTag: d,
            localSequenceNumber: o,
            remoteSequenceNumber: void 0,
            localURI: l,
            remoteURI: u,
            remoteTarget: n,
            routeSet: s,
            secure: !1
          };
        }

        static initialDialogStateForUserAgentServer(e, t, s = !1) {
          const r = e.getHeaders("record-route"),
                n = e.parseHeader("contact");
          if (!n) throw new Error("Contact undefined.");
          if (!(n instanceof i.NameAddrHeader)) throw new Error("Contact not instance of NameAddrHeader.");
          const o = n.uri,
                a = e.cseq,
                c = e.callId,
                d = t,
                l = e.fromTag,
                u = e.from.uri;
          return {
            id: c + d + l,
            early: s,
            callId: c,
            localTag: d,
            remoteTag: l,
            localSequenceNumber: void 0,
            remoteSequenceNumber: a,
            localURI: e.to.uri,
            remoteURI: u,
            remoteTarget: o,
            routeSet: r,
            secure: !1
          };
        }

        dispose() {
          this.core.dialogs.delete(this.id);
        }

        get id() {
          return this.dialogState.id;
        }

        get early() {
          return this.dialogState.early;
        }

        get callId() {
          return this.dialogState.callId;
        }

        get localTag() {
          return this.dialogState.localTag;
        }

        get remoteTag() {
          return this.dialogState.remoteTag;
        }

        get localSequenceNumber() {
          return this.dialogState.localSequenceNumber;
        }

        get remoteSequenceNumber() {
          return this.dialogState.remoteSequenceNumber;
        }

        get localURI() {
          return this.dialogState.localURI;
        }

        get remoteURI() {
          return this.dialogState.remoteURI;
        }

        get remoteTarget() {
          return this.dialogState.remoteTarget;
        }

        get routeSet() {
          return this.dialogState.routeSet;
        }

        get secure() {
          return this.dialogState.secure;
        }

        get userAgentCore() {
          return this.core;
        }

        confirm() {
          this.dialogState.early = !1;
        }

        receiveRequest(e) {
          if (e.method !== r.C.ACK) {
            if (this.remoteSequenceNumber) {
              if (e.cseq <= this.remoteSequenceNumber) throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
              this.dialogState.remoteSequenceNumber = e.cseq;
            }

            this.remoteSequenceNumber || (this.dialogState.remoteSequenceNumber = e.cseq);
          }
        }

        recomputeRouteSet(e) {
          this.dialogState.routeSet = e.getHeaders("record-route").reverse();
        }

        createOutgoingRequestMessage(e, t) {
          const s = this.remoteURI,
                i = this.remoteTag,
                r = this.localURI,
                n = this.localTag,
                o = this.callId;
          let a;
          a = t && t.cseq ? t.cseq : this.dialogState.localSequenceNumber ? this.dialogState.localSequenceNumber += 1 : this.dialogState.localSequenceNumber = 1;
          const c = this.remoteTarget,
                d = this.routeSet,
                l = t && t.extraHeaders,
                u = t && t.body;
          return this.userAgentCore.makeOutgoingRequestMessage(e, c, r, s, {
            callId: o,
            cseq: a,
            fromTag: n,
            toTag: i,
            routeSet: d
          }, l, u);
        }

        incrementLocalSequenceNumber() {
          if (!this.dialogState.localSequenceNumber) throw new Error("Local sequence number undefined.");
          this.dialogState.localSequenceNumber += 1;
        }

        sequenceGuard(e) {
          return e.method === r.C.ACK || !(this.remoteSequenceNumber && e.cseq <= this.remoteSequenceNumber) || (this.core.replyStateless(e, {
            statusCode: 500
          }), !1);
        }

      }
    },
    "./node_modules/sip.js/lib/core/dialogs/index.js":
    /*!*******************************************************!*\
      !*** ./node_modules/sip.js/lib/core/dialogs/index.js ***!
      \*******************************************************/

    /*! exports provided: Dialog, SessionDialog, SubscriptionDialog */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/dialog.js");
      s.d(t, "Dialog", function () {
        return i.Dialog;
      });
      s(
      /*! ./dialog-state.js */
      "./node_modules/sip.js/lib/core/dialogs/dialog-state.js");
      var r = s(
      /*! ./session-dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/session-dialog.js");
      s.d(t, "SessionDialog", function () {
        return r.SessionDialog;
      });
      var n = s(
      /*! ./subscription-dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js");
      s.d(t, "SubscriptionDialog", function () {
        return n.SubscriptionDialog;
      });
    },
    "./node_modules/sip.js/lib/core/dialogs/session-dialog.js":
    /*!****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/dialogs/session-dialog.js ***!
      \****************************************************************/

    /*! exports provided: SessionDialog */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SessionDialog", function () {
        return A;
      });

      var i = s(
      /*! ../../grammar/name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js"),
          r = s(
      /*! ../messages/body.js */
      "./node_modules/sip.js/lib/core/messages/body.js"),
          n = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          o = s(
      /*! ../messages/incoming-request-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-request-message.js"),
          a = s(
      /*! ../messages/incoming-response-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response-message.js"),
          c = s(
      /*! ../messages/outgoing-request-message.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js"),
          d = s(
      /*! ../session/session.js */
      "./node_modules/sip.js/lib/core/session/session.js"),
          l = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          u = s(
      /*! ../transactions/invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"),
          h = s(
      /*! ../transactions/invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"),
          g = s(
      /*! ../transactions/transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js"),
          p = s(
      /*! ../user-agents/bye-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js"),
          m = s(
      /*! ../user-agents/bye-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js"),
          f = s(
      /*! ../user-agents/info-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js"),
          v = s(
      /*! ../user-agents/info-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js"),
          b = s(
      /*! ../user-agents/message-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js"),
          S = s(
      /*! ../user-agents/message-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js"),
          j = s(
      /*! ../user-agents/notify-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js"),
          w = s(
      /*! ../user-agents/notify-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js"),
          T = s(
      /*! ../user-agents/prack-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js"),
          y = s(
      /*! ../user-agents/prack-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js"),
          _ = s(
      /*! ../user-agents/re-invite-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js"),
          R = s(
      /*! ../user-agents/re-invite-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js"),
          C = s(
      /*! ../user-agents/refer-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js"),
          E = s(
      /*! ../user-agents/refer-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js"),
          I = s(
      /*! ./dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/dialog.js");

      class A extends I.Dialog {
        constructor(e, t, s, i) {
          super(t, s), this.initialTransaction = e, this._signalingState = d.SignalingState.Initial, this.ackWait = !1, this.ackProcessing = !1, this.delegate = i, e instanceof h.InviteServerTransaction && (this.ackWait = !0), this.early || this.start2xxRetransmissionTimer(), this.signalingStateTransition(e.request), this.logger = t.loggerFactory.getLogger("sip.invite-dialog"), this.logger.log(`INVITE dialog ${this.id} constructed`);
        }

        dispose() {
          super.dispose(), this._signalingState = d.SignalingState.Closed, this._offer = void 0, this._answer = void 0, this.invite2xxTimer && (clearTimeout(this.invite2xxTimer), this.invite2xxTimer = void 0), this.logger.log(`INVITE dialog ${this.id} destroyed`);
        }

        get sessionState() {
          return this.early ? d.SessionState.Early : this.ackWait ? d.SessionState.AckWait : this._signalingState === d.SignalingState.Closed ? d.SessionState.Terminated : d.SessionState.Confirmed;
        }

        get signalingState() {
          return this._signalingState;
        }

        get offer() {
          return this._offer;
        }

        get answer() {
          return this._answer;
        }

        confirm() {
          this.early && this.start2xxRetransmissionTimer(), super.confirm();
        }

        reConfirm() {
          this.reinviteUserAgentServer && this.startReInvite2xxRetransmissionTimer();
        }

        ack(e = {}) {
          let t;

          if (this.logger.log(`INVITE dialog ${this.id} sending ACK request`), this.reinviteUserAgentClient) {
            if (!(this.reinviteUserAgentClient.transaction instanceof u.InviteClientTransaction)) throw new Error("Transaction not instance of InviteClientTransaction.");
            t = this.reinviteUserAgentClient.transaction, this.reinviteUserAgentClient = void 0;
          } else {
            if (!(this.initialTransaction instanceof u.InviteClientTransaction)) throw new Error("Initial transaction not instance of InviteClientTransaction.");
            t = this.initialTransaction;
          }

          const s = this.createOutgoingRequestMessage(n.C.ACK, {
            cseq: t.request.cseq,
            extraHeaders: e.extraHeaders,
            body: e.body
          });
          return t.ackResponse(s), this.signalingStateTransition(s), {
            message: s
          };
        }

        bye(e, t) {
          if (this.logger.log(`INVITE dialog ${this.id} sending BYE request`), this.initialTransaction instanceof h.InviteServerTransaction) {
            if (this.early) throw new Error("UAS MUST NOT send a BYE on early dialogs.");
            if (this.ackWait && this.initialTransaction.state !== g.TransactionState.Terminated) throw new Error("UAS MUST NOT send a BYE on a confirmed dialog until it has received an ACK for its 2xx response or until the server transaction times out.");
          }

          return new p.ByeUserAgentClient(this, e, t);
        }

        info(e, t) {
          if (this.logger.log(`INVITE dialog ${this.id} sending INFO request`), this.early) throw new Error("Dialog not confirmed.");
          return new f.InfoUserAgentClient(this, e, t);
        }

        invite(e, t) {
          if (this.logger.log(`INVITE dialog ${this.id} sending INVITE request`), this.early) throw new Error("Dialog not confirmed.");
          if (this.reinviteUserAgentClient) throw new Error("There is an ongoing re-INVITE client transaction.");
          if (this.reinviteUserAgentServer) throw new Error("There is an ongoing re-INVITE server transaction.");
          return new _.ReInviteUserAgentClient(this, e, t);
        }

        message(e, t) {
          if (this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`), this.early) throw new Error("Dialog not confirmed.");
          const s = this.createOutgoingRequestMessage(n.C.MESSAGE, t);
          return new b.MessageUserAgentClient(this.core, s, e);
        }

        notify(e, t) {
          if (this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`), this.early) throw new Error("Dialog not confirmed.");
          return new j.NotifyUserAgentClient(this, e, t);
        }

        prack(e, t) {
          return this.logger.log(`INVITE dialog ${this.id} sending PRACK request`), new T.PrackUserAgentClient(this, e, t);
        }

        refer(e, t) {
          if (this.logger.log(`INVITE dialog ${this.id} sending REFER request`), this.early) throw new Error("Dialog not confirmed.");
          return new C.ReferUserAgentClient(this, e, t);
        }

        receiveRequest(e) {
          if (this.logger.log(`INVITE dialog ${this.id} received ${e.method} request`), e.method !== n.C.ACK) {
            if (this.sequenceGuard(e)) {
              if (super.receiveRequest(e), e.method === n.C.INVITE) {
                const t = () => {
                  const e = this.ackWait ? "waiting for initial ACK" : "processing initial ACK";
                  this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${e}`);
                  let t = "RFC 5407 suggests the following to avoid this race condition... ";
                  t += " Note: Implementation issues are outside the scope of this document,", t += " but the following tip is provided for avoiding race conditions of", t += " this type.  The caller can delay sending re-INVITE F6 for some period", t += " of time (2 seconds, perhaps), after which the caller can reasonably", t += " assume that its ACK has been received.  Implementors can decouple the", t += " actions of the user (e.g., pressing the hold button) from the actions", t += " of the protocol (the sending of re-INVITE F6), so that the UA can", t += " behave like this.  In this case, it is the implementor's choice as to", t += " how long to wait.  In most cases, such an implementation may be", t += " useful to prevent the type of race condition shown in this section.", t += " This document expresses no preference about whether or not they", t += " should wait for an ACK to be delivered.  After considering the impact", t += " on user experience, implementors should decide whether or not to wait", t += " for a while, because the user experience depends on the", t += " implementation and has no direct bearing on protocol behavior.", this.logger.warn("RFC 5407 suggests the following to avoid this race condition...  Note: Implementation issues are outside the scope of this document, but the following tip is provided for avoiding race conditions of this type.  The caller can delay sending re-INVITE F6 for some period of time (2 seconds, perhaps), after which the caller can reasonably assume that its ACK has been received.  Implementors can decouple the actions of the user (e.g., pressing the hold button) from the actions of the protocol (the sending of re-INVITE F6), so that the UA can behave like this.  In this case, it is the implementor's choice as to how long to wait.  In most cases, such an implementation may be useful to prevent the type of race condition shown in this section. This document expresses no preference about whether or not they should wait for an ACK to be delivered.  After considering the impact on user experience, implementors should decide whether or not to wait for a while, because the user experience depends on the implementation and has no direct bearing on protocol behavior.");
                },
                      s = [`Retry-After: ${Math.floor(10 * Math.random()) + 1}`];

                if (this.ackProcessing) return this.core.replyStateless(e, {
                  statusCode: 500,
                  extraHeaders: s
                }), void t();
                if (this.ackWait && this.signalingState !== d.SignalingState.Stable) return this.core.replyStateless(e, {
                  statusCode: 500,
                  extraHeaders: s
                }), void t();
                if (this.reinviteUserAgentServer) return void this.core.replyStateless(e, {
                  statusCode: 500,
                  extraHeaders: s
                });
                if (this.reinviteUserAgentClient) return void this.core.replyStateless(e, {
                  statusCode: 491
                });
              }

              if (e.method === n.C.INVITE) {
                const t = e.parseHeader("contact");
                if (!t) throw new Error("Contact undefined.");
                if (!(t instanceof i.NameAddrHeader)) throw new Error("Contact not instance of NameAddrHeader.");
                this.dialogState.remoteTarget = t.uri;
              }

              switch (e.method) {
                case n.C.BYE:
                  {
                    const t = new m.ByeUserAgentServer(this, e);
                    this.delegate && this.delegate.onBye ? this.delegate.onBye(t) : t.accept(), this.dispose();
                  }
                  break;

                case n.C.INFO:
                  {
                    const t = new v.InfoUserAgentServer(this, e);
                    this.delegate && this.delegate.onInfo ? this.delegate.onInfo(t) : t.reject({
                      statusCode: 469,
                      extraHeaders: ["Recv-Info:"]
                    });
                  }
                  break;

                case n.C.INVITE:
                  {
                    const t = new R.ReInviteUserAgentServer(this, e);
                    this.signalingStateTransition(e), this.delegate && this.delegate.onInvite ? this.delegate.onInvite(t) : t.reject({
                      statusCode: 488
                    });
                  }
                  break;

                case n.C.MESSAGE:
                  {
                    const t = new S.MessageUserAgentServer(this.core, e);
                    this.delegate && this.delegate.onMessage ? this.delegate.onMessage(t) : t.accept();
                  }
                  break;

                case n.C.NOTIFY:
                  {
                    const t = new w.NotifyUserAgentServer(this, e);
                    this.delegate && this.delegate.onNotify ? this.delegate.onNotify(t) : t.accept();
                  }
                  break;

                case n.C.PRACK:
                  {
                    const t = new y.PrackUserAgentServer(this, e);
                    this.delegate && this.delegate.onPrack ? this.delegate.onPrack(t) : t.accept();
                  }
                  break;

                case n.C.REFER:
                  {
                    const t = new E.ReferUserAgentServer(this, e);
                    this.delegate && this.delegate.onRefer ? this.delegate.onRefer(t) : t.reject();
                  }
                  break;

                default:
                  this.logger.log(`INVITE dialog ${this.id} received unimplemented ${e.method} request`), this.core.replyStateless(e, {
                    statusCode: 501
                  });
              }
            } else this.logger.log(`INVITE dialog ${this.id} rejected out of order ${e.method} request.`);
          } else {
            if (this.ackWait) {
              if (this.initialTransaction instanceof u.InviteClientTransaction) return void this.logger.warn(`INVITE dialog ${this.id} received unexpected ${e.method} request, dropping.`);
              if (this.initialTransaction.request.cseq !== e.cseq) return void this.logger.warn(`INVITE dialog ${this.id} received unexpected ${e.method} request, dropping.`);
              this.ackWait = !1;
            } else {
              if (!this.reinviteUserAgentServer) return void this.logger.warn(`INVITE dialog ${this.id} received unexpected ${e.method} request, dropping.`);
              if (this.reinviteUserAgentServer.transaction.request.cseq !== e.cseq) return void this.logger.warn(`INVITE dialog ${this.id} received unexpected ${e.method} request, dropping.`);
              this.reinviteUserAgentServer = void 0;
            }

            if (this.signalingStateTransition(e), this.delegate && this.delegate.onAck) {
              const t = this.delegate.onAck({
                message: e
              });
              t instanceof Promise && (this.ackProcessing = !0, t.then(() => this.ackProcessing = !1).catch(() => this.ackProcessing = !1));
            }
          }
        }

        reliableSequenceGuard(e) {
          const t = e.statusCode;
          if (!t) throw new Error("Status code undefined");

          if (t > 100 && t < 200) {
            const t = e.getHeader("require"),
                  s = e.getHeader("rseq"),
                  i = t && t.includes("100rel") && s ? Number(s) : void 0;

            if (i) {
              if (this.rseq && this.rseq + 1 !== i) return !1;
              this.rseq = this.rseq ? this.rseq + 1 : i;
            }
          }

          return !0;
        }

        signalingStateRollback() {
          this._signalingState !== d.SignalingState.HaveLocalOffer && this.signalingState !== d.SignalingState.HaveRemoteOffer || this._rollbackOffer && this._rollbackAnswer && (this._signalingState = d.SignalingState.Stable, this._offer = this._rollbackOffer, this._answer = this._rollbackAnswer);
        }

        signalingStateTransition(e) {
          const t = Object(r.getBody)(e);

          if (t && "session" === t.contentDisposition) {
            if (this._signalingState === d.SignalingState.Stable && (this._rollbackOffer = this._offer, this._rollbackAnswer = this._answer), e instanceof o.IncomingRequestMessage) switch (this._signalingState) {
              case d.SignalingState.Initial:
              case d.SignalingState.Stable:
                this._signalingState = d.SignalingState.HaveRemoteOffer, this._offer = t, this._answer = void 0;
                break;

              case d.SignalingState.HaveLocalOffer:
                this._signalingState = d.SignalingState.Stable, this._answer = t;
                break;

              case d.SignalingState.HaveRemoteOffer:
              case d.SignalingState.Closed:
                break;

              default:
                throw new Error("Unexpected signaling state.");
            }
            if (e instanceof a.IncomingResponseMessage) switch (this._signalingState) {
              case d.SignalingState.Initial:
              case d.SignalingState.Stable:
                this._signalingState = d.SignalingState.HaveRemoteOffer, this._offer = t, this._answer = void 0;
                break;

              case d.SignalingState.HaveLocalOffer:
                this._signalingState = d.SignalingState.Stable, this._answer = t;
                break;

              case d.SignalingState.HaveRemoteOffer:
              case d.SignalingState.Closed:
                break;

              default:
                throw new Error("Unexpected signaling state.");
            }
            if (e instanceof c.OutgoingRequestMessage) switch (this._signalingState) {
              case d.SignalingState.Initial:
              case d.SignalingState.Stable:
                this._signalingState = d.SignalingState.HaveLocalOffer, this._offer = t, this._answer = void 0;
                break;

              case d.SignalingState.HaveLocalOffer:
                break;

              case d.SignalingState.HaveRemoteOffer:
                this._signalingState = d.SignalingState.Stable, this._answer = t;
                break;

              case d.SignalingState.Closed:
                break;

              default:
                throw new Error("Unexpected signaling state.");
            }
            if (Object(r.isBody)(e)) switch (this._signalingState) {
              case d.SignalingState.Initial:
              case d.SignalingState.Stable:
                this._signalingState = d.SignalingState.HaveLocalOffer, this._offer = t, this._answer = void 0;
                break;

              case d.SignalingState.HaveLocalOffer:
                break;

              case d.SignalingState.HaveRemoteOffer:
                this._signalingState = d.SignalingState.Stable, this._answer = t;
                break;

              case d.SignalingState.Closed:
                break;

              default:
                throw new Error("Unexpected signaling state.");
            }
          }
        }

        start2xxRetransmissionTimer() {
          if (this.initialTransaction instanceof h.InviteServerTransaction) {
            const e = this.initialTransaction;
            let t = l.Timers.T1;

            const s = () => {
              this.ackWait ? (this.logger.log("No ACK for 2xx response received, attempting retransmission"), e.retransmitAcceptedResponse(), t = Math.min(2 * t, l.Timers.T2), this.invite2xxTimer = setTimeout(s, t)) : this.invite2xxTimer = void 0;
            };

            this.invite2xxTimer = setTimeout(s, t);

            const i = () => {
              e.state === g.TransactionState.Terminated && (e.removeStateChangeListener(i), this.invite2xxTimer && (clearTimeout(this.invite2xxTimer), this.invite2xxTimer = void 0), this.ackWait && (this.delegate && this.delegate.onAckTimeout ? this.delegate.onAckTimeout() : this.bye()));
            };

            e.addStateChangeListener(i);
          }
        }

        startReInvite2xxRetransmissionTimer() {
          if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof h.InviteServerTransaction) {
            const e = this.reinviteUserAgentServer.transaction;
            let t = l.Timers.T1;

            const s = () => {
              this.reinviteUserAgentServer ? (this.logger.log("No ACK for 2xx response received, attempting retransmission"), e.retransmitAcceptedResponse(), t = Math.min(2 * t, l.Timers.T2), this.invite2xxTimer = setTimeout(s, t)) : this.invite2xxTimer = void 0;
            };

            this.invite2xxTimer = setTimeout(s, t);

            const i = () => {
              e.state === g.TransactionState.Terminated && (e.removeStateChangeListener(i), this.invite2xxTimer && (clearTimeout(this.invite2xxTimer), this.invite2xxTimer = void 0), this.reinviteUserAgentServer);
            };

            e.addStateChangeListener(i);
          }
        }

      }
    },
    "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js":
    /*!*********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js ***!
      \*********************************************************************/

    /*! exports provided: SubscriptionDialog */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SubscriptionDialog", function () {
        return u;
      });
      var i = s(
      /*! ../../grammar/name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js"),
          r = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          n = s(
      /*! ../subscription/subscription.js */
      "./node_modules/sip.js/lib/core/subscription/subscription.js"),
          o = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          a = s(
      /*! ../user-agent-core/allowed-methods.js */
      "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js"),
          c = s(
      /*! ../user-agents/notify-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js"),
          d = s(
      /*! ../user-agents/re-subscribe-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js"),
          l = s(
      /*! ./dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/dialog.js");

      class u extends l.Dialog {
        constructor(e, t, s, i, r, n) {
          super(i, r), this.delegate = n, this._autoRefresh = !1, this._subscriptionEvent = e, this._subscriptionExpires = t, this._subscriptionExpiresInitial = t, this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1e3), this._subscriptionRefresh = void 0, this._subscriptionRefreshLastSet = void 0, this._subscriptionState = s, this.logger = i.loggerFactory.getLogger("sip.subscribe-dialog"), this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);
        }

        static initialDialogStateForSubscription(e, t) {
          const s = t.getHeaders("record-route"),
                r = t.parseHeader("contact");
          if (!r) throw new Error("Contact undefined.");
          if (!(r instanceof i.NameAddrHeader)) throw new Error("Contact not instance of NameAddrHeader.");
          const n = r.uri,
                o = e.cseq,
                a = e.callId,
                c = e.fromTag,
                d = t.fromTag;
          if (!a) throw new Error("Call id undefined.");
          if (!c) throw new Error("From tag undefined.");
          if (!d) throw new Error("To tag undefined.");
          if (!e.from) throw new Error("From undefined.");
          if (!e.to) throw new Error("To undefined.");
          return {
            id: a + c + d,
            early: !1,
            callId: a,
            localTag: c,
            remoteTag: d,
            localSequenceNumber: o,
            remoteSequenceNumber: void 0,
            localURI: e.from.uri,
            remoteURI: e.to.uri,
            remoteTarget: n,
            routeSet: s,
            secure: !1
          };
        }

        dispose() {
          super.dispose(), this.N && (clearTimeout(this.N), this.N = void 0), this.refreshTimerClear(), this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);
        }

        get autoRefresh() {
          return this._autoRefresh;
        }

        set autoRefresh(e) {
          this._autoRefresh = !0, this.refreshTimerSet();
        }

        get subscriptionEvent() {
          return this._subscriptionEvent;
        }

        get subscriptionExpires() {
          const e = Math.floor(Date.now() / 1e3) - this._subscriptionExpiresLastSet,
                t = this._subscriptionExpires - e;

          return Math.max(t, 0);
        }

        set subscriptionExpires(e) {
          if (e < 0) throw new Error("Expires must be greater than or equal to zero.");

          if (this._subscriptionExpires = e, this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1e3), this.autoRefresh) {
            const t = this.subscriptionRefresh;
            (void 0 === t || t >= e) && this.refreshTimerSet();
          }
        }

        get subscriptionExpiresInitial() {
          return this._subscriptionExpiresInitial;
        }

        get subscriptionRefresh() {
          if (void 0 === this._subscriptionRefresh || void 0 === this._subscriptionRefreshLastSet) return;

          const e = Math.floor(Date.now() / 1e3) - this._subscriptionRefreshLastSet,
                t = this._subscriptionRefresh - e;

          return Math.max(t, 0);
        }

        get subscriptionState() {
          return this._subscriptionState;
        }

        receiveRequest(e) {
          if (this.logger.log(`SUBSCRIBE dialog ${this.id} received ${e.method} request`), this.sequenceGuard(e)) switch (super.receiveRequest(e), e.method) {
            case r.C.NOTIFY:
              this.onNotify(e);
              break;

            default:
              this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${e.method} request`), this.core.replyStateless(e, {
                statusCode: 501
              });
          } else this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${e.method} request.`);
        }

        refresh() {
          const e = "Allow: " + a.AllowedMethods.toString(),
                t = {};
          return t.extraHeaders = (t.extraHeaders || []).slice(), t.extraHeaders.push(e), t.extraHeaders.push("Event: " + this.subscriptionEvent), t.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial), t.extraHeaders.push("Contact: " + this.core.configuration.contact.toString()), this.subscribe(void 0, t);
        }

        subscribe(e, t = {}) {
          var s;
          if (this.subscriptionState !== n.SubscriptionState.Pending && this.subscriptionState !== n.SubscriptionState.Active) throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state "pending" or "active".`);
          this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);
          const i = new d.ReSubscribeUserAgentClient(this, e, t);
          return this.N && (clearTimeout(this.N), this.N = void 0), (null === (s = t.extraHeaders) || void 0 === s ? void 0 : s.includes("Expires: 0")) || (this.N = setTimeout(() => this.timerN(), o.Timers.TIMER_N)), i;
        }

        terminate() {
          this.stateTransition(n.SubscriptionState.Terminated), this.onTerminated();
        }

        unsubscribe() {
          const e = "Allow: " + a.AllowedMethods.toString(),
                t = {};
          return t.extraHeaders = (t.extraHeaders || []).slice(), t.extraHeaders.push(e), t.extraHeaders.push("Event: " + this.subscriptionEvent), t.extraHeaders.push("Expires: 0"), t.extraHeaders.push("Contact: " + this.core.configuration.contact.toString()), this.subscribe(void 0, t);
        }

        onNotify(e) {
          const t = e.parseHeader("Event").event;
          if (!t || t !== this.subscriptionEvent) return void this.core.replyStateless(e, {
            statusCode: 489
          });
          this.N && (clearTimeout(this.N), this.N = void 0);
          const s = e.parseHeader("Subscription-State");
          if (!s || !s.state) return void this.core.replyStateless(e, {
            statusCode: 489
          });
          const i = s.state,
                r = s.expires ? Math.max(s.expires, 0) : void 0;

          switch (i) {
            case "pending":
              this.stateTransition(n.SubscriptionState.Pending, r);
              break;

            case "active":
              this.stateTransition(n.SubscriptionState.Active, r);
              break;

            case "terminated":
              this.stateTransition(n.SubscriptionState.Terminated, r);
              break;

            default:
              this.logger.warn("Unrecognized subscription state.");
          }

          const o = new c.NotifyUserAgentServer(this, e);
          this.delegate && this.delegate.onNotify ? this.delegate.onNotify(o) : o.accept();
        }

        onRefresh(e) {
          this.delegate && this.delegate.onRefresh && this.delegate.onRefresh(e);
        }

        onTerminated() {
          this.delegate && this.delegate.onTerminated && this.delegate.onTerminated();
        }

        refreshTimerClear() {
          this.refreshTimer && (clearTimeout(this.refreshTimer), this.refreshTimer = void 0);
        }

        refreshTimerSet() {
          if (this.refreshTimerClear(), this.autoRefresh && this.subscriptionExpires > 0) {
            const e = 900 * this.subscriptionExpires;
            this._subscriptionRefresh = Math.floor(e / 1e3), this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1e3), this.refreshTimer = setTimeout(() => {
              this.refreshTimer = void 0, this._subscriptionRefresh = void 0, this._subscriptionRefreshLastSet = void 0, this.onRefresh(this.refresh());
            }, e);
          }
        }

        stateTransition(e, t) {
          const s = () => {
            this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${e}`);
          };

          switch (e) {
            case n.SubscriptionState.Initial:
            case n.SubscriptionState.NotifyWait:
              return void s();

            case n.SubscriptionState.Pending:
              if (this.subscriptionState !== n.SubscriptionState.NotifyWait && this.subscriptionState !== n.SubscriptionState.Pending) return void s();
              break;

            case n.SubscriptionState.Active:
            case n.SubscriptionState.Terminated:
              if (this.subscriptionState !== n.SubscriptionState.NotifyWait && this.subscriptionState !== n.SubscriptionState.Pending && this.subscriptionState !== n.SubscriptionState.Active) return void s();
              break;

            default:
              return void s();
          }

          e === n.SubscriptionState.Pending && t && (this.subscriptionExpires = t), e === n.SubscriptionState.Active && t && (this.subscriptionExpires = t), e === n.SubscriptionState.Terminated && this.dispose(), this._subscriptionState = e;
        }

        timerN() {
          this.logger.warn("Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY."), this.subscriptionState !== n.SubscriptionState.Terminated && (this.stateTransition(n.SubscriptionState.Terminated), this.onTerminated());
        }

      }
    },
    "./node_modules/sip.js/lib/core/exceptions/exception.js":
    /*!**************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/exceptions/exception.js ***!
      \**************************************************************/

    /*! exports provided: Exception */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Exception", function () {
        return i;
      });

      class i extends Error {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, new.target.prototype);
        }

      }
    },
    "./node_modules/sip.js/lib/core/exceptions/index.js":
    /*!**********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/exceptions/index.js ***!
      \**********************************************************/

    /*! exports provided: Exception, TransactionStateError, TransportError */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");
      s.d(t, "Exception", function () {
        return i.Exception;
      });
      var r = s(
      /*! ./transaction-state-error.js */
      "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js");
      s.d(t, "TransactionStateError", function () {
        return r.TransactionStateError;
      });
      var n = s(
      /*! ./transport-error.js */
      "./node_modules/sip.js/lib/core/exceptions/transport-error.js");
      s.d(t, "TransportError", function () {
        return n.TransportError;
      });
    },
    "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js ***!
      \****************************************************************************/

    /*! exports provided: TransactionStateError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "TransactionStateError", function () {
        return r;
      });
      var i = s(
      /*! ./exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor(e) {
          super(e || "Transaction state error.");
        }

      }
    },
    "./node_modules/sip.js/lib/core/exceptions/transport-error.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/exceptions/transport-error.js ***!
      \********************************************************************/

    /*! exports provided: TransportError */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "TransportError", function () {
        return r;
      });
      var i = s(
      /*! ./exception.js */
      "./node_modules/sip.js/lib/core/exceptions/exception.js");

      class r extends i.Exception {
        constructor(e) {
          super(e || "Unspecified transport error.");
        }

      }
    },
    "./node_modules/sip.js/lib/core/index.js":
    /*!***********************************************!*\
      !*** ./node_modules/sip.js/lib/core/index.js ***!
      \***********************************************/

    /*! exports provided: Dialog, SessionDialog, SubscriptionDialog, Exception, TransactionStateError, TransportError, Levels, LoggerFactory, Logger, C, fromBodyLegacy, isBody, getBody, DigestAuthentication, IncomingMessage, IncomingRequestMessage, IncomingResponseMessage, OutgoingRequestMessage, constructOutgoingResponse, Parser, SessionState, SignalingState, SubscriptionState, ClientTransaction, InviteClientTransaction, InviteServerTransaction, NonInviteClientTransaction, NonInviteServerTransaction, ServerTransaction, TransactionState, Transaction, UserAgentCore, ByeUserAgentClient, ByeUserAgentServer, CancelUserAgentClient, InfoUserAgentClient, InfoUserAgentServer, InviteUserAgentClient, InviteUserAgentServer, MessageUserAgentClient, MessageUserAgentServer, NotifyUserAgentClient, NotifyUserAgentServer, PublishUserAgentClient, PrackUserAgentClient, PrackUserAgentServer, ReInviteUserAgentClient, ReInviteUserAgentServer, ReSubscribeUserAgentClient, ReSubscribeUserAgentServer, ReferUserAgentClient, ReferUserAgentServer, RegisterUserAgentClient, RegisterUserAgentServer, SubscribeUserAgentClient, SubscribeUserAgentServer, UserAgentClient, UserAgentServer, Timers, Grammar, NameAddrHeader, Parameters, URI, equivalentURI */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./dialogs/index.js */
      "./node_modules/sip.js/lib/core/dialogs/index.js");
      s.d(t, "Dialog", function () {
        return i.Dialog;
      }), s.d(t, "SessionDialog", function () {
        return i.SessionDialog;
      }), s.d(t, "SubscriptionDialog", function () {
        return i.SubscriptionDialog;
      });
      var r = s(
      /*! ./exceptions/index.js */
      "./node_modules/sip.js/lib/core/exceptions/index.js");
      s.d(t, "Exception", function () {
        return r.Exception;
      }), s.d(t, "TransactionStateError", function () {
        return r.TransactionStateError;
      }), s.d(t, "TransportError", function () {
        return r.TransportError;
      });
      var n = s(
      /*! ./log/index.js */
      "./node_modules/sip.js/lib/core/log/index.js");
      s.d(t, "Levels", function () {
        return n.Levels;
      }), s.d(t, "LoggerFactory", function () {
        return n.LoggerFactory;
      }), s.d(t, "Logger", function () {
        return n.Logger;
      });
      var o = s(
      /*! ./messages/index.js */
      "./node_modules/sip.js/lib/core/messages/index.js");
      s.d(t, "C", function () {
        return o.C;
      }), s.d(t, "fromBodyLegacy", function () {
        return o.fromBodyLegacy;
      }), s.d(t, "isBody", function () {
        return o.isBody;
      }), s.d(t, "getBody", function () {
        return o.getBody;
      }), s.d(t, "DigestAuthentication", function () {
        return o.DigestAuthentication;
      }), s.d(t, "IncomingMessage", function () {
        return o.IncomingMessage;
      }), s.d(t, "IncomingRequestMessage", function () {
        return o.IncomingRequestMessage;
      }), s.d(t, "IncomingResponseMessage", function () {
        return o.IncomingResponseMessage;
      }), s.d(t, "OutgoingRequestMessage", function () {
        return o.OutgoingRequestMessage;
      }), s.d(t, "constructOutgoingResponse", function () {
        return o.constructOutgoingResponse;
      }), s.d(t, "Parser", function () {
        return o.Parser;
      });
      var a = s(
      /*! ./session/index.js */
      "./node_modules/sip.js/lib/core/session/index.js");
      s.d(t, "SessionState", function () {
        return a.SessionState;
      }), s.d(t, "SignalingState", function () {
        return a.SignalingState;
      });
      var c = s(
      /*! ./subscription/index.js */
      "./node_modules/sip.js/lib/core/subscription/index.js");
      s.d(t, "SubscriptionState", function () {
        return c.SubscriptionState;
      });
      var d = s(
      /*! ./transactions/index.js */
      "./node_modules/sip.js/lib/core/transactions/index.js");
      s.d(t, "ClientTransaction", function () {
        return d.ClientTransaction;
      }), s.d(t, "InviteClientTransaction", function () {
        return d.InviteClientTransaction;
      }), s.d(t, "InviteServerTransaction", function () {
        return d.InviteServerTransaction;
      }), s.d(t, "NonInviteClientTransaction", function () {
        return d.NonInviteClientTransaction;
      }), s.d(t, "NonInviteServerTransaction", function () {
        return d.NonInviteServerTransaction;
      }), s.d(t, "ServerTransaction", function () {
        return d.ServerTransaction;
      }), s.d(t, "TransactionState", function () {
        return d.TransactionState;
      }), s.d(t, "Transaction", function () {
        return d.Transaction;
      });
      var l = s(
      /*! ./user-agent-core/index.js */
      "./node_modules/sip.js/lib/core/user-agent-core/index.js");
      s.d(t, "UserAgentCore", function () {
        return l.UserAgentCore;
      });
      var u = s(
      /*! ./user-agents/index.js */
      "./node_modules/sip.js/lib/core/user-agents/index.js");
      s.d(t, "ByeUserAgentClient", function () {
        return u.ByeUserAgentClient;
      }), s.d(t, "ByeUserAgentServer", function () {
        return u.ByeUserAgentServer;
      }), s.d(t, "CancelUserAgentClient", function () {
        return u.CancelUserAgentClient;
      }), s.d(t, "InfoUserAgentClient", function () {
        return u.InfoUserAgentClient;
      }), s.d(t, "InfoUserAgentServer", function () {
        return u.InfoUserAgentServer;
      }), s.d(t, "InviteUserAgentClient", function () {
        return u.InviteUserAgentClient;
      }), s.d(t, "InviteUserAgentServer", function () {
        return u.InviteUserAgentServer;
      }), s.d(t, "MessageUserAgentClient", function () {
        return u.MessageUserAgentClient;
      }), s.d(t, "MessageUserAgentServer", function () {
        return u.MessageUserAgentServer;
      }), s.d(t, "NotifyUserAgentClient", function () {
        return u.NotifyUserAgentClient;
      }), s.d(t, "NotifyUserAgentServer", function () {
        return u.NotifyUserAgentServer;
      }), s.d(t, "PublishUserAgentClient", function () {
        return u.PublishUserAgentClient;
      }), s.d(t, "PrackUserAgentClient", function () {
        return u.PrackUserAgentClient;
      }), s.d(t, "PrackUserAgentServer", function () {
        return u.PrackUserAgentServer;
      }), s.d(t, "ReInviteUserAgentClient", function () {
        return u.ReInviteUserAgentClient;
      }), s.d(t, "ReInviteUserAgentServer", function () {
        return u.ReInviteUserAgentServer;
      }), s.d(t, "ReSubscribeUserAgentClient", function () {
        return u.ReSubscribeUserAgentClient;
      }), s.d(t, "ReSubscribeUserAgentServer", function () {
        return u.ReSubscribeUserAgentServer;
      }), s.d(t, "ReferUserAgentClient", function () {
        return u.ReferUserAgentClient;
      }), s.d(t, "ReferUserAgentServer", function () {
        return u.ReferUserAgentServer;
      }), s.d(t, "RegisterUserAgentClient", function () {
        return u.RegisterUserAgentClient;
      }), s.d(t, "RegisterUserAgentServer", function () {
        return u.RegisterUserAgentServer;
      }), s.d(t, "SubscribeUserAgentClient", function () {
        return u.SubscribeUserAgentClient;
      }), s.d(t, "SubscribeUserAgentServer", function () {
        return u.SubscribeUserAgentServer;
      }), s.d(t, "UserAgentClient", function () {
        return u.UserAgentClient;
      }), s.d(t, "UserAgentServer", function () {
        return u.UserAgentServer;
      });
      var h = s(
      /*! ./timers.js */
      "./node_modules/sip.js/lib/core/timers.js");
      s.d(t, "Timers", function () {
        return h.Timers;
      });
      s(
      /*! ./transport.js */
      "./node_modules/sip.js/lib/core/transport.js");
      var g = s(
      /*! ../grammar/index.js */
      "./node_modules/sip.js/lib/grammar/index.js");
      s.d(t, "Grammar", function () {
        return g.Grammar;
      }), s.d(t, "NameAddrHeader", function () {
        return g.NameAddrHeader;
      }), s.d(t, "Parameters", function () {
        return g.Parameters;
      }), s.d(t, "URI", function () {
        return g.URI;
      }), s.d(t, "equivalentURI", function () {
        return g.equivalentURI;
      });
    },
    "./node_modules/sip.js/lib/core/log/index.js":
    /*!***************************************************!*\
      !*** ./node_modules/sip.js/lib/core/log/index.js ***!
      \***************************************************/

    /*! exports provided: Levels, LoggerFactory, Logger */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./levels.js */
      "./node_modules/sip.js/lib/core/log/levels.js");
      s.d(t, "Levels", function () {
        return i.Levels;
      });
      var r = s(
      /*! ./logger-factory.js */
      "./node_modules/sip.js/lib/core/log/logger-factory.js");
      s.d(t, "LoggerFactory", function () {
        return r.LoggerFactory;
      });
      var n = s(
      /*! ./logger.js */
      "./node_modules/sip.js/lib/core/log/logger.js");
      s.d(t, "Logger", function () {
        return n.Logger;
      });
    },
    "./node_modules/sip.js/lib/core/log/levels.js":
    /*!****************************************************!*\
      !*** ./node_modules/sip.js/lib/core/log/levels.js ***!
      \****************************************************/

    /*! exports provided: Levels */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "Levels", function () {
        return i;
      }), function (e) {
        e[e.error = 0] = "error", e[e.warn = 1] = "warn", e[e.log = 2] = "log", e[e.debug = 3] = "debug";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/core/log/logger-factory.js":
    /*!************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/log/logger-factory.js ***!
      \************************************************************/

    /*! exports provided: LoggerFactory */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "LoggerFactory", function () {
        return n;
      });
      var i = s(
      /*! ./levels.js */
      "./node_modules/sip.js/lib/core/log/levels.js"),
          r = s(
      /*! ./logger.js */
      "./node_modules/sip.js/lib/core/log/logger.js");

      class n {
        constructor() {
          this.builtinEnabled = !0, this._level = i.Levels.log, this.loggers = {}, this.logger = this.getLogger("sip:loggerfactory");
        }

        get level() {
          return this._level;
        }

        set level(e) {
          e >= 0 && e <= 3 ? this._level = e : e > 3 ? this._level = 3 : i.Levels.hasOwnProperty(e) ? this._level = e : this.logger.error("invalid 'level' parameter value: " + JSON.stringify(e));
        }

        get connector() {
          return this._connector;
        }

        set connector(e) {
          e ? "function" == typeof e ? this._connector = e : this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(e)) : this._connector = void 0;
        }

        getLogger(e, t) {
          if (t && 3 === this.level) return new r.Logger(this, e, t);
          if (this.loggers[e]) return this.loggers[e];
          {
            const t = new r.Logger(this, e);
            return this.loggers[e] = t, t;
          }
        }

        genericLog(e, t, s, r) {
          this.level >= e && this.builtinEnabled && this.print(e, t, s, r), this.connector && this.connector(i.Levels[e], t, s, r);
        }

        print(e, t, s, r) {
          if ("string" == typeof r) {
            const e = [new Date(), t];
            s && e.push(s), r = e.concat(r).join(" | ");
          }

          switch (e) {
            case i.Levels.error:
              console.error(r);
              break;

            case i.Levels.warn:
              console.warn(r);
              break;

            case i.Levels.log:
              console.log(r);
              break;

            case i.Levels.debug:
              console.debug(r);
          }
        }

      }
    },
    "./node_modules/sip.js/lib/core/log/logger.js":
    /*!****************************************************!*\
      !*** ./node_modules/sip.js/lib/core/log/logger.js ***!
      \****************************************************/

    /*! exports provided: Logger */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Logger", function () {
        return r;
      });
      var i = s(
      /*! ./levels.js */
      "./node_modules/sip.js/lib/core/log/levels.js");

      class r {
        constructor(e, t, s) {
          this.logger = e, this.category = t, this.label = s;
        }

        error(e) {
          this.genericLog(i.Levels.error, e);
        }

        warn(e) {
          this.genericLog(i.Levels.warn, e);
        }

        log(e) {
          this.genericLog(i.Levels.log, e);
        }

        debug(e) {
          this.genericLog(i.Levels.debug, e);
        }

        genericLog(e, t) {
          this.logger.genericLog(e, this.category, this.label, t);
        }

        get level() {
          return this.logger.level;
        }

        set level(e) {
          this.logger.level = e;
        }

      }
    },
    "./node_modules/sip.js/lib/core/messages/body.js":
    /*!*******************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/body.js ***!
      \*******************************************************/

    /*! exports provided: fromBodyLegacy, isBody, getBody */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "fromBodyLegacy", function () {
        return a;
      }), s.d(t, "isBody", function () {
        return c;
      }), s.d(t, "getBody", function () {
        return d;
      });
      var i = s(
      /*! ./incoming-request-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-request-message.js"),
          r = s(
      /*! ./incoming-response-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response-message.js"),
          n = s(
      /*! ./outgoing-request-message.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js");

      function o(e) {
        return "application/sdp" === e ? "session" : "render";
      }

      function a(e) {
        const t = "string" == typeof e ? e : e.body,
              s = "string" == typeof e ? "application/sdp" : e.contentType;
        return {
          contentDisposition: o(s),
          contentType: s,
          content: t
        };
      }

      function c(e) {
        return !(!e || "string" != typeof e.content || "string" != typeof e.contentType || void 0 !== e.contentDisposition) || "string" == typeof e.contentDisposition;
      }

      function d(e) {
        let t, s, a;

        if (e instanceof i.IncomingRequestMessage && e.body) {
          const i = e.parseHeader("Content-Disposition");
          t = i ? i.type : void 0, s = e.parseHeader("Content-Type"), a = e.body;
        }

        if (e instanceof r.IncomingResponseMessage && e.body) {
          const i = e.parseHeader("Content-Disposition");
          t = i ? i.type : void 0, s = e.parseHeader("Content-Type"), a = e.body;
        }

        if (e instanceof n.OutgoingRequestMessage && e.body) if (t = e.getHeader("Content-Disposition"), s = e.getHeader("Content-Type"), "string" == typeof e.body) {
          if (!s) throw new Error("Header content type header does not equal body content type.");
          a = e.body;
        } else {
          if (s && s !== e.body.contentType) throw new Error("Header content type header does not equal body content type.");
          s = e.body.contentType, a = e.body.body;
        }

        if (c(e) && (t = e.contentDisposition, s = e.contentType, a = e.content), a) {
          if (s && !t && (t = o(s)), !t) throw new Error("Content disposition undefined.");
          if (!s) throw new Error("Content type undefined.");
          return {
            contentDisposition: t,
            contentType: s,
            content: a
          };
        }
      }
    },
    "./node_modules/sip.js/lib/core/messages/digest-authentication.js":
    /*!************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/digest-authentication.js ***!
      \************************************************************************/

    /*! exports provided: DigestAuthentication */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "DigestAuthentication", function () {
        return o;
      });
      var i = s(
      /*! ./md5.js */
      "./node_modules/sip.js/lib/core/messages/md5.js"),
          r = s(
      /*! ./utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js");

      function n(e) {
        return i.Md5.hashStr(e);
      }

      class o {
        constructor(e, t, s, i) {
          this.logger = e.getLogger("sipjs.digestauthentication"), this.username = s, this.password = i, this.ha1 = t, this.nc = 0, this.ncHex = "00000000";
        }

        authenticate(e, t, s) {
          if (this.algorithm = t.algorithm, this.realm = t.realm, this.nonce = t.nonce, this.opaque = t.opaque, this.stale = t.stale, this.algorithm) {
            if ("MD5" !== this.algorithm) return this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted"), !1;
          } else this.algorithm = "MD5";

          if (!this.realm) return this.logger.warn("challenge without Digest realm, authentication aborted"), !1;
          if (!this.nonce) return this.logger.warn("challenge without Digest nonce, authentication aborted"), !1;
          if (t.qop) {
            if (t.qop.indexOf("auth") > -1) this.qop = "auth";else {
              if (!(t.qop.indexOf("auth-int") > -1)) return this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted"), !1;
              this.qop = "auth-int";
            }
          } else this.qop = void 0;
          return this.method = e.method, this.uri = e.ruri, this.cnonce = Object(r.createRandomToken)(12), this.nc += 1, this.updateNcHex(), 4294967296 === this.nc && (this.nc = 1, this.ncHex = "00000001"), this.calculateResponse(s), !0;
        }

        toString() {
          const e = [];
          if (!this.response) throw new Error("response field does not exist, cannot generate Authorization header");
          return e.push("algorithm=" + this.algorithm), e.push('username="' + this.username + '"'), e.push('realm="' + this.realm + '"'), e.push('nonce="' + this.nonce + '"'), e.push('uri="' + this.uri + '"'), e.push('response="' + this.response + '"'), this.opaque && e.push('opaque="' + this.opaque + '"'), this.qop && (e.push("qop=" + this.qop), e.push('cnonce="' + this.cnonce + '"'), e.push("nc=" + this.ncHex)), "Digest " + e.join(", ");
        }

        updateNcHex() {
          const e = Number(this.nc).toString(16);
          this.ncHex = "00000000".substr(0, 8 - e.length) + e;
        }

        calculateResponse(e) {
          let t, s;
          "" !== (t = this.ha1) && void 0 !== t || (t = n(this.username + ":" + this.realm + ":" + this.password)), "auth" === this.qop ? (s = n(this.method + ":" + this.uri), this.response = n(t + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + s)) : "auth-int" === this.qop ? (s = n(this.method + ":" + this.uri + ":" + n(e || "")), this.response = n(t + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + s)) : void 0 === this.qop && (s = n(this.method + ":" + this.uri), this.response = n(t + ":" + this.nonce + ":" + s));
        }

      }
    },
    "./node_modules/sip.js/lib/core/messages/incoming-message.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/incoming-message.js ***!
      \*******************************************************************/

    /*! exports provided: IncomingMessage */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "IncomingMessage", function () {
        return n;
      });
      var i = s(
      /*! ../../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          r = s(
      /*! ./utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js");

      class n {
        constructor() {
          this.headers = {};
        }

        addHeader(e, t) {
          const s = {
            raw: t
          };
          e = Object(r.headerize)(e), this.headers[e] ? this.headers[e].push(s) : this.headers[e] = [s];
        }

        getHeader(e) {
          const t = this.headers[Object(r.headerize)(e)];
          if (t) return t[0] ? t[0].raw : void 0;
        }

        getHeaders(e) {
          const t = this.headers[Object(r.headerize)(e)],
                s = [];
          if (!t) return [];

          for (const e of t) s.push(e.raw);

          return s;
        }

        hasHeader(e) {
          return !!this.headers[Object(r.headerize)(e)];
        }

        parseHeader(e, t = 0) {
          if (e = Object(r.headerize)(e), !this.headers[e]) return;
          if (t >= this.headers[e].length) return;
          const s = this.headers[e][t],
                n = s.raw;
          if (s.parsed) return s.parsed;
          const o = i.Grammar.parse(n, e.replace(/-/g, "_"));
          return -1 === o ? void this.headers[e].splice(t, 1) : (s.parsed = o, o);
        }

        s(e, t = 0) {
          return this.parseHeader(e, t);
        }

        setHeader(e, t) {
          this.headers[Object(r.headerize)(e)] = [{
            raw: t
          }];
        }

        toString() {
          return this.data;
        }

      }
    },
    "./node_modules/sip.js/lib/core/messages/incoming-request-message.js":
    /*!***************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/incoming-request-message.js ***!
      \***************************************************************************/

    /*! exports provided: IncomingRequestMessage */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "IncomingRequestMessage", function () {
        return r;
      });
      var i = s(
      /*! ./incoming-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-message.js");

      class r extends i.IncomingMessage {
        constructor() {
          super();
        }

      }
    },
    "./node_modules/sip.js/lib/core/messages/incoming-request.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/incoming-request.js ***!
      \*******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/incoming-response-message.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/incoming-response-message.js ***!
      \****************************************************************************/

    /*! exports provided: IncomingResponseMessage */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "IncomingResponseMessage", function () {
        return r;
      });
      var i = s(
      /*! ./incoming-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-message.js");

      class r extends i.IncomingMessage {
        constructor() {
          super();
        }

      }
    },
    "./node_modules/sip.js/lib/core/messages/incoming-response.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/incoming-response.js ***!
      \********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/index.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/index.js ***!
      \********************************************************/

    /*! exports provided: C, fromBodyLegacy, isBody, getBody, DigestAuthentication, IncomingMessage, IncomingRequestMessage, IncomingResponseMessage, OutgoingRequestMessage, constructOutgoingResponse, Parser */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./methods/index.js */
      "./node_modules/sip.js/lib/core/messages/methods/index.js");
      s.d(t, "C", function () {
        return i.C;
      });
      var r = s(
      /*! ./body.js */
      "./node_modules/sip.js/lib/core/messages/body.js");
      s.d(t, "fromBodyLegacy", function () {
        return r.fromBodyLegacy;
      }), s.d(t, "isBody", function () {
        return r.isBody;
      }), s.d(t, "getBody", function () {
        return r.getBody;
      });
      var n = s(
      /*! ./digest-authentication.js */
      "./node_modules/sip.js/lib/core/messages/digest-authentication.js");
      s.d(t, "DigestAuthentication", function () {
        return n.DigestAuthentication;
      });
      var o = s(
      /*! ./incoming-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-message.js");
      s.d(t, "IncomingMessage", function () {
        return o.IncomingMessage;
      });
      var a = s(
      /*! ./incoming-request-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-request-message.js");
      s.d(t, "IncomingRequestMessage", function () {
        return a.IncomingRequestMessage;
      });
      s(
      /*! ./incoming-request.js */
      "./node_modules/sip.js/lib/core/messages/incoming-request.js");
      var c = s(
      /*! ./incoming-response-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response-message.js");
      s.d(t, "IncomingResponseMessage", function () {
        return c.IncomingResponseMessage;
      });
      s(
      /*! ./incoming-response.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response.js");
      var d = s(
      /*! ./outgoing-request-message.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js");
      s.d(t, "OutgoingRequestMessage", function () {
        return d.OutgoingRequestMessage;
      });
      s(
      /*! ./outgoing-request.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-request.js");
      var l = s(
      /*! ./outgoing-response.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-response.js");
      s.d(t, "constructOutgoingResponse", function () {
        return l.constructOutgoingResponse;
      });
      var u = s(
      /*! ./parser.js */
      "./node_modules/sip.js/lib/core/messages/parser.js");
      s.d(t, "Parser", function () {
        return u.Parser;
      });
    },
    "./node_modules/sip.js/lib/core/messages/md5.js":
    /*!******************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/md5.js ***!
      \******************************************************/

    /*! exports provided: Md5 */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Md5", function () {
        return i;
      });

      class i {
        constructor() {
          this._dataLength = 0, this._bufferLength = 0, this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
        }

        static hashStr(e, t = !1) {
          return this.onePassHasher.start().appendStr(e).end(t);
        }

        static hashAsciiStr(e, t = !1) {
          return this.onePassHasher.start().appendAsciiStr(e).end(t);
        }

        static _hex(e) {
          const t = i.hexChars,
                s = i.hexOut;
          let r, n, o, a;

          for (a = 0; a < 4; a += 1) for (n = 8 * a, r = e[a], o = 0; o < 8; o += 2) s[n + 1 + o] = t.charAt(15 & r), r >>>= 4, s[n + 0 + o] = t.charAt(15 & r), r >>>= 4;

          return s.join("");
        }

        static _md5cycle(e, t) {
          let s = e[0],
              i = e[1],
              r = e[2],
              n = e[3];
          i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & r | ~i & n) + t[0] - 680876936 | 0) << 7 | s >>> 25) + i | 0) & i | ~s & r) + t[1] - 389564586 | 0) << 12 | n >>> 20) + s | 0) & s | ~n & i) + t[2] + 606105819 | 0) << 17 | r >>> 15) + n | 0) & n | ~r & s) + t[3] - 1044525330 | 0) << 22 | i >>> 10) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & r | ~i & n) + t[4] - 176418897 | 0) << 7 | s >>> 25) + i | 0) & i | ~s & r) + t[5] + 1200080426 | 0) << 12 | n >>> 20) + s | 0) & s | ~n & i) + t[6] - 1473231341 | 0) << 17 | r >>> 15) + n | 0) & n | ~r & s) + t[7] - 45705983 | 0) << 22 | i >>> 10) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & r | ~i & n) + t[8] + 1770035416 | 0) << 7 | s >>> 25) + i | 0) & i | ~s & r) + t[9] - 1958414417 | 0) << 12 | n >>> 20) + s | 0) & s | ~n & i) + t[10] - 42063 | 0) << 17 | r >>> 15) + n | 0) & n | ~r & s) + t[11] - 1990404162 | 0) << 22 | i >>> 10) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & r | ~i & n) + t[12] + 1804603682 | 0) << 7 | s >>> 25) + i | 0) & i | ~s & r) + t[13] - 40341101 | 0) << 12 | n >>> 20) + s | 0) & s | ~n & i) + t[14] - 1502002290 | 0) << 17 | r >>> 15) + n | 0) & n | ~r & s) + t[15] + 1236535329 | 0) << 22 | i >>> 10) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & n | r & ~n) + t[1] - 165796510 | 0) << 5 | s >>> 27) + i | 0) & r | i & ~r) + t[6] - 1069501632 | 0) << 9 | n >>> 23) + s | 0) & i | s & ~i) + t[11] + 643717713 | 0) << 14 | r >>> 18) + n | 0) & s | n & ~s) + t[0] - 373897302 | 0) << 20 | i >>> 12) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & n | r & ~n) + t[5] - 701558691 | 0) << 5 | s >>> 27) + i | 0) & r | i & ~r) + t[10] + 38016083 | 0) << 9 | n >>> 23) + s | 0) & i | s & ~i) + t[15] - 660478335 | 0) << 14 | r >>> 18) + n | 0) & s | n & ~s) + t[4] - 405537848 | 0) << 20 | i >>> 12) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & n | r & ~n) + t[9] + 568446438 | 0) << 5 | s >>> 27) + i | 0) & r | i & ~r) + t[14] - 1019803690 | 0) << 9 | n >>> 23) + s | 0) & i | s & ~i) + t[3] - 187363961 | 0) << 14 | r >>> 18) + n | 0) & s | n & ~s) + t[8] + 1163531501 | 0) << 20 | i >>> 12) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i & n | r & ~n) + t[13] - 1444681467 | 0) << 5 | s >>> 27) + i | 0) & r | i & ~r) + t[2] - 51403784 | 0) << 9 | n >>> 23) + s | 0) & i | s & ~i) + t[7] + 1735328473 | 0) << 14 | r >>> 18) + n | 0) & s | n & ~s) + t[12] - 1926607734 | 0) << 20 | i >>> 12) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i ^ r ^ n) + t[5] - 378558 | 0) << 4 | s >>> 28) + i | 0) ^ i ^ r) + t[8] - 2022574463 | 0) << 11 | n >>> 21) + s | 0) ^ s ^ i) + t[11] + 1839030562 | 0) << 16 | r >>> 16) + n | 0) ^ n ^ s) + t[14] - 35309556 | 0) << 23 | i >>> 9) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i ^ r ^ n) + t[1] - 1530992060 | 0) << 4 | s >>> 28) + i | 0) ^ i ^ r) + t[4] + 1272893353 | 0) << 11 | n >>> 21) + s | 0) ^ s ^ i) + t[7] - 155497632 | 0) << 16 | r >>> 16) + n | 0) ^ n ^ s) + t[10] - 1094730640 | 0) << 23 | i >>> 9) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i ^ r ^ n) + t[13] + 681279174 | 0) << 4 | s >>> 28) + i | 0) ^ i ^ r) + t[0] - 358537222 | 0) << 11 | n >>> 21) + s | 0) ^ s ^ i) + t[3] - 722521979 | 0) << 16 | r >>> 16) + n | 0) ^ n ^ s) + t[6] + 76029189 | 0) << 23 | i >>> 9) + r | 0, i = ((i += ((r = ((r += ((n = ((n += ((s = ((s += (i ^ r ^ n) + t[9] - 640364487 | 0) << 4 | s >>> 28) + i | 0) ^ i ^ r) + t[12] - 421815835 | 0) << 11 | n >>> 21) + s | 0) ^ s ^ i) + t[15] + 530742520 | 0) << 16 | r >>> 16) + n | 0) ^ n ^ s) + t[2] - 995338651 | 0) << 23 | i >>> 9) + r | 0, i = ((i += ((n = ((n += (i ^ ((s = ((s += (r ^ (i | ~n)) + t[0] - 198630844 | 0) << 6 | s >>> 26) + i | 0) | ~r)) + t[7] + 1126891415 | 0) << 10 | n >>> 22) + s | 0) ^ ((r = ((r += (s ^ (n | ~i)) + t[14] - 1416354905 | 0) << 15 | r >>> 17) + n | 0) | ~s)) + t[5] - 57434055 | 0) << 21 | i >>> 11) + r | 0, i = ((i += ((n = ((n += (i ^ ((s = ((s += (r ^ (i | ~n)) + t[12] + 1700485571 | 0) << 6 | s >>> 26) + i | 0) | ~r)) + t[3] - 1894986606 | 0) << 10 | n >>> 22) + s | 0) ^ ((r = ((r += (s ^ (n | ~i)) + t[10] - 1051523 | 0) << 15 | r >>> 17) + n | 0) | ~s)) + t[1] - 2054922799 | 0) << 21 | i >>> 11) + r | 0, i = ((i += ((n = ((n += (i ^ ((s = ((s += (r ^ (i | ~n)) + t[8] + 1873313359 | 0) << 6 | s >>> 26) + i | 0) | ~r)) + t[15] - 30611744 | 0) << 10 | n >>> 22) + s | 0) ^ ((r = ((r += (s ^ (n | ~i)) + t[6] - 1560198380 | 0) << 15 | r >>> 17) + n | 0) | ~s)) + t[13] + 1309151649 | 0) << 21 | i >>> 11) + r | 0, i = ((i += ((n = ((n += (i ^ ((s = ((s += (r ^ (i | ~n)) + t[4] - 145523070 | 0) << 6 | s >>> 26) + i | 0) | ~r)) + t[11] - 1120210379 | 0) << 10 | n >>> 22) + s | 0) ^ ((r = ((r += (s ^ (n | ~i)) + t[2] + 718787259 | 0) << 15 | r >>> 17) + n | 0) | ~s)) + t[9] - 343485551 | 0) << 21 | i >>> 11) + r | 0, e[0] = s + e[0] | 0, e[1] = i + e[1] | 0, e[2] = r + e[2] | 0, e[3] = n + e[3] | 0;
        }

        start() {
          return this._dataLength = 0, this._bufferLength = 0, this._state.set(i.stateIdentity), this;
        }

        appendStr(e) {
          const t = this._buffer8,
                s = this._buffer32;
          let r,
              n,
              o = this._bufferLength;

          for (n = 0; n < e.length; n += 1) {
            if ((r = e.charCodeAt(n)) < 128) t[o++] = r;else if (r < 2048) t[o++] = 192 + (r >>> 6), t[o++] = 63 & r | 128;else if (r < 55296 || r > 56319) t[o++] = 224 + (r >>> 12), t[o++] = r >>> 6 & 63 | 128, t[o++] = 63 & r | 128;else {
              if ((r = 1024 * (r - 55296) + (e.charCodeAt(++n) - 56320) + 65536) > 1114111) throw new Error("Unicode standard supports code points up to U+10FFFF");
              t[o++] = 240 + (r >>> 18), t[o++] = r >>> 12 & 63 | 128, t[o++] = r >>> 6 & 63 | 128, t[o++] = 63 & r | 128;
            }
            o >= 64 && (this._dataLength += 64, i._md5cycle(this._state, s), o -= 64, s[0] = s[16]);
          }

          return this._bufferLength = o, this;
        }

        appendAsciiStr(e) {
          const t = this._buffer8,
                s = this._buffer32;
          let r,
              n = this._bufferLength,
              o = 0;

          for (;;) {
            for (r = Math.min(e.length - o, 64 - n); r--;) t[n++] = e.charCodeAt(o++);

            if (n < 64) break;
            this._dataLength += 64, i._md5cycle(this._state, s), n = 0;
          }

          return this._bufferLength = n, this;
        }

        appendByteArray(e) {
          const t = this._buffer8,
                s = this._buffer32;
          let r,
              n = this._bufferLength,
              o = 0;

          for (;;) {
            for (r = Math.min(e.length - o, 64 - n); r--;) t[n++] = e[o++];

            if (n < 64) break;
            this._dataLength += 64, i._md5cycle(this._state, s), n = 0;
          }

          return this._bufferLength = n, this;
        }

        getState() {
          const e = this._state;
          return {
            buffer: String.fromCharCode.apply(null, this._buffer8),
            buflen: this._bufferLength,
            length: this._dataLength,
            state: [e[0], e[1], e[2], e[3]]
          };
        }

        setState(e) {
          const t = e.buffer,
                s = e.state,
                i = this._state;
          let r;

          for (this._dataLength = e.length, this._bufferLength = e.buflen, i[0] = s[0], i[1] = s[1], i[2] = s[2], i[3] = s[3], r = 0; r < t.length; r += 1) this._buffer8[r] = t.charCodeAt(r);
        }

        end(e = !1) {
          const t = this._bufferLength,
                s = this._buffer8,
                r = this._buffer32,
                n = 1 + (t >> 2);
          let o;
          if (this._dataLength += t, s[t] = 128, s[t + 1] = s[t + 2] = s[t + 3] = 0, r.set(i.buffer32Identity.subarray(n), n), t > 55 && (i._md5cycle(this._state, r), r.set(i.buffer32Identity)), (o = 8 * this._dataLength) <= 4294967295) r[14] = o;else {
            const e = o.toString(16).match(/(.*?)(.{0,8})$/);
            if (null === e) return;
            const t = parseInt(e[2], 16),
                  s = parseInt(e[1], 16) || 0;
            r[14] = t, r[15] = s;
          }
          return i._md5cycle(this._state, r), e ? this._state : i._hex(this._state);
        }

      }

      i.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]), i.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), i.hexChars = "0123456789abcdef", i.hexOut = [], i.onePassHasher = new i(), "5d41402abc4b2a76b9719d911017c592" !== i.hashStr("hello") && console.error("Md5 self test failed.");
    },
    "./node_modules/sip.js/lib/core/messages/methods/ack.js":
    /*!**************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/ack.js ***!
      \**************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/bye.js":
    /*!**************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/bye.js ***!
      \**************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/cancel.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/cancel.js ***!
      \*****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/constants.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/constants.js ***!
      \********************************************************************/

    /*! exports provided: C */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "C", function () {
        return i;
      }), function (e) {
        e.ACK = "ACK", e.BYE = "BYE", e.CANCEL = "CANCEL", e.INFO = "INFO", e.INVITE = "INVITE", e.MESSAGE = "MESSAGE", e.NOTIFY = "NOTIFY", e.OPTIONS = "OPTIONS", e.REGISTER = "REGISTER", e.UPDATE = "UPDATE", e.SUBSCRIBE = "SUBSCRIBE", e.PUBLISH = "PUBLISH", e.REFER = "REFER", e.PRACK = "PRACK";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/core/messages/methods/index.js":
    /*!****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/index.js ***!
      \****************************************************************/

    /*! exports provided: C */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js");
      s.d(t, "C", function () {
        return i.C;
      });
      s(
      /*! ./ack.js */
      "./node_modules/sip.js/lib/core/messages/methods/ack.js"), s(
      /*! ./bye.js */
      "./node_modules/sip.js/lib/core/messages/methods/bye.js"), s(
      /*! ./cancel.js */
      "./node_modules/sip.js/lib/core/messages/methods/cancel.js"), s(
      /*! ./info.js */
      "./node_modules/sip.js/lib/core/messages/methods/info.js"), s(
      /*! ./invite.js */
      "./node_modules/sip.js/lib/core/messages/methods/invite.js"), s(
      /*! ./message.js */
      "./node_modules/sip.js/lib/core/messages/methods/message.js"), s(
      /*! ./notify.js */
      "./node_modules/sip.js/lib/core/messages/methods/notify.js"), s(
      /*! ./prack.js */
      "./node_modules/sip.js/lib/core/messages/methods/prack.js"), s(
      /*! ./publish.js */
      "./node_modules/sip.js/lib/core/messages/methods/publish.js"), s(
      /*! ./register.js */
      "./node_modules/sip.js/lib/core/messages/methods/register.js"), s(
      /*! ./refer.js */
      "./node_modules/sip.js/lib/core/messages/methods/refer.js"), s(
      /*! ./subscribe.js */
      "./node_modules/sip.js/lib/core/messages/methods/subscribe.js");
    },
    "./node_modules/sip.js/lib/core/messages/methods/info.js":
    /*!***************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/info.js ***!
      \***************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/invite.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/invite.js ***!
      \*****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/message.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/message.js ***!
      \******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/notify.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/notify.js ***!
      \*****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/prack.js":
    /*!****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/prack.js ***!
      \****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/publish.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/publish.js ***!
      \******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/refer.js":
    /*!****************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/refer.js ***!
      \****************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/register.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/register.js ***!
      \*******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/methods/subscribe.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/methods/subscribe.js ***!
      \********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js":
    /*!***************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/outgoing-request-message.js ***!
      \***************************************************************************/

    /*! exports provided: OutgoingRequestMessage */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "OutgoingRequestMessage", function () {
        return n;
      });
      var i = s(
      /*! ../../grammar/name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js"),
          r = s(
      /*! ./utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js");

      class n {
        constructor(e, t, s, i, o, a, c) {
          this.headers = {}, this.extraHeaders = [], this.options = n.getDefaultOptions(), o && (this.options = Object.assign(Object.assign({}, this.options), o), this.options.optionTags && this.options.optionTags.length && (this.options.optionTags = this.options.optionTags.slice()), this.options.routeSet && this.options.routeSet.length && (this.options.routeSet = this.options.routeSet.slice())), a && a.length && (this.extraHeaders = a.slice()), c && (this.body = {
            body: c.content,
            contentType: c.contentType
          }), this.method = e, this.ruri = t.clone(), this.fromURI = s.clone(), this.fromTag = this.options.fromTag ? this.options.fromTag : Object(r.newTag)(), this.from = n.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag), this.toURI = i.clone(), this.toTag = this.options.toTag, this.to = n.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag), this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + Object(r.createRandomToken)(15), this.cseq = this.options.cseq, this.setHeader("route", this.options.routeSet), this.setHeader("via", ""), this.setHeader("to", this.to.toString()), this.setHeader("from", this.from.toString()), this.setHeader("cseq", this.cseq + " " + this.method), this.setHeader("call-id", this.callId), this.setHeader("max-forwards", "70");
        }

        static getDefaultOptions() {
          return {
            callId: "",
            callIdPrefix: "",
            cseq: 1,
            toDisplayName: "",
            toTag: "",
            fromDisplayName: "",
            fromTag: "",
            forceRport: !1,
            hackViaTcp: !1,
            optionTags: ["outbound"],
            routeSet: [],
            userAgentString: "sip.js",
            viaHost: ""
          };
        }

        static makeNameAddrHeader(e, t, s) {
          const r = {};
          return s && (r.tag = s), new i.NameAddrHeader(e, t, r);
        }

        getHeader(e) {
          const t = this.headers[Object(r.headerize)(e)];

          if (t) {
            if (t[0]) return t[0];
          } else {
            const t = new RegExp("^\\s*" + e + "\\s*:", "i");

            for (const e of this.extraHeaders) if (t.test(e)) return e.substring(e.indexOf(":") + 1).trim();
          }
        }

        getHeaders(e) {
          const t = [],
                s = this.headers[Object(r.headerize)(e)];
          if (s) for (const e of s) t.push(e);else {
            const s = new RegExp("^\\s*" + e + "\\s*:", "i");

            for (const e of this.extraHeaders) s.test(e) && t.push(e.substring(e.indexOf(":") + 1).trim());
          }
          return t;
        }

        hasHeader(e) {
          if (this.headers[Object(r.headerize)(e)]) return !0;
          {
            const t = new RegExp("^\\s*" + e + "\\s*:", "i");

            for (const e of this.extraHeaders) if (t.test(e)) return !0;
          }
          return !1;
        }

        setHeader(e, t) {
          this.headers[Object(r.headerize)(e)] = t instanceof Array ? t : [t];
        }

        setViaHeader(e, t) {
          this.options.hackViaTcp && (t = "TCP");
          let s = "SIP/2.0/" + t;
          s += " " + this.options.viaHost + ";branch=" + e, this.options.forceRport && (s += ";rport"), this.setHeader("via", s), this.branch = e;
        }

        toString() {
          let e = "";
          e += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";

          for (const t in this.headers) if (this.headers[t]) for (const s of this.headers[t]) e += t + ": " + s + "\r\n";

          for (const t of this.extraHeaders) e += t.trim() + "\r\n";

          return e += "Supported: " + this.options.optionTags.join(", ") + "\r\n", e += "User-Agent: " + this.options.userAgentString + "\r\n", this.body ? "string" == typeof this.body ? (e += "Content-Length: " + Object(r.utf8Length)(this.body) + "\r\n\r\n", e += this.body) : this.body.body && this.body.contentType ? (e += "Content-Type: " + this.body.contentType + "\r\n", e += "Content-Length: " + Object(r.utf8Length)(this.body.body) + "\r\n\r\n", e += this.body.body) : e += "Content-Length: 0\r\n\r\n" : e += "Content-Length: 0\r\n\r\n", e;
        }

      }
    },
    "./node_modules/sip.js/lib/core/messages/outgoing-request.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/outgoing-request.js ***!
      \*******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/messages/outgoing-response.js":
    /*!********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/outgoing-response.js ***!
      \********************************************************************/

    /*! exports provided: constructOutgoingResponse */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "constructOutgoingResponse", function () {
        return r;
      });
      var i = s(
      /*! ./utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js");

      function r(e, t) {
        const s = "\r\n";
        if (t.statusCode < 100 || t.statusCode > 699) throw new TypeError("Invalid statusCode: " + t.statusCode);
        const r = t.reasonPhrase ? t.reasonPhrase : Object(i.getReasonPhrase)(t.statusCode);
        let n = "SIP/2.0 " + t.statusCode + " " + r + s;
        t.statusCode >= 100 && t.statusCode, t.statusCode;
        const o = "From: " + e.getHeader("From") + s,
              a = "Call-ID: " + e.callId + s,
              c = "CSeq: " + e.cseq + " " + e.method + s,
              d = e.getHeaders("via").reduce((e, t) => e + "Via: " + t + s, "");
        let l = "To: " + e.getHeader("to");

        if (t.statusCode > 100 && !e.parseHeader("to").hasParam("tag")) {
          let e = t.toTag;
          e || (e = Object(i.newTag)()), l += ";tag=" + e;
        }

        l += s;
        let u = "";
        t.supported && (u = "Supported: " + t.supported.join(", ") + s);
        let h = "";
        t.userAgent && (h = "User-Agent: " + t.userAgent + s);
        let g = "";
        return t.extraHeaders && (g = t.extraHeaders.reduce((e, t) => e + t.trim() + s, "")), n += d, n += o, n += l, n += c, n += a, n += u, n += h, n += g, t.body ? (n += "Content-Type: " + t.body.contentType + s, n += "Content-Length: " + Object(i.utf8Length)(t.body.content) + s + s, n += t.body.content) : n += "Content-Length: 0\r\n\r\n", {
          message: n
        };
      }
    },
    "./node_modules/sip.js/lib/core/messages/parser.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/parser.js ***!
      \*********************************************************/

    /*! exports provided: Parser */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Parser", function () {
        return i;
      });
      var i,
          r = s(
      /*! ../../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js"),
          n = s(
      /*! ./incoming-request-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-request-message.js"),
          o = s(
      /*! ./incoming-response-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response-message.js");
      !function (e) {
        function t(e, t) {
          let s = t,
              i = 0,
              r = 0;
          if (e.substring(s, s + 2).match(/(^\r\n)/)) return -2;

          for (; 0 === i;) {
            if (-1 === (r = e.indexOf("\r\n", s))) return r;
            !e.substring(r + 2, r + 4).match(/(^\r\n)/) && e.charAt(r + 2).match(/(^\s+)/) ? s = r + 2 : i = r;
          }

          return i;
        }

        function s(e, t, s, i) {
          const n = t.indexOf(":", s),
                a = t.substring(s, n).trim(),
                c = t.substring(n + 1, i).trim();
          let d;

          switch (a.toLowerCase()) {
            case "via":
            case "v":
              e.addHeader("via", c), 1 === e.getHeaders("via").length ? (d = e.parseHeader("Via")) && (e.via = d, e.viaBranch = d.branch) : d = 0;
              break;

            case "from":
            case "f":
              e.setHeader("from", c), (d = e.parseHeader("from")) && (e.from = d, e.fromTag = d.getParam("tag"));
              break;

            case "to":
            case "t":
              e.setHeader("to", c), (d = e.parseHeader("to")) && (e.to = d, e.toTag = d.getParam("tag"));
              break;

            case "record-route":
              if (-1 === (d = r.Grammar.parse(c, "Record_Route"))) {
                d = void 0;
                break;
              }

              if (!(d instanceof Array)) {
                d = void 0;
                break;
              }

              d.forEach(t => {
                e.addHeader("record-route", c.substring(t.position, t.offset)), e.headers["Record-Route"][e.getHeaders("record-route").length - 1].parsed = t.parsed;
              });
              break;

            case "call-id":
            case "i":
              e.setHeader("call-id", c), (d = e.parseHeader("call-id")) && (e.callId = c);
              break;

            case "contact":
            case "m":
              if (-1 === (d = r.Grammar.parse(c, "Contact"))) {
                d = void 0;
                break;
              }

              if (!(d instanceof Array)) {
                d = void 0;
                break;
              }

              d.forEach(t => {
                e.addHeader("contact", c.substring(t.position, t.offset)), e.headers.Contact[e.getHeaders("contact").length - 1].parsed = t.parsed;
              });
              break;

            case "content-length":
            case "l":
              e.setHeader("content-length", c), d = e.parseHeader("content-length");
              break;

            case "content-type":
            case "c":
              e.setHeader("content-type", c), d = e.parseHeader("content-type");
              break;

            case "cseq":
              e.setHeader("cseq", c), (d = e.parseHeader("cseq")) && (e.cseq = d.value), e instanceof o.IncomingResponseMessage && (e.method = d.method);
              break;

            case "max-forwards":
              e.setHeader("max-forwards", c), d = e.parseHeader("max-forwards");
              break;

            case "www-authenticate":
              e.setHeader("www-authenticate", c), d = e.parseHeader("www-authenticate");
              break;

            case "proxy-authenticate":
              e.setHeader("proxy-authenticate", c), d = e.parseHeader("proxy-authenticate");
              break;

            case "refer-to":
            case "r":
              e.setHeader("refer-to", c), (d = e.parseHeader("refer-to")) && (e.referTo = d);
              break;

            default:
              e.addHeader(a.toLowerCase(), c), d = 0;
          }

          return void 0 !== d || {
            error: "error parsing header '" + a + "'"
          };
        }

        e.getHeader = t, e.parseHeader = s, e.parseMessage = function (e, i) {
          let a = 0,
              c = e.indexOf("\r\n");
          if (-1 === c) return void i.warn("no CRLF found, not a SIP message, discarded");
          const d = e.substring(0, c),
                l = r.Grammar.parse(d, "Request_Response");
          let u, h;

          if (-1 !== l) {
            for (l.status_code ? ((u = new o.IncomingResponseMessage()).statusCode = l.status_code, u.reasonPhrase = l.reason_phrase) : ((u = new n.IncomingRequestMessage()).method = l.method, u.ruri = l.uri), u.data = e, a = c + 2;;) {
              if (-2 === (c = t(e, a))) {
                h = a + 2;
                break;
              }

              if (-1 === c) return void i.error("malformed message");
              const r = s(u, e, a, c);
              if (r && !0 !== r) return void i.error(r.error);
              a = c + 2;
            }

            return u.hasHeader("content-length") ? u.body = e.substr(h, Number(u.getHeader("content-length"))) : u.body = e.substring(h), u;
          }

          i.warn('error parsing first line of SIP message: "' + d + '"');
        };
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/core/messages/utils.js":
    /*!********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/messages/utils.js ***!
      \********************************************************/

    /*! exports provided: createRandomToken, getReasonPhrase, newTag, headerize, utf8Length */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "createRandomToken", function () {
        return r;
      }), s.d(t, "getReasonPhrase", function () {
        return n;
      }), s.d(t, "newTag", function () {
        return o;
      }), s.d(t, "headerize", function () {
        return a;
      }), s.d(t, "utf8Length", function () {
        return c;
      });
      const i = {
        100: "Trying",
        180: "Ringing",
        181: "Call Is Being Forwarded",
        182: "Queued",
        183: "Session Progress",
        199: "Early Dialog Terminated",
        200: "OK",
        202: "Accepted",
        204: "No Notification",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        305: "Use Proxy",
        380: "Alternative Service",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        410: "Gone",
        412: "Conditional Request Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Long",
        415: "Unsupported Media Type",
        416: "Unsupported URI Scheme",
        417: "Unknown Resource-Priority",
        420: "Bad Extension",
        421: "Extension Required",
        422: "Session Interval Too Small",
        423: "Interval Too Brief",
        428: "Use Identity Header",
        429: "Provide Referrer Identity",
        430: "Flow Failed",
        433: "Anonymity Disallowed",
        436: "Bad Identity-Info",
        437: "Unsupported Certificate",
        438: "Invalid Identity Header",
        439: "First Hop Lacks Outbound Support",
        440: "Max-Breadth Exceeded",
        469: "Bad Info Package",
        470: "Consent Needed",
        478: "Unresolvable Destination",
        480: "Temporarily Unavailable",
        481: "Call/Transaction Does Not Exist",
        482: "Loop Detected",
        483: "Too Many Hops",
        484: "Address Incomplete",
        485: "Ambiguous",
        486: "Busy Here",
        487: "Request Terminated",
        488: "Not Acceptable Here",
        489: "Bad Event",
        491: "Request Pending",
        493: "Undecipherable",
        494: "Security Agreement Required",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Server Time-out",
        505: "Version Not Supported",
        513: "Message Too Large",
        580: "Precondition Failure",
        600: "Busy Everywhere",
        603: "Decline",
        604: "Does Not Exist Anywhere",
        606: "Not Acceptable"
      };

      function r(e, t = 32) {
        let s = "";

        for (let i = 0; i < e; i++) {
          s += Math.floor(Math.random() * t).toString(t);
        }

        return s;
      }

      function n(e) {
        return i[e] || "";
      }

      function o() {
        return r(10);
      }

      function a(e) {
        const t = {
          "Call-Id": "Call-ID",
          Cseq: "CSeq",
          "Min-Se": "Min-SE",
          Rack: "RAck",
          Rseq: "RSeq",
          "Www-Authenticate": "WWW-Authenticate"
        },
              s = e.toLowerCase().replace(/_/g, "-").split("-"),
              i = s.length;
        let r = "";

        for (let e = 0; e < i; e++) 0 !== e && (r += "-"), r += s[e].charAt(0).toUpperCase() + s[e].substring(1);

        return t[r] && (r = t[r]), r;
      }

      function c(e) {
        return encodeURIComponent(e).replace(/%[A-F\d]{2}/g, "U").length;
      }
    },
    "./node_modules/sip.js/lib/core/session/index.js":
    /*!*******************************************************!*\
      !*** ./node_modules/sip.js/lib/core/session/index.js ***!
      \*******************************************************/

    /*! exports provided: SessionState, SignalingState */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./session.js */
      "./node_modules/sip.js/lib/core/session/session.js");
      s.d(t, "SessionState", function () {
        return i.SessionState;
      }), s.d(t, "SignalingState", function () {
        return i.SignalingState;
      });
      s(
      /*! ./session-delegate.js */
      "./node_modules/sip.js/lib/core/session/session-delegate.js");
    },
    "./node_modules/sip.js/lib/core/session/session-delegate.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/session/session-delegate.js ***!
      \******************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/session/session.js":
    /*!*********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/session/session.js ***!
      \*********************************************************/

    /*! exports provided: SessionState, SignalingState */
    function (e, t, s) {
      "use strict";

      var i, r;
      s.r(t), s.d(t, "SessionState", function () {
        return i;
      }), s.d(t, "SignalingState", function () {
        return r;
      }), function (e) {
        e.Initial = "Initial", e.Early = "Early", e.AckWait = "AckWait", e.Confirmed = "Confirmed", e.Terminated = "Terminated";
      }(i = i || (i = {})), function (e) {
        e.Initial = "Initial", e.HaveLocalOffer = "HaveLocalOffer", e.HaveRemoteOffer = "HaveRemoteOffer", e.Stable = "Stable", e.Closed = "Closed";
      }(r = r || (r = {}));
    },
    "./node_modules/sip.js/lib/core/subscription/index.js":
    /*!************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/subscription/index.js ***!
      \************************************************************/

    /*! exports provided: SubscriptionState */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./subscription.js */
      "./node_modules/sip.js/lib/core/subscription/subscription.js");
      s.d(t, "SubscriptionState", function () {
        return i.SubscriptionState;
      });
      s(
      /*! ./subscription-delegate.js */
      "./node_modules/sip.js/lib/core/subscription/subscription-delegate.js");
    },
    "./node_modules/sip.js/lib/core/subscription/subscription-delegate.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/subscription/subscription-delegate.js ***!
      \****************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/subscription/subscription.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/subscription/subscription.js ***!
      \*******************************************************************/

    /*! exports provided: SubscriptionState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "SubscriptionState", function () {
        return i;
      }), function (e) {
        e.Initial = "Initial", e.NotifyWait = "NotifyWait", e.Pending = "Pending", e.Active = "Active", e.Terminated = "Terminated";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/core/timers.js":
    /*!************************************************!*\
      !*** ./node_modules/sip.js/lib/core/timers.js ***!
      \************************************************/

    /*! exports provided: Timers */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Timers", function () {
        return r;
      });
      const i = 500,
            r = {
        T1: i,
        T2: 4e3,
        T4: 5e3,
        TIMER_B: 32e3,
        TIMER_D: 0,
        TIMER_F: 32e3,
        TIMER_H: 32e3,
        TIMER_I: 0,
        TIMER_J: 0,
        TIMER_K: 0,
        TIMER_L: 32e3,
        TIMER_M: 32e3,
        TIMER_N: 32e3,
        PROVISIONAL_RESPONSE_INTERVAL: 6e4
      };
    },
    "./node_modules/sip.js/lib/core/transactions/client-transaction.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/client-transaction.js ***!
      \*************************************************************************/

    /*! exports provided: ClientTransaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ClientTransaction", function () {
        return r;
      });
      var i = s(
      /*! ./transaction.js */
      "./node_modules/sip.js/lib/core/transactions/transaction.js");

      class r extends i.Transaction {
        constructor(e, t, s, i, n) {
          super(t, s, r.makeId(e), i, n), this._request = e, this.user = s, e.setViaHeader(this.id, t.protocol);
        }

        static makeId(e) {
          if ("CANCEL" === e.method) {
            if (!e.branch) throw new Error("Outgoing CANCEL request without a branch.");
            return e.branch;
          }

          return "z9hG4bK" + Math.floor(1e7 * Math.random());
        }

        get request() {
          return this._request;
        }

        onRequestTimeout() {
          this.user.onRequestTimeout && this.user.onRequestTimeout();
        }

      }
    },
    "./node_modules/sip.js/lib/core/transactions/index.js":
    /*!************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/index.js ***!
      \************************************************************/

    /*! exports provided: ClientTransaction, InviteClientTransaction, InviteServerTransaction, NonInviteClientTransaction, NonInviteServerTransaction, ServerTransaction, TransactionState, Transaction */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/client-transaction.js");
      s.d(t, "ClientTransaction", function () {
        return i.ClientTransaction;
      });
      var r = s(
      /*! ./invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js");
      s.d(t, "InviteClientTransaction", function () {
        return r.InviteClientTransaction;
      });
      var n = s(
      /*! ./invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js");
      s.d(t, "InviteServerTransaction", function () {
        return n.InviteServerTransaction;
      });
      var o = s(
      /*! ./non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js");
      s.d(t, "NonInviteClientTransaction", function () {
        return o.NonInviteClientTransaction;
      });
      var a = s(
      /*! ./non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js");
      s.d(t, "NonInviteServerTransaction", function () {
        return a.NonInviteServerTransaction;
      });
      var c = s(
      /*! ./server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/server-transaction.js");
      s.d(t, "ServerTransaction", function () {
        return c.ServerTransaction;
      });
      var d = s(
      /*! ./transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
      s.d(t, "TransactionState", function () {
        return d.TransactionState;
      });
      s(
      /*! ./transaction-user.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-user.js");
      var l = s(
      /*! ./transaction.js */
      "./node_modules/sip.js/lib/core/transactions/transaction.js");
      s.d(t, "Transaction", function () {
        return l.Transaction;
      });
    },
    "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js":
    /*!********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js ***!
      \********************************************************************************/

    /*! exports provided: InviteClientTransaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "InviteClientTransaction", function () {
        return o;
      });
      var i = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          r = s(
      /*! ./client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/client-transaction.js"),
          n = s(
      /*! ./transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");

      class o extends r.ClientTransaction {
        constructor(e, t, s) {
          super(e, t, s, n.TransactionState.Calling, "sip.transaction.ict"), this.ackRetransmissionCache = new Map(), this.B = setTimeout(() => this.timerB(), i.Timers.TIMER_B), this.send(e.toString()).catch(e => {
            this.logTransportError(e, "Failed to send initial outgoing request.");
          });
        }

        dispose() {
          this.B && (clearTimeout(this.B), this.B = void 0), this.D && (clearTimeout(this.D), this.D = void 0), this.M && (clearTimeout(this.M), this.M = void 0), super.dispose();
        }

        get kind() {
          return "ict";
        }

        ackResponse(e) {
          const t = e.toTag;
          if (!t) throw new Error("To tag undefined.");
          const s = "z9hG4bK" + Math.floor(1e7 * Math.random());
          e.setViaHeader(s, this.transport.protocol), this.ackRetransmissionCache.set(t, e), this.send(e.toString()).catch(e => {
            this.logTransportError(e, "Failed to send ACK to 2xx response.");
          });
        }

        receiveResponse(e) {
          const t = e.statusCode;
          if (!t || t < 100 || t > 699) throw new Error(`Invalid status code ${t}`);

          switch (this.state) {
            case n.TransactionState.Calling:
              if (t >= 100 && t <= 199) return this.stateTransition(n.TransactionState.Proceeding), void (this.user.receiveResponse && this.user.receiveResponse(e));
              if (t >= 200 && t <= 299) return this.ackRetransmissionCache.set(e.toTag, void 0), this.stateTransition(n.TransactionState.Accepted), void (this.user.receiveResponse && this.user.receiveResponse(e));
              if (t >= 300 && t <= 699) return this.stateTransition(n.TransactionState.Completed), this.ack(e), void (this.user.receiveResponse && this.user.receiveResponse(e));
              break;

            case n.TransactionState.Proceeding:
              if (t >= 100 && t <= 199) return void (this.user.receiveResponse && this.user.receiveResponse(e));
              if (t >= 200 && t <= 299) return this.ackRetransmissionCache.set(e.toTag, void 0), this.stateTransition(n.TransactionState.Accepted), void (this.user.receiveResponse && this.user.receiveResponse(e));
              if (t >= 300 && t <= 699) return this.stateTransition(n.TransactionState.Completed), this.ack(e), void (this.user.receiveResponse && this.user.receiveResponse(e));
              break;

            case n.TransactionState.Accepted:
              if (t >= 200 && t <= 299) {
                if (!this.ackRetransmissionCache.has(e.toTag)) return this.ackRetransmissionCache.set(e.toTag, void 0), void (this.user.receiveResponse && this.user.receiveResponse(e));
                const t = this.ackRetransmissionCache.get(e.toTag);
                return t ? void this.send(t.toString()).catch(e => {
                  this.logTransportError(e, "Failed to send retransmission of ACK to 2xx response.");
                }) : void 0;
              }

              break;

            case n.TransactionState.Completed:
              if (t >= 300 && t <= 699) return void this.ack(e);
              break;

            case n.TransactionState.Terminated:
              break;

            default:
              throw new Error(`Invalid state ${this.state}`);
          }

          const s = `Received unexpected ${t} response while in state ${this.state}.`;
          this.logger.warn(s);
        }

        onTransportError(e) {
          this.user.onTransportError && this.user.onTransportError(e), this.stateTransition(n.TransactionState.Terminated, !0);
        }

        typeToString() {
          return "INVITE client transaction";
        }

        ack(e) {
          const t = this.request.ruri,
                s = this.request.callId,
                i = this.request.cseq,
                r = this.request.getHeader("from"),
                n = e.getHeader("to"),
                o = this.request.getHeader("via"),
                a = this.request.getHeader("route");
          if (!r) throw new Error("From undefined.");
          if (!n) throw new Error("To undefined.");
          if (!o) throw new Error("Via undefined.");
          let c = `ACK ${t} SIP/2.0\r\n`;
          a && (c += `Route: ${a}\r\n`), c += `Via: ${o}\r\n`, c += `To: ${n}\r\n`, c += `From: ${r}\r\n`, c += `Call-ID: ${s}\r\n`, c += `CSeq: ${i} ACK\r\n`, c += "Max-Forwards: 70\r\n", c += "Content-Length: 0\r\n\r\n", this.send(c).catch(e => {
            this.logTransportError(e, "Failed to send ACK to non-2xx response.");
          });
        }

        stateTransition(e, t = !1) {
          const s = () => {
            throw new Error(`Invalid state transition from ${this.state} to ${e}`);
          };

          switch (e) {
            case n.TransactionState.Calling:
              s();
              break;

            case n.TransactionState.Proceeding:
              this.state !== n.TransactionState.Calling && s();
              break;

            case n.TransactionState.Accepted:
            case n.TransactionState.Completed:
              this.state !== n.TransactionState.Calling && this.state !== n.TransactionState.Proceeding && s();
              break;

            case n.TransactionState.Terminated:
              this.state !== n.TransactionState.Calling && this.state !== n.TransactionState.Accepted && this.state !== n.TransactionState.Completed && (t || s());
              break;

            default:
              s();
          }

          this.B && (clearTimeout(this.B), this.B = void 0), n.TransactionState.Proceeding, e === n.TransactionState.Completed && (this.D = setTimeout(() => this.timerD(), i.Timers.TIMER_D)), e === n.TransactionState.Accepted && (this.M = setTimeout(() => this.timerM(), i.Timers.TIMER_M)), e === n.TransactionState.Terminated && this.dispose(), this.setState(e);
        }

        timerA() {}

        timerB() {
          this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`), this.state === n.TransactionState.Calling && (this.onRequestTimeout(), this.stateTransition(n.TransactionState.Terminated));
        }

        timerD() {
          this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`), this.state === n.TransactionState.Completed && this.stateTransition(n.TransactionState.Terminated);
        }

        timerM() {
          this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`), this.state === n.TransactionState.Accepted && this.stateTransition(n.TransactionState.Terminated);
        }

      }
    },
    "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js":
    /*!********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js ***!
      \********************************************************************************/

    /*! exports provided: InviteServerTransaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "InviteServerTransaction", function () {
        return a;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          n = s(
      /*! ./server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/server-transaction.js"),
          o = s(
      /*! ./transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");

      class a extends n.ServerTransaction {
        constructor(e, t, s) {
          super(e, t, s, o.TransactionState.Proceeding, "sip.transaction.ist");
        }

        dispose() {
          this.stopProgressExtensionTimer(), this.H && (clearTimeout(this.H), this.H = void 0), this.I && (clearTimeout(this.I), this.I = void 0), this.L && (clearTimeout(this.L), this.L = void 0), super.dispose();
        }

        get kind() {
          return "ist";
        }

        receiveRequest(e) {
          switch (this.state) {
            case o.TransactionState.Proceeding:
              if (e.method === i.C.INVITE) return void (this.lastProvisionalResponse && this.send(this.lastProvisionalResponse).catch(e => {
                this.logTransportError(e, "Failed to send retransmission of provisional response.");
              }));
              break;

            case o.TransactionState.Accepted:
              if (e.method === i.C.INVITE) return;
              break;

            case o.TransactionState.Completed:
              if (e.method === i.C.INVITE) {
                if (!this.lastFinalResponse) throw new Error("Last final response undefined.");
                return void this.send(this.lastFinalResponse).catch(e => {
                  this.logTransportError(e, "Failed to send retransmission of final response.");
                });
              }

              if (e.method === i.C.ACK) return void this.stateTransition(o.TransactionState.Confirmed);
              break;

            case o.TransactionState.Confirmed:
            case o.TransactionState.Terminated:
              if (e.method === i.C.INVITE || e.method === i.C.ACK) return;
              break;

            default:
              throw new Error(`Invalid state ${this.state}`);
          }

          const t = `INVITE server transaction received unexpected ${e.method} request while in state ${this.state}.`;
          this.logger.warn(t);
        }

        receiveResponse(e, t) {
          if (e < 100 || e > 699) throw new Error(`Invalid status code ${e}`);

          switch (this.state) {
            case o.TransactionState.Proceeding:
              if (e >= 100 && e <= 199) return this.lastProvisionalResponse = t, e > 100 && this.startProgressExtensionTimer(), void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send 1xx response.");
              });
              if (e >= 200 && e <= 299) return this.lastFinalResponse = t, this.stateTransition(o.TransactionState.Accepted), void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send 2xx response.");
              });
              if (e >= 300 && e <= 699) return this.lastFinalResponse = t, this.stateTransition(o.TransactionState.Completed), void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send non-2xx final response.");
              });
              break;

            case o.TransactionState.Accepted:
              if (e >= 200 && e <= 299) return void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send 2xx response.");
              });
              break;

            case o.TransactionState.Completed:
            case o.TransactionState.Confirmed:
            case o.TransactionState.Terminated:
              break;

            default:
              throw new Error(`Invalid state ${this.state}`);
          }

          const s = `INVITE server transaction received unexpected ${e} response from TU while in state ${this.state}.`;
          throw this.logger.error(s), new Error(s);
        }

        retransmitAcceptedResponse() {
          this.state === o.TransactionState.Accepted && this.lastFinalResponse && this.send(this.lastFinalResponse).catch(e => {
            this.logTransportError(e, "Failed to send 2xx response.");
          });
        }

        onTransportError(e) {
          this.user.onTransportError && this.user.onTransportError(e);
        }

        typeToString() {
          return "INVITE server transaction";
        }

        stateTransition(e) {
          const t = () => {
            throw new Error(`Invalid state transition from ${this.state} to ${e}`);
          };

          switch (e) {
            case o.TransactionState.Proceeding:
              t();
              break;

            case o.TransactionState.Accepted:
            case o.TransactionState.Completed:
              this.state !== o.TransactionState.Proceeding && t();
              break;

            case o.TransactionState.Confirmed:
              this.state !== o.TransactionState.Completed && t();
              break;

            case o.TransactionState.Terminated:
              this.state !== o.TransactionState.Accepted && this.state !== o.TransactionState.Completed && this.state !== o.TransactionState.Confirmed && t();
              break;

            default:
              t();
          }

          this.stopProgressExtensionTimer(), e === o.TransactionState.Accepted && (this.L = setTimeout(() => this.timerL(), r.Timers.TIMER_L)), e === o.TransactionState.Completed && (this.H = setTimeout(() => this.timerH(), r.Timers.TIMER_H)), e === o.TransactionState.Confirmed && (this.I = setTimeout(() => this.timerI(), r.Timers.TIMER_I)), e === o.TransactionState.Terminated && this.dispose(), this.setState(e);
        }

        startProgressExtensionTimer() {
          void 0 === this.progressExtensionTimer && (this.progressExtensionTimer = setInterval(() => {
            if (this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`), !this.lastProvisionalResponse) throw new Error("Last provisional response undefined.");
            this.send(this.lastProvisionalResponse).catch(e => {
              this.logTransportError(e, "Failed to send retransmission of provisional response.");
            });
          }, r.Timers.PROVISIONAL_RESPONSE_INTERVAL));
        }

        stopProgressExtensionTimer() {
          void 0 !== this.progressExtensionTimer && (clearInterval(this.progressExtensionTimer), this.progressExtensionTimer = void 0);
        }

        timerG() {}

        timerH() {
          this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`), this.state === o.TransactionState.Completed && (this.logger.warn("ACK to negative final response was never received, terminating transaction."), this.stateTransition(o.TransactionState.Terminated));
        }

        timerI() {
          this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`), this.stateTransition(o.TransactionState.Terminated);
        }

        timerL() {
          this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`), this.state === o.TransactionState.Accepted && this.stateTransition(o.TransactionState.Terminated);
        }

      }
    },
    "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js":
    /*!************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js ***!
      \************************************************************************************/

    /*! exports provided: NonInviteClientTransaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "NonInviteClientTransaction", function () {
        return o;
      });
      var i = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          r = s(
      /*! ./client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/client-transaction.js"),
          n = s(
      /*! ./transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");

      class o extends r.ClientTransaction {
        constructor(e, t, s) {
          super(e, t, s, n.TransactionState.Trying, "sip.transaction.nict"), this.F = setTimeout(() => this.timerF(), i.Timers.TIMER_F), this.send(e.toString()).catch(e => {
            this.logTransportError(e, "Failed to send initial outgoing request.");
          });
        }

        dispose() {
          this.F && (clearTimeout(this.F), this.F = void 0), this.K && (clearTimeout(this.K), this.K = void 0), super.dispose();
        }

        get kind() {
          return "nict";
        }

        receiveResponse(e) {
          const t = e.statusCode;
          if (!t || t < 100 || t > 699) throw new Error(`Invalid status code ${t}`);

          switch (this.state) {
            case n.TransactionState.Trying:
              if (t >= 100 && t <= 199) return this.stateTransition(n.TransactionState.Proceeding), void (this.user.receiveResponse && this.user.receiveResponse(e));
              if (t >= 200 && t <= 699) return this.stateTransition(n.TransactionState.Completed), 408 === t ? void this.onRequestTimeout() : void (this.user.receiveResponse && this.user.receiveResponse(e));
              break;

            case n.TransactionState.Proceeding:
              if (t >= 100 && t <= 199 && this.user.receiveResponse) return this.user.receiveResponse(e);
              if (t >= 200 && t <= 699) return this.stateTransition(n.TransactionState.Completed), 408 === t ? void this.onRequestTimeout() : void (this.user.receiveResponse && this.user.receiveResponse(e));
              break;

            case n.TransactionState.Completed:
            case n.TransactionState.Terminated:
              return;

            default:
              throw new Error(`Invalid state ${this.state}`);
          }

          const s = `Non-INVITE client transaction received unexpected ${t} response while in state ${this.state}.`;
          this.logger.warn(s);
        }

        onTransportError(e) {
          this.user.onTransportError && this.user.onTransportError(e), this.stateTransition(n.TransactionState.Terminated, !0);
        }

        typeToString() {
          return "non-INVITE client transaction";
        }

        stateTransition(e, t = !1) {
          const s = () => {
            throw new Error(`Invalid state transition from ${this.state} to ${e}`);
          };

          switch (e) {
            case n.TransactionState.Trying:
              s();
              break;

            case n.TransactionState.Proceeding:
              this.state !== n.TransactionState.Trying && s();
              break;

            case n.TransactionState.Completed:
              this.state !== n.TransactionState.Trying && this.state !== n.TransactionState.Proceeding && s();
              break;

            case n.TransactionState.Terminated:
              this.state !== n.TransactionState.Trying && this.state !== n.TransactionState.Proceeding && this.state !== n.TransactionState.Completed && (t || s());
              break;

            default:
              s();
          }

          e === n.TransactionState.Completed && (this.F && (clearTimeout(this.F), this.F = void 0), this.K = setTimeout(() => this.timerK(), i.Timers.TIMER_K)), e === n.TransactionState.Terminated && this.dispose(), this.setState(e);
        }

        timerF() {
          this.logger.debug(`Timer F expired for non-INVITE client transaction ${this.id}.`), this.state !== n.TransactionState.Trying && this.state !== n.TransactionState.Proceeding || (this.onRequestTimeout(), this.stateTransition(n.TransactionState.Terminated));
        }

        timerK() {
          this.state === n.TransactionState.Completed && this.stateTransition(n.TransactionState.Terminated);
        }

      }
    },
    "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js":
    /*!************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js ***!
      \************************************************************************************/

    /*! exports provided: NonInviteServerTransaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "NonInviteServerTransaction", function () {
        return o;
      });
      var i = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          r = s(
      /*! ./server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/server-transaction.js"),
          n = s(
      /*! ./transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");

      class o extends r.ServerTransaction {
        constructor(e, t, s) {
          super(e, t, s, n.TransactionState.Trying, "sip.transaction.nist");
        }

        dispose() {
          this.J && (clearTimeout(this.J), this.J = void 0), super.dispose();
        }

        get kind() {
          return "nist";
        }

        receiveRequest(e) {
          switch (this.state) {
            case n.TransactionState.Trying:
              break;

            case n.TransactionState.Proceeding:
              if (!this.lastResponse) throw new Error("Last response undefined.");
              this.send(this.lastResponse).catch(e => {
                this.logTransportError(e, "Failed to send retransmission of provisional response.");
              });
              break;

            case n.TransactionState.Completed:
              if (!this.lastResponse) throw new Error("Last response undefined.");
              this.send(this.lastResponse).catch(e => {
                this.logTransportError(e, "Failed to send retransmission of final response.");
              });
              break;

            case n.TransactionState.Terminated:
              break;

            default:
              throw new Error(`Invalid state ${this.state}`);
          }
        }

        receiveResponse(e, t) {
          if (e < 100 || e > 699) throw new Error(`Invalid status code ${e}`);
          if (e > 100 && e <= 199) throw new Error("Provisional response other than 100 not allowed.");

          switch (this.state) {
            case n.TransactionState.Trying:
              if (this.lastResponse = t, e >= 100 && e < 200) return this.stateTransition(n.TransactionState.Proceeding), void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send provisional response.");
              });
              if (e >= 200 && e <= 699) return this.stateTransition(n.TransactionState.Completed), void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send final response.");
              });
              break;

            case n.TransactionState.Proceeding:
              if (this.lastResponse = t, e >= 200 && e <= 699) return this.stateTransition(n.TransactionState.Completed), void this.send(t).catch(e => {
                this.logTransportError(e, "Failed to send final response.");
              });
              break;

            case n.TransactionState.Completed:
              return;

            case n.TransactionState.Terminated:
              break;

            default:
              throw new Error(`Invalid state ${this.state}`);
          }

          const s = `Non-INVITE server transaction received unexpected ${e} response from TU while in state ${this.state}.`;
          throw this.logger.error(s), new Error(s);
        }

        onTransportError(e) {
          this.user.onTransportError && this.user.onTransportError(e), this.stateTransition(n.TransactionState.Terminated, !0);
        }

        typeToString() {
          return "non-INVITE server transaction";
        }

        stateTransition(e, t = !1) {
          const s = () => {
            throw new Error(`Invalid state transition from ${this.state} to ${e}`);
          };

          switch (e) {
            case n.TransactionState.Trying:
              s();
              break;

            case n.TransactionState.Proceeding:
              this.state !== n.TransactionState.Trying && s();
              break;

            case n.TransactionState.Completed:
              this.state !== n.TransactionState.Trying && this.state !== n.TransactionState.Proceeding && s();
              break;

            case n.TransactionState.Terminated:
              this.state !== n.TransactionState.Proceeding && this.state !== n.TransactionState.Completed && (t || s());
              break;

            default:
              s();
          }

          e === n.TransactionState.Completed && (this.J = setTimeout(() => this.timerJ(), i.Timers.TIMER_J)), e === n.TransactionState.Terminated && this.dispose(), this.setState(e);
        }

        timerJ() {
          this.logger.debug(`Timer J expired for NON-INVITE server transaction ${this.id}.`), this.state === n.TransactionState.Completed && this.stateTransition(n.TransactionState.Terminated);
        }

      }
    },
    "./node_modules/sip.js/lib/core/transactions/server-transaction.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/server-transaction.js ***!
      \*************************************************************************/

    /*! exports provided: ServerTransaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ServerTransaction", function () {
        return r;
      });
      var i = s(
      /*! ./transaction.js */
      "./node_modules/sip.js/lib/core/transactions/transaction.js");

      class r extends i.Transaction {
        constructor(e, t, s, i, r) {
          super(t, s, e.viaBranch, i, r), this._request = e, this.user = s;
        }

        get request() {
          return this._request;
        }

      }
    },
    "./node_modules/sip.js/lib/core/transactions/transaction-state.js":
    /*!************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/transaction-state.js ***!
      \************************************************************************/

    /*! exports provided: TransactionState */
    function (e, t, s) {
      "use strict";

      var i;
      s.r(t), s.d(t, "TransactionState", function () {
        return i;
      }), function (e) {
        e.Accepted = "Accepted", e.Calling = "Calling", e.Completed = "Completed", e.Confirmed = "Confirmed", e.Proceeding = "Proceeding", e.Terminated = "Terminated", e.Trying = "Trying";
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/core/transactions/transaction-user.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/transaction-user.js ***!
      \***********************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/transactions/transaction.js":
    /*!******************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transactions/transaction.js ***!
      \******************************************************************/

    /*! exports provided: Transaction */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Transaction", function () {
        return r;
      });
      var i = s(
      /*! ../exceptions/transport-error.js */
      "./node_modules/sip.js/lib/core/exceptions/transport-error.js");

      class r {
        constructor(e, t, s, i, r) {
          this._transport = e, this._user = t, this._id = s, this._state = i, this.listeners = new Array(), this.logger = t.loggerFactory.getLogger(r, s), this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);
        }

        dispose() {
          this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);
        }

        get id() {
          return this._id;
        }

        get kind() {
          throw new Error("Invalid kind.");
        }

        get state() {
          return this._state;
        }

        get transport() {
          return this._transport;
        }

        addStateChangeListener(e, t) {
          const s = () => {
            this.removeStateChangeListener(s), e();
          };

          !0 === (null == t ? void 0 : t.once) ? this.listeners.push(s) : this.listeners.push(e);
        }

        notifyStateChangeListeners() {
          this.listeners.slice().forEach(e => e());
        }

        removeStateChangeListener(e) {
          this.listeners = this.listeners.filter(t => t !== e);
        }

        logTransportError(e, t) {
          this.logger.error(e.message), this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`), this.logger.error(t);
        }

        send(e) {
          return this.transport.send(e).catch(e => {
            if (e instanceof i.TransportError) throw this.onTransportError(e), e;
            let t;
            throw t = e && "string" == typeof e.message ? new i.TransportError(e.message) : new i.TransportError(), this.onTransportError(t), t;
          });
        }

        setState(e) {
          this.logger.debug(`State change to "${e}" on ${this.typeToString()} with id ${this.id}.`), this._state = e, this._user.onStateChange && this._user.onStateChange(e), this.notifyStateChangeListeners();
        }

        typeToString() {
          return "UnknownType";
        }

      }
    },
    "./node_modules/sip.js/lib/core/transport.js":
    /*!***************************************************!*\
      !*** ./node_modules/sip.js/lib/core/transport.js ***!
      \***************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js ***!
      \*************************************************************************/

    /*! exports provided: AllowedMethods */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "AllowedMethods", function () {
        return r;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js");
      const r = [i.C.ACK, i.C.BYE, i.C.CANCEL, i.C.INFO, i.C.INVITE, i.C.MESSAGE, i.C.NOTIFY, i.C.OPTIONS, i.C.PRACK, i.C.REFER, i.C.REGISTER, i.C.SUBSCRIBE];
    },
    "./node_modules/sip.js/lib/core/user-agent-core/index.js":
    /*!***************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agent-core/index.js ***!
      \***************************************************************/

    /*! exports provided: UserAgentCore */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./user-agent-core.js */
      "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js");
      s.d(t, "UserAgentCore", function () {
        return i.UserAgentCore;
      });
      s(
      /*! ./user-agent-core-configuration.js */
      "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core-configuration.js"), s(
      /*! ./user-agent-core-delegate.js */
      "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core-delegate.js");
    },
    "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core-configuration.js":
    /*!***************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agent-core/user-agent-core-configuration.js ***!
      \***************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core-delegate.js":
    /*!**********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agent-core/user-agent-core-delegate.js ***!
      \**********************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js ***!
      \*************************************************************************/

    /*! exports provided: UserAgentCore */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "UserAgentCore", function () {
        return y;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../messages/outgoing-request-message.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js"),
          n = s(
      /*! ../messages/outgoing-response.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-response.js"),
          o = s(
      /*! ../transactions/invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"),
          a = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          c = s(
      /*! ../transactions/transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js"),
          d = s(
      /*! ../user-agents/invite-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js"),
          l = s(
      /*! ../user-agents/invite-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js"),
          u = s(
      /*! ../user-agents/message-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js"),
          h = s(
      /*! ../user-agents/message-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js"),
          g = s(
      /*! ../user-agents/notify-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js"),
          p = s(
      /*! ../user-agents/publish-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js"),
          m = s(
      /*! ../user-agents/refer-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js"),
          f = s(
      /*! ../user-agents/register-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js"),
          v = s(
      /*! ../user-agents/register-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js"),
          b = s(
      /*! ../user-agents/subscribe-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js"),
          S = s(
      /*! ../user-agents/subscribe-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js"),
          j = s(
      /*! ../user-agents/user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js"),
          w = s(
      /*! ./allowed-methods.js */
      "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
      const T = ["application/sdp", "application/dtmf-relay"];

      class y {
        constructor(e, t = {}) {
          this.userAgentClients = new Map(), this.userAgentServers = new Map(), this.configuration = e, this.delegate = t, this.dialogs = new Map(), this.subscribers = new Map(), this.logger = e.loggerFactory.getLogger("sip.user-agent-core");
        }

        dispose() {
          this.reset();
        }

        reset() {
          this.dialogs.forEach(e => e.dispose()), this.dialogs.clear(), this.subscribers.forEach(e => e.dispose()), this.subscribers.clear(), this.userAgentClients.forEach(e => e.dispose()), this.userAgentClients.clear(), this.userAgentServers.forEach(e => e.dispose()), this.userAgentServers.clear();
        }

        get loggerFactory() {
          return this.configuration.loggerFactory;
        }

        get transport() {
          const e = this.configuration.transportAccessor();
          if (!e) throw new Error("Transport undefined.");
          return e;
        }

        invite(e, t) {
          return new d.InviteUserAgentClient(this, e, t);
        }

        message(e, t) {
          return new u.MessageUserAgentClient(this, e, t);
        }

        publish(e, t) {
          return new p.PublishUserAgentClient(this, e, t);
        }

        register(e, t) {
          return new f.RegisterUserAgentClient(this, e, t);
        }

        subscribe(e, t) {
          return new b.SubscribeUserAgentClient(this, e, t);
        }

        request(e, t) {
          return new j.UserAgentClient(a.NonInviteClientTransaction, this, e, t);
        }

        makeOutgoingRequestMessage(e, t, s, n, o, a, c) {
          const d = this.configuration.sipjsId,
                l = this.configuration.displayName,
                u = this.configuration.viaForceRport,
                h = this.configuration.hackViaTcp,
                g = this.configuration.supportedOptionTags.slice();
          e === i.C.REGISTER && g.push("path", "gruu"), e === i.C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu) && g.push("gruu");
          const p = {
            callIdPrefix: d,
            forceRport: u,
            fromDisplayName: l,
            hackViaTcp: h,
            optionTags: g,
            routeSet: this.configuration.routeSet,
            userAgentString: this.configuration.userAgentHeaderFieldValue,
            viaHost: this.configuration.viaHost
          },
                m = Object.assign(Object.assign({}, p), o);
          return new r.OutgoingRequestMessage(e, t, s, n, m, a, c);
        }

        receiveIncomingRequestFromTransport(e) {
          this.receiveRequestFromTransport(e);
        }

        receiveIncomingResponseFromTransport(e) {
          this.receiveResponseFromTransport(e);
        }

        replyStateless(e, t) {
          const s = this.configuration.userAgentHeaderFieldValue,
                i = this.configuration.supportedOptionTagsResponse;
          t = Object.assign(Object.assign({}, t), {
            userAgent: s,
            supported: i
          });
          const r = Object(n.constructOutgoingResponse)(e, t);
          return this.transport.send(r.message).catch(t => {
            t instanceof Error && this.logger.error(t.message), this.logger.error(`Transport error occurred sending stateless reply to ${e.method} request.`);
          }), r;
        }

        receiveRequestFromTransport(e) {
          const t = e.viaBranch,
                s = this.userAgentServers.get(t);
          e.method === i.C.ACK && s && s.transaction.state === c.TransactionState.Accepted && s instanceof l.InviteUserAgentServer ? this.logger.warn(`Discarding out of dialog ACK after 2xx response sent on transaction ${t}.`) : e.method !== i.C.CANCEL ? s ? s.transaction.receiveRequest(e) : this.receiveRequest(e) : s ? (this.replyStateless(e, {
            statusCode: 200
          }), s.transaction instanceof o.InviteServerTransaction && s.transaction.state === c.TransactionState.Proceeding && s instanceof l.InviteUserAgentServer && s.receiveCancel(e)) : this.replyStateless(e, {
            statusCode: 481
          });
        }

        receiveRequest(e) {
          if (!w.AllowedMethods.includes(e.method)) {
            const t = "Allow: " + w.AllowedMethods.toString();
            return void this.replyStateless(e, {
              statusCode: 405,
              extraHeaders: [t]
            });
          }

          if (!e.ruri) throw new Error("Request-URI undefined.");
          if ("sip" !== e.ruri.scheme) return void this.replyStateless(e, {
            statusCode: 416
          });

          const t = e.ruri,
                s = e => !!e && e.user === t.user;

          if (!s(this.configuration.aor) && !(s(this.configuration.contact.uri) || s(this.configuration.contact.pubGruu) || s(this.configuration.contact.tempGruu))) return this.logger.warn("Request-URI does not point to us."), void (e.method !== i.C.ACK && this.replyStateless(e, {
            statusCode: 404
          }));

          if (e.method !== i.C.INVITE || e.hasHeader("Contact")) {
            if (!e.toTag) {
              const t = e.viaBranch;

              if (!this.userAgentServers.has(t)) {
                if (Array.from(this.userAgentServers.values()).some(t => t.transaction.request.fromTag === e.fromTag && t.transaction.request.callId === e.callId && t.transaction.request.cseq === e.cseq)) return void this.replyStateless(e, {
                  statusCode: 482
                });
              }
            }

            e.toTag ? this.receiveInsideDialogRequest(e) : this.receiveOutsideDialogRequest(e);
          } else this.replyStateless(e, {
            statusCode: 400,
            reasonPhrase: "Missing Contact Header"
          });
        }

        receiveInsideDialogRequest(e) {
          if (e.method === i.C.NOTIFY) {
            const t = e.parseHeader("Event");
            if (!t || !t.event) return void this.replyStateless(e, {
              statusCode: 489
            });
            const s = e.callId + e.toTag + t.event,
                  i = this.subscribers.get(s);

            if (i) {
              const t = new g.NotifyUserAgentServer(this, e);
              return void i.onNotify(t);
            }
          }

          const t = e.callId + e.toTag + e.fromTag,
                s = this.dialogs.get(t);

          if (s) {
            if (e.method === i.C.OPTIONS) {
              const t = "Allow: " + w.AllowedMethods.toString(),
                    s = "Accept: " + T.toString();
              return void this.replyStateless(e, {
                statusCode: 200,
                extraHeaders: [t, s]
              });
            }

            s.receiveRequest(e);
          } else e.method !== i.C.ACK && this.replyStateless(e, {
            statusCode: 481
          });
        }

        receiveOutsideDialogRequest(e) {
          switch (e.method) {
            case i.C.ACK:
              break;

            case i.C.BYE:
              this.replyStateless(e, {
                statusCode: 481
              });
              break;

            case i.C.CANCEL:
              throw new Error(`Unexpected out of dialog request method ${e.method}.`);

            case i.C.INFO:
              this.replyStateless(e, {
                statusCode: 405
              });
              break;

            case i.C.INVITE:
              {
                const t = new l.InviteUserAgentServer(this, e);
                this.delegate.onInvite ? this.delegate.onInvite(t) : t.reject();
              }
              break;

            case i.C.MESSAGE:
              {
                const t = new h.MessageUserAgentServer(this, e);
                this.delegate.onMessage ? this.delegate.onMessage(t) : t.accept();
              }
              break;

            case i.C.NOTIFY:
              {
                const t = new g.NotifyUserAgentServer(this, e);
                this.delegate.onNotify ? this.delegate.onNotify(t) : t.reject({
                  statusCode: 405
                });
              }
              break;

            case i.C.OPTIONS:
              {
                const t = "Allow: " + w.AllowedMethods.toString(),
                      s = "Accept: " + T.toString();
                this.replyStateless(e, {
                  statusCode: 200,
                  extraHeaders: [t, s]
                });
              }
              break;

            case i.C.REFER:
              {
                const t = new m.ReferUserAgentServer(this, e);
                this.delegate.onRefer ? this.delegate.onRefer(t) : t.reject({
                  statusCode: 405
                });
              }
              break;

            case i.C.REGISTER:
              {
                const t = new v.RegisterUserAgentServer(this, e);
                this.delegate.onRegister ? this.delegate.onRegister(t) : t.reject({
                  statusCode: 405
                });
              }
              break;

            case i.C.SUBSCRIBE:
              {
                const t = new S.SubscribeUserAgentServer(this, e);
                this.delegate.onSubscribe ? this.delegate.onSubscribe(t) : t.reject({
                  statusCode: 480
                });
              }
              break;

            default:
              throw new Error(`Unexpected out of dialog request method ${e.method}.`);
          }
        }

        receiveResponseFromTransport(e) {
          if (e.getHeaders("via").length > 1) return void this.logger.warn("More than one Via header field present in the response, dropping");
          const t = e.viaBranch + e.method,
                s = this.userAgentClients.get(t);
          s ? s.transaction.receiveResponse(e) : this.logger.warn(`Discarding unmatched ${e.statusCode} response to ${e.method} ${t}.`);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js":
    /*!***************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js ***!
      \***************************************************************************/

    /*! exports provided: ByeUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ByeUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.BYE, s);
          super(r.NonInviteClientTransaction, e.userAgentCore, n, t), e.dispose();
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js":
    /*!***************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js ***!
      \***************************************************************************/

    /*! exports provided: ByeUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ByeUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e.userAgentCore, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js":
    /*!******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js ***!
      \******************************************************************************/

    /*! exports provided: CancelUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "CancelUserAgentClient", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          r = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class n extends r.UserAgentClient {
        constructor(e, t, s) {
          super(i.NonInviteClientTransaction, e, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/index.js":
    /*!***********************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/index.js ***!
      \***********************************************************/

    /*! exports provided: ByeUserAgentClient, ByeUserAgentServer, CancelUserAgentClient, InfoUserAgentClient, InfoUserAgentServer, InviteUserAgentClient, InviteUserAgentServer, MessageUserAgentClient, MessageUserAgentServer, NotifyUserAgentClient, NotifyUserAgentServer, PublishUserAgentClient, PrackUserAgentClient, PrackUserAgentServer, ReInviteUserAgentClient, ReInviteUserAgentServer, ReSubscribeUserAgentClient, ReSubscribeUserAgentServer, ReferUserAgentClient, ReferUserAgentServer, RegisterUserAgentClient, RegisterUserAgentServer, SubscribeUserAgentClient, SubscribeUserAgentServer, UserAgentClient, UserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./bye-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js");
      s.d(t, "ByeUserAgentClient", function () {
        return i.ByeUserAgentClient;
      });
      var r = s(
      /*! ./bye-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js");
      s.d(t, "ByeUserAgentServer", function () {
        return r.ByeUserAgentServer;
      });
      var n = s(
      /*! ./cancel-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js");
      s.d(t, "CancelUserAgentClient", function () {
        return n.CancelUserAgentClient;
      });
      var o = s(
      /*! ./info-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js");
      s.d(t, "InfoUserAgentClient", function () {
        return o.InfoUserAgentClient;
      });
      var a = s(
      /*! ./info-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js");
      s.d(t, "InfoUserAgentServer", function () {
        return a.InfoUserAgentServer;
      });
      var c = s(
      /*! ./invite-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js");
      s.d(t, "InviteUserAgentClient", function () {
        return c.InviteUserAgentClient;
      });
      var d = s(
      /*! ./invite-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js");
      s.d(t, "InviteUserAgentServer", function () {
        return d.InviteUserAgentServer;
      });
      var l = s(
      /*! ./message-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js");
      s.d(t, "MessageUserAgentClient", function () {
        return l.MessageUserAgentClient;
      });
      var u = s(
      /*! ./message-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js");
      s.d(t, "MessageUserAgentServer", function () {
        return u.MessageUserAgentServer;
      });
      var h = s(
      /*! ./notify-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js");
      s.d(t, "NotifyUserAgentClient", function () {
        return h.NotifyUserAgentClient;
      });
      var g = s(
      /*! ./notify-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js");
      s.d(t, "NotifyUserAgentServer", function () {
        return g.NotifyUserAgentServer;
      });
      var p = s(
      /*! ./publish-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js");
      s.d(t, "PublishUserAgentClient", function () {
        return p.PublishUserAgentClient;
      });
      var m = s(
      /*! ./prack-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js");
      s.d(t, "PrackUserAgentClient", function () {
        return m.PrackUserAgentClient;
      });
      var f = s(
      /*! ./prack-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js");
      s.d(t, "PrackUserAgentServer", function () {
        return f.PrackUserAgentServer;
      });
      var v = s(
      /*! ./re-invite-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js");
      s.d(t, "ReInviteUserAgentClient", function () {
        return v.ReInviteUserAgentClient;
      });
      var b = s(
      /*! ./re-invite-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js");
      s.d(t, "ReInviteUserAgentServer", function () {
        return b.ReInviteUserAgentServer;
      });
      var S = s(
      /*! ./re-subscribe-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js");
      s.d(t, "ReSubscribeUserAgentClient", function () {
        return S.ReSubscribeUserAgentClient;
      });
      var j = s(
      /*! ./re-subscribe-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js");
      s.d(t, "ReSubscribeUserAgentServer", function () {
        return j.ReSubscribeUserAgentServer;
      });
      var w = s(
      /*! ./refer-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js");
      s.d(t, "ReferUserAgentClient", function () {
        return w.ReferUserAgentClient;
      });
      var T = s(
      /*! ./refer-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js");
      s.d(t, "ReferUserAgentServer", function () {
        return T.ReferUserAgentServer;
      });
      var y = s(
      /*! ./register-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js");
      s.d(t, "RegisterUserAgentClient", function () {
        return y.RegisterUserAgentClient;
      });

      var _ = s(
      /*! ./register-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js");

      s.d(t, "RegisterUserAgentServer", function () {
        return _.RegisterUserAgentServer;
      });
      var R = s(
      /*! ./subscribe-user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js");
      s.d(t, "SubscribeUserAgentClient", function () {
        return R.SubscribeUserAgentClient;
      });
      var C = s(
      /*! ./subscribe-user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js");
      s.d(t, "SubscribeUserAgentServer", function () {
        return C.SubscribeUserAgentServer;
      });
      var E = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
      s.d(t, "UserAgentClient", function () {
        return E.UserAgentClient;
      });
      var I = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
      s.d(t, "UserAgentServer", function () {
        return I.UserAgentServer;
      });
    },
    "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js ***!
      \****************************************************************************/

    /*! exports provided: InfoUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "InfoUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.INFO, s);
          super(r.NonInviteClientTransaction, e.userAgentCore, n, t);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js ***!
      \****************************************************************************/

    /*! exports provided: InfoUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "InfoUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e.userAgentCore, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js":
    /*!******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js ***!
      \******************************************************************************/

    /*! exports provided: InviteUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "InviteUserAgentClient", function () {
        return d;
      });
      var i = s(
      /*! ../dialogs/dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/dialog.js"),
          r = s(
      /*! ../dialogs/session-dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/session-dialog.js"),
          n = s(
      /*! ../session/session.js */
      "./node_modules/sip.js/lib/core/session/session.js"),
          o = s(
      /*! ../transactions/invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"),
          a = s(
      /*! ../transactions/transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js"),
          c = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class d extends c.UserAgentClient {
        constructor(e, t, s) {
          super(o.InviteClientTransaction, e, t, s), this.confirmedDialogAcks = new Map(), this.confirmedDialogs = new Map(), this.earlyDialogs = new Map(), this.delegate = s;
        }

        dispose() {
          this.earlyDialogs.forEach(e => e.dispose()), this.earlyDialogs.clear(), super.dispose();
        }

        onTransportError(e) {
          if (this.transaction.state === a.TransactionState.Calling) return super.onTransportError(e);
          this.logger.error(e.message), this.logger.error("User agent client request transport error while sending ACK.");
        }

        receiveResponse(e) {
          if (!this.authenticationGuard(e)) return;
          const t = e.statusCode ? e.statusCode.toString() : "";
          if (!t) throw new Error("Response status code undefined.");

          switch (!0) {
            case /^100$/.test(t):
              return void (this.delegate && this.delegate.onTrying && this.delegate.onTrying({
                message: e
              }));

            case /^1[0-9]{2}$/.test(t):
              {
                if (!e.toTag) return void this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
                if (!e.parseHeader("contact")) return void this.logger.error("Non-100 1xx INVITE response received without a Contact header field, dropping.");
                const t = i.Dialog.initialDialogStateForUserAgentClient(this.message, e);
                let s = this.earlyDialogs.get(t.id);

                if (!s) {
                  const e = this.transaction;
                  if (!(e instanceof o.InviteClientTransaction)) throw new Error("Transaction not instance of InviteClientTransaction.");
                  s = new r.SessionDialog(e, this.core, t), this.earlyDialogs.set(s.id, s);
                }

                if (!s.reliableSequenceGuard(e)) return void this.logger.warn("1xx INVITE reliable response received out of order or is a retransmission, dropping.");
                s.signalingState !== n.SignalingState.Initial && s.signalingState !== n.SignalingState.HaveLocalOffer || s.signalingStateTransition(e);
                const a = s;
                this.delegate && this.delegate.onProgress && this.delegate.onProgress({
                  message: e,
                  session: a,
                  prack: e => {
                    return a.prack(void 0, e);
                  }
                });
              }
              return;

            case /^2[0-9]{2}$/.test(t):
              {
                if (!e.toTag) return void this.logger.error("2xx INVITE response received without a to tag, dropping.");
                if (!e.parseHeader("contact")) return void this.logger.error("2xx INVITE response received without a Contact header field, dropping.");
                const t = i.Dialog.initialDialogStateForUserAgentClient(this.message, e);
                let s = this.confirmedDialogs.get(t.id);

                if (s) {
                  const e = this.confirmedDialogAcks.get(t.id);

                  if (e) {
                    const t = this.transaction;
                    if (!(t instanceof o.InviteClientTransaction)) throw new Error("Client transaction not instance of InviteClientTransaction.");
                    t.ackResponse(e.message);
                  }

                  return;
                }

                if (s = this.earlyDialogs.get(t.id)) s.confirm(), s.recomputeRouteSet(e), this.earlyDialogs.delete(s.id), this.confirmedDialogs.set(s.id, s);else {
                  const e = this.transaction;
                  if (!(e instanceof o.InviteClientTransaction)) throw new Error("Transaction not instance of InviteClientTransaction.");
                  s = new r.SessionDialog(e, this.core, t), this.confirmedDialogs.set(s.id, s);
                }
                s.signalingState !== n.SignalingState.Initial && s.signalingState !== n.SignalingState.HaveLocalOffer || s.signalingStateTransition(e);
                const a = s;
                if (this.delegate && this.delegate.onAccept) this.delegate.onAccept({
                  message: e,
                  session: a,
                  ack: e => {
                    const t = a.ack(e);
                    return this.confirmedDialogAcks.set(a.id, t), t;
                  }
                });else {
                  const e = a.ack();
                  this.confirmedDialogAcks.set(a.id, e);
                }
              }
              return;

            case /^3[0-9]{2}$/.test(t):
              return this.earlyDialogs.forEach(e => e.dispose()), this.earlyDialogs.clear(), void (this.delegate && this.delegate.onRedirect && this.delegate.onRedirect({
                message: e
              }));

            case /^[4-6][0-9]{2}$/.test(t):
              return this.earlyDialogs.forEach(e => e.dispose()), this.earlyDialogs.clear(), void (this.delegate && this.delegate.onReject && this.delegate.onReject({
                message: e
              }));

            default:
              throw new Error(`Invalid status code ${t}`);
          }

          throw new Error(`Executing what should be an unreachable code path receiving ${t} response.`);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js":
    /*!******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js ***!
      \******************************************************************************/

    /*! exports provided: InviteUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "InviteUserAgentServer", function () {
        return l;
      });
      var i = s(
      /*! ../dialogs/dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/dialog.js"),
          r = s(
      /*! ../dialogs/session-dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/session-dialog.js"),
          n = s(
      /*! ../exceptions/transaction-state-error.js */
      "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js"),
          o = s(
      /*! ../session/session.js */
      "./node_modules/sip.js/lib/core/session/session.js"),
          a = s(
      /*! ../transactions/invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"),
          c = s(
      /*! ../user-agent-core/allowed-methods.js */
      "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js"),
          d = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class l extends d.UserAgentServer {
        constructor(e, t, s) {
          super(a.InviteServerTransaction, e, t, s), this.core = e;
        }

        dispose() {
          this.earlyDialog && this.earlyDialog.dispose(), super.dispose();
        }

        accept(e = {
          statusCode: 200
        }) {
          if (!this.acceptable) throw new n.TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);
          if (!this.confirmedDialog) if (this.earlyDialog) this.earlyDialog.confirm(), this.confirmedDialog = this.earlyDialog, this.earlyDialog = void 0;else {
            const e = this.transaction;
            if (!(e instanceof a.InviteServerTransaction)) throw new Error("Transaction not instance of InviteClientTransaction.");
            const t = i.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);
            this.confirmedDialog = new r.SessionDialog(e, this.core, t);
          }
          const t = this.message.getHeaders("record-route").map(e => `Record-Route: ${e}`),
                s = `Contact: ${this.core.configuration.contact.toString()}`,
                d = "Allow: " + c.AllowedMethods.toString();
          if (!e.body) if (this.confirmedDialog.signalingState === o.SignalingState.Stable) e.body = this.confirmedDialog.answer;else if (this.confirmedDialog.signalingState === o.SignalingState.Initial || this.confirmedDialog.signalingState === o.SignalingState.HaveRemoteOffer) throw new Error("Response must have a body.");
          e.statusCode = e.statusCode || 200, e.extraHeaders = e.extraHeaders || [], e.extraHeaders = e.extraHeaders.concat(t), e.extraHeaders.push(d), e.extraHeaders.push(s);
          const l = super.accept(e),
                u = this.confirmedDialog,
                h = Object.assign(Object.assign({}, l), {
            session: u
          });
          return e.body && this.confirmedDialog.signalingState !== o.SignalingState.Stable && this.confirmedDialog.signalingStateTransition(e.body), h;
        }

        progress(e = {
          statusCode: 180
        }) {
          if (!this.progressable) throw new n.TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);

          if (!this.earlyDialog) {
            const e = this.transaction;
            if (!(e instanceof a.InviteServerTransaction)) throw new Error("Transaction not instance of InviteClientTransaction.");
            const t = i.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, !0);
            this.earlyDialog = new r.SessionDialog(e, this.core, t);
          }

          const t = this.message.getHeaders("record-route").map(e => `Record-Route: ${e}`),
                s = `Contact: ${this.core.configuration.contact}`;
          e.extraHeaders = e.extraHeaders || [], e.extraHeaders = e.extraHeaders.concat(t), e.extraHeaders.push(s);
          const c = super.progress(e),
                d = this.earlyDialog,
                l = Object.assign(Object.assign({}, c), {
            session: d
          });
          return e.body && this.earlyDialog.signalingState !== o.SignalingState.Stable && this.earlyDialog.signalingStateTransition(e.body), l;
        }

        redirect(e, t = {
          statusCode: 302
        }) {
          return super.redirect(e, t);
        }

        reject(e = {
          statusCode: 486
        }) {
          return super.reject(e);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js ***!
      \*******************************************************************************/

    /*! exports provided: MessageUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "MessageUserAgentClient", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          r = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class n extends r.UserAgentClient {
        constructor(e, t, s) {
          super(i.NonInviteClientTransaction, e, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js ***!
      \*******************************************************************************/

    /*! exports provided: MessageUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "MessageUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js":
    /*!******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js ***!
      \******************************************************************************/

    /*! exports provided: NotifyUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "NotifyUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.NOTIFY, s);
          super(r.NonInviteClientTransaction, e.userAgentCore, n, t);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js":
    /*!******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js ***!
      \******************************************************************************/

    /*! exports provided: NotifyUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "NotifyUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          const r = void 0 !== e.userAgentCore ? e.userAgentCore : e;
          super(i.NonInviteServerTransaction, r, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js":
    /*!*****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js ***!
      \*****************************************************************************/

    /*! exports provided: PrackUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "PrackUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.PRACK, s);
          super(r.NonInviteClientTransaction, e.userAgentCore, n, t), e.signalingStateTransition(n);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js":
    /*!*****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js ***!
      \*****************************************************************************/

    /*! exports provided: PrackUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "PrackUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e.userAgentCore, t, s), e.signalingStateTransition(t), this.dialog = e;
        }

        accept(e = {
          statusCode: 200
        }) {
          return e.body && this.dialog.signalingStateTransition(e.body), super.accept(e);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js ***!
      \*******************************************************************************/

    /*! exports provided: PublishUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "PublishUserAgentClient", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          r = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class n extends r.UserAgentClient {
        constructor(e, t, s) {
          super(i.NonInviteClientTransaction, e, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js ***!
      \*********************************************************************************/

    /*! exports provided: ReInviteUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ReInviteUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.INVITE, s);
          super(r.InviteClientTransaction, e.userAgentCore, n, t), this.delegate = t, e.signalingStateTransition(n), e.reinviteUserAgentClient = this, this.dialog = e;
        }

        receiveResponse(e) {
          if (!this.authenticationGuard(e, this.dialog)) return;
          const t = e.statusCode ? e.statusCode.toString() : "";
          if (!t) throw new Error("Response status code undefined.");

          switch (!0) {
            case /^100$/.test(t):
              this.delegate && this.delegate.onTrying && this.delegate.onTrying({
                message: e
              });
              break;

            case /^1[0-9]{2}$/.test(t):
              this.delegate && this.delegate.onProgress && this.delegate.onProgress({
                message: e,
                session: this.dialog,
                prack: e => {
                  throw new Error("Unimplemented.");
                }
              });
              break;

            case /^2[0-9]{2}$/.test(t):
              this.dialog.signalingStateTransition(e), this.delegate && this.delegate.onAccept && this.delegate.onAccept({
                message: e,
                session: this.dialog,
                ack: e => {
                  return this.dialog.ack(e);
                }
              });
              break;

            case /^3[0-9]{2}$/.test(t):
              this.dialog.signalingStateRollback(), this.dialog.reinviteUserAgentClient = void 0, this.delegate && this.delegate.onRedirect && this.delegate.onRedirect({
                message: e
              });
              break;

            case /^[4-6][0-9]{2}$/.test(t):
              this.dialog.signalingStateRollback(), this.dialog.reinviteUserAgentClient = void 0, this.delegate && this.delegate.onReject && this.delegate.onReject({
                message: e
              });
              break;

            default:
              throw new Error(`Invalid status code ${t}`);
          }
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js ***!
      \*********************************************************************************/

    /*! exports provided: ReInviteUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ReInviteUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.InviteServerTransaction, e.userAgentCore, t, s), e.reinviteUserAgentServer = this, this.dialog = e;
        }

        accept(e = {
          statusCode: 200
        }) {
          e.extraHeaders = e.extraHeaders || [], e.extraHeaders = e.extraHeaders.concat(this.dialog.routeSet.map(e => `Record-Route: ${e}`));
          const t = super.accept(e),
                s = this.dialog,
                i = Object.assign(Object.assign({}, t), {
            session: s
          });
          return e.body && this.dialog.signalingStateTransition(e.body), this.dialog.reConfirm(), i;
        }

        progress(e = {
          statusCode: 180
        }) {
          const t = super.progress(e),
                s = this.dialog,
                i = Object.assign(Object.assign({}, t), {
            session: s
          });
          return e.body && this.dialog.signalingStateTransition(e.body), i;
        }

        redirect(e, t = {
          statusCode: 302
        }) {
          throw this.dialog.signalingStateRollback(), this.dialog.reinviteUserAgentServer = void 0, new Error("Unimplemented.");
        }

        reject(e = {
          statusCode: 488
        }) {
          return this.dialog.signalingStateRollback(), this.dialog.reinviteUserAgentServer = void 0, super.reject(e);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js":
    /*!************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js ***!
      \************************************************************************************/

    /*! exports provided: ReSubscribeUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ReSubscribeUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.SUBSCRIBE, s);
          super(r.NonInviteClientTransaction, e.userAgentCore, n, t), this.dialog = e;
        }

        waitNotifyStop() {}

        receiveResponse(e) {
          if (e.statusCode && e.statusCode >= 200 && e.statusCode < 300) {
            const t = e.getHeader("Expires");

            if (t) {
              const e = Number(t);
              this.dialog.subscriptionExpires > e && (this.dialog.subscriptionExpires = e);
            } else this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
          }

          if (e.statusCode && e.statusCode >= 400 && e.statusCode < 700) {
            [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604].includes(e.statusCode) && this.dialog.terminate();
          }

          super.receiveResponse(e);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js":
    /*!************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js ***!
      \************************************************************************************/

    /*! exports provided: ReSubscribeUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ReSubscribeUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e.userAgentCore, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js":
    /*!*****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js ***!
      \*****************************************************************************/

    /*! exports provided: ReferUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ReferUserAgentClient", function () {
        return o;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          n = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class o extends n.UserAgentClient {
        constructor(e, t, s) {
          const n = e.createOutgoingRequestMessage(i.C.REFER, s);
          super(r.NonInviteClientTransaction, e.userAgentCore, n, t);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js":
    /*!*****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js ***!
      \*****************************************************************************/

    /*! exports provided: ReferUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "ReferUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          const r = void 0 !== e.userAgentCore ? e.userAgentCore : e;
          super(i.NonInviteServerTransaction, r, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js":
    /*!********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js ***!
      \********************************************************************************/

    /*! exports provided: RegisterUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "RegisterUserAgentClient", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          r = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class n extends r.UserAgentClient {
        constructor(e, t, s) {
          super(i.NonInviteClientTransaction, e, t, s);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js":
    /*!********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js ***!
      \********************************************************************************/

    /*! exports provided: RegisterUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "RegisterUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e, t, s), this.core = e;
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js ***!
      \*********************************************************************************/

    /*! exports provided: SubscribeUserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SubscribeUserAgentClient", function () {
        return c;
      });
      var i = s(
      /*! ../dialogs/subscription-dialog.js */
      "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js"),
          r = s(
      /*! ../subscription/subscription.js */
      "./node_modules/sip.js/lib/core/subscription/subscription.js"),
          n = s(
      /*! ../timers.js */
      "./node_modules/sip.js/lib/core/timers.js"),
          o = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          a = s(
      /*! ./user-agent-client.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");

      class c extends a.UserAgentClient {
        constructor(e, t, s) {
          const i = t.getHeader("Event");
          if (!i) throw new Error("Event undefined");
          const n = t.getHeader("Expires");
          if (!n) throw new Error("Expires undefined");
          super(o.NonInviteClientTransaction, e, t, s), this.delegate = s, this.subscriberId = t.callId + t.fromTag + i, this.subscriptionExpiresRequested = this.subscriptionExpires = Number(n), this.subscriptionEvent = i, this.subscriptionState = r.SubscriptionState.NotifyWait, this.waitNotifyStart();
        }

        dispose() {
          super.dispose();
        }

        onNotify(e) {
          const t = e.message.parseHeader("Event").event;
          if (!t || t !== this.subscriptionEvent) return this.logger.warn("Failed to parse event."), void e.reject({
            statusCode: 489
          });
          const s = e.message.parseHeader("Subscription-State");
          if (!s || !s.state) return this.logger.warn("Failed to parse subscription state."), void e.reject({
            statusCode: 489
          });
          const n = s.state;

          switch (n) {
            case "pending":
            case "active":
            case "terminated":
              break;

            default:
              return this.logger.warn(`Invalid subscription state ${n}`), void e.reject({
                statusCode: 489
              });
          }

          if ("terminated" !== n) {
            if (!e.message.parseHeader("contact")) return this.logger.warn("Failed to parse contact."), void e.reject({
              statusCode: 489
            });
          }

          if (this.dialog) throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");

          switch (this.waitNotifyStop(), this.subscriptionExpires = s.expires ? Math.min(this.subscriptionExpires, Math.max(s.expires, 0)) : this.subscriptionExpires, n) {
            case "pending":
              this.subscriptionState = r.SubscriptionState.Pending;
              break;

            case "active":
              this.subscriptionState = r.SubscriptionState.Active;
              break;

            case "terminated":
              this.subscriptionState = r.SubscriptionState.Terminated;
              break;

            default:
              throw new Error(`Unrecognized state ${n}.`);
          }

          if (this.subscriptionState !== r.SubscriptionState.Terminated) {
            const t = i.SubscriptionDialog.initialDialogStateForSubscription(this.message, e.message);
            this.dialog = new i.SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, t);
          }

          if (this.delegate && this.delegate.onNotify) {
            const t = e,
                  s = this.dialog;
            this.delegate.onNotify({
              request: t,
              subscription: s
            });
          } else e.accept();
        }

        waitNotifyStart() {
          this.N || (this.core.subscribers.set(this.subscriberId, this), this.N = setTimeout(() => this.timerN(), n.Timers.TIMER_N));
        }

        waitNotifyStop() {
          this.N && (this.core.subscribers.delete(this.subscriberId), clearTimeout(this.N), this.N = void 0);
        }

        receiveResponse(e) {
          if (this.authenticationGuard(e)) {
            if (e.statusCode && e.statusCode >= 200 && e.statusCode < 300) {
              const t = e.getHeader("Expires");

              if (t) {
                const e = Number(t);
                e > this.subscriptionExpiresRequested && this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request"), e < this.subscriptionExpires && (this.subscriptionExpires = e);
              } else this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");

              this.dialog && this.dialog.subscriptionExpires > this.subscriptionExpires && (this.dialog.subscriptionExpires = this.subscriptionExpires);
            }

            e.statusCode && e.statusCode >= 300 && e.statusCode < 700 && this.waitNotifyStop(), super.receiveResponse(e);
          }
        }

        timerN() {
          this.logger.warn("Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY."), this.waitNotifyStop(), this.delegate && this.delegate.onNotifyTimeout && this.delegate.onNotifyTimeout();
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js ***!
      \*********************************************************************************/

    /*! exports provided: SubscribeUserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SubscribeUserAgentServer", function () {
        return n;
      });
      var i = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          r = s(
      /*! ./user-agent-server.js */
      "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");

      class n extends r.UserAgentServer {
        constructor(e, t, s) {
          super(i.NonInviteServerTransaction, e, t, s), this.core = e;
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/user-agent-client.js ***!
      \***********************************************************************/

    /*! exports provided: UserAgentClient */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "UserAgentClient", function () {
        return a;
      });
      var i = s(
      /*! ../messages/methods/constants.js */
      "./node_modules/sip.js/lib/core/messages/methods/constants.js"),
          r = s(
      /*! ../messages/incoming-response-message.js */
      "./node_modules/sip.js/lib/core/messages/incoming-response-message.js"),
          n = s(
      /*! ../transactions/non-invite-client-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"),
          o = s(
      /*! ../transactions/transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");

      class a {
        constructor(e, t, s, i) {
          this.transactionConstructor = e, this.core = t, this.message = s, this.delegate = i, this.challenged = !1, this.stale = !1, this.logger = this.loggerFactory.getLogger("sip.user-agent-client"), this.init();
        }

        dispose() {
          this.transaction.dispose();
        }

        get loggerFactory() {
          return this.core.loggerFactory;
        }

        get transaction() {
          if (!this._transaction) throw new Error("Transaction undefined.");
          return this._transaction;
        }

        cancel(e, t = {}) {
          if (!this.transaction) throw new Error("Transaction undefined.");
          if (!this.message.to) throw new Error("To undefined.");
          if (!this.message.from) throw new Error("From undefined.");
          const s = this.core.makeOutgoingRequestMessage(i.C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
            toTag: this.message.toTag,
            fromTag: this.message.fromTag,
            callId: this.message.callId,
            cseq: this.message.cseq
          }, t.extraHeaders);
          return s.branch = this.message.branch, this.message.headers.Route && (s.headers.Route = this.message.headers.Route), e && s.setHeader("Reason", e), this.transaction.state === o.TransactionState.Proceeding ? new a(n.NonInviteClientTransaction, this.core, s) : this.transaction.addStateChangeListener(() => {
            this.transaction && this.transaction.state === o.TransactionState.Proceeding && new a(n.NonInviteClientTransaction, this.core, s);
          }, {
            once: !0
          }), s;
        }

        authenticationGuard(e, t) {
          const s = e.statusCode;
          if (!s) throw new Error("Response status code undefined.");
          if (401 !== s && 407 !== s) return !0;
          let i, r;
          if (401 === s ? (i = e.parseHeader("www-authenticate"), r = "authorization") : (i = e.parseHeader("proxy-authenticate"), r = "proxy-authorization"), !i) return this.logger.warn(s + " with wrong or missing challenge, cannot authenticate"), !0;
          if (this.challenged && (this.stale || !0 !== i.stale)) return this.logger.warn(s + " apparently in authentication loop, cannot authenticate"), !0;
          if (!this.credentials && (this.credentials = this.core.configuration.authenticationFactory(), !this.credentials)) return this.logger.warn("Unable to obtain credentials, cannot authenticate"), !0;
          if (!this.credentials.authenticate(this.message, i)) return !0;
          this.challenged = !0, i.stale && (this.stale = !0);
          let n = this.message.cseq += 1;
          return t && t.localSequenceNumber && (t.incrementLocalSequenceNumber(), n = this.message.cseq = t.localSequenceNumber), this.message.setHeader("cseq", n + " " + this.message.method), this.message.setHeader(r, this.credentials.toString()), this.init(), !1;
        }

        onRequestTimeout() {
          this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
          const e = new r.IncomingResponseMessage();
          e.statusCode = 408, e.reasonPhrase = "Request Timeout", this.receiveResponse(e);
        }

        onTransportError(e) {
          this.logger.error(e.message), this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
          const t = new r.IncomingResponseMessage();
          t.statusCode = 503, t.reasonPhrase = "Service Unavailable", this.receiveResponse(t);
        }

        receiveResponse(e) {
          if (!this.authenticationGuard(e)) return;
          const t = e.statusCode ? e.statusCode.toString() : "";
          if (!t) throw new Error("Response status code undefined.");

          switch (!0) {
            case /^100$/.test(t):
              this.delegate && this.delegate.onTrying && this.delegate.onTrying({
                message: e
              });
              break;

            case /^1[0-9]{2}$/.test(t):
              this.delegate && this.delegate.onProgress && this.delegate.onProgress({
                message: e
              });
              break;

            case /^2[0-9]{2}$/.test(t):
              this.delegate && this.delegate.onAccept && this.delegate.onAccept({
                message: e
              });
              break;

            case /^3[0-9]{2}$/.test(t):
              this.delegate && this.delegate.onRedirect && this.delegate.onRedirect({
                message: e
              });
              break;

            case /^[4-6][0-9]{2}$/.test(t):
              this.delegate && this.delegate.onReject && this.delegate.onReject({
                message: e
              });
              break;

            default:
              throw new Error(`Invalid status code ${t}`);
          }
        }

        init() {
          const e = {
            loggerFactory: this.loggerFactory,
            onRequestTimeout: () => this.onRequestTimeout(),
            onStateChange: e => {
              e === o.TransactionState.Terminated && (this.core.userAgentClients.delete(s), t === this._transaction && this.dispose());
            },
            onTransportError: e => this.onTransportError(e),
            receiveResponse: e => this.receiveResponse(e)
          },
                t = new this.transactionConstructor(this.message, this.core.transport, e);
          this._transaction = t;
          const s = t.id + t.request.method;
          this.core.userAgentClients.set(s, this);
        }

      }
    },
    "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/sip.js/lib/core/user-agents/user-agent-server.js ***!
      \***********************************************************************/

    /*! exports provided: UserAgentServer */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "UserAgentServer", function () {
        return d;
      });
      var i = s(
      /*! ../exceptions/transaction-state-error.js */
      "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js"),
          r = s(
      /*! ../messages/outgoing-response.js */
      "./node_modules/sip.js/lib/core/messages/outgoing-response.js"),
          n = s(
      /*! ../messages/utils.js */
      "./node_modules/sip.js/lib/core/messages/utils.js"),
          o = s(
      /*! ../transactions/invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"),
          a = s(
      /*! ../transactions/non-invite-server-transaction.js */
      "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"),
          c = s(
      /*! ../transactions/transaction-state.js */
      "./node_modules/sip.js/lib/core/transactions/transaction-state.js");

      class d {
        constructor(e, t, s, i) {
          this.transactionConstructor = e, this.core = t, this.message = s, this.delegate = i, this.logger = this.loggerFactory.getLogger("sip.user-agent-server"), this.toTag = s.toTag ? s.toTag : Object(n.newTag)(), this.init();
        }

        dispose() {
          this.transaction.dispose();
        }

        get loggerFactory() {
          return this.core.loggerFactory;
        }

        get transaction() {
          if (!this._transaction) throw new Error("Transaction undefined.");
          return this._transaction;
        }

        accept(e = {
          statusCode: 200
        }) {
          if (!this.acceptable) throw new i.TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);
          const t = e.statusCode;
          if (t < 200 || t > 299) throw new TypeError(`Invalid statusCode: ${t}`);
          return this.reply(e);
        }

        progress(e = {
          statusCode: 180
        }) {
          if (!this.progressable) throw new i.TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);
          const t = e.statusCode;
          if (t < 101 || t > 199) throw new TypeError(`Invalid statusCode: ${t}`);
          return this.reply(e);
        }

        redirect(e, t = {
          statusCode: 302
        }) {
          if (!this.redirectable) throw new i.TransactionStateError(`${this.message.method} not redirectable in state ${this.transaction.state}.`);
          const s = t.statusCode;
          if (s < 300 || s > 399) throw new TypeError(`Invalid statusCode: ${s}`);
          const r = new Array();
          return e.forEach(e => r.push(`Contact: ${e.toString()}`)), t.extraHeaders = (t.extraHeaders || []).concat(r), this.reply(t);
        }

        reject(e = {
          statusCode: 480
        }) {
          if (!this.rejectable) throw new i.TransactionStateError(`${this.message.method} not rejectable in state ${this.transaction.state}.`);
          const t = e.statusCode;
          if (t < 400 || t > 699) throw new TypeError(`Invalid statusCode: ${t}`);
          return this.reply(e);
        }

        trying(e) {
          if (!this.tryingable) throw new i.TransactionStateError(`${this.message.method} not tryingable in state ${this.transaction.state}.`);
          return this.reply({
            statusCode: 100
          });
        }

        receiveCancel(e) {
          this.delegate && this.delegate.onCancel && this.delegate.onCancel(e);
        }

        get acceptable() {
          if (this.transaction instanceof o.InviteServerTransaction) return this.transaction.state === c.TransactionState.Proceeding || this.transaction.state === c.TransactionState.Accepted;
          if (this.transaction instanceof a.NonInviteServerTransaction) return this.transaction.state === c.TransactionState.Trying || this.transaction.state === c.TransactionState.Proceeding;
          throw new Error("Unknown transaction type.");
        }

        get progressable() {
          if (this.transaction instanceof o.InviteServerTransaction) return this.transaction.state === c.TransactionState.Proceeding;
          if (this.transaction instanceof a.NonInviteServerTransaction) return !1;
          throw new Error("Unknown transaction type.");
        }

        get redirectable() {
          if (this.transaction instanceof o.InviteServerTransaction) return this.transaction.state === c.TransactionState.Proceeding;
          if (this.transaction instanceof a.NonInviteServerTransaction) return this.transaction.state === c.TransactionState.Trying || this.transaction.state === c.TransactionState.Proceeding;
          throw new Error("Unknown transaction type.");
        }

        get rejectable() {
          if (this.transaction instanceof o.InviteServerTransaction) return this.transaction.state === c.TransactionState.Proceeding;
          if (this.transaction instanceof a.NonInviteServerTransaction) return this.transaction.state === c.TransactionState.Trying || this.transaction.state === c.TransactionState.Proceeding;
          throw new Error("Unknown transaction type.");
        }

        get tryingable() {
          if (this.transaction instanceof o.InviteServerTransaction) return this.transaction.state === c.TransactionState.Proceeding;
          if (this.transaction instanceof a.NonInviteServerTransaction) return this.transaction.state === c.TransactionState.Trying;
          throw new Error("Unknown transaction type.");
        }

        reply(e) {
          e.toTag || 100 === e.statusCode || (e.toTag = this.toTag), e.userAgent = e.userAgent || this.core.configuration.userAgentHeaderFieldValue, e.supported = e.supported || this.core.configuration.supportedOptionTagsResponse;
          const t = Object(r.constructOutgoingResponse)(this.message, e);
          return this.transaction.receiveResponse(e.statusCode, t.message), t;
        }

        init() {
          const e = {
            loggerFactory: this.loggerFactory,
            onStateChange: e => {
              e === c.TransactionState.Terminated && (this.core.userAgentServers.delete(s), this.dispose());
            },
            onTransportError: e => {
              this.logger.error(e.message), this.delegate && this.delegate.onTransportError ? this.delegate.onTransportError(e) : this.logger.error("User agent server response transport error.");
            }
          },
                t = new this.transactionConstructor(this.message, this.core.transport, e);
          this._transaction = t;
          const s = t.id;
          this.core.userAgentServers.set(t.id, this);
        }

      }
    },
    "./node_modules/sip.js/lib/grammar/grammar.js":
    /*!****************************************************!*\
      !*** ./node_modules/sip.js/lib/grammar/grammar.js ***!
      \****************************************************/

    /*! exports provided: Grammar */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Grammar", function () {
        return i;
      });
      var i,
          r = s(
      /*! ./pegjs/dist/grammar.js */
      "./node_modules/sip.js/lib/grammar/pegjs/dist/grammar.js");
      !function (e) {
        e.parse = function (e, t) {
          const s = {
            startRule: t
          };

          try {
            r.parse(e, s);
          } catch (e) {
            s.data = -1;
          }

          return s.data;
        }, e.nameAddrHeaderParse = function (t) {
          const s = e.parse(t, "Name_Addr_Header");
          return -1 !== s ? s : void 0;
        }, e.URIParse = function (t) {
          const s = e.parse(t, "SIP_URI");
          return -1 !== s ? s : void 0;
        };
      }(i = i || (i = {}));
    },
    "./node_modules/sip.js/lib/grammar/index.js":
    /*!**************************************************!*\
      !*** ./node_modules/sip.js/lib/grammar/index.js ***!
      \**************************************************/

    /*! exports provided: Grammar, NameAddrHeader, Parameters, URI, equivalentURI */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js");
      s.d(t, "Grammar", function () {
        return i.Grammar;
      });
      var r = s(
      /*! ./name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js");
      s.d(t, "NameAddrHeader", function () {
        return r.NameAddrHeader;
      });
      var n = s(
      /*! ./parameters.js */
      "./node_modules/sip.js/lib/grammar/parameters.js");
      s.d(t, "Parameters", function () {
        return n.Parameters;
      });
      var o = s(
      /*! ./uri.js */
      "./node_modules/sip.js/lib/grammar/uri.js");
      s.d(t, "URI", function () {
        return o.URI;
      }), s.d(t, "equivalentURI", function () {
        return o.equivalentURI;
      });
    },
    "./node_modules/sip.js/lib/grammar/name-addr-header.js":
    /*!*************************************************************!*\
      !*** ./node_modules/sip.js/lib/grammar/name-addr-header.js ***!
      \*************************************************************/

    /*! exports provided: NameAddrHeader */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "NameAddrHeader", function () {
        return r;
      });
      var i = s(
      /*! ./parameters.js */
      "./node_modules/sip.js/lib/grammar/parameters.js");

      class r extends i.Parameters {
        constructor(e, t, s) {
          super(s), this.uri = e, this._displayName = t;
        }

        get friendlyName() {
          return this.displayName || this.uri.aor;
        }

        get displayName() {
          return this._displayName;
        }

        set displayName(e) {
          this._displayName = e;
        }

        clone() {
          return new r(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
        }

        toString() {
          let e = this.displayName || "0" === this.displayName ? '"' + this.displayName + '" ' : "";
          e += "<" + this.uri.toString() + ">";

          for (const t in this.parameters) this.parameters.hasOwnProperty(t) && (e += ";" + t, null !== this.parameters[t] && (e += "=" + this.parameters[t]));

          return e;
        }

      }
    },
    "./node_modules/sip.js/lib/grammar/parameters.js":
    /*!*******************************************************!*\
      !*** ./node_modules/sip.js/lib/grammar/parameters.js ***!
      \*******************************************************/

    /*! exports provided: Parameters */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Parameters", function () {
        return i;
      });

      class i {
        constructor(e) {
          this.parameters = {};

          for (const t in e) e.hasOwnProperty(t) && this.setParam(t, e[t]);
        }

        setParam(e, t) {
          e && (this.parameters[e.toLowerCase()] = null == t ? null : t.toString());
        }

        getParam(e) {
          if (e) return this.parameters[e.toLowerCase()];
        }

        hasParam(e) {
          return !(!e || void 0 === this.parameters[e.toLowerCase()]);
        }

        deleteParam(e) {
          if (e = e.toLowerCase(), this.hasParam(e)) {
            const t = this.parameters[e];
            return delete this.parameters[e], t;
          }
        }

        clearParams() {
          this.parameters = {};
        }

      }
    },
    "./node_modules/sip.js/lib/grammar/pegjs/dist/grammar.js":
    /*!***************************************************************!*\
      !*** ./node_modules/sip.js/lib/grammar/pegjs/dist/grammar.js ***!
      \***************************************************************/

    /*! exports provided: SyntaxError, parse */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SyntaxError", function () {
        return o;
      }), s.d(t, "parse", function () {
        return a;
      });
      var i = s(
      /*! ../../name-addr-header.js */
      "./node_modules/sip.js/lib/grammar/name-addr-header.js"),
          r = s(
      /*! ../../uri.js */
      "./node_modules/sip.js/lib/grammar/uri.js");

      function n(e, t, s) {
        return s = s || " ", e.length > t ? e : (t -= e.length, e + (s += s.repeat(t)).slice(0, t));
      }

      class o extends Error {
        constructor(e, t, s, i) {
          super(), this.message = e, this.expected = t, this.found = s, this.location = i, this.name = "SyntaxError", "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf(this, o.prototype) : this.__proto__ = o.prototype, "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, o);
        }

        static buildMessage(e, t) {
          function s(e) {
            return e.charCodeAt(0).toString(16).toUpperCase();
          }

          function i(e) {
            return e.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, e => "\\x0" + s(e)).replace(/[\x10-\x1F\x7F-\x9F]/g, e => "\\x" + s(e));
          }

          function r(e) {
            return e.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, e => "\\x0" + s(e)).replace(/[\x10-\x1F\x7F-\x9F]/g, e => "\\x" + s(e));
          }

          function n(e) {
            switch (e.type) {
              case "literal":
                return '"' + i(e.text) + '"';

              case "class":
                const t = e.parts.map(e => Array.isArray(e) ? r(e[0]) + "-" + r(e[1]) : r(e));
                return "[" + (e.inverted ? "^" : "") + t + "]";

              case "any":
                return "any character";

              case "end":
                return "end of input";

              case "other":
                return e.description;
            }
          }

          return "Expected " + function (e) {
            const t = e.map(n);
            let s, i;

            if (t.sort(), t.length > 0) {
              for (s = 1, i = 1; s < t.length; s++) t[s - 1] !== t[s] && (t[i] = t[s], i++);

              t.length = i;
            }

            switch (t.length) {
              case 1:
                return t[0];

              case 2:
                return t[0] + " or " + t[1];

              default:
                return t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
            }
          }(e) + " but " + ((o = t) ? '"' + i(o) + '"' : "end of input") + " found.";
          var o;
        }

        format(e) {
          let t = "Error: " + this.message;

          if (this.location) {
            let s,
                i = null;

            for (s = 0; s < e.length; s++) if (e[s].source === this.location.source) {
              i = e[s].text.split(/\r\n|\n|\r/g);
              break;
            }

            let r = this.location.start,
                o = this.location.source + ":" + r.line + ":" + r.column;

            if (i) {
              let e = this.location.end,
                  s = n("", r.line.toString().length, " "),
                  a = i[r.line - 1],
                  c = r.line === e.line ? e.column : a.length + 1;
              t += "\n --\x3e " + o + "\n" + s + " |\n" + r.line + " | " + a + "\n" + s + " | " + n("", r.column - 1, " ") + n("", c - r.column, "^");
            } else t += "\n at " + o;
          }

          return t;
        }

      }

      const a = function (e, t) {
        const s = {},
              n = (t = void 0 !== t ? t : {}).grammarSource,
              a = {
          Contact: 119,
          Name_Addr_Header: 156,
          Record_Route: 176,
          Request_Response: 81,
          SIP_URI: 45,
          Subscription_State: 186,
          Supported: 191,
          Require: 182,
          Via: 194,
          absoluteURI: 84,
          Call_ID: 118,
          Content_Disposition: 130,
          Content_Length: 135,
          Content_Type: 136,
          CSeq: 146,
          displayName: 122,
          Event: 149,
          From: 151,
          host: 52,
          Max_Forwards: 154,
          Min_SE: 213,
          Proxy_Authenticate: 157,
          quoted_string: 40,
          Refer_To: 178,
          Replaces: 179,
          Session_Expires: 210,
          stun_URI: 217,
          To: 192,
          turn_URI: 223,
          uuid: 226,
          WWW_Authenticate: 209,
          challenge: 158,
          sipfrag: 230,
          Referred_By: 231
        };
        let c = 119;
        const d = ["\r\n", j("\r\n", !1), /^[0-9]/, w([["0", "9"]], !1, !1), /^[a-zA-Z]/, w([["a", "z"], ["A", "Z"]], !1, !1), /^[0-9a-fA-F]/, w([["0", "9"], ["a", "f"], ["A", "F"]], !1, !1), /^[\0-\xFF]/, w([["\0", ""]], !1, !1), /^["]/, w(['"'], !1, !1), " ", j(" ", !1), "\t", j("\t", !1), /^[a-zA-Z0-9]/, w([["a", "z"], ["A", "Z"], ["0", "9"]], !1, !1), ";", j(";", !1), "/", j("/", !1), "?", j("?", !1), ":", j(":", !1), "@", j("@", !1), "&", j("&", !1), "=", j("=", !1), "+", j("+", !1), "$", j("$", !1), ",", j(",", !1), "-", j("-", !1), "_", j("_", !1), ".", j(".", !1), "!", j("!", !1), "~", j("~", !1), "*", j("*", !1), "'", j("'", !1), "(", j("(", !1), ")", j(")", !1), "%", j("%", !1), function () {
          return " ";
        }, function () {
          return ":";
        }, /^[!-~]/, w([["!", "~"]], !1, !1), /^[\x80-\uFFFF]/, w([["", ""]], !1, !1), /^[\x80-\xBF]/, w([["", ""]], !1, !1), /^[a-f]/, w([["a", "f"]], !1, !1), "`", j("`", !1), "<", j("<", !1), ">", j(">", !1), "\\", j("\\", !1), "[", j("[", !1), "]", j("]", !1), "{", j("{", !1), "}", j("}", !1), function () {
          return "*";
        }, function () {
          return "/";
        }, function () {
          return "=";
        }, function () {
          return "(";
        }, function () {
          return ")";
        }, function () {
          return ">";
        }, function () {
          return "<";
        }, function () {
          return ",";
        }, function () {
          return ";";
        }, function () {
          return ":";
        }, function () {
          return '"';
        }, /^[!-']/, w([["!", "'"]], !1, !1), /^[*-[]/, w([["*", "["]], !1, !1), /^[\]-~]/, w([["]", "~"]], !1, !1), function (e) {
          return e;
        }, /^[#-[]/, w([["#", "["]], !1, !1), /^[\0-\t]/, w([["\0", "\t"]], !1, !1), /^[\v-\f]/, w([["\v", "\f"]], !1, !1), /^[\x0E-\x7F]/, w([["", ""]], !1, !1), function () {
          (t = t || {
            data: {}
          }).data.uri = new r.URI(t.data.scheme, t.data.user, t.data.host, t.data.port), delete t.data.scheme, delete t.data.user, delete t.data.host, delete t.data.host_type, delete t.data.port;
        }, function () {
          (t = t || {
            data: {}
          }).data.uri = new r.URI(t.data.scheme, t.data.user, t.data.host, t.data.port, t.data.uri_params, t.data.uri_headers), delete t.data.scheme, delete t.data.user, delete t.data.host, delete t.data.host_type, delete t.data.port, delete t.data.uri_params, "SIP_URI" === t.startRule && (t.data = t.data.uri);
        }, "sips", j("sips", !0), "sip", j("sip", !0), function (e) {
          (t = t || {
            data: {}
          }).data.scheme = e;
        }, function () {
          (t = t || {
            data: {}
          }).data.user = decodeURIComponent(b().slice(0, -1));
        }, function () {
          (t = t || {
            data: {}
          }).data.password = b();
        }, function () {
          return (t = t || {
            data: {}
          }).data.host = b(), t.data.host;
        }, function () {
          return (t = t || {
            data: {}
          }).data.host_type = "domain", b();
        }, /^[a-zA-Z0-9_\-]/, w([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], !1, !1), /^[a-zA-Z0-9\-]/, w([["a", "z"], ["A", "Z"], ["0", "9"], "-"], !1, !1), function () {
          return (t = t || {
            data: {}
          }).data.host_type = "IPv6", b();
        }, "::", j("::", !1), function () {
          return (t = t || {
            data: {}
          }).data.host_type = "IPv6", b();
        }, function () {
          return (t = t || {
            data: {}
          }).data.host_type = "IPv4", b();
        }, "25", j("25", !1), /^[0-5]/, w([["0", "5"]], !1, !1), "2", j("2", !1), /^[0-4]/, w([["0", "4"]], !1, !1), "1", j("1", !1), /^[1-9]/, w([["1", "9"]], !1, !1), function (e) {
          return t = t || {
            data: {}
          }, e = parseInt(e.join("")), t.data.port = e, e;
        }, "transport=", j("transport=", !0), "udp", j("udp", !0), "tcp", j("tcp", !0), "sctp", j("sctp", !0), "tls", j("tls", !0), function (e) {
          (t = t || {
            data: {}
          }).data.uri_params || (t.data.uri_params = {}), t.data.uri_params.transport = e.toLowerCase();
        }, "user=", j("user=", !0), "phone", j("phone", !0), "ip", j("ip", !0), function (e) {
          (t = t || {
            data: {}
          }).data.uri_params || (t.data.uri_params = {}), t.data.uri_params.user = e.toLowerCase();
        }, "method=", j("method=", !0), function (e) {
          (t = t || {
            data: {}
          }).data.uri_params || (t.data.uri_params = {}), t.data.uri_params.method = e;
        }, "ttl=", j("ttl=", !0), function (e) {
          (t = t || {
            data: {}
          }).data.params || (t.data.params = {}), t.data.params.ttl = e;
        }, "maddr=", j("maddr=", !0), function (e) {
          (t = t || {
            data: {}
          }).data.uri_params || (t.data.uri_params = {}), t.data.uri_params.maddr = e;
        }, "lr", j("lr", !0), function () {
          (t = t || {
            data: {}
          }).data.uri_params || (t.data.uri_params = {}), t.data.uri_params.lr = void 0;
        }, function (e, s) {
          (t = t || {
            data: {}
          }).data.uri_params || (t.data.uri_params = {}), s = null === s ? void 0 : s[1], t.data.uri_params[e.toLowerCase()] = s;
        }, function (e, s) {
          e = e.join("").toLowerCase(), s = s.join(""), (t = t || {
            data: {}
          }).data.uri_headers || (t.data.uri_headers = {}), t.data.uri_headers[e] ? t.data.uri_headers[e].push(s) : t.data.uri_headers[e] = [s];
        }, function () {
          "Refer_To" === (t = t || {
            data: {}
          }).startRule && (t.data.uri = new r.URI(t.data.scheme, t.data.user, t.data.host, t.data.port, t.data.uri_params, t.data.uri_headers), delete t.data.scheme, delete t.data.user, delete t.data.host, delete t.data.host_type, delete t.data.port, delete t.data.uri_params);
        }, "//", j("//", !1), function () {
          (t = t || {
            data: {}
          }).data.scheme = b();
        }, j("SIP", !0), function () {
          (t = t || {
            data: {}
          }).data.sip_version = b();
        }, "INVITE", j("INVITE", !1), "ACK", j("ACK", !1), "VXACH", j("VXACH", !1), "OPTIONS", j("OPTIONS", !1), "BYE", j("BYE", !1), "CANCEL", j("CANCEL", !1), "REGISTER", j("REGISTER", !1), "SUBSCRIBE", j("SUBSCRIBE", !1), "NOTIFY", j("NOTIFY", !1), "REFER", j("REFER", !1), "PUBLISH", j("PUBLISH", !1), function () {
          return (t = t || {
            data: {}
          }).data.method = b(), t.data.method;
        }, function (e) {
          (t = t || {
            data: {}
          }).data.status_code = parseInt(e.join(""));
        }, function () {
          (t = t || {
            data: {}
          }).data.reason_phrase = b();
        }, function () {
          (t = t || {
            data: {}
          }).data = b();
        }, function () {
          var e, s;

          for (s = (t = t || {
            data: {}
          }).data.multi_header.length, e = 0; e < s; e++) if (null === t.data.multi_header[e].parsed) {
            t.data = null;
            break;
          }

          null !== t.data ? t.data = t.data.multi_header : t.data = -1;
        }, function () {
          var e;
          (t = t || {
            data: {}
          }).data.multi_header || (t.data.multi_header = []);

          try {
            e = new i.NameAddrHeader(t.data.uri, t.data.displayName, t.data.params), delete t.data.uri, delete t.data.displayName, delete t.data.params;
          } catch (t) {
            e = null;
          }

          t.data.multi_header.push({
            position: u,
            offset: S().start.offset,
            parsed: e
          });
        }, function (e) {
          '"' === (e = b().trim())[0] && (e = e.substring(1, e.length - 1)), (t = t || {
            data: {}
          }).data.displayName = e;
        }, "q", j("q", !0), function (e) {
          (t = t || {
            data: {}
          }).data.params || (t.data.params = {}), t.data.params.q = e;
        }, "expires", j("expires", !0), function (e) {
          (t = t || {
            data: {}
          }).data.params || (t.data.params = {}), t.data.params.expires = e;
        }, function (e) {
          return parseInt(e.join(""));
        }, "0", j("0", !1), function () {
          return parseFloat(b());
        }, function (e, s) {
          (t = t || {
            data: {}
          }).data.params || (t.data.params = {}), s = null === s ? void 0 : s[1], t.data.params[e.toLowerCase()] = s;
        }, "render", j("render", !0), "session", j("session", !0), "icon", j("icon", !0), "alert", j("alert", !0), function () {
          "Content_Disposition" === (t = t || {
            data: {}
          }).startRule && (t.data.type = b().toLowerCase());
        }, "handling", j("handling", !0), "optional", j("optional", !0), "required", j("required", !0), function (e) {
          (t = t || {
            data: {}
          }).data = parseInt(e.join(""));
        }, function () {
          (t = t || {
            data: {}
          }).data = b();
        }, "text", j("text", !0), "image", j("image", !0), "audio", j("audio", !0), "video", j("video", !0), "application", j("application", !0), "message", j("message", !0), "multipart", j("multipart", !0), "x-", j("x-", !0), function (e) {
          (t = t || {
            data: {}
          }).data.value = parseInt(e.join(""));
        }, function (e) {
          (t = t || {
            data: {}
          }).data = e;
        }, function (e) {
          (t = t || {
            data: {}
          }).data.event = e.toLowerCase();
        }, function () {
          var e = (t = t || {
            data: {}
          }).data.tag;
          t.data = new i.NameAddrHeader(t.data.uri, t.data.displayName, t.data.params), e && t.data.setParam("tag", e);
        }, "tag", j("tag", !0), function (e) {
          (t = t || {
            data: {}
          }).data.tag = e;
        }, function (e) {
          (t = t || {
            data: {}
          }).data = parseInt(e.join(""));
        }, function (e) {
          (t = t || {
            data: {}
          }).data = e;
        }, function () {
          (t = t || {
            data: {}
          }).data = new i.NameAddrHeader(t.data.uri, t.data.displayName, t.data.params);
        }, "digest", j("Digest", !0), "realm", j("realm", !0), function (e) {
          (t = t || {
            data: {}
          }).data.realm = e;
        }, "domain", j("domain", !0), "nonce", j("nonce", !0), function (e) {
          (t = t || {
            data: {}
          }).data.nonce = e;
        }, "opaque", j("opaque", !0), function (e) {
          (t = t || {
            data: {}
          }).data.opaque = e;
        }, "stale", j("stale", !0), "true", j("true", !0), function () {
          (t = t || {
            data: {}
          }).data.stale = !0;
        }, "false", j("false", !0), function () {
          (t = t || {
            data: {}
          }).data.stale = !1;
        }, "algorithm", j("algorithm", !0), "md5", j("MD5", !0), "md5-sess", j("MD5-sess", !0), function (e) {
          (t = t || {
            data: {}
          }).data.algorithm = e.toUpperCase();
        }, "qop", j("qop", !0), "auth-int", j("auth-int", !0), "auth", j("auth", !0), function (e) {
          (t = t || {
            data: {}
          }).data.qop || (t.data.qop = []), t.data.qop.push(e.toLowerCase());
        }, function (e) {
          (t = t || {
            data: {}
          }).data.value = parseInt(e.join(""));
        }, function () {
          var e, s;

          for (s = (t = t || {
            data: {}
          }).data.multi_header.length, e = 0; e < s; e++) if (null === t.data.multi_header[e].parsed) {
            t.data = null;
            break;
          }

          null !== t.data ? t.data = t.data.multi_header : t.data = -1;
        }, function () {
          var e;
          (t = t || {
            data: {}
          }).data.multi_header || (t.data.multi_header = []);

          try {
            e = new i.NameAddrHeader(t.data.uri, t.data.displayName, t.data.params), delete t.data.uri, delete t.data.displayName, delete t.data.params;
          } catch (t) {
            e = null;
          }

          t.data.multi_header.push({
            position: u,
            offset: S().start.offset,
            parsed: e
          });
        }, function () {
          (t = t || {
            data: {}
          }).data = new i.NameAddrHeader(t.data.uri, t.data.displayName, t.data.params);
        }, function () {
          (t = t || {
            data: {}
          }).data.replaces_from_tag && t.data.replaces_to_tag || (t.data = -1);
        }, function () {
          (t = t || {
            data: {}
          }).data = {
            call_id: t.data
          };
        }, "from-tag", j("from-tag", !0), function (e) {
          (t = t || {
            data: {}
          }).data.replaces_from_tag = e;
        }, "to-tag", j("to-tag", !0), function (e) {
          (t = t || {
            data: {}
          }).data.replaces_to_tag = e;
        }, "early-only", j("early-only", !0), function () {
          (t = t || {
            data: {}
          }).data.early_only = !0;
        }, function (e, t) {
          return t;
        }, function (e, t) {
          return function (e, t) {
            return [e].concat(t);
          }(e, t);
        }, function (e) {
          "Require" === (t = t || {
            data: {}
          }).startRule && (t.data = e || []);
        }, function (e) {
          (t = t || {
            data: {}
          }).data.value = parseInt(e.join(""));
        }, "active", j("active", !0), "pending", j("pending", !0), "terminated", j("terminated", !0), function () {
          (t = t || {
            data: {}
          }).data.state = b();
        }, "reason", j("reason", !0), function (e) {
          t = t || {
            data: {}
          }, void 0 !== e && (t.data.reason = e);
        }, function (e) {
          t = t || {
            data: {}
          }, void 0 !== e && (t.data.expires = e);
        }, "retry_after", j("retry_after", !0), function (e) {
          t = t || {
            data: {}
          }, void 0 !== e && (t.data.retry_after = e);
        }, "deactivated", j("deactivated", !0), "probation", j("probation", !0), "rejected", j("rejected", !0), "timeout", j("timeout", !0), "giveup", j("giveup", !0), "noresource", j("noresource", !0), "invariant", j("invariant", !0), function (e) {
          "Supported" === (t = t || {
            data: {}
          }).startRule && (t.data = e || []);
        }, function () {
          var e = (t = t || {
            data: {}
          }).data.tag;
          t.data = new i.NameAddrHeader(t.data.uri, t.data.displayName, t.data.params), e && t.data.setParam("tag", e);
        }, "ttl", j("ttl", !0), function (e) {
          (t = t || {
            data: {}
          }).data.ttl = e;
        }, "maddr", j("maddr", !0), function (e) {
          (t = t || {
            data: {}
          }).data.maddr = e;
        }, "received", j("received", !0), function (e) {
          (t = t || {
            data: {}
          }).data.received = e;
        }, "branch", j("branch", !0), function (e) {
          (t = t || {
            data: {}
          }).data.branch = e;
        }, "rport", j("rport", !0), function (e) {
          t = t || {
            data: {}
          }, void 0 !== e && (t.data.rport = e.join(""));
        }, function (e) {
          (t = t || {
            data: {}
          }).data.protocol = e;
        }, j("UDP", !0), j("TCP", !0), j("TLS", !0), j("SCTP", !0), function (e) {
          (t = t || {
            data: {}
          }).data.transport = e;
        }, function () {
          (t = t || {
            data: {}
          }).data.host = b();
        }, function (e) {
          (t = t || {
            data: {}
          }).data.port = parseInt(e.join(""));
        }, function (e) {
          return parseInt(e.join(""));
        }, function (e) {
          "Session_Expires" === (t = t || {
            data: {}
          }).startRule && (t.data.deltaSeconds = e);
        }, "refresher", j("refresher", !1), "uas", j("uas", !1), "uac", j("uac", !1), function (e) {
          "Session_Expires" === (t = t || {
            data: {}
          }).startRule && (t.data.refresher = e);
        }, function (e) {
          "Min_SE" === (t = t || {
            data: {}
          }).startRule && (t.data = e);
        }, "stuns", j("stuns", !0), "stun", j("stun", !0), function (e) {
          (t = t || {
            data: {}
          }).data.scheme = e;
        }, function (e) {
          (t = t || {
            data: {}
          }).data.host = e;
        }, "?transport=", j("?transport=", !1), "turns", j("turns", !0), "turn", j("turn", !0), function (e) {
          (t = t || {
            data: {}
          }).data.transport = e;
        }, function () {
          (t = t || {
            data: {}
          }).data = b();
        }, "Referred-By", j("Referred-By", !1), "b", j("b", !1), "cid", j("cid", !1)],
              l = [C('2 ""6 7!'), C('4"""5!7#'), C('4$""5!7%'), C('4&""5!7\''), C(";'.# &;("), C('4(""5!7)'), C('4*""5!7+'), C('2,""6,7-'), C('2.""6.7/'), C('40""5!71'), C('22""6273. &24""6475.} &26""6677.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'), C(";).# &;,"), C('2F""6F7G.} &2H""6H7I.q &2J""6J7K.e &2L""6L7M.Y &2N""6N7O.M &2P""6P7Q.A &2R""6R7S.5 &2T""6T7U.) &2V""6V7W'), C('%%2X""6X7Y/5#;#/,$;#/#$+#)(#\'#("\'#&\'#/"!&,)'), C('%%$;$0#*;$&/,#; /#$+")("\'#&\'#." &"/=#$;$/&#0#*;$&&&#/\'$8":Z" )("\'#&\'#'), C(';.." &"'), C("%$;'.# &;(0)*;'.# &;(&/?#28\"\"6879/0$;//'$8#:[# )(#'#(\"'#&'#"), C('%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+")("\'#&\'#0=*%$;.0#*;.&/,#;2/#$+")("\'#&\'#&/#$+")("\'#&\'#/"!&,)'), C('4\\""5!7].# &;3'), C('4^""5!7_'), C('4`""5!7a'), C(';!.) &4b""5!7c'), C('%$;). &2F""6F7G. &2J""6J7K.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O/#0*;). &2F""6F7G. &2J""6J7K.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O&&&#/"!&,)'), C('%$;). &2F""6F7G.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O/#0*;). &2F""6F7G.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O&&&#/"!&,)'), C('2T""6T7U. &2V""6V7W. &2f""6f7g. &2h""6h7i. &2:""6:7;. &2D""6D7E. &22""6273. &28""6879. &2j""6j7k. &;&.} &24""6475.q &2l""6l7m.e &2n""6n7o.Y &26""6677.M &2>""6>7?.A &2p""6p7q.5 &2r""6r7s.) &;\'.# &;('), C('%$;). &2F""6F7G. &2J""6J7K. &2L""6L7M. &2X""6X7Y. &2P""6P7Q. &2H""6H7I. &2@""6@7A. &2d""6d7e. &2R""6R7S. &2N""6N7O. &2T""6T7U. &2V""6V7W. &2f""6f7g. &2h""6h7i. &28""6879.w &2j""6j7k.k &;&.e &24""6475.Y &2l""6l7m.M &2n""6n7o.A &26""6677.5 &2p""6p7q.) &2r""6r7s/#0*;). &2F""6F7G. &2J""6J7K. &2L""6L7M. &2X""6X7Y. &2P""6P7Q. &2H""6H7I. &2@""6@7A. &2d""6d7e. &2R""6R7S. &2N""6N7O. &2T""6T7U. &2V""6V7W. &2f""6f7g. &2h""6h7i. &28""6879.w &2j""6j7k.k &;&.e &24""6475.Y &2l""6l7m.M &2n""6n7o.A &26""6677.5 &2p""6p7q.) &2r""6r7s&&&#/"!&,)'), C("%;//?#2P\"\"6P7Q/0$;//'$8#:t# )(#'#(\"'#&'#"), C("%;//?#24\"\"6475/0$;//'$8#:u# )(#'#(\"'#&'#"), C("%;//?#2>\"\"6>7?/0$;//'$8#:v# )(#'#(\"'#&'#"), C("%;//?#2T\"\"6T7U/0$;//'$8#:w# )(#'#(\"'#&'#"), C("%;//?#2V\"\"6V7W/0$;//'$8#:x# )(#'#(\"'#&'#"), C('%2h""6h7i/0#;//\'$8":y" )("\'#&\'#'), C('%;//6#2f""6f7g/\'$8":z" )("\'#&\'#'), C("%;//?#2D\"\"6D7E/0$;//'$8#:{# )(#'#(\"'#&'#"), C("%;//?#22\"\"6273/0$;//'$8#:|# )(#'#(\"'#&'#"), C("%;//?#28\"\"6879/0$;//'$8#:}# )(#'#(\"'#&'#"), C("%;//0#;&/'$8\":~\" )(\"'#&'#"), C("%;&/0#;//'$8\":~\" )(\"'#&'#"), C("%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\"'#&'#"), C('4""5!7.A &4""5!7.5 &4""5!7.) &;3.# &;.'), C("%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\"'#&'#/\"!&,)"), C("%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\"!&,)/1$;&/($8$:$!!)($'#(#'#(\"'#&'#"), C(';..G &2L""6L7M.; &4""5!7./ &4""5!7.# &;3'), C('%2j""6j7k/J#4""5!7.5 &4""5!7.) &4""5!7/#$+")("\'#&\'#'), C("%;N/M#28\"\"6879/>$;O.\" &\"/0$;S/'$8$:$ )($'#(#'#(\"'#&'#"), C("%;N/d#28\"\"6879/U$;O.\" &\"/G$;S/>$;_/5$;l.\" &\"/'$8&:& )(&'#(%'#($'#(#'#(\"'#&'#"), C('%3""5$7.) &3""5#7/\' 8!:!! )'), C('%;P/]#%28""6879/,#;R/#$+")("\'#&\'#." &"/6$2:""6:7;/\'$8#:# )(#\'#("\'#&\'#'), C("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"), C('2<""6<7=.q &2>""6>7?.e &2@""6@7A.Y &2B""6B7C.M &2D""6D7E.A &22""6273.5 &26""6677.) &24""6475'), C('%$;+._ &;-.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E0e*;+._ &;-.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E&/& 8!:! )'), C('%;T/J#%28""6879/,#;^/#$+")("\'#&\'#." &"/#$+")("\'#&\'#'), C("%;U.) &;\\.# &;X/& 8!:! )"), C('%$%;V/2#2J""6J7K/#$+")("\'#&\'#0<*%;V/2#2J""6J7K/#$+")("\'#&\'#&/D#;W/;$2J""6J7K." &"/\'$8#:# )(#\'#("\'#&\'#'), C('$4""5!7/,#0)*4""5!7&&&#'), C('%4$""5!7%/?#$4""5!70)*4""5!7&/#$+")("\'#&\'#'), C('%2l""6l7m/?#;Y/6$2n""6n7o/\'$8#:# )(#\'#("\'#&\'#'), C('%%;Z/#28""6879/$;Z/$28""6879/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+-)(-\'#(,\'#(+\'#(*\'#()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%2""67/#;Z/$28""6879/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+,)(,\'#(+\'#(*\'#()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%2""67/#;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+*)(*\'#()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%2""67/t#;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+()((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%2""67/\\#;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+&)(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%2""67/D#;Z/;$28""6879/,$;[/#$+$)($\'#(#\'#("\'#&\'#. &%2""67/,#;[/#$+")("\'#&\'#. &%2""67/,#;Z/#$+")("\'#&\'#. &%;Z/#2""67/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$++)(+\'#(*\'#()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%;Z/#%28""6879/,#;Z/#$+")("\'#&\'#." &"/$2""67/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+*)(*\'#()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%;Z/#%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/k$2""67/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+))()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%;Z/#%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/z$%28""6879/,#;Z/#$+")("\'#&\'#." &"/S$2""67/D$;Z/;$28""6879/,$;[/#$+()((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%;Z/#%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/b$%28""6879/,#;Z/#$+")("\'#&\'#." &"/;$2""67/,$;[/#$+\')(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%;Z/#%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/b$%28""6879/,#;Z/#$+")("\'#&\'#." &"/;$2""67/,$;Z/#$+()((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#. &%;Z/#%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/$%28""6879/,#;Z/#$+")("\'#&\'#." &"/Y$%28""6879/,#;Z/#$+")("\'#&\'#." &"/2$2""67/#$+()((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#/& 8!:! )'), C('%;#/M#;#." &"/?$;#." &"/1$;#." &"/#$+$)($\'#(#\'#("\'#&\'#'), C("%;Z/;#28\"\"6879/,$;Z/#$+#)(#'#(\"'#&'#.# &;\\"), C("%;]/o#2J\"\"6J7K/`$;]/W$2J\"\"6J7K/H$;]/?$2J\"\"6J7K/0$;]/'$8':' )(''#(&'#(%'#($'#(#'#(\"'#&'#"), C('%2""67/2#4""5!7/#$+")("\'#&\'#. &%2""67/;#4""5!7/,$;!/#$+#)(#\'#("\'#&\'#.j &%2""67/5#;!/,$;!/#$+#)(#\'#("\'#&\'#.B &%4""5!7/,#;!/#$+")("\'#&\'#.# &;!'), C('%%;!." &"/[#;!." &"/M$;!." &"/?$;!." &"/1$;!." &"/#$+%)(%\'#($\'#(#\'#("\'#&\'#/\' 8!:!! )'), C('$%22""6273/,#;`/#$+")("\'#&\'#0<*%22""6273/,#;`/#$+")("\'#&\'#&'), C(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"), C('%3""5*7/a#3""5#7.G &3""5#7.; &3""5$7./ &3""5#7.# &;6/($8":"! )("\'#&\'#'), C('%3""5%7/I#3""5%7./ &3""5"7.# &;6/($8":"! )("\'#&\'#'), C('%3""5\'7/1#;/($8":"! )("\'#&\'#'), C('%3""5$7/1#;/($8":"! )("\'#&\'#'), C('%3""5&7/1#;T/($8":"! )("\'#&\'#'), C('%3""5"7/N#%2>""6>7?/,#;6/#$+")("\'#&\'#." &"/\'$8":" )("\'#&\'#'), C('%;h/P#%2>""6>7?/,#;i/#$+")("\'#&\'#." &"/)$8":""! )("\'#&\'#'), C('%$;j/&#0#*;j&&&#/"!&,)'), C('%$;j/&#0#*;j&&&#/"!&,)'), C(";k.) &;+.# &;-"), C('2l""6l7m.e &2n""6n7o.Y &24""6475.M &28""6879.A &2<""6<7=.5 &2@""6@7A.) &2B""6B7C'), C('%26""6677/n#;m/e$$%2<""6<7=/,#;m/#$+")("\'#&\'#0<*%2<""6<7=/,#;m/#$+")("\'#&\'#&/#$+#)(#\'#("\'#&\'#'), C('%;n/A#2>""6>7?/2$;o/)$8#:#"" )(#\'#("\'#&\'#'), C("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"), C("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"), C('2l""6l7m.e &2n""6n7o.Y &24""6475.M &26""6677.A &28""6879.5 &2@""6@7A.) &2B""6B7C'), C(";.# &;r"), C("%;/G#;'/>$;s/5$;'/,$;/#$+%)(%'#($'#(#'#(\"'#&'#"), C(";M.# &;t"), C("%;/E#28\"\"6879/6$;u.# &;x/'$8#:# )(#'#(\"'#&'#"), C('%;v.# &;w/J#%26""6677/,#;/#$+")("\'#&\'#." &"/#$+")("\'#&\'#'), C('%2""67/:#;/1$;w." &"/#$+#)(#\'#("\'#&\'#'), C('%24""6475/,#;{/#$+")("\'#&\'#'), C("%;z/3#$;y0#*;y&/#$+\")(\"'#&'#"), C(";*.) &;+.# &;-"), C(';+. &;-. &22""6273.} &26""6677.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'), C('%;|/e#$%24""6475/,#;|/#$+")("\'#&\'#0<*%24""6475/,#;|/#$+")("\'#&\'#&/#$+")("\'#&\'#'), C('%$;~0#*;~&/e#$%22""6273/,#;}/#$+")("\'#&\'#0<*%22""6273/,#;}/#$+")("\'#&\'#&/#$+")("\'#&\'#'), C("$;~0#*;~&"), C(';+.w &;-.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'), C('%%;"/#$;".G &;!.A &2@""6@7A.5 &2F""6F7G.) &2J""6J7K0M*;".G &;!.A &2@""6@7A.5 &2F""6F7G.) &2J""6J7K&/#$+")("\'#&\'#/& 8!:! )'), C(";.# &;"), C('%%;O/2#2:""6:7;/#$+")("\'#&\'#." &"/,#;S/#$+")("\'#&\'#." &"'), C('$;+. &;-.} &2B""6B7C.q &2D""6D7E.e &22""6273.Y &28""6879.M &2:""6:7;.A &2<""6<7=.5 &2>""6>7?.) &2@""6@7A/#0*;+. &;-.} &2B""6B7C.q &2D""6D7E.e &22""6273.Y &28""6879.M &2:""6:7;.A &2<""6<7=.5 &2>""6>7?.) &2@""6@7A&&&#'), C("$;y0#*;y&"), C('%3""5#7/q#24""6475/b$$;!/&#0#*;!&&&#/L$2J""6J7K/=$$;!/&#0#*;!&&&#/\'$8%:% )(%\'#($\'#(#\'#("\'#&\'#'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C('2""67'), C("%;.Y &;.S &;.M &;.G &;.A &;.; &;.5 &;./ &;.) &;.# &;6/& 8!:! )"), C("%;/G#;'/>$;/5$;'/,$;/#$+%)(%'#($'#(#'#(\"'#&'#"), C("%;/' 8!:!! )"), C("%;!/5#;!/,$;!/#$+#)(#'#(\"'#&'#"), C("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:! )"), C("%;/Y#$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C('%;9/N#%2:""6:7;/,#;9/#$+")("\'#&\'#." &"/\'$8":" )("\'#&\'#'), C("%;:.c &%;/Y#$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/& 8!:! )"), C("%;L.# &;/]#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/'$8\":\" )(\"'#&'#"), C("%;.\" &\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\"'#&'#"), C("%%;6/Y#$%;./,#;6/#$+\")(\"'#&'#06*%;./,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#.# &;H/' 8!:!! )"), C(";.) &;.# &;"), C("%3\"\"5!7/:#;</1$;/($8#:#! )(#'#(\"'#&'#"), C("%3\"\"5'7/:#;</1$;/($8#:#! )(#'#(\"'#&'#"), C("%$;!/&#0#*;!&&&#/' 8!:!! )"), C('%2""67/o#%2J""6J7K/M#;!." &"/?$;!." &"/1$;!." &"/#$+$)($\'#(#\'#("\'#&\'#." &"/\'$8":" )("\'#&\'#'), C('%;6/J#%;</,#;/#$+")("\'#&\'#." &"/)$8":""! )("\'#&\'#'), C(";6.) &;T.# &;H"), C("%;/Y#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C('%3""5&7.G &3""5\'7.; &3""5$7./ &3""5%7.# &;6/& 8!:! )'), C(";.# &;"), C('%3""5(7/M#;</D$3""5(7./ &3""5(7.# &;6/#$+#)(#\'#("\'#&\'#'), C("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C("%$;!/&#0#*;!&&&#/' 8!:!! )"), C("%;/& 8!:! )"), C("%;/k#;;/b$;/Y$$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), C(";.# &;"), C('3""5$7.S &3""5%7.G &3""5%7.; &3""5%7./ &3""5+7.# &;'), C('3""5\'7./ &3""5)7.# &;'), C(";6.# &;"), C('%3""5"7/,#;6/#$+")("\'#&\'#'), C(";.# &;6"), C("%;6/5#;</,$;/#$+#)(#'#(\"'#&'#"), C(";6.# &;H"), C("%;/5#;./,$;/#$+#)(#'#(\"'#&'#"), C("%$;!/&#0#*;!&&&#/' 8!:!! )"), C("%;/' 8!:!! )"), C('%;/^#$%;B/,#;/#$+")("\'#&\'#06*%;B/,#;/#$+")("\'#&\'#&/($8":"!!)("\'#&\'#'), C('%%;7/e#$%2J""6J7K/,#;7/#$+")("\'#&\'#0<*%2J""6J7K/,#;7/#$+")("\'#&\'#&/#$+")("\'#&\'#/"!&,)'), C("%;L.# &;/]#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/'$8\":\" )(\"'#&'#"), C(";.# &;"), C("%3\"\"5#7/:#;</1$;6/($8#:#! )(#'#(\"'#&'#"), C("%$;!/&#0#*;!&&&#/' 8!:!! )"), C("%;/' 8!:!! )"), C("%$;0#*;&/x#;@/o$;M/f$;?/]$$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/'$8%:% )(%'#($'#(#'#(\"'#&'#"), C(";"), C("%3\"\"5&7/k#;./b$;/Y$$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#.# &;"), C("%;6/k#;./b$;/Y$$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), C("%;6/;#;</2$;6.# &;H/#$+#)(#'#(\"'#&'#"), C(";.G &;.A &;.; &;.5 &;./ &;.) &;.# &;"), C("%3\"\"5%7/5#;</,$;/#$+#)(#'#(\"'#&'#"), C("%;I/' 8!:!! )"), C("%3\"\"5&7/#;</$;D/$;/|$$%$;'/&#0#*;'&&&#/,#;/#$+\")(\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;/#$+\")(\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"), C(";t.# &;w"), C("%3\"\"5%7/5#;</,$;/#$+#)(#'#(\"'#&'#"), C("%;I/' 8!:!! )"), C("%3\"\"5&7/:#;</1$;I/($8#:#! )(#'#(\"'#&'#"), C('%3""5%7/]#;</T$%3""5$7/& 8!:! ).4 &%3""5%7/& 8!:! )/#$+#)(#\'#("\'#&\'#'), C('%3""5)7/R#;</I$3""5#7./ &3""5(7.# &;6/($8#:#! )(#\'#("\'#&\'#'), C('%3""5#7/#;</$;D/$%;/e#$%2D""6D7E/,#;/#$+")("\'#&\'#0<*%2D""6D7E/,#;/#$+")("\'#&\'#&/#$+")("\'#&\'#/,$;E/#$+%)(%\'#($\'#(#\'#("\'#&\'#'), C('%3""5(7./ &3""5$7.# &;6/\' 8!:!! )'), C("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C("%;/G#;./>$;/5$;./,$;/#$+%)(%'#($'#(#'#(\"'#&'#"), C("%$;!/&#0#*;!&&&#/' 8!:!! )"), C("%;/]#$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/'$8\":\" )(\"'#&'#"), C("%;/]#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/'$8\":\" )(\"'#&'#"), C('%;L.O &;.I &%;@." &"/:#;t/1$;?." &"/#$+#)(#\'#("\'#&\'#/]#$%;B/,#;/#$+")("\'#&\'#06*%;B/,#;/#$+")("\'#&\'#&/\'$8":" )("\'#&\'#'), C("%;/]#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/'$8\":\" )(\"'#&'#"), C("%;/& 8!:! )"), C('%3""5(7/:#;</1$;6/($8#:#! )(#\'#("\'#&\'#.g &%3""5&7/:#;</1$;6/($8#:#! )(#\'#("\'#&\'#.: &%3""5*7/& 8!:! ).# &;'), C('%%;6/k#$%;A/2#;6/)$8":""$ )("\'#&\'#0<*%;A/2#;6/)$8":""$ )("\'#&\'#&/)$8":""! )("\'#&\'#." &"/\' 8!:!! )'), C("%;/Y#$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C("%;/Y#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C("%$;!/&#0#*;!&&&#/' 8!:!! )"), C("%;/Y#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C('%3""5&7.; &3""5\'7./ &3""5*7.# &;6/& 8!:! )'), C("%3\"\"5&7/:#;</1$;/($8#:#! )(#'#(\"'#&'#.} &%3\"\"5'7/:#;</1$;/($8#:#! )(#'#(\"'#&'#.P &%3\"\"5+7/:#;</1$;/($8#:#! )(#'#(\"'#&'#.# &;"), C('3""5+7.k &3""5)7._ &3""5(7.S &3""5\'7.G &3""5&7.; &3""5*7./ &3""5)7.# &;6'), C(';1." &"'), C('%%;6/k#$%;A/2#;6/)$8":""$ )("\'#&\'#0<*%;A/2#;6/)$8":""$ )("\'#&\'#&/)$8":""! )("\'#&\'#." &"/\' 8!:!! )'), C("%;L.# &;/]#$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/'$8\":\" )(\"'#&'#"), C(";.# &;"), C("%;/Y#$%;A/,#;/#$+\")(\"'#&'#06*%;A/,#;/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), C("%;/k#;./b$;/Y$$%;B/,#;/#$+\")(\"'#&'#06*%;B/,#;/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), C(";.; &;.5 &;./ &;.) &;.# &;"), C("%3\"\"5#7/:#;</1$;/($8#:#! )(#'#(\"'#&'#"), C("%3\"\"5%7/:#;</1$;T/($8#:#! )(#'#(\"'#&'#"), C("%3\"\"5(7/F#;</=$;\\.) &;Y.# &;X/($8#:#! )(#'#(\"'#&'#"), C("%3\"\"5&7/:#;</1$;6/($8#:#! )(#'#(\"'#&'#"), C("%3\"\"5%7/A#;</8$$;!0#*;!&/($8#:#! )(#'#(\"'#&'#"), C("%;/G#;;/>$;6/5$;;/,$;/#$+%)(%'#($'#(#'#(\"'#&'#"), C('%3""5#7.# &;6/\' 8!:!! )'), C('%3""5#7.G &3""5#7.; &3""5#7./ &3""5$7.# &;6/\' 8!:!! )'), C('%;/D#%;C/,#;/#$+")("\'#&\'#." &"/#$+")("\'#&\'#'), C("%;U.) &;\\.# &;X/& 8!:! )"), C('%%;!." &"/[#;!." &"/M$;!." &"/?$;!." &"/1$;!." &"/#$+%)(%\'#($\'#(#\'#("\'#&\'#/\' 8!:!! )'), C('%%;!/?#;!." &"/1$;!." &"/#$+#)(#\'#("\'#&\'#/\' 8!:!! )'), C(";"), C('%;/^#$%;B/,#;/#$+")("\'#&\'#06*%;B/,#;/#$+")("\'#&\'#&/($8":"!!)("\'#&\'#'), C(";.# &;"), C('%2""67/L#;</C$2""67.) &2""67/($8#:#! )(#\'#("\'#&\'#'), C('%;/^#$%;B/,#;/#$+")("\'#&\'#06*%;B/,#;/#$+")("\'#&\'#&/($8":"!!)("\'#&\'#'), C("%;6/5#;0/,$;/#$+#)(#'#(\"'#&'#"), C("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"), C("$;%0#*;%&"), C("%;/;#28\"\"6879/,$;/#$+#)(#'#(\"'#&'#"), C('%3""5%7.) &3""5$7/\' 8!:!! )'), C('%;/J#%28""6879/,#;^/#$+")("\'#&\'#." &"/#$+")("\'#&\'#'), C("%;\\.) &;X.# &;/' 8!:!! )"), C(';".S &;!.M &2F""6F7G.A &2J""6J7K.5 &2H""6H7I.) &2N""6N7O'), C('2L""6L7M. &2B""6B7C. &2<""6<7=.} &2R""6R7S.q &2T""6T7U.e &2V""6V7W.Y &2P""6P7Q.M &2@""6@7A.A &2D""6D7E.5 &22""6273.) &2>""6>7?'), C('%;/b#28""6879/S$;/J$%2""67/,#;/#$+")("\'#&\'#." &"/#$+$)($\'#(#\'#("\'#&\'#'), C('%3""5%7.) &3""5$7/\' 8!:!! )'), C('%3""5#7.6 &3""5#7.* &$;+0#*;+&/\' 8!:!! )'), C("%;/#2F\"\"6F7G/x$;/o$2F\"\"6F7G/`$;/W$2F\"\"6F7G/H$;/?$2F\"\"6F7G/0$;/'$8):) )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"), C("%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\"'#&'#"), C("%;/,#;/#$+\")(\"'#&'#"), C("%;/5#;/,$;/#$+#)(#'#(\"'#&'#"), C("%;q/T#$;m0#*;m&/D$%; /,#;/#$+\")(\"'#&'#.\" &\"/#$+#)(#'#(\"'#&'#"), C('%2""67.) &2""67/w#;0/n$;/e$$%;B/2#;.# &;/#$+")("\'#&\'#0<*%;B/2#;.# &;/#$+")("\'#&\'#&/#$+$)($\'#(#\'#("\'#&\'#'), C(";.# &;L"), C("%2\"\"67/5#;</,$;/#$+#)(#'#(\"'#&'#"), C("%;D/S#;,/J$2:\"\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#")];
        let u = 0,
            h = 0;
        const g = [{
          line: 1,
          column: 1
        }];
        let p,
            m = 0,
            f = [],
            v = 0;

        if (void 0 !== t.startRule) {
          if (!(t.startRule in a)) throw new Error("Can't start parsing from rule \"" + t.startRule + '".');
          c = a[t.startRule];
        }

        function b() {
          return e.substring(h, u);
        }

        function S() {
          return y(h, u);
        }

        function j(e, t) {
          return {
            type: "literal",
            text: e,
            ignoreCase: t
          };
        }

        function w(e, t, s) {
          return {
            type: "class",
            parts: e,
            inverted: t,
            ignoreCase: s
          };
        }

        function T(t) {
          let s,
              i = g[t];
          if (i) return i;

          for (s = t - 1; !g[s];) s--;

          for (i = {
            line: (i = g[s]).line,
            column: i.column
          }; s < t;) 10 === e.charCodeAt(s) ? (i.line++, i.column = 1) : i.column++, s++;

          return g[t] = i, i;
        }

        function y(e, t) {
          const s = T(e),
                i = T(t);
          return {
            source: n,
            start: {
              offset: e,
              line: s.line,
              column: s.column
            },
            end: {
              offset: t,
              line: i.line,
              column: i.column
            }
          };
        }

        function _(e) {
          u < m || (u > m && (m = u, f = []), f.push(e));
        }

        function R(e, t, s) {
          return new o(o.buildMessage(e, t), e, t, s);
        }

        function C(e) {
          return e.split("").map(e => e.charCodeAt(0) - 32);
        }

        if (t.data = {}, (p = function t(i) {
          const r = l[i];
          let n = 0;
          const o = [];
          let a = r.length;
          const c = [],
                g = [];
          let p;

          for (;;) {
            for (; n < a;) switch (r[n]) {
              case 0:
                g.push(d[r[n + 1]]), n += 2;
                break;

              case 1:
                g.push(void 0), n++;
                break;

              case 2:
                g.push(null), n++;
                break;

              case 3:
                g.push(s), n++;
                break;

              case 4:
                g.push([]), n++;
                break;

              case 5:
                g.push(u), n++;
                break;

              case 6:
                g.pop(), n++;
                break;

              case 7:
                u = g.pop(), n++;
                break;

              case 8:
                g.length -= r[n + 1], n += 2;
                break;

              case 9:
                g.splice(-2, 1), n++;
                break;

              case 10:
                g[g.length - 2].push(g.pop()), n++;
                break;

              case 11:
                g.push(g.splice(g.length - r[n + 1], r[n + 1])), n += 2;
                break;

              case 12:
                g.push(e.substring(g.pop(), u)), n++;
                break;

              case 13:
                c.push(a), o.push(n + 3 + r[n + 1] + r[n + 2]), g[g.length - 1] ? (a = n + 3 + r[n + 1], n += 3) : (a = n + 3 + r[n + 1] + r[n + 2], n += 3 + r[n + 1]);
                break;

              case 14:
                c.push(a), o.push(n + 3 + r[n + 1] + r[n + 2]), g[g.length - 1] === s ? (a = n + 3 + r[n + 1], n += 3) : (a = n + 3 + r[n + 1] + r[n + 2], n += 3 + r[n + 1]);
                break;

              case 15:
                c.push(a), o.push(n + 3 + r[n + 1] + r[n + 2]), g[g.length - 1] !== s ? (a = n + 3 + r[n + 1], n += 3) : (a = n + 3 + r[n + 1] + r[n + 2], n += 3 + r[n + 1]);
                break;

              case 16:
                g[g.length - 1] !== s ? (c.push(a), o.push(n), a = n + 2 + r[n + 1], n += 2) : n += 2 + r[n + 1];
                break;

              case 17:
                c.push(a), o.push(n + 3 + r[n + 1] + r[n + 2]), e.length > u ? (a = n + 3 + r[n + 1], n += 3) : (a = n + 3 + r[n + 1] + r[n + 2], n += 3 + r[n + 1]);
                break;

              case 18:
                c.push(a), o.push(n + 4 + r[n + 2] + r[n + 3]), e.substr(u, d[r[n + 1]].length) === d[r[n + 1]] ? (a = n + 4 + r[n + 2], n += 4) : (a = n + 4 + r[n + 2] + r[n + 3], n += 4 + r[n + 2]);
                break;

              case 19:
                c.push(a), o.push(n + 4 + r[n + 2] + r[n + 3]), e.substr(u, d[r[n + 1]].length).toLowerCase() === d[r[n + 1]] ? (a = n + 4 + r[n + 2], n += 4) : (a = n + 4 + r[n + 2] + r[n + 3], n += 4 + r[n + 2]);
                break;

              case 20:
                c.push(a), o.push(n + 4 + r[n + 2] + r[n + 3]), d[r[n + 1]].test(e.charAt(u)) ? (a = n + 4 + r[n + 2], n += 4) : (a = n + 4 + r[n + 2] + r[n + 3], n += 4 + r[n + 2]);
                break;

              case 21:
                g.push(e.substr(u, r[n + 1])), u += r[n + 1], n += 2;
                break;

              case 22:
                g.push(d[r[n + 1]]), u += d[r[n + 1]].length, n += 2;
                break;

              case 23:
                g.push(s), 0 === v && _(d[r[n + 1]]), n += 2;
                break;

              case 24:
                h = g[g.length - 1 - r[n + 1]], n += 2;
                break;

              case 25:
                h = u, n++;
                break;

              case 26:
                p = r.slice(n + 4, n + 4 + r[n + 3]).map(function (e) {
                  return g[g.length - 1 - e];
                }), g.splice(g.length - r[n + 2], r[n + 2], d[r[n + 1]].apply(null, p)), n += 4 + r[n + 3];
                break;

              case 27:
                g.push(t(r[n + 1])), n += 2;
                break;

              case 28:
                v++, n++;
                break;

              case 29:
                v--, n++;
                break;

              default:
                throw new Error("Invalid opcode: " + r[n] + ".");
            }

            if (!(c.length > 0)) break;
            a = c.pop(), n = o.pop();
          }

          return g[0];
        }(c)) !== s && u === e.length) return p;
        throw p !== s && u < e.length && _({
          type: "end"
        }), R(f, m < e.length ? e.charAt(m) : null, m < e.length ? y(m, m + 1) : y(m, m));
      };
    },
    "./node_modules/sip.js/lib/grammar/uri.js":
    /*!************************************************!*\
      !*** ./node_modules/sip.js/lib/grammar/uri.js ***!
      \************************************************/

    /*! exports provided: URI, equivalentURI */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "URI", function () {
        return r;
      }), s.d(t, "equivalentURI", function () {
        return n;
      });
      var i = s(
      /*! ./parameters.js */
      "./node_modules/sip.js/lib/grammar/parameters.js");

      class r extends i.Parameters {
        constructor(e = "sip", t, s, i, r, n) {
          if (super(r || {}), this.headers = {}, !s) throw new TypeError('missing or invalid "host" parameter');

          for (const e in n) n.hasOwnProperty(e) && this.setHeader(e, n[e]);

          this.raw = {
            scheme: e,
            user: t,
            host: s,
            port: i
          }, this.normal = {
            scheme: e.toLowerCase(),
            user: t,
            host: s.toLowerCase(),
            port: i
          };
        }

        get scheme() {
          return this.normal.scheme;
        }

        set scheme(e) {
          this.raw.scheme = e, this.normal.scheme = e.toLowerCase();
        }

        get user() {
          return this.normal.user;
        }

        set user(e) {
          this.normal.user = this.raw.user = e;
        }

        get host() {
          return this.normal.host;
        }

        set host(e) {
          this.raw.host = e, this.normal.host = e.toLowerCase();
        }

        get aor() {
          return this.normal.user + "@" + this.normal.host;
        }

        get port() {
          return this.normal.port;
        }

        set port(e) {
          this.normal.port = this.raw.port = e;
        }

        setHeader(e, t) {
          this.headers[this.headerize(e)] = t instanceof Array ? t : [t];
        }

        getHeader(e) {
          if (e) return this.headers[this.headerize(e)];
        }

        hasHeader(e) {
          return !!e && !!this.headers.hasOwnProperty(this.headerize(e));
        }

        deleteHeader(e) {
          if (e = this.headerize(e), this.headers.hasOwnProperty(e)) {
            const t = this.headers[e];
            return delete this.headers[e], t;
          }
        }

        clearHeaders() {
          this.headers = {};
        }

        clone() {
          return new r(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
        }

        toRaw() {
          return this._toString(this._raw);
        }

        toString() {
          return this._toString(this._normal);
        }

        get _normal() {
          return this.normal;
        }

        get _raw() {
          return this.raw;
        }

        _toString(e) {
          let t = e.scheme + ":";
          e.scheme.toLowerCase().match("^sips?$") || (t += "//"), e.user && (t += this.escapeUser(e.user) + "@"), t += e.host, (e.port || 0 === e.port) && (t += ":" + e.port);

          for (const e in this.parameters) this.parameters.hasOwnProperty(e) && (t += ";" + e, null !== this.parameters[e] && (t += "=" + this.parameters[e]));

          const s = [];

          for (const e in this.headers) if (this.headers.hasOwnProperty(e)) for (const t in this.headers[e]) this.headers[e].hasOwnProperty(t) && s.push(e + "=" + this.headers[e][t]);

          return s.length > 0 && (t += "?" + s.join("&")), t;
        }

        escapeUser(e) {
          let t;

          try {
            t = decodeURIComponent(e);
          } catch (e) {
            throw e;
          }

          return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%2B/gi, "+").replace(/%3F/gi, "?").replace(/%2F/gi, "/");
        }

        headerize(e) {
          const t = {
            "Call-Id": "Call-ID",
            Cseq: "CSeq",
            "Min-Se": "Min-SE",
            Rack: "RAck",
            Rseq: "RSeq",
            "Www-Authenticate": "WWW-Authenticate"
          },
                s = e.toLowerCase().replace(/_/g, "-").split("-"),
                i = s.length;
          let r = "";

          for (let e = 0; e < i; e++) 0 !== e && (r += "-"), r += s[e].charAt(0).toUpperCase() + s[e].substring(1);

          return t[r] && (r = t[r]), r;
        }

      }

      function n(e, t) {
        if (e.scheme !== t.scheme) return !1;
        if (e.user !== t.user || e.host !== t.host || e.port !== t.port) return !1;
        if (!function (e, t) {
          const s = Object.keys(e.parameters),
                i = Object.keys(t.parameters);
          return !!s.filter(e => i.includes(e)).every(s => e.parameters[s] === t.parameters[s]) && !!["user", "ttl", "method", "transport"].every(s => e.hasParam(s) && t.hasParam(s) || !e.hasParam(s) && !t.hasParam(s)) && !!["maddr"].every(s => e.hasParam(s) && t.hasParam(s) || !e.hasParam(s) && !t.hasParam(s));
        }(e, t)) return !1;
        const s = Object.keys(e.headers),
              i = Object.keys(t.headers);

        if (0 !== s.length || 0 !== i.length) {
          if (s.length !== i.length) return !1;
          const r = s.filter(e => i.includes(e));
          if (r.length !== i.length) return !1;
          if (!r.every(s => e.headers[s].length && t.headers[s].length && e.headers[s][0] === t.headers[s][0])) return !1;
        }

        return !0;
      }
    },
    "./node_modules/sip.js/lib/index.js":
    /*!******************************************!*\
      !*** ./node_modules/sip.js/lib/index.js ***!
      \******************************************/

    /*! exports provided: name, version, ContentTypeUnsupportedError, RequestPendingError, SessionDescriptionHandlerError, SessionTerminatedError, StateTransitionError, Ack, Bye, Cancel, EmitterImpl, Info, Invitation, Inviter, Message, Messager, Notification, PublisherState, Publisher, Referral, RegistererState, Registerer, SessionState, Session, Subscriber, SubscriptionState, Subscription, TransportState, SIPExtension, UserAgentRegisteredOptionTags, UserAgentState, UserAgent, Grammar, NameAddrHeader, Parameters, URI, equivalentURI, Core, Web */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "name", function () {
        return d;
      }), s.d(t, "version", function () {
        return c;
      });
      var i = s(
      /*! ./version.js */
      "./node_modules/sip.js/lib/version.js"),
          r = s(
      /*! ./api/index.js */
      "./node_modules/sip.js/lib/api/index.js");
      s.d(t, "ContentTypeUnsupportedError", function () {
        return r.ContentTypeUnsupportedError;
      }), s.d(t, "RequestPendingError", function () {
        return r.RequestPendingError;
      }), s.d(t, "SessionDescriptionHandlerError", function () {
        return r.SessionDescriptionHandlerError;
      }), s.d(t, "SessionTerminatedError", function () {
        return r.SessionTerminatedError;
      }), s.d(t, "StateTransitionError", function () {
        return r.StateTransitionError;
      }), s.d(t, "Ack", function () {
        return r.Ack;
      }), s.d(t, "Bye", function () {
        return r.Bye;
      }), s.d(t, "Cancel", function () {
        return r.Cancel;
      }), s.d(t, "EmitterImpl", function () {
        return r.EmitterImpl;
      }), s.d(t, "Info", function () {
        return r.Info;
      }), s.d(t, "Invitation", function () {
        return r.Invitation;
      }), s.d(t, "Inviter", function () {
        return r.Inviter;
      }), s.d(t, "Message", function () {
        return r.Message;
      }), s.d(t, "Messager", function () {
        return r.Messager;
      }), s.d(t, "Notification", function () {
        return r.Notification;
      }), s.d(t, "PublisherState", function () {
        return r.PublisherState;
      }), s.d(t, "Publisher", function () {
        return r.Publisher;
      }), s.d(t, "Referral", function () {
        return r.Referral;
      }), s.d(t, "RegistererState", function () {
        return r.RegistererState;
      }), s.d(t, "Registerer", function () {
        return r.Registerer;
      }), s.d(t, "SessionState", function () {
        return r.SessionState;
      }), s.d(t, "Session", function () {
        return r.Session;
      }), s.d(t, "Subscriber", function () {
        return r.Subscriber;
      }), s.d(t, "SubscriptionState", function () {
        return r.SubscriptionState;
      }), s.d(t, "Subscription", function () {
        return r.Subscription;
      }), s.d(t, "TransportState", function () {
        return r.TransportState;
      }), s.d(t, "SIPExtension", function () {
        return r.SIPExtension;
      }), s.d(t, "UserAgentRegisteredOptionTags", function () {
        return r.UserAgentRegisteredOptionTags;
      }), s.d(t, "UserAgentState", function () {
        return r.UserAgentState;
      }), s.d(t, "UserAgent", function () {
        return r.UserAgent;
      });
      var n = s(
      /*! ./grammar/index.js */
      "./node_modules/sip.js/lib/grammar/index.js");
      s.d(t, "Grammar", function () {
        return n.Grammar;
      }), s.d(t, "NameAddrHeader", function () {
        return n.NameAddrHeader;
      }), s.d(t, "Parameters", function () {
        return n.Parameters;
      }), s.d(t, "URI", function () {
        return n.URI;
      }), s.d(t, "equivalentURI", function () {
        return n.equivalentURI;
      });
      var o = s(
      /*! ./core/index.js */
      "./node_modules/sip.js/lib/core/index.js");
      s.d(t, "Core", function () {
        return o;
      });
      var a = s(
      /*! ./platform/web/index.js */
      "./node_modules/sip.js/lib/platform/web/index.js");
      s.d(t, "Web", function () {
        return a;
      });
      const c = i.LIBRARY_VERSION,
            d = "sip.js";
    },
    "./node_modules/sip.js/lib/platform/web/index.js":
    /*!*******************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/index.js ***!
      \*******************************************************/

    /*! exports provided: stripTcpCandidates, stripTelephoneEvent, cleanJitsiSdpImageattr, stripG722, stripRtpPayload, stripVideo, addMidLines, holdModifier, defaultMediaStreamFactory, defaultPeerConnectionConfiguration, defaultSessionDescriptionHandlerFactory, SessionDescriptionHandler, startLocalConference, WebAudioSessionDescriptionHandler, defaultManagedSessionFactory, SessionManager, SimpleUser, Transport */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./modifiers/index.js */
      "./node_modules/sip.js/lib/platform/web/modifiers/index.js");
      s.d(t, "stripTcpCandidates", function () {
        return i.stripTcpCandidates;
      }), s.d(t, "stripTelephoneEvent", function () {
        return i.stripTelephoneEvent;
      }), s.d(t, "cleanJitsiSdpImageattr", function () {
        return i.cleanJitsiSdpImageattr;
      }), s.d(t, "stripG722", function () {
        return i.stripG722;
      }), s.d(t, "stripRtpPayload", function () {
        return i.stripRtpPayload;
      }), s.d(t, "stripVideo", function () {
        return i.stripVideo;
      }), s.d(t, "addMidLines", function () {
        return i.addMidLines;
      }), s.d(t, "holdModifier", function () {
        return i.holdModifier;
      });
      var r = s(
      /*! ./session-description-handler/index.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/index.js");
      s.d(t, "defaultMediaStreamFactory", function () {
        return r.defaultMediaStreamFactory;
      }), s.d(t, "defaultPeerConnectionConfiguration", function () {
        return r.defaultPeerConnectionConfiguration;
      }), s.d(t, "defaultSessionDescriptionHandlerFactory", function () {
        return r.defaultSessionDescriptionHandlerFactory;
      }), s.d(t, "SessionDescriptionHandler", function () {
        return r.SessionDescriptionHandler;
      }), s.d(t, "startLocalConference", function () {
        return r.startLocalConference;
      }), s.d(t, "WebAudioSessionDescriptionHandler", function () {
        return r.WebAudioSessionDescriptionHandler;
      });
      var n = s(
      /*! ./session-manager/index.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/index.js");
      s.d(t, "defaultManagedSessionFactory", function () {
        return n.defaultManagedSessionFactory;
      }), s.d(t, "SessionManager", function () {
        return n.SessionManager;
      });
      var o = s(
      /*! ./simple-user/index.js */
      "./node_modules/sip.js/lib/platform/web/simple-user/index.js");
      s.d(t, "SimpleUser", function () {
        return o.SimpleUser;
      });
      var a = s(
      /*! ./transport/index.js */
      "./node_modules/sip.js/lib/platform/web/transport/index.js");
      s.d(t, "Transport", function () {
        return a.Transport;
      });
    },
    "./node_modules/sip.js/lib/platform/web/modifiers/index.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/modifiers/index.js ***!
      \*****************************************************************/

    /*! exports provided: stripTcpCandidates, stripTelephoneEvent, cleanJitsiSdpImageattr, stripG722, stripRtpPayload, stripVideo, addMidLines, holdModifier */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./modifiers.js */
      "./node_modules/sip.js/lib/platform/web/modifiers/modifiers.js");
      s.d(t, "stripTcpCandidates", function () {
        return i.stripTcpCandidates;
      }), s.d(t, "stripTelephoneEvent", function () {
        return i.stripTelephoneEvent;
      }), s.d(t, "cleanJitsiSdpImageattr", function () {
        return i.cleanJitsiSdpImageattr;
      }), s.d(t, "stripG722", function () {
        return i.stripG722;
      }), s.d(t, "stripRtpPayload", function () {
        return i.stripRtpPayload;
      }), s.d(t, "stripVideo", function () {
        return i.stripVideo;
      }), s.d(t, "addMidLines", function () {
        return i.addMidLines;
      }), s.d(t, "holdModifier", function () {
        return i.holdModifier;
      });
    },
    "./node_modules/sip.js/lib/platform/web/modifiers/modifiers.js":
    /*!*********************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/modifiers/modifiers.js ***!
      \*********************************************************************/

    /*! exports provided: stripTcpCandidates, stripTelephoneEvent, cleanJitsiSdpImageattr, stripG722, stripRtpPayload, stripVideo, addMidLines, holdModifier */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "stripTcpCandidates", function () {
        return n;
      }), s.d(t, "stripTelephoneEvent", function () {
        return o;
      }), s.d(t, "cleanJitsiSdpImageattr", function () {
        return a;
      }), s.d(t, "stripG722", function () {
        return c;
      }), s.d(t, "stripRtpPayload", function () {
        return d;
      }), s.d(t, "stripVideo", function () {
        return l;
      }), s.d(t, "addMidLines", function () {
        return u;
      }), s.d(t, "holdModifier", function () {
        return h;
      });

      const i = (e, t) => {
        const s = [],
              i = e.split(/\r\n/);
        let r;

        for (let e = 0; e < i.length;) {
          const n = i[e];
          if (/^m=(?:audio|video)/.test(n)) r = {
            index: e,
            stripped: []
          }, s.push(r);else if (r) {
            const s = /^a=rtpmap:(\d+) ([^/]+)\//.exec(n);

            if (s && t === s[2]) {
              i.splice(e, 1), r.stripped.push(s[1]);
              continue;
            }
          }
          e++;
        }

        for (const e of s) {
          const t = i[e.index].split(" ");

          for (let s = 3; s < t.length;) -1 === e.stripped.indexOf(t[s]) ? s++ : t.splice(s, 1);

          i[e.index] = t.join(" ");
        }

        return i.join("\r\n");
      },
            r = (e, t) => {
        const s = new RegExp("m=" + t + ".*$", "gm"),
              i = new RegExp("^a=group:.*$", "gm");

        if (s.test(e)) {
          let s;
          const r = (e = e.split(/^m=/gm).filter(e => {
            if (e.substr(0, t.length) === t) {
              if (s = e.match(/^a=mid:.*$/gm)) {
                const e = s[0].match(/:.+$/g);
                e && (s = e[0].substr(1));
              }

              return !1;
            }

            return !0;
          }).join("m=")).match(i);

          if (r && 1 === r.length) {
            let t = r[0];
            const n = new RegExp(" *" + s + "[^ ]*", "g");
            t = t.replace(n, ""), e = e.split(i).join(t);
          }
        }

        return e;
      };

      function n(e) {
        return e.sdp = (e.sdp || "").replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/gim, ""), Promise.resolve(e);
      }

      function o(e) {
        return e.sdp = i(e.sdp || "", "telephone-event"), Promise.resolve(e);
      }

      function a(e) {
        return e.sdp = (e.sdp || "").replace(/^(a=imageattr:.*?)(x|y)=\[0-/gm, "$1$2=[1:"), Promise.resolve(e);
      }

      function c(e) {
        return e.sdp = i(e.sdp || "", "G722"), Promise.resolve(e);
      }

      function d(e) {
        return t => (t.sdp = i(t.sdp || "", e), Promise.resolve(t));
      }

      function l(e) {
        return e.sdp = r(e.sdp || "", "video"), Promise.resolve(e);
      }

      function u(e) {
        let t = e.sdp || "";

        if (-1 === t.search(/^a=mid.*$/gm)) {
          const s = t.match(/^m=.*$/gm),
                i = t.split(/^m=.*$/gm);
          s && s.forEach((e, t) => {
            s[t] = e + "\na=mid:" + t;
          }), i.forEach((e, t) => {
            s && s[t] && (i[t] = e + s[t]);
          }), t = i.join(""), e.sdp = t;
        }

        return Promise.resolve(e);
      }

      function h(e) {
        if (!e.sdp || !e.type) throw new Error("Invalid SDP");
        let t = e.sdp;
        const s = e.type;
        return t && (t = /a=(sendrecv|sendonly|recvonly|inactive)/.test(t) ? (t = t.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n")).replace(/a=recvonly\r\n/g, "a=inactive\r\n") : t.replace(/(m=[^\r]*\r\n)/g, "$1a=sendonly\r\n")), Promise.resolve({
          sdp: t,
          type: s
        });
      }
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/index.js":
    /*!***********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/index.js ***!
      \***********************************************************************************/

    /*! exports provided: defaultMediaStreamFactory, defaultPeerConnectionConfiguration, defaultSessionDescriptionHandlerFactory, SessionDescriptionHandler, startLocalConference, WebAudioSessionDescriptionHandler */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./media-stream-factory-default.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js");
      s.d(t, "defaultMediaStreamFactory", function () {
        return i.defaultMediaStreamFactory;
      });
      s(
      /*! ./media-stream-factory.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory.js");
      var r = s(
      /*! ./peer-connection-configuration-default.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js");
      s.d(t, "defaultPeerConnectionConfiguration", function () {
        return r.defaultPeerConnectionConfiguration;
      });
      s(
      /*! ./peer-connection-delegate.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-delegate.js"), s(
      /*! ./session-description-handler-configuration.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-configuration.js");
      var n = s(
      /*! ./session-description-handler-factory-default.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-default.js");
      s.d(t, "defaultSessionDescriptionHandlerFactory", function () {
        return n.defaultSessionDescriptionHandlerFactory;
      });
      s(
      /*! ./session-description-handler-factory-options.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-options.js"), s(
      /*! ./session-description-handler-factory.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory.js"), s(
      /*! ./session-description-handler-options.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-options.js");
      var o = s(
      /*! ./session-description-handler.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js");
      s.d(t, "SessionDescriptionHandler", function () {
        return o.SessionDescriptionHandler;
      });
      var a = s(
      /*! ./web-audio-session-description-handler.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/web-audio-session-description-handler.js");
      s.d(t, "startLocalConference", function () {
        return a.startLocalConference;
      }), s.d(t, "WebAudioSessionDescriptionHandler", function () {
        return a.WebAudioSessionDescriptionHandler;
      });
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js":
    /*!**********************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js ***!
      \**********************************************************************************************************/

    /*! exports provided: defaultMediaStreamFactory */
    function (e, t, s) {
      "use strict";

      function i() {
        return e => e.audio || e.video ? void 0 === navigator.mediaDevices ? Promise.reject(new Error("Media devices not available in insecure contexts.")) : navigator.mediaDevices.getUserMedia.call(navigator.mediaDevices, e) : Promise.resolve(new MediaStream());
      }

      s.r(t), s.d(t, "defaultMediaStreamFactory", function () {
        return i;
      });
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory.js":
    /*!**************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory.js ***!
      \**************************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js":
    /*!*******************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js ***!
      \*******************************************************************************************************************/

    /*! exports provided: defaultPeerConnectionConfiguration */
    function (e, t, s) {
      "use strict";

      function i() {
        return {
          bundlePolicy: "balanced",
          certificates: void 0,
          iceCandidatePoolSize: 0,
          iceServers: [{
            urls: "stun:stun.l.google.com:19302"
          }],
          iceTransportPolicy: "all",
          rtcpMuxPolicy: "require"
        };
      }

      s.r(t), s.d(t, "defaultPeerConnectionConfiguration", function () {
        return i;
      });
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-delegate.js":
    /*!******************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-delegate.js ***!
      \******************************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-configuration.js":
    /*!***********************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-configuration.js ***!
      \***********************************************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-default.js":
    /*!*************************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-default.js ***!
      \*************************************************************************************************************************/

    /*! exports provided: defaultSessionDescriptionHandlerFactory */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "defaultSessionDescriptionHandlerFactory", function () {
        return o;
      });
      var i = s(
      /*! ./media-stream-factory-default.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js"),
          r = s(
      /*! ./peer-connection-configuration-default.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js"),
          n = s(
      /*! ./session-description-handler.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js");

      function o(e) {
        return (t, s) => {
          void 0 === e && (e = Object(i.defaultMediaStreamFactory)());
          const o = {
            iceGatheringTimeout: void 0 !== (null == s ? void 0 : s.iceGatheringTimeout) ? null == s ? void 0 : s.iceGatheringTimeout : 5e3,
            peerConnectionConfiguration: Object.assign(Object.assign({}, Object(r.defaultPeerConnectionConfiguration)()), null == s ? void 0 : s.peerConnectionConfiguration)
          },
                a = t.userAgent.getLogger("sip.SessionDescriptionHandler");
          return new n.SessionDescriptionHandler(a, e, o);
        };
      }
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-options.js":
    /*!*************************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-options.js ***!
      \*************************************************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory.js":
    /*!*****************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory.js ***!
      \*****************************************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-options.js":
    /*!*****************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-options.js ***!
      \*****************************************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js":
    /*!*********************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js ***!
      \*********************************************************************************************************/

    /*! exports provided: SessionDescriptionHandler */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SessionDescriptionHandler", function () {
        return i;
      });

      class i {
        constructor(e, t, s) {
          e.debug("SessionDescriptionHandler.constructor"), this.logger = e, this.mediaStreamFactory = t, this.sessionDescriptionHandlerConfiguration = s, this._localMediaStream = new MediaStream(), this._remoteMediaStream = new MediaStream(), this._peerConnection = new RTCPeerConnection(null == s ? void 0 : s.peerConnectionConfiguration), this.initPeerConnectionEventHandlers();
        }

        get localMediaStream() {
          return this._localMediaStream;
        }

        get remoteMediaStream() {
          return this._remoteMediaStream;
        }

        get dataChannel() {
          return this._dataChannel;
        }

        get peerConnection() {
          return this._peerConnection;
        }

        get peerConnectionDelegate() {
          return this._peerConnectionDelegate;
        }

        set peerConnectionDelegate(e) {
          this._peerConnectionDelegate = e;
        }

        static dispatchAddTrackEvent(e, t) {
          e.dispatchEvent(new MediaStreamTrackEvent("addtrack", {
            track: t
          }));
        }

        static dispatchRemoveTrackEvent(e, t) {
          e.dispatchEvent(new MediaStreamTrackEvent("removetrack", {
            track: t
          }));
        }

        close() {
          this.logger.debug("SessionDescriptionHandler.close"), void 0 !== this._peerConnection && (this._peerConnection.getReceivers().forEach(e => {
            e.track && e.track.stop();
          }), this._peerConnection.getSenders().forEach(e => {
            e.track && e.track.stop();
          }), this._dataChannel && this._dataChannel.close(), this._peerConnection.close(), this._peerConnection = void 0);
        }

        enableReceiverTracks(e) {
          const t = this.peerConnection;
          if (!t) throw new Error("Peer connection closed.");
          t.getReceivers().forEach(t => {
            t.track && (t.track.enabled = e);
          });
        }

        enableSenderTracks(e) {
          const t = this.peerConnection;
          if (!t) throw new Error("Peer connection closed.");
          t.getSenders().forEach(t => {
            t.track && (t.track.enabled = e);
          });
        }

        getDescription(e, t) {
          var s, i;
          if (this.logger.debug("SessionDescriptionHandler.getDescription"), void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));
          this.onDataChannel = null == e ? void 0 : e.onDataChannel;
          const r = null === (s = null == e ? void 0 : e.offerOptions) || void 0 === s ? void 0 : s.iceRestart,
                n = void 0 === (null == e ? void 0 : e.iceGatheringTimeout) ? null === (i = this.sessionDescriptionHandlerConfiguration) || void 0 === i ? void 0 : i.iceGatheringTimeout : null == e ? void 0 : e.iceGatheringTimeout;
          return this.getLocalMediaStream(e).then(() => this.updateDirection(e)).then(() => this.createDataChannel(e)).then(() => this.createLocalOfferOrAnswer(e)).then(e => this.applyModifiers(e, t)).then(e => this.setLocalSessionDescription(e)).then(() => this.waitForIceGatheringComplete(r, n)).then(() => this.getLocalSessionDescription()).then(e => ({
            body: e.sdp,
            contentType: "application/sdp"
          })).catch(e => {
            throw this.logger.error("SessionDescriptionHandler.getDescription failed - " + e), e;
          });
        }

        hasDescription(e) {
          return this.logger.debug("SessionDescriptionHandler.hasDescription"), "application/sdp" === e;
        }

        iceGatheringComplete() {
          this.logger.debug("SessionDescriptionHandler.iceGatheringComplete"), void 0 !== this.iceGatheringCompleteTimeoutId && (this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - clearing timeout"), clearTimeout(this.iceGatheringCompleteTimeoutId), this.iceGatheringCompleteTimeoutId = void 0), void 0 !== this.iceGatheringCompletePromise && (this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - resolving promise"), this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve(), this.iceGatheringCompletePromise = void 0, this.iceGatheringCompleteResolve = void 0, this.iceGatheringCompleteReject = void 0);
        }

        sendDtmf(e, t) {
          if (this.logger.debug("SessionDescriptionHandler.sendDtmf"), void 0 === this._peerConnection) return this.logger.error("SessionDescriptionHandler.sendDtmf failed - peer connection closed"), !1;

          const s = this._peerConnection.getSenders();

          if (0 === s.length) return this.logger.error("SessionDescriptionHandler.sendDtmf failed - no senders"), !1;
          const i = s[0].dtmf;
          if (!i) return this.logger.error("SessionDescriptionHandler.sendDtmf failed - no DTMF sender"), !1;
          const r = null == t ? void 0 : t.duration,
                n = null == t ? void 0 : t.interToneGap;

          try {
            i.insertDTMF(e, r, n);
          } catch (e) {
            return this.logger.error(e.toString()), !1;
          }

          return this.logger.log("SessionDescriptionHandler.sendDtmf sent via RTP: " + e.toString()), !0;
        }

        setDescription(e, t, s) {
          if (this.logger.debug("SessionDescriptionHandler.setDescription"), void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));
          this.onDataChannel = null == t ? void 0 : t.onDataChannel;
          const i = "have-local-offer" === this._peerConnection.signalingState ? "answer" : "offer";
          return this.getLocalMediaStream(t).then(() => this.applyModifiers({
            sdp: e,
            type: i
          }, s)).then(e => this.setRemoteSessionDescription(e)).catch(e => {
            throw this.logger.error("SessionDescriptionHandler.setDescription failed - " + e), e;
          });
        }

        applyModifiers(e, t) {
          return this.logger.debug("SessionDescriptionHandler.applyModifiers"), t && 0 !== t.length ? t.reduce((e, t) => e.then(t), Promise.resolve(e)).then(e => {
            if (this.logger.debug("SessionDescriptionHandler.applyModifiers - modified sdp"), !e.sdp || !e.type) throw new Error("Invalid SDP.");
            return {
              sdp: e.sdp,
              type: e.type
            };
          }) : Promise.resolve(e);
        }

        createDataChannel(e) {
          if (void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));
          if (!0 !== (null == e ? void 0 : e.dataChannel)) return Promise.resolve();
          if (this._dataChannel) return Promise.resolve();

          switch (this._peerConnection.signalingState) {
            case "stable":
              this.logger.debug("SessionDescriptionHandler.createDataChannel - creating data channel");

              try {
                return this._dataChannel = this._peerConnection.createDataChannel((null == e ? void 0 : e.dataChannelLabel) || "", null == e ? void 0 : e.dataChannelOptions), this.onDataChannel && this.onDataChannel(this._dataChannel), Promise.resolve();
              } catch (e) {
                return Promise.reject(e);
              }

            case "have-remote-offer":
              return Promise.resolve();

            case "have-local-offer":
            case "have-local-pranswer":
            case "have-remote-pranswer":
            case "closed":
            default:
              return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
          }
        }

        createLocalOfferOrAnswer(e) {
          if (void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));

          switch (this._peerConnection.signalingState) {
            case "stable":
              return this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer"), this._peerConnection.createOffer(null == e ? void 0 : e.offerOptions);

            case "have-remote-offer":
              return this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer"), this._peerConnection.createAnswer(null == e ? void 0 : e.answerOptions);

            case "have-local-offer":
            case "have-local-pranswer":
            case "have-remote-pranswer":
            case "closed":
            default:
              return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
          }
        }

        getLocalMediaStream(e) {
          if (this.logger.debug("SessionDescriptionHandler.getLocalMediaStream"), void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));
          let t = Object.assign({}, null == e ? void 0 : e.constraints);

          if (this.localMediaStreamConstraints) {
            if (t.audio = t.audio || this.localMediaStreamConstraints.audio, t.video = t.video || this.localMediaStreamConstraints.video, JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(t.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(t.video)) return Promise.resolve();
          } else void 0 === t.audio && void 0 === t.video && (t = {
            audio: !0
          });

          return this.localMediaStreamConstraints = t, this.mediaStreamFactory(t, this, e).then(e => this.setLocalMediaStream(e));
        }

        setLocalMediaStream(e) {
          if (this.logger.debug("SessionDescriptionHandler.setLocalMediaStream"), !this._peerConnection) throw new Error("Peer connection undefined.");

          const t = this._peerConnection,
                s = this._localMediaStream,
                r = [],
                n = e => {
            const n = e.kind;
            if ("audio" !== n && "video" !== n) throw new Error(`Unknown new track kind ${n}.`);
            const o = t.getSenders().find(e => e.track && e.track.kind === n);
            o ? r.push(new Promise(e => {
              this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${n} track`), e();
            }).then(() => o.replaceTrack(e).then(() => {
              const t = s.getTracks().find(e => e.kind === n);
              t && (t.stop(), s.removeTrack(t), i.dispatchRemoveTrackEvent(s, t)), s.addTrack(e), i.dispatchAddTrackEvent(s, e);
            }).catch(e => {
              throw this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${n} track`), e;
            }))) : r.push(new Promise(e => {
              this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${n} track`), e();
            }).then(() => {
              try {
                t.addTrack(e, s);
              } catch (e) {
                throw this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${n} track`), e;
              }

              s.addTrack(e), i.dispatchAddTrackEvent(s, e);
            }));
          },
                o = e.getAudioTracks();

          o.length && n(o[0]);
          const a = e.getVideoTracks();
          return a.length && n(a[0]), r.reduce((e, t) => e.then(() => t), Promise.resolve());
        }

        getLocalSessionDescription() {
          if (this.logger.debug("SessionDescriptionHandler.getLocalSessionDescription"), void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));
          const e = this._peerConnection.localDescription;
          return e ? Promise.resolve(e) : Promise.reject(new Error("Failed to get local session description"));
        }

        setLocalSessionDescription(e) {
          return this.logger.debug("SessionDescriptionHandler.setLocalSessionDescription"), void 0 === this._peerConnection ? Promise.reject(new Error("Peer connection closed.")) : this._peerConnection.setLocalDescription(e);
        }

        setRemoteSessionDescription(e) {
          if (this.logger.debug("SessionDescriptionHandler.setRemoteSessionDescription"), void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));
          const t = e.sdp;
          let s;

          switch (this._peerConnection.signalingState) {
            case "stable":
              s = "offer";
              break;

            case "have-local-offer":
              s = "answer";
              break;

            case "have-local-pranswer":
            case "have-remote-offer":
            case "have-remote-pranswer":
            case "closed":
            default:
              return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
          }

          return t ? this._peerConnection.setRemoteDescription({
            sdp: t,
            type: s
          }) : (this.logger.error("SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp"), Promise.reject(new Error("SDP is undefined")));
        }

        setRemoteTrack(e) {
          this.logger.debug("SessionDescriptionHandler.setRemoteTrack");
          const t = this._remoteMediaStream;
          t.getTrackById(e.id) ? this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${e.kind} track`) : "audio" === e.kind ? (this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${e.kind} track`), t.getAudioTracks().forEach(e => {
            e.stop(), t.removeTrack(e), i.dispatchRemoveTrackEvent(t, e);
          }), t.addTrack(e), i.dispatchAddTrackEvent(t, e)) : "video" === e.kind && (this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${e.kind} track`), t.getVideoTracks().forEach(e => {
            e.stop(), t.removeTrack(e), i.dispatchRemoveTrackEvent(t, e);
          }), t.addTrack(e), i.dispatchAddTrackEvent(t, e));
        }

        updateDirection(e) {
          if (void 0 === this._peerConnection) return Promise.reject(new Error("Peer connection closed."));

          switch (this._peerConnection.signalingState) {
            case "stable":
              this.logger.debug("SessionDescriptionHandler.updateDirection - setting offer direction");
              {
                const t = t => {
                  switch (t) {
                    case "inactive":
                    case "recvonly":
                      return (null == e ? void 0 : e.hold) ? "inactive" : "recvonly";

                    case "sendonly":
                    case "sendrecv":
                      return (null == e ? void 0 : e.hold) ? "sendonly" : "sendrecv";

                    case "stopped":
                      return "stopped";

                    default:
                      throw new Error("Should never happen");
                  }
                };

                this._peerConnection.getTransceivers().forEach(e => {
                  if (e.direction) {
                    const s = t(e.direction);
                    e.direction !== s && (e.direction = s);
                  }
                });
              }
              break;

            case "have-remote-offer":
              this.logger.debug("SessionDescriptionHandler.updateDirection - setting answer direction");
              {
                const t = (() => {
                  const e = this._peerConnection.remoteDescription;
                  if (!e) throw new Error("Failed to read remote offer");
                  const t = /a=sendrecv\r\n|a=sendonly\r\n|a=recvonly\r\n|a=inactive\r\n/.exec(e.sdp);
                  if (t) switch (t[0]) {
                    case "a=inactive\r\n":
                      return "inactive";

                    case "a=recvonly\r\n":
                      return "recvonly";

                    case "a=sendonly\r\n":
                      return "sendonly";

                    case "a=sendrecv\r\n":
                      return "sendrecv";

                    default:
                      throw new Error("Should never happen");
                  }
                  return "sendrecv";
                })(),
                      s = (() => {
                  switch (t) {
                    case "inactive":
                      return "inactive";

                    case "recvonly":
                      return "sendonly";

                    case "sendonly":
                      return (null == e ? void 0 : e.hold) ? "inactive" : "recvonly";

                    case "sendrecv":
                      return (null == e ? void 0 : e.hold) ? "sendonly" : "sendrecv";

                    default:
                      throw new Error("Should never happen");
                  }
                })();

                this._peerConnection.getTransceivers().forEach(e => {
                  e.direction && "stopped" !== e.direction && e.direction !== s && (e.direction = s);
                });
              }
              break;

            case "have-local-offer":
            case "have-local-pranswer":
            case "have-remote-pranswer":
            case "closed":
            default:
              return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
          }

          return Promise.resolve();
        }

        waitForIceGatheringComplete(e = !1, t = 0) {
          return this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete"), void 0 === this._peerConnection ? Promise.reject("Peer connection closed.") : e || "complete" !== this._peerConnection.iceGatheringState ? (void 0 !== this.iceGatheringCompletePromise && (this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise"), this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error("Promise superseded.")), this.iceGatheringCompletePromise = void 0, this.iceGatheringCompleteResolve = void 0, this.iceGatheringCompleteReject = void 0), this.iceGatheringCompletePromise = new Promise((e, s) => {
            this.iceGatheringCompleteResolve = e, this.iceGatheringCompleteReject = s, t > 0 && (this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in " + t), this.iceGatheringCompleteTimeoutId = setTimeout(() => {
              this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout"), this.iceGatheringComplete();
            }, t));
          }), this.iceGatheringCompletePromise) : (this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - already complete"), Promise.resolve());
        }

        initPeerConnectionEventHandlers() {
          if (this.logger.debug("SessionDescriptionHandler.initPeerConnectionEventHandlers"), !this._peerConnection) throw new Error("Peer connection undefined.");
          const e = this._peerConnection;
          e.onconnectionstatechange = t => {
            var s;
            const i = e.connectionState;
            this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${i}`), (null === (s = this._peerConnectionDelegate) || void 0 === s ? void 0 : s.onconnectionstatechange) && this._peerConnectionDelegate.onconnectionstatechange(t);
          }, e.ondatachannel = e => {
            var t;
            this.logger.debug("SessionDescriptionHandler.ondatachannel"), this._dataChannel = e.channel, this.onDataChannel && this.onDataChannel(this._dataChannel), (null === (t = this._peerConnectionDelegate) || void 0 === t ? void 0 : t.ondatachannel) && this._peerConnectionDelegate.ondatachannel(e);
          }, e.onicecandidate = e => {
            var t;
            this.logger.debug("SessionDescriptionHandler.onicecandidate"), (null === (t = this._peerConnectionDelegate) || void 0 === t ? void 0 : t.onicecandidate) && this._peerConnectionDelegate.onicecandidate(e);
          }, e.onicecandidateerror = e => {
            var t;
            this.logger.debug("SessionDescriptionHandler.onicecandidateerror"), (null === (t = this._peerConnectionDelegate) || void 0 === t ? void 0 : t.onicecandidateerror) && this._peerConnectionDelegate.onicecandidateerror(e);
          }, e.oniceconnectionstatechange = t => {
            var s;
            const i = e.iceConnectionState;
            this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${i}`), (null === (s = this._peerConnectionDelegate) || void 0 === s ? void 0 : s.oniceconnectionstatechange) && this._peerConnectionDelegate.oniceconnectionstatechange(t);
          }, e.onicegatheringstatechange = t => {
            var s;
            const i = e.iceGatheringState;
            this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${i}`), "complete" === i && this.iceGatheringComplete(), (null === (s = this._peerConnectionDelegate) || void 0 === s ? void 0 : s.onicegatheringstatechange) && this._peerConnectionDelegate.onicegatheringstatechange(t);
          }, e.onnegotiationneeded = e => {
            var t;
            this.logger.debug("SessionDescriptionHandler.onnegotiationneeded"), (null === (t = this._peerConnectionDelegate) || void 0 === t ? void 0 : t.onnegotiationneeded) && this._peerConnectionDelegate.onnegotiationneeded(e);
          }, e.onsignalingstatechange = t => {
            var s;
            const i = e.signalingState;
            this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${i}`), (null === (s = this._peerConnectionDelegate) || void 0 === s ? void 0 : s.onsignalingstatechange) && this._peerConnectionDelegate.onsignalingstatechange(t);
          }, e.ontrack = e => {
            var t;
            const s = e.track.kind,
                  i = e.track.enabled ? "enabled" : "disabled";
            this.logger.debug(`SessionDescriptionHandler.ontrack ${s} ${i}`), this.setRemoteTrack(e.track), (null === (t = this._peerConnectionDelegate) || void 0 === t ? void 0 : t.ontrack) && this._peerConnectionDelegate.ontrack(e);
          };
        }

      }
    },
    "./node_modules/sip.js/lib/platform/web/session-description-handler/web-audio-session-description-handler.js":
    /*!*******************************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-description-handler/web-audio-session-description-handler.js ***!
      \*******************************************************************************************************************/

    /*! exports provided: startLocalConference, WebAudioSessionDescriptionHandler */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "startLocalConference", function () {
        return r;
      }), s.d(t, "WebAudioSessionDescriptionHandler", function () {
        return n;
      });
      var i = s(
      /*! ./session-description-handler.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js");

      function r(e) {
        if (e.length < 2) throw new Error("Start local conference requires at leaast 2 sessions.");
        (e => e.map((t, s) => e.slice(s + 1).map(e => [t, e])).reduce((e, t) => e.concat(t), []))(e.map(e => e.sessionDescriptionHandler)).forEach(([e, t]) => {
          if (!(e instanceof n && t instanceof n)) throw new Error("Session description handler not instance of SessionManagerSessionDescriptionHandler");
          e.joinWith(t);
        });
      }

      class n extends i.SessionDescriptionHandler {
        constructor(e, t, s) {
          super(e, t, s), n.audioContext || (n.audioContext = new AudioContext());
        }

        enableSenderTracks(e) {
          const t = this.localMediaStreamReal;
          if (void 0 === t) throw new Error("Stream undefined.");
          t.getAudioTracks().forEach(t => {
            t.enabled = e;
          });
        }

        initLocalMediaStream(e) {
          if (!n.audioContext) throw new Error("SessionManagerSessionDescriptionHandler.audioContext undefined.");
          return this.localMediaStreamReal = e, this.localMediaStreamSourceNode = n.audioContext.createMediaStreamSource(e), this.localMediaStreamDestinationNode = n.audioContext.createMediaStreamDestination(), this.localMediaStreamSourceNode.connect(this.localMediaStreamDestinationNode), this.localMediaStreamDestinationNode.stream;
        }

        joinWith(e) {
          if (!n.audioContext) throw new Error("SessionManagerSessionDescriptionHandler.audioContext undefined.");
          const t = n.audioContext.createMediaStreamSource(this.remoteMediaStream),
                s = e.localMediaStreamDestinationNode;
          if (void 0 === s) throw new Error("Peer outbound (local) stream local media stream destination is undefined.");
          t.connect(s);
          const i = n.audioContext.createMediaStreamSource(e.remoteMediaStream),
                r = this.localMediaStreamDestinationNode;
          if (void 0 === r) throw new Error("Our outbound (local) stream local media stream destination is undefined.");
          i.connect(r);
        }

        setRealLocalMediaStream(e) {
          if (!n.audioContext) throw new Error("SessionManagerSessionDescriptionHandler.audioContext undefined.");

          if (this.localMediaStreamReal) {
            if (!this.localMediaStreamDestinationNode || !this.localMediaStreamSourceNode || !this.localMediaStreamReal) throw new Error("Local media stream undefined.");
            this.localMediaStreamReal = e, this.localMediaStreamSourceNode.disconnect(this.localMediaStreamDestinationNode), this.localMediaStreamSourceNode = n.audioContext.createMediaStreamSource(e), this.localMediaStreamSourceNode.connect(this.localMediaStreamDestinationNode);
          } else this.initLocalMediaStream(e);
        }

      }
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/index.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/index.js ***!
      \***********************************************************************/

    /*! exports provided: defaultManagedSessionFactory, SessionManager */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./managed-session-factory-default.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory-default.js");
      s.d(t, "defaultManagedSessionFactory", function () {
        return i.defaultManagedSessionFactory;
      });
      s(
      /*! ./managed-session-factory.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory.js"), s(
      /*! ./managed-session.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/managed-session.js"), s(
      /*! ./session-manager-delegate.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/session-manager-delegate.js"), s(
      /*! ./session-manager-options.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/session-manager-options.js");
      var r = s(
      /*! ./session-manager.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/session-manager.js");
      s.d(t, "SessionManager", function () {
        return r.SessionManager;
      });
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory-default.js":
    /*!*************************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory-default.js ***!
      \*************************************************************************************************/

    /*! exports provided: defaultManagedSessionFactory */
    function (e, t, s) {
      "use strict";

      function i() {
        return (e, t) => ({
          session: t,
          held: !1,
          muted: !1
        });
      }

      s.r(t), s.d(t, "defaultManagedSessionFactory", function () {
        return i;
      });
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory.js":
    /*!*****************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory.js ***!
      \*****************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/managed-session.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/managed-session.js ***!
      \*********************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/session-manager-delegate.js":
    /*!******************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/session-manager-delegate.js ***!
      \******************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/session-manager-options.js":
    /*!*****************************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/session-manager-options.js ***!
      \*****************************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/session-manager/session-manager.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/session-manager/session-manager.js ***!
      \*********************************************************************************/

    /*! exports provided: SessionManager */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SessionManager", function () {
        return f;
      });
      var i = s(
      /*! ../../../api/invitation.js */
      "./node_modules/sip.js/lib/api/invitation.js"),
          r = s(
      /*! ../../../api/inviter.js */
      "./node_modules/sip.js/lib/api/inviter.js"),
          n = s(
      /*! ../../../api/messager.js */
      "./node_modules/sip.js/lib/api/messager.js"),
          o = s(
      /*! ../../../api/registerer.js */
      "./node_modules/sip.js/lib/api/registerer.js"),
          a = s(
      /*! ../../../api/registerer-state.js */
      "./node_modules/sip.js/lib/api/registerer-state.js"),
          c = s(
      /*! ../../../api/exceptions/request-pending.js */
      "./node_modules/sip.js/lib/api/exceptions/request-pending.js"),
          d = s(
      /*! ../../../api/session.js */
      "./node_modules/sip.js/lib/api/session.js"),
          l = s(
      /*! ../../../api/session-state.js */
      "./node_modules/sip.js/lib/api/session-state.js"),
          u = s(
      /*! ../../../api/user-agent.js */
      "./node_modules/sip.js/lib/api/user-agent.js"),
          h = s(
      /*! ../../../api/user-agent-state.js */
      "./node_modules/sip.js/lib/api/user-agent-state.js"),
          g = s(
      /*! ../session-description-handler/session-description-handler.js */
      "./node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js"),
          p = s(
      /*! ../transport/transport.js */
      "./node_modules/sip.js/lib/platform/web/transport/transport.js"),
          m = s(
      /*! ./managed-session-factory-default.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/managed-session-factory-default.js");

      class f {
        constructor(e, t = {}) {
          this.managedSessions = [], this.attemptingReconnection = !1, this.optionsPingFailure = !1, this.optionsPingRunning = !1, this.shouldBeConnected = !1, this.shouldBeRegistered = !1, this.delegate = t.delegate, this.options = Object.assign({
            aor: "",
            autoStop: !0,
            delegate: {},
            iceStopWaitingOnServerReflexive: !1,
            managedSessionFactory: Object(m.defaultManagedSessionFactory)(),
            maxSimultaneousSessions: 2,
            media: {},
            optionsPingInterval: -1,
            optionsPingRequestURI: "",
            reconnectionAttempts: 3,
            reconnectionDelay: 4,
            registrationRetry: !1,
            registrationRetryInterval: 3,
            registerGuard: null,
            registererOptions: {},
            registererRegisterOptions: {},
            sendDTMFUsingSessionDescriptionHandler: !1,
            userAgentOptions: {}
          }, f.stripUndefinedProperties(t));
          const s = Object.assign({}, t.userAgentOptions);

          if (s.transportConstructor || (s.transportConstructor = p.Transport), s.transportOptions || (s.transportOptions = {
            server: e
          }), !s.uri && t.aor) {
            const e = u.UserAgent.makeURI(t.aor);
            if (!e) throw new Error(`Failed to create valid URI from ${t.aor}`);
            s.uri = e;
          }

          if (this.userAgent = new u.UserAgent(s), this.userAgent.delegate = {
            onConnect: () => {
              this.logger.log("Connected"), this.delegate && this.delegate.onServerConnect && this.delegate.onServerConnect(), this.shouldBeRegistered && this.register(), this.options.optionsPingInterval > 0 && this.optionsPingStart();
            },
            onDisconnect: async e => {
              this.logger.log("Disconnected");
              let t = !1;
              this.options.optionsPingInterval > 0 && (t = this.optionsPingFailure, this.optionsPingFailure = !1, this.optionsPingStop()), this.delegate && this.delegate.onServerDisconnect && this.delegate.onServerDisconnect(e), (e || t) && (this.registerer && (this.logger.log("Disposing of registerer..."), this.registerer.dispose().catch(e => {
                this.logger.debug("Error occurred disposing of registerer after connection with server was lost."), this.logger.debug(e.toString());
              }), this.registerer = void 0), this.managedSessions.slice().map(e => e.session).forEach(async e => {
                this.logger.log("Disposing of session..."), e.dispose().catch(e => {
                  this.logger.debug("Error occurred disposing of a session after connection with server was lost."), this.logger.debug(e.toString());
                });
              }), this.shouldBeConnected && this.attemptReconnection());
            },
            onInvite: e => {
              this.logger.log(`[${e.id}] Received INVITE ManagedSession:${this.managedSessions.length}`);
              const t = this.options.maxSimultaneousSessions;
              if (0 !== t && this.managedSessions.length >= t) return this.logger.warn(`[${e.id}] Session already in progress, rejecting INVITE...`), void e.reject().then(() => {
                this.logger.log(`[${e.id}] Rejected INVITE`);
              }).catch(t => {
                this.logger.error(`[${e.id}] Failed to reject INVITE`), this.logger.error(t.toString());
              });
              const s = {
                sessionDescriptionHandlerOptions: {
                  constraints: this.constraints
                }
              };
              this.initSession(e, s), this.delegate && this.delegate.onCallReceived ? this.delegate.onCallReceived(e) : (this.logger.warn(`[${e.id}] No handler available, rejecting INVITE...`), e.reject().then(() => {
                this.logger.log(`[${e.id}] Rejected INVITE`);
              }).catch(t => {
                this.logger.error(`[${e.id}] Failed to reject INVITE`), this.logger.error(t.toString());
              }));
            },
            onMessage: e => {
              e.accept().then(() => {
                this.delegate && this.delegate.onMessageReceived && this.delegate.onMessageReceived(e);
              });
            },
            onNotify: e => {
              e.accept().then(() => {
                this.delegate && this.delegate.onNotificationReceived && this.delegate.onNotificationReceived(e);
              });
            }
          }, this.registererOptions = Object.assign({}, t.registererOptions), this.registererRegisterOptions = Object.assign({}, t.registererRegisterOptions), this.options.registrationRetry) {
            this.registererRegisterOptions.requestDelegate = this.registererRegisterOptions.requestDelegate || {};
            const e = this.registererRegisterOptions.requestDelegate.onReject;

            this.registererRegisterOptions.requestDelegate.onReject = t => {
              e && e(t), this.attemptRegistration();
            };
          }

          this.logger = this.userAgent.getLogger("sip.SessionManager"), window.addEventListener("online", () => {
            this.logger.log("Online"), this.shouldBeConnected && this.connect();
          }), this.options.autoStop && window.addEventListener("beforeunload", async () => {
            this.shouldBeConnected = !1, this.shouldBeRegistered = !1, this.userAgent.state !== h.UserAgentState.Stopped && (await this.userAgent.stop());
          });
        }

        static stripUndefinedProperties(e) {
          return Object.keys(e).reduce((t, s) => (void 0 !== e[s] && (t[s] = e[s]), t), {});
        }

        getLocalMediaStream(e) {
          const t = e.sessionDescriptionHandler;

          if (t) {
            if (!(t instanceof g.SessionDescriptionHandler)) throw new Error("Session description handler not instance of web SessionDescriptionHandler");
            return t.localMediaStream;
          }
        }

        getRemoteMediaStream(e) {
          const t = e.sessionDescriptionHandler;

          if (t) {
            if (!(t instanceof g.SessionDescriptionHandler)) throw new Error("Session description handler not instance of web SessionDescriptionHandler");
            return t.remoteMediaStream;
          }
        }

        getLocalAudioTrack(e) {
          var t;
          return null === (t = this.getLocalMediaStream(e)) || void 0 === t ? void 0 : t.getTracks().find(e => "audio" === e.kind);
        }

        getLocalVideoTrack(e) {
          var t;
          return null === (t = this.getLocalMediaStream(e)) || void 0 === t ? void 0 : t.getTracks().find(e => "video" === e.kind);
        }

        getRemoteAudioTrack(e) {
          var t;
          return null === (t = this.getRemoteMediaStream(e)) || void 0 === t ? void 0 : t.getTracks().find(e => "audio" === e.kind);
        }

        getRemoteVideoTrack(e) {
          var t;
          return null === (t = this.getRemoteMediaStream(e)) || void 0 === t ? void 0 : t.getTracks().find(e => "video" === e.kind);
        }

        async connect() {
          return this.logger.log("Connecting UserAgent..."), this.shouldBeConnected = !0, this.userAgent.state !== h.UserAgentState.Started ? this.userAgent.start() : this.userAgent.reconnect();
        }

        async disconnect() {
          return this.logger.log("Disconnecting UserAgent..."), this.userAgent.state === h.UserAgentState.Stopped ? Promise.resolve() : (this.shouldBeConnected = !1, this.shouldBeRegistered = !1, this.registerer = void 0, this.userAgent.stop());
        }

        isConnected() {
          return this.userAgent.isConnected();
        }

        async register(e) {
          return this.logger.log("Registering UserAgent..."), this.shouldBeRegistered = !0, void 0 !== e && (this.registererRegisterOptions = Object.assign({}, e)), this.registerer || (this.registerer = new o.Registerer(this.userAgent, this.registererOptions), this.registerer.stateChange.addListener(e => {
            switch (e) {
              case a.RegistererState.Initial:
                break;

              case a.RegistererState.Registered:
                this.delegate && this.delegate.onRegistered && this.delegate.onRegistered();
                break;

              case a.RegistererState.Unregistered:
                if (this.delegate && this.delegate.onUnregistered) {
                  let e = this.register.statusCode || 503;
                  this.logger.log(`[${this.id}] Registering statusCode=${e}`), this.delegate.onUnregistered(e);
                }

                this.shouldBeRegistered && this.attemptRegistration();
                break;

              case a.RegistererState.Terminated:
                break;

              default:
                throw new Error("Unknown registerer state.");
            }
          })), this.attemptRegistration(!0);
        }

        async unregister(e) {
          return this.logger.log("Unregistering UserAgent..."), this.shouldBeRegistered = !1, this.registerer ? this.registerer.unregister(e).then(() => {}) : (this.logger.warn("No registerer to unregister."), Promise.resolve());
        }

        async call(e, t, s) {
          this.logger.log("Beginning Session...");
          const i = this.options.maxSimultaneousSessions;
          if (0 !== i && this.managedSessions.length > i) return Promise.reject(new Error("Maximum number of sessions already exists."));
          const n = u.UserAgent.makeURI(e);
          if (!n) return Promise.reject(new Error(`Failed to create a valid URI from "${e}"`));

          if (t || (t = {}), t.sessionDescriptionHandlerOptions || (t.sessionDescriptionHandlerOptions = {}), t.sessionDescriptionHandlerOptions.constraints || (t.sessionDescriptionHandlerOptions.constraints = this.constraints), t.earlyMedia) {
            (s = s || {}).requestDelegate = s.requestDelegate || {};
            const e = s.requestDelegate.onProgress;

            s.requestDelegate.onProgress = t => {
              183 === t.message.statusCode && this.setupRemoteMedia(o), e && e(t);
            };
          }

          this.options.iceStopWaitingOnServerReflexive && (t.delegate = t.delegate || {}, t.delegate.onSessionDescriptionHandler = e => {
            if (!(e instanceof g.SessionDescriptionHandler)) throw new Error("Session description handler not instance of SessionDescriptionHandler");
            e.peerConnectionDelegate = {
              onicecandidate: t => {
                var s;

                if ("srflx" === (null === (s = t.candidate) || void 0 === s ? void 0 : s.type)) {
                  this.logger.log(`[${o.id}] Found srflx ICE candidate, stop waiting...`), e.iceGatheringComplete();
                }
              }
            };
          });
          const o = new r.Inviter(this.userAgent, n, t);
          return this.sendInvite(o, t, s).then(() => o);
        }

        async hangup(e) {
          return this.logger.log(`[${e.id}] Hangup...`), this.sessionExists(e) ? this.terminate(e) : Promise.reject(new Error("Session does not exist."));
        }

        async answer(e, t) {
          return this.logger.log(`[${e.id}] Accepting Invitation...`), this.sessionExists(e) ? e instanceof i.Invitation ? (t || (t = {}), t.sessionDescriptionHandlerOptions || (t.sessionDescriptionHandlerOptions = {}), t.sessionDescriptionHandlerOptions.constraints || (t.sessionDescriptionHandlerOptions.constraints = this.constraints), e.accept(t)) : Promise.reject(new Error("Session not instance of Invitation.")) : Promise.reject(new Error("Session does not exist."));
        }

        async decline(e) {
          return this.logger.log(`[${e.id}] Rejecting Invitation...`), this.sessionExists(e) ? e instanceof i.Invitation ? e.reject({
            statusCode: 603
          }) : Promise.reject(new Error("Session not instance of Invitation.")) : Promise.reject(new Error("Session does not exist."));
        }

        async hold(e) {
          return this.logger.log(`[${e.id}] Holding session...`), this.setHold(e, !0);
        }

        async unhold(e) {
          return this.logger.log(`[${e.id}] Unholding session...`), this.setHold(e, !1);
        }

        isHeld(e) {
          const t = this.sessionManaged(e);
          return !!t && t.held;
        }

        mute(e) {
          this.logger.log(`[${e.id}] Disabling media tracks...`), this.setMute(e, !0);
        }

        unmute(e) {
          this.logger.log(`[${e.id}] Enabling media tracks...`), this.setMute(e, !1);
        }

        isMuted(e) {
          const t = this.sessionManaged(e);
          return !!t && t.muted;
        }

        async sendDTMF(e, t) {
          if (this.logger.log(`[${e.id}] Sending DTMF...`), !/^[0-9A-D#*,]$/.exec(t)) return Promise.reject(new Error("Invalid DTMF tone."));
          if (!this.sessionExists(e)) return Promise.reject(new Error("Session does not exist."));
          if (this.logger.log(`[${e.id}] Sending DTMF tone: ${t}`), this.options.sendDTMFUsingSessionDescriptionHandler) return e.sessionDescriptionHandler ? e.sessionDescriptionHandler.sendDtmf(t) ? Promise.resolve() : Promise.reject(new Error("Failed to send DTMF")) : Promise.reject(new Error("Session desciption handler undefined."));
          {
            const s = {
              body: {
                contentDisposition: "render",
                contentType: "application/dtmf-relay",
                content: "Signal=" + t + "\r\nDuration=" + 2e3
              }
            };
            return e.info({
              requestOptions: s
            }).then(() => {});
          }
        }

        async transfer(e, t, s) {
          if (this.logger.log(`[${e.id}] Referring session...`), t instanceof d.Session) return e.refer(t, s).then(() => {});
          const i = u.UserAgent.makeURI(t);
          return i ? e.refer(i, s).then(() => {}) : Promise.reject(new Error(`Failed to create a valid URI from "${t}"`));
        }

        async message(e, t) {
          this.logger.log("Sending message...");
          const s = u.UserAgent.makeURI(e);
          return s ? new n.Messager(this.userAgent, s, t).message() : Promise.reject(new Error(`Failed to create a valid URI from "${e}"`));
        }

        get constraints() {
          let e = {
            audio: !0,
            video: !1
          };
          return this.options.media.constraints && (e = Object.assign({}, this.options.media.constraints)), e;
        }

        attemptReconnection(e = 1) {
          const t = this.options.reconnectionAttempts,
                s = this.options.reconnectionDelay;
          this.shouldBeConnected ? (this.attemptingReconnection && this.logger.log("Reconnection attempt already in progress"), e > t ? this.logger.log("Reconnection maximum attempts reached") : (1 === e ? this.logger.log(`Reconnection attempt ${e} of ${t} - trying`) : this.logger.log(`Reconnection attempt ${e} of ${t} - trying in ${s} seconds`), this.attemptingReconnection = !0, setTimeout(() => {
            if (!this.shouldBeConnected) return this.logger.log(`Reconnection attempt ${e} of ${t} - aborted`), void (this.attemptingReconnection = !1);
            this.userAgent.reconnect().then(() => {
              this.logger.log(`Reconnection attempt ${e} of ${t} - succeeded`), this.attemptingReconnection = !1;
            }).catch(s => {
              this.logger.log(`Reconnection attempt ${e} of ${t} - failed`), this.logger.error(s.message), this.attemptingReconnection = !1, this.attemptReconnection(++e);
            });
          }, 1 === e ? 0 : 1e3 * s))) : this.logger.log("Should not be connected currently");
        }

        attemptRegistration(e = !1) {
          if (this.logger.log(`Registration attempt ${e ? "without delay" : ""}`), !this.shouldBeRegistered) return this.logger.log("Should not be registered currently"), Promise.resolve();
          if (void 0 !== this.registrationAttemptTimeout) return this.logger.log("Registration attempt already in progress"), Promise.resolve();

          const t = () => this.registerer ? this.isConnected() ? this.userAgent.state === h.UserAgentState.Stopped ? (this.logger.log("User agent stopped"), Promise.resolve()) : this.options.registerGuard ? this.options.registerGuard().catch(e => {
            throw this.logger.log("Register guard rejected will making registration attempt"), e;
          }).then(e => e || !this.registerer ? Promise.resolve() : this.registerer.register(this.registererRegisterOptions).then(() => {})) : this.registerer.register(this.registererRegisterOptions).then(() => {}) : (this.logger.log("User agent not connected"), Promise.resolve()) : (this.logger.log("Registerer undefined"), Promise.resolve());

          return new Promise((s, i) => {
            this.registrationAttemptTimeout = setTimeout(() => {
              t().then(() => {
                this.registrationAttemptTimeout = void 0, s();
              }).catch(e => {
                this.registrationAttemptTimeout = void 0, e instanceof c.RequestPendingError ? s() : i(e);
              });
            }, e ? 0 : (e => {
              const t = 2 * e;
              return 1e3 * (Math.random() * (t - e) + e);
            })(this.options.registrationRetryInterval));
          });
        }

        cleanupMedia(e) {
          const t = this.sessionManaged(e);
          if (!t) throw new Error("Managed session does not exist.");
          t.mediaLocal && t.mediaLocal.video && (t.mediaLocal.video.srcObject = null, t.mediaLocal.video.pause()), t.mediaRemote && (t.mediaRemote.audio && (t.mediaRemote.audio.srcObject = null, t.mediaRemote.audio.pause()), t.mediaRemote.video && (t.mediaRemote.video.srcObject = null, t.mediaRemote.video.pause()));
        }

        enableReceiverTracks(e, t) {
          if (!this.sessionExists(e)) throw new Error("Session does not exist.");
          const s = e.sessionDescriptionHandler;
          if (!(s instanceof g.SessionDescriptionHandler)) throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
          s.enableReceiverTracks(t);
        }

        enableSenderTracks(e, t) {
          if (!this.sessionExists(e)) throw new Error("Session does not exist.");
          const s = e.sessionDescriptionHandler;
          if (!(s instanceof g.SessionDescriptionHandler)) throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
          s.enableSenderTracks(t);
        }

        initSession(e, t) {
          this.sessionAdd(e), this.delegate && this.delegate.onCallCreated && this.delegate.onCallCreated(e), e.stateChange.addListener(t => {
            switch (this.logger.log(`[${e.id}] Session state changed to ${t}`), t) {
              case l.SessionState.Initial:
              case l.SessionState.Establishing:
                break;

              case l.SessionState.Established:
                this.setupLocalMedia(e), this.setupRemoteMedia(e), this.delegate && this.delegate.onCallAnswered && this.delegate.onCallAnswered(e);
                break;

              case l.SessionState.Terminating:
              case l.SessionState.Terminated:
                this.sessionExists(e) && (this.cleanupMedia(e), this.sessionRemove(e), this.delegate && this.delegate.onCallHangup && this.delegate.onCallHangup(e));
                break;

              default:
                throw new Error("Unknown session state.");
            }
          }), e.delegate = e.delegate || {}, e.delegate.onInfo = t => {
            var s;
            if (void 0 === (null === (s = this.delegate) || void 0 === s ? void 0 : s.onCallDTMFReceived)) return void t.reject();
            const i = t.request.getHeader("content-type");
            if (!i || !/^application\/dtmf-relay/i.exec(i)) return void t.reject();
            const r = t.request.body.split("\r\n", 2);
            if (2 !== r.length) return void t.reject();
            let n;
            const o = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;
            if (void 0 !== r[0] && o.test(r[0]) && (n = r[0].replace(o, "$2")), !n) return void t.reject();
            let a;
            const c = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
            void 0 !== r[1] && c.test(r[1]) && (a = parseInt(r[1].replace(c, "$2"), 10)), a ? t.accept().then(() => {
              if (this.delegate && this.delegate.onCallDTMFReceived) {
                if (!n || !a) throw new Error("Tone or duration undefined.");
                this.delegate.onCallDTMFReceived(e, n, a);
              }
            }).catch(e => {
              this.logger.error(e.message);
            }) : t.reject();
          }, e.delegate.onRefer = e => {
            e.accept().then(() => this.sendInvite(e.makeInviter(t), t)).catch(e => {
              this.logger.error(e.message);
            });
          };
        }

        optionsPingRun(e, t, s) {
          if (this.options.optionsPingInterval < 1) throw new Error("Invalid options ping interval.");
          this.optionsPingRunning || (this.optionsPingRunning = !0, this.optionsPingTimeout = setTimeout(() => {
            this.optionsPingTimeout = void 0;

            const i = () => {
              this.optionsPingFailure = !1, this.optionsPingRunning && (this.optionsPingRunning = !1, this.optionsPingRun(e, t, s));
            },
                  r = () => {
              this.logger.error("OPTIONS ping failed"), this.optionsPingFailure = !0, this.optionsPingRunning = !1, this.userAgent.transport.disconnect().catch(e => this.logger.error(e));
            },
                  n = this.userAgent.userAgentCore,
                  o = n.makeOutgoingRequestMessage("OPTIONS", e, t, s, {});

            this.optionsPingRequest = n.request(o, {
              onAccept: () => {
                this.optionsPingRequest = void 0, i();
              },
              onReject: e => {
                this.optionsPingRequest = void 0, 408 === e.message.statusCode || 503 === e.message.statusCode ? r() : i();
              }
            });
          }, 1e3 * this.options.optionsPingInterval));
        }

        optionsPingStart() {
          let e, t, s;

          if (this.logger.log("OPTIONS pings started"), this.options.optionsPingRequestURI) {
            if (!(e = u.UserAgent.makeURI(this.options.optionsPingRequestURI))) throw new Error("Failed to create Request URI.");
            t = this.userAgent.contact.uri.clone(), s = this.userAgent.contact.uri.clone();
          } else {
            if (!this.options.aor) return void this.logger.error("You have enabled sending OPTIONS pings and as such you must provide either a) an AOR to register, or b) an RURI to use for the target of the OPTIONS ping requests. ");
            {
              const i = u.UserAgent.makeURI(this.options.aor);
              if (!i) throw new Error("Failed to create URI.");
              (e = i.clone()).user = void 0, t = i.clone(), s = i.clone();
            }
          }

          this.optionsPingRun(e, t, s);
        }

        optionsPingStop() {
          this.logger.log("OPTIONS pings stopped"), this.optionsPingRunning = !1, this.optionsPingFailure = !1, this.optionsPingRequest && (this.optionsPingRequest.dispose(), this.optionsPingRequest = void 0), this.optionsPingTimeout && (clearTimeout(this.optionsPingTimeout), this.optionsPingTimeout = void 0);
        }

        async sendInvite(e, t, s) {
          return this.initSession(e, t), e.invite(s).then(() => {
            this.logger.log(`[${e.id}] Sent INVITE`);
          });
        }

        sessionAdd(e) {
          const t = this.options.managedSessionFactory(this, e);
          this.managedSessions.push(t);
        }

        sessionExists(e) {
          return void 0 !== this.sessionManaged(e);
        }

        sessionManaged(e) {
          return this.managedSessions.find(t => t.session.id === e.id);
        }

        sessionRemove(e) {
          this.managedSessions = this.managedSessions.filter(t => t.session.id !== e.id);
        }

        async setHold(e, t) {
          if (!this.sessionExists(e)) return Promise.reject(new Error("Session does not exist."));
          if (this.isHeld(e) === t) return Promise.resolve();
          if (!(e.sessionDescriptionHandler instanceof g.SessionDescriptionHandler)) throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
          const s = {
            requestDelegate: {
              onAccept: () => {
                const s = this.sessionManaged(e);
                void 0 !== s && (s.held = t, this.enableReceiverTracks(e, !s.held), this.enableSenderTracks(e, !s.held && !s.muted), this.delegate && this.delegate.onCallHold && this.delegate.onCallHold(e, s.held));
              },
              onReject: () => {
                this.logger.warn(`[${e.id}] Re-invite request was rejected`);
                const s = this.sessionManaged(e);
                void 0 !== s && (s.held = !t, this.enableReceiverTracks(e, !s.held), this.enableSenderTracks(e, !s.held && !s.muted), this.delegate && this.delegate.onCallHold && this.delegate.onCallHold(e, s.held));
              }
            }
          },
                i = e.sessionDescriptionHandlerOptionsReInvite;
          i.hold = t, e.sessionDescriptionHandlerOptionsReInvite = i;
          const r = this.sessionManaged(e);
          if (!r) throw new Error("Managed session is undefiend.");
          return r.held = t, e.invite(s).then(() => {
            const t = this.sessionManaged(e);
            void 0 !== t && (this.enableReceiverTracks(e, !t.held), this.enableSenderTracks(e, !t.held && !t.muted));
          }).catch(s => {
            throw r.held = !t, s instanceof c.RequestPendingError && this.logger.error(`[${e.id}] A hold request is already in progress.`), s;
          });
        }

        setMute(e, t) {
          if (!this.sessionExists(e)) return void this.logger.warn(`[${e.id}] A session is required to enabled/disable media tracks`);
          if (e.state !== l.SessionState.Established) return void this.logger.warn(`[${e.id}] An established session is required to enable/disable media tracks`);
          const s = this.sessionManaged(e);
          void 0 !== s && (s.muted = t, this.enableSenderTracks(e, !s.held && !s.muted));
        }

        setupLocalMedia(e) {
          const t = this.sessionManaged(e);
          if (!t) throw new Error("Managed session does not exist.");
          const s = "function" == typeof this.options.media.local ? this.options.media.local(e) : this.options.media.local;
          t.mediaLocal = s;
          const i = null == s ? void 0 : s.video;

          if (i) {
            const t = this.getLocalMediaStream(e);
            if (!t) throw new Error("Local media stream undefiend.");
            i.srcObject = t, i.volume = 0, i.play().catch(t => {
              this.logger.error(`[${e.id}] Failed to play local media`), this.logger.error(t.message);
            });
          }
        }

        setupRemoteMedia(e) {
          const t = this.sessionManaged(e);
          if (!t) throw new Error("Managed session does not exist.");
          const s = "function" == typeof this.options.media.remote ? this.options.media.remote(e) : this.options.media.remote;
          t.mediaRemote = s;
          const i = (null == s ? void 0 : s.video) || (null == s ? void 0 : s.audio);

          if (i) {
            const t = this.getRemoteMediaStream(e);
            if (!t) throw new Error("Remote media stream undefiend.");
            i.autoplay = !0, i.srcObject = t, i.play().catch(t => {
              this.logger.error(`[${e.id}] Failed to play remote media`), this.logger.error(t.message);
            }), t.onaddtrack = () => {
              this.logger.log("Remote media onaddtrack"), i.load(), i.play().catch(t => {
                this.logger.error(`[${e.id}] Failed to play remote media`), this.logger.error(t.message);
              });
            };
          }
        }

        async terminate(e) {
          switch (this.logger.log(`[${e.id}] Terminating...`), e.state) {
            case l.SessionState.Initial:
              if (e instanceof r.Inviter) return e.cancel().then(() => {
                this.logger.log(`[${e.id}] Inviter never sent INVITE (canceled)`);
              });
              if (e instanceof i.Invitation) return e.reject().then(() => {
                this.logger.log(`[${e.id}] Invitation rejected (sent 480)`);
              });
              throw new Error("Unknown session type.");

            case l.SessionState.Establishing:
              if (e instanceof r.Inviter) return e.cancel().then(() => {
                this.logger.log(`[${e.id}] Inviter canceled (sent CANCEL)`);
              });
              if (e instanceof i.Invitation) return e.reject().then(() => {
                this.logger.log(`[${e.id}] Invitation rejected (sent 480)`);
              });
              throw new Error("Unknown session type.");

            case l.SessionState.Established:
              return e.bye().then(() => {
                this.logger.log(`[${e.id}] Session ended (sent BYE)`);
              });

            case l.SessionState.Terminating:
            case l.SessionState.Terminated:
              break;

            default:
              throw new Error("Unknown state");
          }

          return this.logger.log(`[${e.id}] Terminating in state ${e.state}, no action taken`), Promise.resolve();
        }

      }
    },
    "./node_modules/sip.js/lib/platform/web/simple-user/index.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/simple-user/index.js ***!
      \*******************************************************************/

    /*! exports provided: SimpleUser */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./simple-user.js */
      "./node_modules/sip.js/lib/platform/web/simple-user/simple-user.js");
      s.d(t, "SimpleUser", function () {
        return i.SimpleUser;
      });
      s(
      /*! ./simple-user-delegate.js */
      "./node_modules/sip.js/lib/platform/web/simple-user/simple-user-delegate.js"), s(
      /*! ./simple-user-options.js */
      "./node_modules/sip.js/lib/platform/web/simple-user/simple-user-options.js");
    },
    "./node_modules/sip.js/lib/platform/web/simple-user/simple-user-delegate.js":
    /*!**********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/simple-user/simple-user-delegate.js ***!
      \**********************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/simple-user/simple-user-options.js":
    /*!*********************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/simple-user/simple-user-options.js ***!
      \*********************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/simple-user/simple-user.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/simple-user/simple-user.js ***!
      \*************************************************************************/

    /*! exports provided: SimpleUser */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "SimpleUser", function () {
        return r;
      });
      var i = s(
      /*! ../session-manager/session-manager.js */
      "./node_modules/sip.js/lib/platform/web/session-manager/session-manager.js");

      class r {
        constructor(e, t = {}) {
          this.session = void 0, this.delegate = t.delegate, this.options = Object.assign({}, t);
          const s = {
            aor: this.options.aor,
            delegate: {
              onCallAnswered: () => {
                var e, t;
                return null === (t = null === (e = this.delegate) || void 0 === e ? void 0 : e.onCallAnswered) || void 0 === t ? void 0 : t.call(e);
              },
              onCallCreated: e => {
                var t, s;
                this.session = e, null === (s = null === (t = this.delegate) || void 0 === t ? void 0 : t.onCallCreated) || void 0 === s || s.call(t);
              },
              onCallReceived: () => {
                var e, t;
                return null === (t = null === (e = this.delegate) || void 0 === e ? void 0 : e.onCallReceived) || void 0 === t ? void 0 : t.call(e);
              },
              onCallHangup: () => {
                var e, t;
                this.session = void 0, (null === (e = this.delegate) || void 0 === e ? void 0 : e.onCallHangup) && (null === (t = this.delegate) || void 0 === t || t.onCallHangup());
              },
              onCallHold: (e, t) => {
                var s, i;
                return null === (i = null === (s = this.delegate) || void 0 === s ? void 0 : s.onCallHold) || void 0 === i ? void 0 : i.call(s, t);
              },
              onCallDTMFReceived: (e, t, s) => {
                var i, r;
                return null === (r = null === (i = this.delegate) || void 0 === i ? void 0 : i.onCallDTMFReceived) || void 0 === r ? void 0 : r.call(i, t, s);
              },
              onMessageReceived: e => {
                var t, s;
                return null === (s = null === (t = this.delegate) || void 0 === t ? void 0 : t.onMessageReceived) || void 0 === s ? void 0 : s.call(t, e.request.body);
              },
              onRegistered: () => {
                var e, t;
                return null === (t = null === (e = this.delegate) || void 0 === e ? void 0 : e.onRegistered) || void 0 === t ? void 0 : t.call(e);
              },
              onUnregistered: e => {
                var t, s;
                return null === (s = null === (t = this.delegate) || void 0 === t ? void 0 : t.onUnregistered) || void 0 === s ? void 0 : s.call(t, e);
              },
              onServerConnect: () => {
                var e, t;
                return null === (t = null === (e = this.delegate) || void 0 === e ? void 0 : e.onServerConnect) || void 0 === t ? void 0 : t.call(e);
              },
              onServerDisconnect: () => {
                var e, t;
                return null === (t = null === (e = this.delegate) || void 0 === e ? void 0 : e.onServerDisconnect) || void 0 === t ? void 0 : t.call(e);
              }
            },
            maxSimultaneousSessions: 1,
            media: this.options.media,
            reconnectionAttempts: this.options.reconnectionAttempts,
            reconnectionDelay: this.options.reconnectionDelay,
            registererOptions: this.options.registererOptions,
            sendDTMFUsingSessionDescriptionHandler: this.options.sendDTMFUsingSessionDescriptionHandler,
            userAgentOptions: this.options.userAgentOptions
          };
          this.sessionManager = new i.SessionManager(e, s), this.logger = this.sessionManager.userAgent.getLogger("sip.SimpleUser");
        }

        get id() {
          return this.options.userAgentOptions && this.options.userAgentOptions.displayName || "Anonymous";
        }

        get activeSession() {
          return this.session;
        }

        get localMediaStream() {
          return this.session && this.sessionManager.getLocalMediaStream(this.session);
        }

        get remoteMediaStream() {
          return this.session && this.sessionManager.getRemoteMediaStream(this.session);
        }

        get localAudioTrack() {
          return this.session && this.sessionManager.getLocalAudioTrack(this.session);
        }

        get localVideoTrack() {
          return this.session && this.sessionManager.getLocalVideoTrack(this.session);
        }

        get remoteAudioTrack() {
          return this.session && this.sessionManager.getRemoteAudioTrack(this.session);
        }

        get remoteVideoTrack() {
          return this.session && this.sessionManager.getRemoteVideoTrack(this.session);
        }

        connect() {
          return this.logger.log(`[${this.id}] Connecting UserAgent...`), this.sessionManager.connect();
        }

        disconnect() {
          return this.logger.log(`[${this.id}] Disconnecting UserAgent...`), this.sessionManager.disconnect();
        }

        isConnected() {
          return this.sessionManager.isConnected();
        }

        register(e) {
          return this.logger.log(`[${this.id}] Registering UserAgent...`), this.sessionManager.register(e);
        }

        unregister(e) {
          return this.logger.log(`[${this.id}] Unregistering UserAgent...`), this.sessionManager.unregister(e);
        }

        call(e, t, s) {
          return this.logger.log(`[${this.id}] Beginning Session...`), this.session ? Promise.reject(new Error("Session already exists.")) : this.sessionManager.call(e, t, s).then(() => {});
        }

        hangup() {
          return this.logger.log(`[${this.id}] Hangup...`), this.session ? this.sessionManager.hangup(this.session).then(() => {
            this.session = void 0;
          }) : Promise.reject(new Error("Session does not exist."));
        }

        answer(e) {
          return this.logger.log(`[${this.id}] Accepting Invitation...`), this.session ? this.sessionManager.answer(this.session, e) : Promise.reject(new Error("Session does not exist."));
        }

        decline() {
          return this.logger.log(`[${this.id}] rejecting Invitation...`), this.session ? this.sessionManager.decline(this.session) : Promise.reject(new Error("Session does not exist."));
        }

        hold() {
          return this.logger.log(`[${this.id}] holding session...`), this.session ? this.sessionManager.hold(this.session) : Promise.reject(new Error("Session does not exist."));
        }

        unhold() {
          return this.logger.log(`[${this.id}] unholding session...`), this.session ? this.sessionManager.unhold(this.session) : Promise.reject(new Error("Session does not exist."));
        }

        isHeld() {
          return !!this.session && this.sessionManager.isHeld(this.session);
        }

        mute() {
          return this.logger.log(`[${this.id}] disabling media tracks...`), this.session && this.sessionManager.mute(this.session);
        }

        unmute() {
          return this.logger.log(`[${this.id}] enabling media tracks...`), this.session && this.sessionManager.unmute(this.session);
        }

        isMuted() {
          return !!this.session && this.sessionManager.isMuted(this.session);
        }

        sendDTMF(e) {
          return this.logger.log(`[${this.id}] sending DTMF...`), this.session ? this.sessionManager.sendDTMF(this.session, e) : Promise.reject(new Error("Session does not exist."));
        }

        message(e, t) {
          return this.logger.log(`[${this.id}] sending message...`), this.sessionManager.message(e, t);
        }

      }
    },
    "./node_modules/sip.js/lib/platform/web/transport/index.js":
    /*!*****************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/transport/index.js ***!
      \*****************************************************************/

    /*! exports provided: Transport */
    function (e, t, s) {
      "use strict";

      s.r(t);
      var i = s(
      /*! ./transport.js */
      "./node_modules/sip.js/lib/platform/web/transport/transport.js");
      s.d(t, "Transport", function () {
        return i.Transport;
      });
      s(
      /*! ./transport-options.js */
      "./node_modules/sip.js/lib/platform/web/transport/transport-options.js");
    },
    "./node_modules/sip.js/lib/platform/web/transport/transport-options.js":
    /*!*****************************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/transport/transport-options.js ***!
      \*****************************************************************************/

    /*! no exports provided */
    function (e, t, s) {
      "use strict";

      s.r(t);
    },
    "./node_modules/sip.js/lib/platform/web/transport/transport.js":
    /*!*********************************************************************!*\
      !*** ./node_modules/sip.js/lib/platform/web/transport/transport.js ***!
      \*********************************************************************/

    /*! exports provided: Transport */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "Transport", function () {
        return a;
      });
      var i = s(
      /*! ../../../api/emitter.js */
      "./node_modules/sip.js/lib/api/emitter.js"),
          r = s(
      /*! ../../../api/exceptions/state-transition.js */
      "./node_modules/sip.js/lib/api/exceptions/state-transition.js"),
          n = s(
      /*! ../../../api/transport-state.js */
      "./node_modules/sip.js/lib/api/transport-state.js"),
          o = s(
      /*! ../../../grammar/grammar.js */
      "./node_modules/sip.js/lib/grammar/grammar.js");

      class a {
        constructor(e, t) {
          if (this._state = n.TransportState.Disconnected, this.transitioningState = !1, this._stateEventEmitter = new i.EmitterImpl(), this.logger = e, t) {
            const e = t,
                  s = null == e ? void 0 : e.wsServers,
                  i = null == e ? void 0 : e.maxReconnectionAttempts;

            if (void 0 !== s) {
              const e = 'The transport option "wsServers" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.';
              this.logger.warn(e);
            }

            if (void 0 !== i) {
              const e = 'The transport option "maxReconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.';
              this.logger.warn(e);
            }

            s && !t.server && ("string" == typeof s && (t.server = s), s instanceof Array && (t.server = s[0]));
          }

          this.configuration = Object.assign(Object.assign({}, a.defaultOptions), t);
          const s = this.configuration.server,
                r = o.Grammar.parse(s, "absoluteURI");
          if (-1 === r) throw this.logger.error(`Invalid WebSocket Server URL "${s}"`), new Error("Invalid WebSocket Server URL");
          if (!["wss", "ws", "udp"].includes(r.scheme)) throw this.logger.error(`Invalid scheme in WebSocket Server URL "${s}"`), new Error("Invalid scheme in WebSocket Server URL");
          this._protocol = r.scheme.toUpperCase();
        }

        dispose() {
          return this.disconnect();
        }

        get protocol() {
          return this._protocol;
        }

        get server() {
          return this.configuration.server;
        }

        get state() {
          return this._state;
        }

        get stateChange() {
          return this._stateEventEmitter;
        }

        get ws() {
          return this._ws;
        }

        connect() {
          return this._connect();
        }

        disconnect() {
          return this._disconnect();
        }

        isConnected() {
          return this.state === n.TransportState.Connected;
        }

        send(e) {
          return this._send(e);
        }

        _connect() {
          switch (this.logger.log(`Connecting ${this.server}`), this.state) {
            case n.TransportState.Connecting:
              if (this.transitioningState) return Promise.reject(this.transitionLoopDetectedError(n.TransportState.Connecting));
              if (!this.connectPromise) throw new Error("Connect promise must be defined.");
              return this.connectPromise;

            case n.TransportState.Connected:
              if (this.transitioningState) return Promise.reject(this.transitionLoopDetectedError(n.TransportState.Connecting));
              if (this.connectPromise) throw new Error("Connect promise must not be defined.");
              return Promise.resolve();

            case n.TransportState.Disconnecting:
            case n.TransportState.Disconnected:
              if (this.connectPromise) throw new Error("Connect promise must not be defined.");

              try {
                this.transitionState(n.TransportState.Connecting);
              } catch (e) {
                if (e instanceof r.StateTransitionError) return Promise.reject(e);
                throw e;
              }

              break;

            default:
              throw new Error("Unknown state");
          }

          let e;

          try {
            (e = new WebSocket(this.server, "sip")).binaryType = "arraybuffer", e.addEventListener("close", t => this.onWebSocketClose(t, e)), e.addEventListener("error", t => this.onWebSocketError(t, e)), e.addEventListener("open", t => this.onWebSocketOpen(t, e)), e.addEventListener("message", t => this.onWebSocketMessage(t, e)), this._ws = e;
          } catch (e) {
            return this._ws = void 0, this.logger.error("WebSocket construction failed."), this.logger.error(e.toString()), new Promise((t, s) => {
              this.connectResolve = t, this.connectReject = s, this.transitionState(n.TransportState.Disconnected, e);
            });
          }

          return this.connectPromise = new Promise((t, s) => {
            this.connectResolve = t, this.connectReject = s, this.connectTimeout = setTimeout(() => {
              this.logger.warn("Connect timed out. Exceeded time set in configuration.connectionTimeout: " + this.configuration.connectionTimeout + "s."), e.close(1e3);
            }, 1e3 * this.configuration.connectionTimeout);
          }), this.connectPromise;
        }

        _disconnect() {
          switch (this.logger.log(`Disconnecting ${this.server}`), this.state) {
            case n.TransportState.Connecting:
            case n.TransportState.Connected:
              if (this.disconnectPromise) throw new Error("Disconnect promise must not be defined.");

              try {
                this.transitionState(n.TransportState.Disconnecting);
              } catch (e) {
                if (e instanceof r.StateTransitionError) return Promise.reject(e);
                throw e;
              }

              break;

            case n.TransportState.Disconnecting:
              if (this.transitioningState) return Promise.reject(this.transitionLoopDetectedError(n.TransportState.Disconnecting));
              if (!this.disconnectPromise) throw new Error("Disconnect promise must be defined.");
              return this.disconnectPromise;

            case n.TransportState.Disconnected:
              if (this.transitioningState) return Promise.reject(this.transitionLoopDetectedError(n.TransportState.Disconnecting));
              if (this.disconnectPromise) throw new Error("Disconnect promise must not be defined.");
              return Promise.resolve();

            default:
              throw new Error("Unknown state");
          }

          if (!this._ws) throw new Error("WebSocket must be defined.");
          const e = this._ws;
          return this.disconnectPromise = new Promise((t, s) => {
            this.disconnectResolve = t, this.disconnectReject = s;

            try {
              e.close(1e3);
            } catch (e) {
              throw this.logger.error("WebSocket close failed."), this.logger.error(e.toString()), e;
            }
          }), this.disconnectPromise;
        }

        _send(e) {
          if (!0 === this.configuration.traceSip && this.logger.log("Sending WebSocket message:\n\n" + e + "\n"), this._state !== n.TransportState.Connected) return Promise.reject(new Error("Not connected."));
          if (!this._ws) throw new Error("WebSocket undefined.");

          try {
            this._ws.send(e);
          } catch (e) {
            return e instanceof Error ? Promise.reject(e) : Promise.reject(new Error("WebSocket send failed."));
          }

          return Promise.resolve();
        }

        onWebSocketClose(e, t) {
          if (t !== this._ws) return;
          const s = `WebSocket closed ${this.server} (code: ${e.code})`,
                i = this.disconnectPromise ? void 0 : new Error(s);
          i && this.logger.warn("WebSocket closed unexpectedly"), this.logger.log(s), this._ws = void 0, this.transitionState(n.TransportState.Disconnected, i);
        }

        onWebSocketError(e, t) {
          t === this._ws && this.logger.error("WebSocket error occurred.");
        }

        onWebSocketMessage(e, t) {
          if (t !== this._ws) return;
          const s = e.data;
          let i;
          if (/^(\r\n)+$/.test(s)) return this.clearKeepAliveTimeout(), void (!0 === this.configuration.traceSip && this.logger.log("Received WebSocket message with CRLF Keep Alive response"));

          if (s) {
            if ("string" != typeof s) {
              try {
                i = new TextDecoder().decode(new Uint8Array(s));
              } catch (e) {
                return this.logger.error(e.toString()), void this.logger.error("Received WebSocket binary message failed to be converted into string, message discarded");
              }

              !0 === this.configuration.traceSip && this.logger.log("Received WebSocket binary message:\n\n" + i + "\n");
            } else i = s, !0 === this.configuration.traceSip && this.logger.log("Received WebSocket text message:\n\n" + i + "\n");

            if (this.state === n.TransportState.Connected) {
              if (this.onMessage) try {
                this.onMessage(i);
              } catch (e) {
                throw this.logger.error(e.toString()), this.logger.error("Exception thrown by onMessage callback"), e;
              }
            } else this.logger.warn("Received message while not connected, discarding...");
          } else this.logger.warn("Received empty message, discarding...");
        }

        onWebSocketOpen(e, t) {
          t === this._ws && this._state === n.TransportState.Connecting && (this.logger.log(`WebSocket opened ${this.server}`), this.transitionState(n.TransportState.Connected));
        }

        transitionLoopDetectedError(e) {
          let t = "A state transition loop has been detected.";
          return t += ` An attempt to transition from ${this._state} to ${e} before the prior transition completed.`, t += " Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?", this.logger.error(t), new r.StateTransitionError("Loop detected.");
        }

        transitionState(e, t) {
          const s = () => {
            throw new Error(`Invalid state transition from ${this._state} to ${e}`);
          };

          if (this.transitioningState) throw this.transitionLoopDetectedError(e);

          switch (this.transitioningState = !0, this._state) {
            case n.TransportState.Connecting:
              e !== n.TransportState.Connected && e !== n.TransportState.Disconnecting && e !== n.TransportState.Disconnected && s();
              break;

            case n.TransportState.Connected:
              e !== n.TransportState.Disconnecting && e !== n.TransportState.Disconnected && s();
              break;

            case n.TransportState.Disconnecting:
              e !== n.TransportState.Connecting && e !== n.TransportState.Disconnected && s();
              break;

            case n.TransportState.Disconnected:
              e !== n.TransportState.Connecting && s();
              break;

            default:
              throw new Error("Unknown state.");
          }

          const i = this._state;
          this._state = e;
          const r = this.connectResolve,
                o = this.connectReject;
          i === n.TransportState.Connecting && (this.connectPromise = void 0, this.connectResolve = void 0, this.connectReject = void 0);
          const a = this.disconnectResolve,
                c = this.disconnectReject;
          if (i === n.TransportState.Disconnecting && (this.disconnectPromise = void 0, this.disconnectResolve = void 0, this.disconnectReject = void 0), this.connectTimeout && (clearTimeout(this.connectTimeout), this.connectTimeout = void 0), this.logger.log(`Transitioned from ${i} to ${this._state}`), this._stateEventEmitter.emit(this._state), e === n.TransportState.Connected && (this.startSendingKeepAlives(), this.onConnect)) try {
            this.onConnect();
          } catch (e) {
            throw this.logger.error(e.toString()), this.logger.error("Exception thrown by onConnect callback"), e;
          }
          if (i === n.TransportState.Connected && (this.stopSendingKeepAlives(), this.onDisconnect)) try {
            t ? this.onDisconnect(t) : this.onDisconnect();
          } catch (e) {
            throw this.logger.error(e.toString()), this.logger.error("Exception thrown by onDisconnect callback"), e;
          }

          if (i === n.TransportState.Connecting) {
            if (!r) throw new Error("Connect resolve undefined.");
            if (!o) throw new Error("Connect reject undefined.");
            e === n.TransportState.Connected ? r() : o(t || new Error("Connect aborted."));
          }

          if (i === n.TransportState.Disconnecting) {
            if (!a) throw new Error("Disconnect resolve undefined.");
            if (!c) throw new Error("Disconnect reject undefined.");
            e === n.TransportState.Disconnected ? a() : c(t || new Error("Disconnect aborted."));
          }

          this.transitioningState = !1;
        }

        clearKeepAliveTimeout() {
          this.keepAliveDebounceTimeout && clearTimeout(this.keepAliveDebounceTimeout), this.keepAliveDebounceTimeout = void 0;
        }

        sendKeepAlive() {
          return this.keepAliveDebounceTimeout ? Promise.resolve() : (this.keepAliveDebounceTimeout = setTimeout(() => {
            this.clearKeepAliveTimeout();
          }, 1e3 * this.configuration.keepAliveDebounce), this.send("\r\n\r\n"));
        }

        startSendingKeepAlives() {
          this.configuration.keepAliveInterval && !this.keepAliveInterval && (this.keepAliveInterval = setInterval(() => {
            this.sendKeepAlive(), this.startSendingKeepAlives();
          }, (e => {
            const t = .8 * e;
            return 1e3 * (Math.random() * (e - t) + t);
          })(this.configuration.keepAliveInterval)));
        }

        stopSendingKeepAlives() {
          this.keepAliveInterval && clearInterval(this.keepAliveInterval), this.keepAliveDebounceTimeout && clearTimeout(this.keepAliveDebounceTimeout), this.keepAliveInterval = void 0, this.keepAliveDebounceTimeout = void 0;
        }

      }

      a.defaultOptions = {
        server: "",
        connectionTimeout: 5,
        keepAliveInterval: 0,
        keepAliveDebounce: 10,
        traceSip: !0
      };
    },
    "./node_modules/sip.js/lib/version.js":
    /*!********************************************!*\
      !*** ./node_modules/sip.js/lib/version.js ***!
      \********************************************/

    /*! exports provided: LIBRARY_VERSION */
    function (e, t, s) {
      "use strict";

      s.r(t), s.d(t, "LIBRARY_VERSION", function () {
        return i;
      });
      const i = "0.21.1";
    }
  });
});

/***/ }),

/***/ 7203:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7203__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	!function() {
/******/ 		__webpack_require__.amdO = {};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ entry_lib; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(7203);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/_virtual/plugin-vue_export-helper.mjs
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;

  for (const [key, val] of props) {
    target[key] = val;
  }

  return target;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/popper2.mjs
const POPPER_INJECTION_KEY = Symbol("popper");
const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/popper4.mjs




const __default__ = {
  name: "ElPopperRoot",
  inheritAttrs: false
};

const _sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...__default__,

  setup(__props, {
    expose
  }) {
    const triggerRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const popperInstanceRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const contentRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const referenceRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const popperProvides = {
      triggerRef,
      popperInstanceRef,
      contentRef,
      referenceRef
    };
    expose(popperProvides);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(POPPER_INJECTION_KEY, popperProvides);
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default");
    };
  }

});

var Popper = /* @__PURE__ */_export_sfc(_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);


;// CONCATENATED MODULE: ./node_modules/@vue/shared/dist/shared.esm-bundler.js
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
  const map = Object.create(null);
  const list = str.split(',');

  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}
/**
 * dev only flag -> name mapping
 */


const PatchFlagNames = {
  [1
  /* TEXT */
  ]: `TEXT`,
  [2
  /* CLASS */
  ]: `CLASS`,
  [4
  /* STYLE */
  ]: `STYLE`,
  [8
  /* PROPS */
  ]: `PROPS`,
  [16
  /* FULL_PROPS */
  ]: `FULL_PROPS`,
  [32
  /* HYDRATE_EVENTS */
  ]: `HYDRATE_EVENTS`,
  [64
  /* STABLE_FRAGMENT */
  ]: `STABLE_FRAGMENT`,
  [128
  /* KEYED_FRAGMENT */
  ]: `KEYED_FRAGMENT`,
  [256
  /* UNKEYED_FRAGMENT */
  ]: `UNKEYED_FRAGMENT`,
  [512
  /* NEED_PATCH */
  ]: `NEED_PATCH`,
  [1024
  /* DYNAMIC_SLOTS */
  ]: `DYNAMIC_SLOTS`,
  [2048
  /* DEV_ROOT_FRAGMENT */
  ]: `DEV_ROOT_FRAGMENT`,
  [-1
  /* HOISTED */
  ]: `HOISTED`,
  [-2
  /* BAIL */
  ]: `BAIL`
};
/**
 * Dev only
 */

const slotFlagsText = {
  [1
  /* STABLE */
  ]: 'STABLE',
  [2
  /* DYNAMIC */
  ]: 'DYNAMIC',
  [3
  /* FORWARDED */
  ]: 'FORWARDED'
};
const GLOBALS_WHITE_LISTED = (/* unused pure expression or super */ null && ('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'));
const isGloballyWhitelisted = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(GLOBALS_WHITE_LISTED)));
const range = 2;

function generateCodeFrame(source, start = 0, end = source.length) {
  // Split the content into individual lines but capture the newline sequence
  // that separated each line. This is important because the actual sequence is
  // needed to properly take into account the full line length for offset
  // comparison
  let lines = source.split(/(\r?\n)/); // Separate the lines and newline sequences into separate arrays for easier referencing

  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];

  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);

    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;

        if (j === i) {
          // push underline
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + '^'.repeat(length));
          }

          count += lineLength + newLineSeqLength;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */


const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(specialBooleanAttrs)));
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */

const isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` + `loop,open,required,reversed,scoped,seamless,` + `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */

function includeBooleanAttr(value) {
  return !!value || value === '';
}

const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }

  const isUnsafe = unsafeAttrCharRE.test(name);

  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }

  return attrValidationCache[name] = !isUnsafe;
}

const propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */

const isNoUnitNumericStyleProp = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` + `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` + `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` + `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` + `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` + `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` + // SVG
`fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` + `stroke-miterlimit,stroke-opacity,stroke-width`)));
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */

const isKnownHtmlAttr = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` + `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` + `border,buffered,capture,challenge,charset,checked,cite,class,code,` + `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` + `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` + `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` + `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` + `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` + `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` + `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` + `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` + `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` + `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` + `start,step,style,summary,tabindex,target,title,translate,type,usemap,` + `value,width,wrap`)));
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */

const isKnownSvgAttr = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` + `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` + `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` + `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` + `color-interpolation-filters,color-profile,color-rendering,` + `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` + `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` + `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` + `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` + `font-family,font-size,font-size-adjust,font-stretch,font-style,` + `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` + `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` + `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` + `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` + `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` + `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` + `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` + `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` + `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` + `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` + `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` + `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` + `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` + `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` + `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` + `specularConstant,specularExponent,speed,spreadMethod,startOffset,` + `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` + `strikethrough-position,strikethrough-thickness,string,stroke,` + `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` + `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` + `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` + `text-decoration,text-rendering,textLength,to,transform,transform-origin,` + `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` + `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` + `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` + `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` + `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` + `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` + `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));

function normalizeStyle(value) {
  if (shared_esm_bundler_isArray(value)) {
    const res = {};

    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = shared_esm_bundler_isString(item) ? parseStringStyle(item) : normalizeStyle(item);

      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }

    return res;
  } else if (shared_esm_bundler_isString(value)) {
    return value;
  } else if (shared_esm_bundler_isObject(value)) {
    return value;
  }
}

const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;

function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function stringifyStyle(styles) {
  let ret = '';

  if (!styles || shared_esm_bundler_isString(styles)) {
    return ret;
  }

  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);

    if (shared_esm_bundler_isString(value) || typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey)) {
      // only render valid values
      ret += `${normalizedKey}:${value};`;
    }
  }

  return ret;
}

function normalizeClass(value) {
  let res = '';

  if (shared_esm_bundler_isString(value)) {
    res = value;
  } else if (shared_esm_bundler_isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);

      if (normalized) {
        res += normalized + ' ';
      }
    }
  } else if (shared_esm_bundler_isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + ' ';
      }
    }
  }

  return res.trim();
}

function normalizeProps(props) {
  if (!props) return null;
  let {
    class: klass,
    style
  } = props;

  if (klass && !shared_esm_bundler_isString(klass)) {
    props.class = normalizeClass(klass);
  }

  if (style) {
    props.style = normalizeStyle(style);
  }

  return props;
} // These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element


const HTML_TAGS = (/* unused pure expression or super */ null && ('html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot')); // https://developer.mozilla.org/en-US/docs/Web/SVG/Element

const SVG_TAGS = (/* unused pure expression or super */ null && ('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view'));
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */

const isHTMLTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(HTML_TAGS)));
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */

const isSVGTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(SVG_TAGS)));
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */

const isVoidTag = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap(VOID_TAGS)));
const escapeRE = /["'&<>]/;

function escapeHtml(string) {
  const str = '' + string;
  const match = escapeRE.exec(str);

  if (!match) {
    return str;
  }

  let html = '';
  let escaped;
  let index;
  let lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escaped = '&quot;';
        break;

      case 38:
        // &
        escaped = '&amp;';
        break;

      case 39:
        // '
        escaped = '&#39;';
        break;

      case 60:
        // <
        escaped = '&lt;';
        break;

      case 62:
        // >
        escaped = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escaped;
  }

  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
} // https://www.w3.org/TR/html52/syntax.html#comments


const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;

  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }

  return equal;
}

function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = isSymbol(a);
  bValidType = isSymbol(b);

  if (aValidType || bValidType) {
    return a === b;
  }

  aValidType = shared_esm_bundler_isArray(a);
  bValidType = shared_esm_bundler_isArray(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }

  aValidType = shared_esm_bundler_isObject(a);
  bValidType = shared_esm_bundler_isObject(b);

  if (aValidType || bValidType) {
    /* istanbul ignore if: this if will probably never be called */
    if (!aValidType || !bValidType) {
      return false;
    }

    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
}

function looseIndexOf(arr, val) {
  return arr.findIndex(item => looseEqual(item, val));
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */


const toDisplayString = val => {
  return shared_esm_bundler_isString(val) ? val : val == null ? '' : shared_esm_bundler_isArray(val) || shared_esm_bundler_isObject(val) && (val.toString === objectToString || !shared_esm_bundler_isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};

const replacer = (_key, val) => {
  // can't use isRef here since @vue/shared has no deps
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
        entries[`${key} =>`] = val;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (shared_esm_bundler_isObject(val) && !shared_esm_bundler_isArray(val) && !isPlainObject(val)) {
    return String(val);
  }

  return val;
};

const EMPTY_OBJ =  false ? 0 : {};
const EMPTY_ARR =  false ? 0 : [];

const NOOP = () => {};
/**
 * Always return false.
 */


const NO = () => false;

const onRE = /^on[^a-z]/;

const isOn = key => onRE.test(key);

const isModelListener = key => key.startsWith('onUpdate:');

const extend = Object.assign;

const remove = (arr, el) => {
  const i = arr.indexOf(el);

  if (i > -1) {
    arr.splice(i, 1);
  }
};

const shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;

const shared_esm_bundler_hasOwn = (val, key) => shared_esm_bundler_hasOwnProperty.call(val, key);

const shared_esm_bundler_isArray = Array.isArray;

const isMap = val => toTypeString(val) === '[object Map]';

const isSet = val => toTypeString(val) === '[object Set]';

const isDate = val => toTypeString(val) === '[object Date]';

const shared_esm_bundler_isFunction = val => typeof val === 'function';

const shared_esm_bundler_isString = val => typeof val === 'string';

const isSymbol = val => typeof val === 'symbol';

const shared_esm_bundler_isObject = val => val !== null && typeof val === 'object';

const isPromise = val => {
  return shared_esm_bundler_isObject(val) && shared_esm_bundler_isFunction(val.then) && shared_esm_bundler_isFunction(val.catch);
};

const objectToString = Object.prototype.toString;

const toTypeString = value => objectToString.call(value);

const toRawType = value => {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1);
};

const isPlainObject = val => toTypeString(val) === '[object Object]';

const isIntegerKey = key => shared_esm_bundler_isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;

const isReservedProp = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap( // the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted')));
const isBuiltInDirective = /*#__PURE__*/(/* unused pure expression or super */ null && (makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')));

const cacheStringFunction = fn => {
  const cache = Object.create(null);
  return str => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

const camelizeRE = /-(\w)/g;
/**
 * @private
 */

const shared_esm_bundler_camelize = cacheStringFunction(str => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */

const hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */

const capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */

const toHandlerKey = cacheStringFunction(str => str ? `on${capitalize(str)}` : ``); // compare whether a value has changed, accounting for NaN.

const hasChanged = (value, oldValue) => !Object.is(value, oldValue);

const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};

const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};

const toNumber = val => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};

let _globalThis;

const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});
};

const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;

function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/vue/install2.mjs


const withInstall = (main, extra) => {
  ;

  main.install = app => {
    for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };

  if (extra) {
    for (const [key, comp] of Object.entries(extra)) {
      ;
      main[key] = comp;
    }
  }

  return main;
};

const withInstallFunction = (fn, name) => {
  ;

  fn.install = app => {
    ;
    fn._context = app._context;
    app.config.globalProperties[name] = fn;
  };

  return fn;
};

const withNoopInstall = component => {
  ;
  component.install = NOOP;
  return component;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/index2.mjs










const ElPopper = withInstall(Popper);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-exception.stack.js
var web_dom_exception_stack = __webpack_require__(2801);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.at.js
var es_typed_array_at = __webpack_require__(8675);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.typed-array.find-last.js
var esnext_typed_array_find_last = __webpack_require__(7380);
// EXTERNAL MODULE: ./node_modules/core-js/modules/esnext.typed-array.find-last-index.js
var esnext_typed_array_find_last_index = __webpack_require__(1118);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__(1703);
;// CONCATENATED MODULE: ./node_modules/vue-demi/lib/index.mjs

var lib_isVue2 = false;
var lib_isVue3 = true;
var Vue2 = (/* unused pure expression or super */ null && (undefined));

function install() {}

function lib_set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  target[key] = val;
  return val;
}
function lib_del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }

  delete target[key];
}


;// CONCATENATED MODULE: ./node_modules/@vueuse/shared/index.mjs


var __defProp$9 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;

var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$b.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);

  if (__getOwnPropSymbols$b) for (var prop of __getOwnPropSymbols$b(b)) {
    if (__propIsEnum$b.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));

function computedEager(fn, options) {
  var _a;

  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, __spreadProps$6(__spreadValues$9({}, options), {
    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
  }));
  return readonly(result);
}

var _a;

const shared_isClient = typeof window !== "undefined";

const shared_isDef = val => typeof val !== "undefined";

const assert = (condition, ...infos) => {
  if (!condition) console.warn(...infos);
};

const shared_toString = Object.prototype.toString;

const shared_isBoolean = val => typeof val === "boolean";

const shared_isFunction = val => typeof val === "function";

const shared_isNumber = val => typeof val === "number";

const shared_isString = val => typeof val === "string";

const shared_isObject = val => shared_toString.call(val) === "[object Object]";

const isWindow = val => typeof window !== "undefined" && shared_toString.call(val) === "[object Window]";

const now = () => Date.now();

const shared_timestamp = () => +Date.now();

const shared_clamp = (n, min, max) => Math.min(max, Math.max(min, n));

const shared_noop = () => {};

const rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

const shared_isIOS = shared_isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

function shared_createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), {
      fn,
      thisArg: this,
      args
    });
  }

  return wrapper;
}

const shared_bypassFilter = invoke => {
  return invoke();
};

function shared_debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;

  const filter = invoke => {
    const duration = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ms);
    const maxDuration = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(options.maxWait);
    if (timer) clearTimeout(timer);

    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }

      return invoke();
    }

    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer) clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }

    timer = setTimeout(() => {
      if (maxTimer) clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };

  return filter;
}

function shared_throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let isLeading = true;

  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };

  const filter = invoke => {
    const duration = unref(ms);
    const elapsed = Date.now() - lastExec;
    clear();

    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }

    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        clear();
        invoke();
      }, duration);
    }

    if (!leading && !timer) timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
  };

  return filter;
}

function shared_pausableFilter(extendFilter = shared_bypassFilter) {
  const isActive = ref(true);

  function pause() {
    isActive.value = false;
  }

  function resume() {
    isActive.value = true;
  }

  const eventFilter = (...args) => {
    if (isActive.value) extendFilter(...args);
  };

  return {
    isActive,
    pause,
    resume,
    eventFilter
  };
}

function __onlyVue3(name = "this function") {
  if (isVue3) return;
  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
}

const directiveHooks = {
  mounted: lib_isVue3 ? "mounted" : "inserted",
  updated: lib_isVue3 ? "updated" : "componentUpdated",
  unmounted: lib_isVue3 ? "unmounted" : "unbind"
};

function shared_promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout) setTimeout(() => reject(reason), ms);else setTimeout(resolve, ms);
  });
}

function shared_identity(arg) {
  return arg;
}

function shared_createSingletonPromise(fn) {
  let _promise;

  function wrapper() {
    if (!_promise) _promise = fn();
    return _promise;
  }

  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev) await _prev;
  };

  return wrapper;
}

function invoke(fn) {
  return fn();
}

function shared_containsProp(obj, ...props) {
  return props.some(k => k in obj);
}

function shared_increaseWithUnit(target, delta) {
  var _a;

  if (typeof target === "number") return target + delta;
  const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
  const unit = target.slice(value.length);
  const result = parseFloat(value) + delta;
  if (Number.isNaN(result)) return target;
  return result + unit;
}

function shared_objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0) n[k] = obj[k];
    }

    return n;
  }, {});
}

function computedWithControl(source, fn) {
  let v = void 0;
  let track;
  let trigger;
  const dirty = ref(true);

  const update = () => {
    dirty.value = true;
    trigger();
  };

  watch(source, update, {
    flush: "sync"
  });
  const get = shared_isFunction(fn) ? fn : fn.get;
  const set = shared_isFunction(fn) ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v = get();
          dirty.value = false;
        }

        track();
        return v;
      },

      set(v2) {
        set == null ? void 0 : set(v2);
      }

    };
  });
  if (Object.isExtensible(result)) result.trigger = update;
  return result;
}

function shared_createEventHook() {
  const fns = [];

  const off = fn => {
    const index = fns.indexOf(fn);
    if (index !== -1) fns.splice(index, 1);
  };

  const on = fn => {
    fns.push(fn);
    return {
      off: () => off(fn)
    };
  };

  const trigger = param => {
    fns.forEach(fn => fn(param));
  };

  return {
    on,
    off,
    trigger
  };
}

function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = effectScope(true);
  return () => {
    if (!initialized) {
      state = scope.run(stateFactory);
      initialized = true;
    }

    return state;
  };
}

function createInjectionState(composable) {
  const key = Symbol("InjectionState");

  const useProvidingState = (...args) => {
    provide(key, composable(...args));
  };

  const useInjectedState = () => inject(key);

  return [useProvidingState, useInjectedState];
}

function shared_tryOnScopeDispose(fn) {
  if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentScope)()) {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onScopeDispose)(fn);
    return true;
  }

  return false;
}

function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;

  const dispose = () => {
    subscribers -= 1;

    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };

  return (...args) => {
    subscribers += 1;

    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }

    shared_tryOnScopeDispose(dispose);
    return state;
  };
}

function extendRef(ref, extend, {
  enumerable = false,
  unwrap = true
} = {}) {
  __onlyVue3();

  for (const [key, value] of Object.entries(extend)) {
    if (key === "value") continue;

    if (isRef(value) && unwrap) {
      Object.defineProperty(ref, key, {
        get() {
          return value.value;
        },

        set(v) {
          value.value = v;
        },

        enumerable
      });
    } else {
      Object.defineProperty(ref, key, {
        value,
        enumerable
      });
    }
  }

  return ref;
}

function get(obj, key) {
  if (key == null) return unref(obj);
  return unref(obj)[key];
}

function isDefined(v) {
  return unref(v) != null;
}

function logicAnd(...args) {
  return computed(() => args.every(i => unref(i)));
}

function logicNot(v) {
  return computed(() => !unref(v));
}

function logicOr(...args) {
  return computed(() => args.some(i => unref(i)));
}

var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;

var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$a.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);

  if (__getOwnPropSymbols$a) for (var prop of __getOwnPropSymbols$a(b)) {
    if (__propIsEnum$a.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);
  }
  return a;
};

function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = __spreadValues$8({}, obj);

    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,

      value() {
        let index = 0;
        return {
          next: () => ({
            value: arr[index++],
            done: index > arr.length
          })
        };
      }

    });
    return clone;
  } else {
    return Object.assign([...arr], obj);
  }
}

function reactify(fn) {
  return function (...args) {
    return computed(() => fn.apply(this, args.map(i => unref(i))));
  };
}

function reactifyObject(obj, optionsOrKeys = {}) {
  let keys = [];

  if (Array.isArray(optionsOrKeys)) {
    keys = optionsOrKeys;
  } else {
    const {
      includeOwnProperties = true
    } = optionsOrKeys;
    keys.push(...Object.keys(obj));
    if (includeOwnProperties) keys.push(...Object.getOwnPropertyNames(obj));
  }

  return Object.fromEntries(keys.map(key => {
    const value = obj[key];
    return [key, typeof value === "function" ? reactify(value.bind(obj)) : value];
  }));
}

function toReactive(objectRef) {
  if (!isRef(objectRef)) return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_, p, receiver) {
      return unref(Reflect.get(objectRef.value, p, receiver));
    },

    set(_, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value)) objectRef.value[p].value = value;else objectRef.value[p] = value;
      return true;
    },

    deleteProperty(_, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },

    has(_, p) {
      return Reflect.has(objectRef.value, p);
    },

    ownKeys() {
      return Object.keys(objectRef.value);
    },

    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }

  });
  return reactive(proxy);
}

function reactiveComputed(fn) {
  return toReactive(computed(fn));
}

function reactiveOmit(obj, ...keys) {
  const flatKeys = keys.flat();
  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter(e => !flatKeys.includes(e[0]))));
}

function reactivePick(obj, ...keys) {
  const flatKeys = keys.flat();
  return reactive(Object.fromEntries(flatKeys.map(k => [k, toRef(obj, k)])));
}

function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track, trigger) => {
    let value = defaultValue;
    let timer;

    const resetAfter = () => setTimeout(() => {
      value = defaultValue;
      trigger();
    }, unref(afterMs));

    shared_tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track();
        return value;
      },

      set(newValue) {
        value = newValue;
        trigger();
        clearTimeout(timer);
        timer = resetAfter();
      }

    };
  });
}

function shared_useDebounceFn(fn, ms = 200, options = {}) {
  return shared_createFilterWrapper(shared_debounceFilter(ms, options), fn);
}

function refDebounced(value, ms = 200, options = {}) {
  if (ms <= 0) return value;
  const debounced = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(value.value);
  const updater = shared_useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(value, () => updater());
  return debounced;
}

function refDefault(source, defaultValue) {
  return computed({
    get() {
      var _a;

      return (_a = source.value) != null ? _a : defaultValue;
    },

    set(value) {
      source.value = value;
    }

  });
}

function shared_useThrottleFn(fn, ms = 200, trailing = true, leading = true) {
  return shared_createFilterWrapper(shared_throttleFilter(ms, trailing, leading), fn);
}

function refThrottled(value, delay = 200, trailing = true, leading = true) {
  if (delay <= 0) return value;
  const throttled = ref(value.value);
  const updater = shared_useThrottleFn(() => {
    throttled.value = value.value;
  }, delay, trailing, leading);
  watch(value, () => updater());
  return throttled;
}

function refWithControl(initial, options = {}) {
  let source = initial;
  let track;
  let trigger;
  const ref = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        return get();
      },

      set(v) {
        set(v);
      }

    };
  });

  function get(tracking = true) {
    if (tracking) track();
    return source;
  }

  function set(value, triggering = true) {
    var _a, _b;

    if (value === source) return;
    const old = source;
    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false) return;
    source = value;
    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);
    if (triggering) trigger();
  }

  const untrackedGet = () => get(false);

  const silentSet = v => set(v, false);

  const peek = () => get(false);

  const lay = v => set(v, false);

  return extendRef(ref, {
    get,
    set,
    untrackedGet,
    silentSet,
    peek,
    lay
  }, {
    enumerable: true
  });
}

const controlledRef = (/* unused pure expression or super */ null && (refWithControl));

function resolveRef(r) {
  return typeof r === "function" ? computed(r) : ref(r);
}

function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}

function shared_set(...args) {
  if (args.length === 2) {
    const [ref, value] = args;
    ref.value = value;
  }

  if (args.length === 3) {
    if (isVue2) {
      set$1(...args);
    } else {
      const [target, key, value] = args;
      target[key] = value;
    }
  }
}

function shared_syncRef(left, right, options = {}) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both"
  } = options;
  let stop1, stop2;

  if (direction === "both" || direction === "ltr") {
    stop1 = watch(left, newValue => right.value = newValue, {
      flush,
      deep,
      immediate
    });
  }

  if (direction === "both" || direction === "rtl") {
    stop2 = watch(right, newValue => left.value = newValue, {
      flush,
      deep,
      immediate
    });
  }

  return () => {
    stop1 == null ? void 0 : stop1();
    stop2 == null ? void 0 : stop2();
  };
}

function syncRefs(source, targets, options = {}) {
  const {
    flush = "sync",
    deep = false,
    immediate = true
  } = options;
  if (!Array.isArray(targets)) targets = [targets];
  return watch(source, newValue => targets.forEach(target => target.value = newValue), {
    flush,
    deep,
    immediate
  });
}

var __defProp$7 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$9.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);

  if (__getOwnPropSymbols$9) for (var prop of __getOwnPropSymbols$9(b)) {
    if (__propIsEnum$9.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));

function shared_toRefs(objectRef) {
  if (!isRef(objectRef)) return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};

  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },

      set(v) {
        if (Array.isArray(objectRef.value)) {
          const copy = [...objectRef.value];
          copy[key] = v;
          objectRef.value = copy;
        } else {
          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), {
            [key]: v
          });

          Object.setPrototypeOf(newObject, objectRef.value);
          objectRef.value = newObject;
        }
      }

    }));
  }

  return result;
}

function shared_tryOnBeforeMount(fn, sync = true) {
  if (getCurrentInstance()) onBeforeMount(fn);else if (sync) fn();else nextTick(fn);
}

function tryOnBeforeUnmount(fn) {
  if (getCurrentInstance()) onBeforeUnmount(fn);
}

function shared_tryOnMounted(fn, sync = true) {
  if (getCurrentInstance()) onMounted(fn);else if (sync) fn();else nextTick(fn);
}

function shared_tryOnUnmounted(fn) {
  if (getCurrentInstance()) onUnmounted(fn);
}

function shared_until(r) {
  let isNot = false;

  function toMatch(condition, {
    flush = "sync",
    deep = false,
    timeout,
    throwOnTimeout
  } = {}) {
    let stop = null;
    const watcher = new Promise(resolve => {
      stop = watch(r, v => {
        if (condition(v) !== isNot) {
          stop == null ? void 0 : stop();
          resolve(v);
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher];

    if (timeout != null) {
      promises.push(shared_promiseTimeout(timeout, throwOnTimeout).then(() => unref(r)).finally(() => stop == null ? void 0 : stop()));
    }

    return Promise.race(promises);
  }

  function toBe(value, options) {
    if (!isRef(value)) return toMatch(v => v === value, options);
    const {
      flush = "sync",
      deep = false,
      timeout,
      throwOnTimeout
    } = options != null ? options : {};
    let stop = null;
    const watcher = new Promise(resolve => {
      stop = watch([r, value], ([v1, v2]) => {
        if (isNot !== (v1 === v2)) {
          stop == null ? void 0 : stop();
          resolve(v1);
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher];

    if (timeout != null) {
      promises.push(shared_promiseTimeout(timeout, throwOnTimeout).then(() => unref(r)).finally(() => {
        stop == null ? void 0 : stop();
        return unref(r);
      }));
    }

    return Promise.race(promises);
  }

  function toBeTruthy(options) {
    return toMatch(v => Boolean(v), options);
  }

  function toBeNull(options) {
    return toBe(null, options);
  }

  function toBeUndefined(options) {
    return toBe(void 0, options);
  }

  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }

  function toContains(value, options) {
    return toMatch(v => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(unref(value));
    }, options);
  }

  function changed(options) {
    return changedTimes(1, options);
  }

  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }

  if (Array.isArray(unref(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,

      get not() {
        isNot = !isNot;
        return this;
      }

    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,

      get not() {
        isNot = !isNot;
        return this;
      }

    };
    return instance;
  }
}

function useCounter(initialValue = 0, options = {}) {
  const count = ref(initialValue);
  const {
    max = Infinity,
    min = -Infinity
  } = options;

  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);

  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);

  const get = () => count.value;

  const set = val => count.value = val;

  const reset = (val = initialValue) => {
    initialValue = val;
    return set(val);
  };

  return {
    count,
    inc,
    dec,
    get,
    set,
    reset
  };
}

const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
const REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;

const formatDate = (date, formatStr) => {
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const matches = {
    YY: String(years).slice(-2),
    YYYY: years,
    M: month + 1,
    MM: `${month + 1}`.padStart(2, "0"),
    D: String(days),
    DD: `${days}`.padStart(2, "0"),
    H: String(hours),
    HH: `${hours}`.padStart(2, "0"),
    h: `${hours % 12 || 12}`.padStart(1, "0"),
    hh: `${hours % 12 || 12}`.padStart(2, "0"),
    m: String(minutes),
    mm: `${minutes}`.padStart(2, "0"),
    s: String(seconds),
    ss: `${seconds}`.padStart(2, "0"),
    SSS: `${milliseconds}`.padStart(3, "0"),
    d: day
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]);
};

const normalizeDate = date => {
  if (date === null) return new Date(NaN);
  if (date === void 0) return new Date();
  if (date instanceof Date) return new Date(date);

  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = date.match(REGEX_PARSE);

    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }

  return new Date(date);
};

function useDateFormat(date, formatStr = "HH:mm:ss") {
  return computed(() => formatDate(normalizeDate(unref(date)), unref(formatStr)));
}

function shared_useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);

  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }

  function pause() {
    isActive.value = false;
    clean();
  }

  function resume() {
    if (unref(interval) <= 0) return;
    isActive.value = true;
    if (immediateCallback) cb();
    clean();
    timer = setInterval(cb, unref(interval));
  }

  if (immediate && shared_isClient) resume();

  if (isRef(interval)) {
    const stopWatch = watch(interval, () => {
      if (isActive.value && shared_isClient) resume();
    });
    shared_tryOnScopeDispose(stopWatch);
  }

  shared_tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$8.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);

  if (__getOwnPropSymbols$8) for (var prop of __getOwnPropSymbols$8(b)) {
    if (__propIsEnum$8.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);
  }
  return a;
};

function useInterval(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    immediate = true
  } = options;
  const counter = ref(0);
  const controls = shared_useIntervalFn(() => counter.value += 1, interval, {
    immediate
  });

  if (exposeControls) {
    return __spreadValues$6({
      counter
    }, controls);
  } else {
    return counter;
  }
}

function useLastChanged(source, options = {}) {
  var _a;

  const ms = ref((_a = options.initialValue) != null ? _a : null);
  watch(source, () => ms.value = shared_timestamp(), options);
  return ms;
}

function shared_useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  let timer = null;

  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }

  function stop() {
    isPending.value = false;
    clear();
  }

  function start(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(interval));
  }

  if (immediate) {
    isPending.value = true;
    if (shared_isClient) start();
  }

  shared_tryOnScopeDispose(stop);
  return {
    isPending,
    start,
    stop
  };
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$7.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);

  if (__getOwnPropSymbols$7) for (var prop of __getOwnPropSymbols$7(b)) {
    if (__propIsEnum$7.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);
  }
  return a;
};

function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false
  } = options;
  const controls = shared_useTimeoutFn(shared_noop, interval, options);
  const ready = computed(() => !controls.isPending.value);

  if (exposeControls) {
    return __spreadValues$5({
      ready
    }, controls);
  } else {
    return ready;
  }
}

function useToggle(initialValue = false, options = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options;
  const valueIsRef = isRef(initialValue);
  const innerValue = ref(initialValue);

  function toggle(value) {
    if (arguments.length) {
      innerValue.value = value;
      return innerValue.value;
    } else {
      innerValue.value = innerValue.value === unref(truthyValue) ? unref(falsyValue) : unref(truthyValue);
      return innerValue.value;
    }
  }

  if (valueIsRef) return toggle;else return [innerValue, toggle];
}

function watchArray(source, cb, options) {
  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...(source instanceof Function ? source() : Array.isArray(source) ? source : unref(source))];
  return watch(source, (newList, _, onCleanup) => {
    const oldListRemains = new Array(oldList.length);
    const added = [];

    for (const obj of newList) {
      let found = false;

      for (let i = 0; i < oldList.length; i++) {
        if (!oldListRemains[i] && obj === oldList[i]) {
          oldListRemains[i] = true;
          found = true;
          break;
        }
      }

      if (!found) added.push(obj);
    }

    const removed = oldList.filter((_2, i) => !oldListRemains[i]);
    cb(newList, oldList, added, removed, onCleanup);
    oldList = [...newList];
  }, options);
}

var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;

var __objRest$5 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$6) for (var prop of __getOwnPropSymbols$6(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function shared_watchWithFilter(source, cb, options = {}) {
  const _a = options,
        {
    eventFilter = shared_bypassFilter
  } = _a,
        watchOptions = __objRest$5(_a, ["eventFilter"]);

  return watch(source, shared_createFilterWrapper(eventFilter, cb), watchOptions);
}

var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;

var __objRest$4 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$5) for (var prop of __getOwnPropSymbols$5(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function watchAtMost(source, cb, options) {
  const _a = options,
        {
    count
  } = _a,
        watchOptions = __objRest$4(_a, ["count"]);

  const current = ref(0);
  const stop = shared_watchWithFilter(source, (...args) => {
    current.value += 1;
    if (current.value >= unref(count)) nextTick(() => stop());
    cb(...args);
  }, watchOptions);
  return {
    count: current,
    stop
  };
}

var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$4.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);

  if (__getOwnPropSymbols$4) for (var prop of __getOwnPropSymbols$4(b)) {
    if (__propIsEnum$4.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));

var __objRest$3 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$4) for (var prop of __getOwnPropSymbols$4(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function watchDebounced(source, cb, options = {}) {
  const _a = options,
        {
    debounce = 0,
    maxWait = void 0
  } = _a,
        watchOptions = __objRest$3(_a, ["debounce", "maxWait"]);

  return shared_watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {
    eventFilter: shared_debounceFilter(debounce, {
      maxWait
    })
  }));
}

var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);

  if (__getOwnPropSymbols$3) for (var prop of __getOwnPropSymbols$3(b)) {
    if (__propIsEnum$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));

var __objRest$2 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$3) for (var prop of __getOwnPropSymbols$3(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function shared_watchIgnorable(source, cb, options = {}) {
  const _a = options,
        {
    eventFilter = shared_bypassFilter
  } = _a,
        watchOptions = __objRest$2(_a, ["eventFilter"]);

  const filteredCb = shared_createFilterWrapper(eventFilter, cb);
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop;

  if (watchOptions.flush === "sync") {
    const ignore = ref(false);

    ignorePrevAsyncUpdates = () => {};

    ignoreUpdates = updater => {
      ignore.value = true;
      updater();
      ignore.value = false;
    };

    stop = watch(source, (...args) => {
      if (!ignore.value) filteredCb(...args);
    }, watchOptions);
  } else {
    const disposables = [];
    const ignoreCounter = ref(0);
    const syncCounter = ref(0);

    ignorePrevAsyncUpdates = () => {
      ignoreCounter.value = syncCounter.value;
    };

    disposables.push(watch(source, () => {
      syncCounter.value++;
    }, __spreadProps$3(__spreadValues$3({}, watchOptions), {
      flush: "sync"
    })));

    ignoreUpdates = updater => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    };

    disposables.push(watch(source, (...args) => {
      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
      ignoreCounter.value = 0;
      syncCounter.value = 0;
      if (ignore) return;
      filteredCb(...args);
    }, watchOptions));

    stop = () => {
      disposables.forEach(fn => fn());
    };
  }

  return {
    stop,
    ignoreUpdates,
    ignorePrevAsyncUpdates
  };
}

function watchOnce(source, cb, options) {
  const stop = watch(source, (...args) => {
    nextTick(() => stop());
    return cb(...args);
  }, options);
}

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);

  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {
    if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));

var __objRest$1 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function watchPausable(source, cb, options = {}) {
  const _a = options,
        {
    eventFilter: filter
  } = _a,
        watchOptions = __objRest$1(_a, ["eventFilter"]);

  const {
    eventFilter,
    pause,
    resume,
    isActive
  } = shared_pausableFilter(filter);
  const stop = shared_watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return {
    stop,
    pause,
    resume,
    isActive
  };
}

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);

  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {
    if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));

var __objRest = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function watchThrottled(source, cb, options = {}) {
  const _a = options,
        {
    throttle = 0,
    trailing = true,
    leading = true
  } = _a,
        watchOptions = __objRest(_a, ["throttle", "trailing", "leading"]);

  return shared_watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {
    eventFilter: shared_throttleFilter(throttle, trailing, leading)
  }));
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);

  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {
    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

function watchTriggerable(source, cb, options = {}) {
  let cleanupFn;

  function onEffect() {
    if (!cleanupFn) return;
    const fn = cleanupFn;
    cleanupFn = void 0;
    fn();
  }

  function onCleanup(callback) {
    cleanupFn = callback;
  }

  const _cb = (value, oldValue) => {
    onEffect();
    return cb(value, oldValue, onCleanup);
  };

  const res = shared_watchIgnorable(source, _cb, options);
  const {
    ignoreUpdates
  } = res;

  const trigger = () => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  };

  return __spreadProps(__spreadValues({}, res), {
    trigger
  });
}

function getWatchSources(sources) {
  if (isReactive(sources)) return sources;
  if (Array.isArray(sources)) return sources.map(item => getOneWatchSource(item));
  return getOneWatchSource(sources);
}

function getOneWatchSource(source) {
  return typeof source === "function" ? source() : unref(source);
}

function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}

function whenever(source, cb, options) {
  return watch(source, (v, ov, onInvalidate) => {
    if (v) cb(v, ov, onInvalidate);
  }, options);
}


;// CONCATENATED MODULE: ./node_modules/@vueuse/core/index.mjs









function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options;

  if (isRef(optionsOrRef)) {
    options = {
      evaluating: optionsOrRef
    };
  } else {
    options = optionsOrRef || {};
  }

  const {
    lazy = false,
    evaluating = void 0,
    onError = noop
  } = options;
  const started = ref(!lazy);
  const current = ref(initialState);
  let counter = 0;
  watchEffect(async onInvalidate => {
    if (!started.value) return;
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;

    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }

    try {
      const result = await evaluationCallback(cancelCallback => {
        onInvalidate(() => {
          if (evaluating) evaluating.value = false;
          if (!hasFinished) cancelCallback();
        });
      });
      if (counterAtBeginning === counter) current.value = result;
    } catch (e) {
      onError(e);
    } finally {
      if (evaluating && counterAtBeginning === counter) evaluating.value = false;
      hasFinished = true;
    }
  });

  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}

function computedInject(key, options, defaultSource, treatDefaultAsFactory) {
  let source = inject(key);
  if (defaultSource) source = inject(key, defaultSource);
  if (treatDefaultAsFactory) source = inject(key, defaultSource, treatDefaultAsFactory);

  if (typeof options === "function") {
    return computed(ctx => options(source, ctx));
  } else {
    return computed({
      get: ctx => options.get(source, ctx),
      set: options.set
    });
  }
}

const createUnrefFn = fn => {
  return function (...args) {
    return fn.apply(this, args.map(i => unref(i)));
  };
};

function unrefElement(elRef) {
  var _a;

  const plain = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}

const defaultWindow = shared_isClient ? window : void 0;
const defaultDocument = shared_isClient ? window.document : void 0;
const defaultNavigator = shared_isClient ? window.navigator : void 0;
const defaultLocation = shared_isClient ? window.location : void 0;

function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;

  if (shared_isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }

  if (!target) return shared_noop;
  let cleanup = shared_noop;
  const stopWatch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => unrefElement(target), el => {
    cleanup();
    if (!el) return;
    el.addEventListener(event, listener, options);

    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = shared_noop;
    };
  }, {
    immediate: true,
    flush: "post"
  });

  const stop = () => {
    stopWatch();
    cleanup();
  };

  shared_tryOnScopeDispose(stop);
  return stop;
}

function onClickOutside(target, handler, options = {}) {
  const {
    window = defaultWindow,
    ignore,
    capture = true,
    detectIframe = false
  } = options;
  if (!window) return;
  const shouldListen = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(true);
  let fallback;

  const listener = event => {
    window.clearTimeout(fallback);
    const el = unrefElement(target);
    const composedPath = event.composedPath();
    if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value) return;

    if (ignore && ignore.length > 0) {
      if (ignore.some(target2 => {
        const el2 = unrefElement(target2);
        return el2 && (event.target === el2 || composedPath.includes(el2));
      })) return;
    }

    handler(event);
  };

  const cleanup = [useEventListener(window, "click", listener, {
    passive: true,
    capture
  }), useEventListener(window, "pointerdown", e => {
    const el = unrefElement(target);
    shouldListen.value = !!el && !e.composedPath().includes(el);
  }, {
    passive: true
  }), useEventListener(window, "pointerup", e => {
    if (e.button === 0) {
      const path = e.composedPath();

      e.composedPath = () => path;

      fallback = window.setTimeout(() => listener(e), 50);
    }
  }, {
    passive: true
  }), detectIframe && useEventListener(window, "blur", event => {
    var _a;

    const el = unrefElement(target);
    if (((_a = document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(document.activeElement))) handler(event);
  })].filter(Boolean);

  const stop = () => cleanup.forEach(fn => fn());

  return stop;
}

var __defProp$j = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;

var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$l.call(b, prop)) __defNormalProp$j(a, prop, b[prop]);

  if (__getOwnPropSymbols$l) for (var prop of __getOwnPropSymbols$l(b)) {
    if (__propIsEnum$l.call(b, prop)) __defNormalProp$j(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));

const createKeyPredicate = keyFilter => {
  if (typeof keyFilter === "function") return keyFilter;else if (typeof keyFilter === "string") return event => event.key === keyFilter;else if (Array.isArray(keyFilter)) return event => keyFilter.includes(event.key);else if (keyFilter) return () => true;else return () => false;
};

function onKeyStroke(key, handler, options = {}) {
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false
  } = options;
  const predicate = createKeyPredicate(key);

  const listener = e => {
    if (predicate(e)) handler(e);
  };

  return useEventListener(target, eventName, listener, passive);
}

function onKeyDown(key, handler, options = {}) {
  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$j({}, options), {
    eventName: "keydown"
  }));
}

function onKeyPressed(key, handler, options = {}) {
  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$j({}, options), {
    eventName: "keypress"
  }));
}

function onKeyUp(key, handler, options = {}) {
  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$j({}, options), {
    eventName: "keyup"
  }));
}

const DEFAULT_DELAY = 500;

function onLongPress(target, handler, options) {
  var _a, _b;

  const elementRef = computed(() => unrefElement(target));
  let timeout = null;

  function clear() {
    if (timeout != null) {
      clearTimeout(timeout);
      timeout = null;
    }
  }

  function onDown(ev) {
    var _a2, _b2, _c, _d;

    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value) return;
    clear();
    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent) ev.preventDefault();
    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop) ev.stopPropagation();
    timeout = setTimeout(() => handler(ev), (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY);
  }

  const listenerOptions = {
    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once
  };
  useEventListener(elementRef, "pointerdown", onDown, listenerOptions);
  useEventListener(elementRef, "pointerup", clear, listenerOptions);
  useEventListener(elementRef, "pointerleave", clear, listenerOptions);
}

const isFocusedElementEditable = () => {
  const {
    activeElement,
    body
  } = document;
  if (!activeElement) return false;
  if (activeElement === body) return false;

  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }

  return activeElement.hasAttribute("contenteditable");
};

const isTypedCharValid = ({
  keyCode,
  metaKey,
  ctrlKey,
  altKey
}) => {
  if (metaKey || ctrlKey || altKey) return false;
  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105) return true;
  if (keyCode >= 65 && keyCode <= 90) return true;
  return false;
};

function onStartTyping(callback, options = {}) {
  const {
    document: document2 = defaultDocument
  } = options;

  const keydown = event => {
    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);
  };

  if (document2) useEventListener(document2, "keydown", keydown, {
    passive: true
  });
}

function templateRef(key, initialValue = null) {
  const instance = getCurrentInstance();

  let _trigger = () => {};

  const element = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        var _a, _b;

        track();
        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
      },

      set() {}

    };
  });
  tryOnMounted(_trigger);
  onUpdated(_trigger);
  return element;
}

function useActiveElement(options = {}) {
  const {
    window = defaultWindow
  } = options;
  const counter = ref(0);

  if (window) {
    useEventListener(window, "blur", () => counter.value += 1, true);
    useEventListener(window, "focus", () => counter.value += 1, true);
  }

  return computed(() => {
    counter.value;
    return window == null ? void 0 : window.document.activeElement;
  });
}

function useAsyncQueue(tasks, options = {}) {
  const {
    interrupt = true,
    onError = noop,
    onFinished = noop
  } = options;
  const promiseState = {
    pending: "pending",
    rejected: "rejected",
    fulfilled: "fulfilled"
  };
  const initialResult = Array.from(new Array(tasks.length), () => ({
    state: promiseState.pending,
    data: null
  }));
  const result = reactive(initialResult);
  const activeIndex = ref(-1);

  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex,
      result
    };
  }

  function updateResult(state, res) {
    activeIndex.value++;
    result[activeIndex.value].data = res;
    result[activeIndex.value].state = state;
  }

  tasks.reduce((prev, curr) => {
    return prev.then(prevRes => {
      var _a;

      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }

      return curr(prevRes).then(currentRes => {
        updateResult(promiseState.fulfilled, currentRes);
        activeIndex.value === tasks.length - 1 && onFinished();
        return currentRes;
      });
    }).catch(e => {
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex,
    result
  };
}

function useAsyncState(promise, initialState, options) {
  const {
    immediate = true,
    delay = 0,
    onError = noop,
    resetOnExecute = true,
    shallow = true
  } = options != null ? options : {};
  const state = shallow ? shallowRef(initialState) : ref(initialState);
  const isReady = ref(false);
  const isLoading = ref(false);
  const error = ref(void 0);

  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute) state.value = initialState;
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0) await promiseTimeout(delay2);

    const _promise = typeof promise === "function" ? promise(...args) : promise;

    try {
      const data = await _promise;
      state.value = data;
      isReady.value = true;
    } catch (e) {
      error.value = e;
      onError(e);
    } finally {
      isLoading.value = false;
    }

    return state.value;
  }

  if (immediate) execute(delay);
  return {
    state,
    isReady,
    isLoading,
    error,
    execute
  };
}

const defaults = {
  array: v => JSON.stringify(v),
  object: v => JSON.stringify(v),
  set: v => JSON.stringify(Array.from(v)),
  map: v => JSON.stringify(Object.fromEntries(v)),
  null: () => ""
};

function getDefaultSerialization(target) {
  if (!target) return defaults.null;
  if (target instanceof Map) return defaults.map;else if (target instanceof Set) return defaults.set;else if (Array.isArray(target)) return defaults.array;else return defaults.object;
}

function useBase64(target, options) {
  const base64 = ref("");
  const promise = ref();

  function execute() {
    if (!isClient) return;
    promise.value = new Promise((resolve, reject) => {
      try {
        const _target = unref(target);

        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], {
            type: "text/plain"
          })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);

          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);

          const serialized = _serializeFn(_target);

          return resolve(blobToBase64(new Blob([serialized], {
            type: "application/json"
          })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    promise.value.then(res => base64.value = res);
    return promise.value;
  }

  if (isRef(target)) watch(target, execute, {
    immediate: true
  });else execute();
  return {
    base64,
    promise,
    execute
  };
}

function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };

      img.onerror = reject;
    } else {
      resolve();
    }
  });
}

function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();

    fr.onload = e => {
      resolve(e.target.result);
    };

    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}

function useBattery({
  navigator = defaultNavigator
} = {}) {
  const events = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported = navigator && "getBattery" in navigator;
  const charging = ref(false);
  const chargingTime = ref(0);
  const dischargingTime = ref(0);
  const level = ref(1);
  let battery;

  function updateBatteryInfo() {
    charging.value = this.charging;
    chargingTime.value = this.chargingTime || 0;
    dischargingTime.value = this.dischargingTime || 0;
    level.value = this.level;
  }

  if (isSupported) {
    navigator.getBattery().then(_battery => {
      battery = _battery;
      updateBatteryInfo.call(battery);

      for (const event of events) useEventListener(battery, event, updateBatteryInfo, {
        passive: true
      });
    });
  }

  return {
    isSupported,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}

function useBluetooth(options) {
  let {
    acceptAllDevices = false
  } = options || {};
  const {
    filters = void 0,
    optionalServices = void 0,
    navigator = defaultNavigator
  } = options || {};
  const isSupported = navigator && "bluetooth" in navigator;
  const device = ref(void 0);
  const error = ref(null);
  watch(device, () => {
    connectToBluetoothGATTServer();
  });

  async function requestDevice() {
    if (!isSupported) return;
    error.value = null;
    if (filters && filters.length > 0) acceptAllDevices = false;

    try {
      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
    } catch (err) {
      error.value = err;
    }
  }

  const server = ref();
  const isConnected = computed(() => {
    var _a;

    return ((_a = server.value) == null ? void 0 : _a.connected) || false;
  });

  async function connectToBluetoothGATTServer() {
    error.value = null;

    if (device.value && device.value.gatt) {
      device.value.addEventListener("gattserverdisconnected", () => {});

      try {
        server.value = await device.value.gatt.connect();
      } catch (err) {
        error.value = err;
      }
    }
  }

  tryOnMounted(() => {
    var _a;

    if (device.value) (_a = device.value.gatt) == null ? void 0 : _a.connect();
  });
  tryOnScopeDispose(() => {
    var _a;

    if (device.value) (_a = device.value.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported,
    isConnected,
    device,
    requestDevice,
    server,
    error
  };
}

function useMediaQuery(query, options = {}) {
  const {
    window = defaultWindow
  } = options;
  const isSupported = Boolean(window && "matchMedia" in window && typeof window.matchMedia === "function");
  let mediaQuery;
  const matches = ref(false);

  const update = () => {
    if (!isSupported) return;
    if (!mediaQuery) mediaQuery = window.matchMedia(query);
    matches.value = mediaQuery.matches;
  };

  tryOnBeforeMount(() => {
    update();
    if (!mediaQuery) return;
    if ("addEventListener" in mediaQuery) mediaQuery.addEventListener("change", update);else mediaQuery.addListener(update);
    tryOnScopeDispose(() => {
      if ("removeEventListener" in mediaQuery) mediaQuery.removeEventListener("change", update);else mediaQuery.removeListener(update);
    });
  });
  return matches;
}

const breakpointsTailwind = {
  "sm": 640,
  "md": 768,
  "lg": 1024,
  "xl": 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetify = {
  xs: 600,
  sm: 960,
  md: 1264,
  lg: 1904
};
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 600,
  sm: 1024,
  md: 1440,
  lg: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
var __defProp$i = Object.defineProperty;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;

var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$k.call(b, prop)) __defNormalProp$i(a, prop, b[prop]);

  if (__getOwnPropSymbols$k) for (var prop of __getOwnPropSymbols$k(b)) {
    if (__propIsEnum$k.call(b, prop)) __defNormalProp$i(a, prop, b[prop]);
  }
  return a;
};

function useBreakpoints(breakpoints, options = {}) {
  function getValue(k, delta) {
    let v = breakpoints[k];
    if (delta != null) v = increaseWithUnit(v, delta);
    if (typeof v === "number") v = `${v}px`;
    return v;
  }

  const {
    window = defaultWindow
  } = options;

  function match(query) {
    if (!window) return false;
    return window.matchMedia(query).matches;
  }

  const greater = k => {
    return useMediaQuery(`(min-width: ${getValue(k)})`, options);
  };

  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: () => greater(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  return __spreadValues$i({
    greater,

    smaller(k) {
      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);
    },

    between(a, b) {
      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);
    },

    isGreater(k) {
      return match(`(min-width: ${getValue(k)})`);
    },

    isSmaller(k) {
      return match(`(max-width: ${getValue(k, -0.1)})`);
    },

    isInBetween(a, b) {
      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);
    }

  }, shortcutMethods);
}

const useBroadcastChannel = options => {
  const {
    name,
    window = defaultWindow
  } = options;
  const isSupported = window && "BroadcastChannel" in window;
  const isClosed = ref(false);
  const channel = ref();
  const data = ref();
  const error = ref(null);

  const post = data2 => {
    if (channel.value) channel.value.postMessage(data2);
  };

  const close = () => {
    if (channel.value) channel.value.close();
    isClosed.value = true;
  };

  if (isSupported) {
    tryOnMounted(() => {
      error.value = null;
      channel.value = new BroadcastChannel(name);
      channel.value.addEventListener("message", e => {
        data.value = e.data;
      }, {
        passive: true
      });
      channel.value.addEventListener("messageerror", e => {
        error.value = e;
      }, {
        passive: true
      });
      channel.value.addEventListener("close", () => {
        isClosed.value = true;
      });
    });
  }

  tryOnScopeDispose(() => {
    close();
  });
  return {
    isSupported,
    channel,
    data,
    post,
    close,
    error,
    isClosed
  };
};

function useBrowserLocation({
  window = defaultWindow
} = {}) {
  const buildState = trigger => {
    const {
      state: state2,
      length
    } = (window == null ? void 0 : window.history) || {};
    const {
      hash,
      host,
      hostname,
      href,
      origin,
      pathname,
      port,
      protocol,
      search
    } = (window == null ? void 0 : window.location) || {};
    return {
      trigger,
      state: state2,
      length,
      hash,
      host,
      hostname,
      href,
      origin,
      pathname,
      port,
      protocol,
      search
    };
  };

  const state = ref(buildState("load"));

  if (window) {
    useEventListener(window, "popstate", () => state.value = buildState("popstate"), {
      passive: true
    });
    useEventListener(window, "hashchange", () => state.value = buildState("hashchange"), {
      passive: true
    });
  }

  return state;
}

function useCached(refValue, comparator = (a, b) => a === b, watchOptions) {
  const cachedValue = ref(refValue.value);
  watch(() => refValue.value, value => {
    if (!comparator(value, cachedValue.value)) cachedValue.value = value;
  }, watchOptions);
  return cachedValue;
}

function useClamp(value, min, max) {
  const _value = ref(value);

  return computed({
    get() {
      return _value.value = clamp(_value.value, unref(min), unref(max));
    },

    set(value2) {
      _value.value = clamp(value2, unref(min), unref(max));
    }

  });
}

function useClipboard(options = {}) {
  const {
    navigator = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500
  } = options;
  const events = ["copy", "cut"];
  const isSupported = Boolean(navigator && "clipboard" in navigator);
  const text = ref("");
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);

  function updateText() {
    navigator.clipboard.readText().then(value => {
      text.value = value;
    });
  }

  if (isSupported && read) {
    for (const event of events) useEventListener(event, updateText);
  }

  async function copy(value = unref(source)) {
    if (isSupported && value != null) {
      await navigator.clipboard.writeText(value);
      text.value = value;
      copied.value = true;
      timeout.start();
    }
  }

  return {
    isSupported,
    text,
    copied,
    copy
  };
}

const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
const handlers = _global[globalKey];

function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}

function setSSRHandler(key, fn) {
  handlers[key] = fn;
}

function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}

const StorageSerializers = {
  boolean: {
    read: v => v === "true",
    write: v => String(v)
  },
  object: {
    read: v => JSON.parse(v),
    write: v => JSON.stringify(v)
  },
  number: {
    read: v => Number.parseFloat(v),
    write: v => String(v)
  },
  any: {
    read: v => v,
    write: v => String(v)
  },
  string: {
    read: v => v,
    write: v => String(v)
  },
  map: {
    read: v => new Map(JSON.parse(v)),
    write: v => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: v => new Set(JSON.parse(v)),
    write: v => JSON.stringify(Array.from(v))
  },
  date: {
    read: v => new Date(v),
    write: v => v.toISOString()
  }
};

function useStorage(key, initialValue, storage, options = {}) {
  var _a;

  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window = defaultWindow,
    eventFilter,
    onError = e => {
      console.error(e);
    }
  } = options;
  const data = (shallow ? shallowRef : ref)(initialValue);

  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;

        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }

  if (!storage) return data;
  const rawInit = unref(initialValue);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  const {
    pause: pauseWatch,
    resume: resumeWatch
  } = pausableWatch(data, () => write(data.value), {
    flush,
    deep,
    eventFilter
  });
  if (window && listenToStorageChanges) useEventListener(window, "storage", update);
  update();
  return data;

  function write(v) {
    try {
      if (v == null) storage.removeItem(key);else storage.setItem(key, serializer.write(v));
    } catch (e) {
      onError(e);
    }
  }

  function read(event) {
    if (event && event.key !== key) return;
    pauseWatch();

    try {
      const rawValue = event ? event.newValue : storage.getItem(key);

      if (rawValue == null) {
        if (writeDefaults && rawInit !== null) storage.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    } finally {
      resumeWatch();
    }
  }

  function update(event) {
    if (event && event.key !== key) return;
    data.value = read(event);
  }
}

function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}

var __defProp$h = Object.defineProperty;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;

var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$j.call(b, prop)) __defNormalProp$h(a, prop, b[prop]);

  if (__getOwnPropSymbols$j) for (var prop of __getOwnPropSymbols$j(b)) {
    if (__propIsEnum$j.call(b, prop)) __defNormalProp$h(a, prop, b[prop]);
  }
  return a;
};

function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    window = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto
  } = options;

  const modes = __spreadValues$h({
    auto: "",
    light: "light",
    dark: "dark"
  }, options.modes || {});

  const preferredDark = usePreferredDark({
    window
  });
  const preferredMode = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? ref("auto") : useStorage(storageKey, "auto", storage, {
    window,
    listenToStorageChanges
  }));
  const state = computed({
    get() {
      return store.value === "auto" && !emitAuto ? preferredMode.value : store.value;
    },

    set(v) {
      store.value = v;
    }

  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value) => {
    const el = window == null ? void 0 : window.document.querySelector(selector2);
    if (!el) return;

    if (attribute2 === "class") {
      const current = value.split(/\s/g);
      Object.values(modes).flatMap(i => (i || "").split(/\s/g)).filter(Boolean).forEach(v => {
        if (current.includes(v)) el.classList.add(v);else el.classList.remove(v);
      });
    } else {
      el.setAttribute(attribute2, value);
    }
  });

  function defaultOnChanged(mode) {
    var _a;

    const resolvedMode = mode === "auto" ? preferredMode.value : mode;
    updateHTMLAttrs(selector, attribute, (_a = modes[resolvedMode]) != null ? _a : resolvedMode);
  }

  function onChanged(mode) {
    if (options.onChanged) options.onChanged(mode, defaultOnChanged);else defaultOnChanged(mode);
  }

  watch(state, onChanged, {
    flush: "post",
    immediate: true
  });
  tryOnMounted(() => onChanged(state.value));
  return state;
}

function useConfirmDialog(revealed = ref(false)) {
  const confirmHook = createEventHook();
  const cancelHook = createEventHook();
  const revealHook = createEventHook();
  let _resolve = noop;

  const reveal = data => {
    revealHook.trigger(data);
    revealed.value = true;
    return new Promise(resolve => {
      _resolve = resolve;
    });
  };

  const confirm = data => {
    revealed.value = false;
    confirmHook.trigger(data);

    _resolve({
      data,
      isCanceled: false
    });
  };

  const cancel = data => {
    revealed.value = false;
    cancelHook.trigger(data);

    _resolve({
      data,
      isCanceled: true
    });
  };

  return {
    isRevealed: computed(() => revealed.value),
    reveal,
    confirm,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
}

function useCssVar(prop, target, {
  window = defaultWindow,
  initialValue = ""
} = {}) {
  const variable = ref(initialValue);
  const elRef = computed(() => {
    var _a;

    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);
  });
  watch([elRef, () => unref(prop)], ([el, prop2]) => {
    var _a;

    if (el && window) {
      const value = (_a = window.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();
      variable.value = value || initialValue;
    }
  }, {
    immediate: true
  });
  watch(variable, val => {
    var _a;

    if ((_a = elRef.value) == null ? void 0 : _a.style) elRef.value.style.setProperty(unref(prop), val);
  });
  return variable;
}

function useCurrentElement() {
  const vm = getCurrentInstance();
  const count = ref(0);
  onUpdated(() => {
    count.value += 1;
  });
  onMounted(() => {
    count.value += 1;
  });
  return computed(() => {
    count.value;
    return vm.proxy.$el;
  });
}

function useCycleList(list, options) {
  var _a;

  const state = shallowRef((_a = options == null ? void 0 : options.initialValue) != null ? _a : list[0]);
  const index = computed({
    get() {
      var _a2;

      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);
      if (index2 < 0) index2 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;
      return index2;
    },

    set(v) {
      set(v);
    }

  });

  function set(i) {
    const length = list.length;
    const index2 = (i % length + length) % length;
    const value = list[index2];
    state.value = value;
    return value;
  }

  function shift(delta = 1) {
    return set(index.value + delta);
  }

  function next(n = 1) {
    return shift(n);
  }

  function prev(n = 1) {
    return shift(-n);
  }

  return {
    state,
    index,
    next,
    prev
  };
}

var __defProp$g = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;

var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$i.call(b, prop)) __defNormalProp$g(a, prop, b[prop]);

  if (__getOwnPropSymbols$i) for (var prop of __getOwnPropSymbols$i(b)) {
    if (__propIsEnum$i.call(b, prop)) __defNormalProp$g(a, prop, b[prop]);
  }
  return a;
};

var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));

function useDark(options = {}) {
  const {
    valueDark = "dark",
    valueLight = "",
    window = defaultWindow
  } = options;
  const mode = useColorMode(__spreadProps$7(__spreadValues$g({}, options), {
    onChanged: (mode2, defaultHandler) => {
      var _a;

      if (options.onChanged) (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === "dark");else defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  }));
  const preferredDark = usePreferredDark({
    window
  });
  const isDark = computed({
    get() {
      return mode.value === "dark";
    },

    set(v) {
      if (v === preferredDark.value) mode.value = "auto";else mode.value = v ? "dark" : "light";
    }

  });
  return isDark;
}

const fnClone = v => JSON.parse(JSON.stringify(v));

const fnBypass = v => v;

const fnSetSource = (source, value) => source.value = value;

function defaultDump(clone) {
  return clone ? isFunction(clone) ? clone : fnClone : fnBypass;
}

function defaultParse(clone) {
  return clone ? isFunction(clone) ? clone : fnClone : fnBypass;
}

function useManualRefHistory(source, options = {}) {
  const {
    clone = false,
    dump = defaultDump(clone),
    parse = defaultParse(clone),
    setSource = fnSetSource
  } = options;

  function _createHistoryRecord() {
    return markRaw({
      snapshot: dump(source.value),
      timestamp: timestamp()
    });
  }

  const last = ref(_createHistoryRecord());
  const undoStack = ref([]);
  const redoStack = ref([]);

  const _setSource = record => {
    setSource(source, parse(record.snapshot));
    last.value = record;
  };

  const commit = () => {
    undoStack.value.unshift(last.value);
    last.value = _createHistoryRecord();
    if (options.capacity && undoStack.value.length > options.capacity) undoStack.value.splice(options.capacity, Infinity);
    if (redoStack.value.length) redoStack.value.splice(0, redoStack.value.length);
  };

  const clear = () => {
    undoStack.value.splice(0, undoStack.value.length);
    redoStack.value.splice(0, redoStack.value.length);
  };

  const undo = () => {
    const state = undoStack.value.shift();

    if (state) {
      redoStack.value.unshift(last.value);

      _setSource(state);
    }
  };

  const redo = () => {
    const state = redoStack.value.shift();

    if (state) {
      undoStack.value.unshift(last.value);

      _setSource(state);
    }
  };

  const reset = () => {
    _setSource(last.value);
  };

  const history = computed(() => [last.value, ...undoStack.value]);
  const canUndo = computed(() => undoStack.value.length > 0);
  const canRedo = computed(() => redoStack.value.length > 0);
  return {
    source,
    undoStack,
    redoStack,
    last,
    history,
    canUndo,
    canRedo,
    clear,
    commit,
    reset,
    undo,
    redo
  };
}

var __defProp$f = Object.defineProperty;
var core_defProps$6 = Object.defineProperties;
var core_getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;

var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$h.call(b, prop)) __defNormalProp$f(a, prop, b[prop]);

  if (__getOwnPropSymbols$h) for (var prop of __getOwnPropSymbols$h(b)) {
    if (__propIsEnum$h.call(b, prop)) __defNormalProp$f(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps$6 = (a, b) => core_defProps$6(a, core_getOwnPropDescs$6(b));

function useRefHistory(source, options = {}) {
  const {
    deep = false,
    flush = "pre",
    eventFilter
  } = options;
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  const {
    ignoreUpdates,
    ignorePrevAsyncUpdates,
    stop
  } = watchIgnorable(source, commit, {
    deep,
    flush,
    eventFilter: composedFilter
  });

  function setSource(source2, value) {
    ignorePrevAsyncUpdates();
    ignoreUpdates(() => {
      source2.value = value;
    });
  }

  const manualHistory = useManualRefHistory(source, core_spreadProps$6(__spreadValues$f({}, options), {
    clone: options.clone || deep,
    setSource
  }));
  const {
    clear,
    commit: manualCommit
  } = manualHistory;

  function commit() {
    ignorePrevAsyncUpdates();
    manualCommit();
  }

  function resume(commitNow) {
    resumeTracking();
    if (commitNow) commit();
  }

  function batch(fn) {
    let canceled = false;

    const cancel = () => canceled = true;

    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled) commit();
  }

  function dispose() {
    stop();
    clear();
  }

  return core_spreadProps$6(__spreadValues$f({}, manualHistory), {
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  });
}

var __defProp$e = Object.defineProperty;
var core_defProps$5 = Object.defineProperties;
var core_getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;

var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$g.call(b, prop)) __defNormalProp$e(a, prop, b[prop]);

  if (__getOwnPropSymbols$g) for (var prop of __getOwnPropSymbols$g(b)) {
    if (__propIsEnum$g.call(b, prop)) __defNormalProp$e(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps$5 = (a, b) => core_defProps$5(a, core_getOwnPropDescs$5(b));

function useDebouncedRefHistory(source, options = {}) {
  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;
  const history = useRefHistory(source, core_spreadProps$5(__spreadValues$e({}, options), {
    eventFilter: filter
  }));
  return __spreadValues$e({}, history);
}

function useDeviceMotion(options = {}) {
  const {
    window = defaultWindow,
    eventFilter = bypassFilter
  } = options;
  const acceleration = ref({
    x: null,
    y: null,
    z: null
  });
  const rotationRate = ref({
    alpha: null,
    beta: null,
    gamma: null
  });
  const interval = ref(0);
  const accelerationIncludingGravity = ref({
    x: null,
    y: null,
    z: null
  });

  if (window) {
    const onDeviceMotion = createFilterWrapper(eventFilter, event => {
      acceleration.value = event.acceleration;
      accelerationIncludingGravity.value = event.accelerationIncludingGravity;
      rotationRate.value = event.rotationRate;
      interval.value = event.interval;
    });
    useEventListener(window, "devicemotion", onDeviceMotion);
  }

  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval
  };
}

function useDeviceOrientation(options = {}) {
  const {
    window = defaultWindow
  } = options;
  const isSupported = Boolean(window && "DeviceOrientationEvent" in window);
  const isAbsolute = ref(false);
  const alpha = ref(null);
  const beta = ref(null);
  const gamma = ref(null);

  if (window && isSupported) {
    useEventListener(window, "deviceorientation", event => {
      isAbsolute.value = event.absolute;
      alpha.value = event.alpha;
      beta.value = event.beta;
      gamma.value = event.gamma;
    });
  }

  return {
    isSupported,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}

const DEVICE_PIXEL_RATIO_SCALES = (/* unused pure expression or super */ null && ([1, 1.325, 1.4, 1.5, 1.8, 2, 2.4, 2.5, 2.75, 3, 3.5, 4]));

function useDevicePixelRatio({
  window = defaultWindow
} = {}) {
  if (!window) {
    return {
      pixelRatio: ref(1)
    };
  }

  const pixelRatio = ref(window.devicePixelRatio);

  const handleDevicePixelRatio = () => {
    pixelRatio.value = window.devicePixelRatio;
  };

  useEventListener(window, "resize", handleDevicePixelRatio, {
    passive: true
  });
  DEVICE_PIXEL_RATIO_SCALES.forEach(dppx => {
    const mqlMin = useMediaQuery(`screen and (min-resolution: ${dppx}dppx)`);
    const mqlMax = useMediaQuery(`screen and (max-resolution: ${dppx}dppx)`);
    watch([mqlMin, mqlMax], handleDevicePixelRatio);
  });
  return {
    pixelRatio
  };
}

function usePermission(permissionDesc, options = {}) {
  const {
    controls = false,
    navigator = defaultNavigator
  } = options;
  const isSupported = Boolean(navigator && "permissions" in navigator);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? {
    name: permissionDesc
  } : permissionDesc;
  const state = ref();

  const onChange = () => {
    if (permissionStatus) state.value = permissionStatus.state;
  };

  const query = createSingletonPromise(async () => {
    if (!isSupported) return;

    if (!permissionStatus) {
      try {
        permissionStatus = await navigator.permissions.query(desc);
        useEventListener(permissionStatus, "change", onChange);
        onChange();
      } catch (e) {
        state.value = "prompt";
      }
    }

    return permissionStatus;
  });
  query();

  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}

function useDevicesList(options = {}) {
  const {
    navigator = defaultNavigator,
    requestPermissions = false,
    constraints = {
      audio: true,
      video: true
    },
    onUpdated
  } = options;
  const devices = ref([]);
  const videoInputs = computed(() => devices.value.filter(i => i.kind === "videoinput"));
  const audioInputs = computed(() => devices.value.filter(i => i.kind === "audioinput"));
  const audioOutputs = computed(() => devices.value.filter(i => i.kind === "audiooutput"));
  let isSupported = false;
  const permissionGranted = ref(false);

  async function update() {
    if (!isSupported) return;
    devices.value = await navigator.mediaDevices.enumerateDevices();
    onUpdated == null ? void 0 : onUpdated(devices.value);
  }

  async function ensurePermissions() {
    if (!isSupported) return false;
    if (permissionGranted.value) return true;
    const {
      state,
      query
    } = usePermission("camera", {
      controls: true
    });
    await query();

    if (state.value !== "granted") {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      stream.getTracks().forEach(t => t.stop());
      update();
      permissionGranted.value = true;
    } else {
      permissionGranted.value = true;
    }

    return permissionGranted.value;
  }

  if (navigator) {
    isSupported = Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);

    if (isSupported) {
      if (requestPermissions) ensurePermissions();
      useEventListener(navigator.mediaDevices, "devicechange", update);
      update();
    }
  }

  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}

function useDisplayMedia(options = {}) {
  var _a, _b;

  const enabled = ref((_a = options.enabled) != null ? _a : false);
  const video = options.video;
  const audio = options.audio;
  const {
    navigator = defaultNavigator
  } = options;
  const isSupported = Boolean((_b = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _b.getDisplayMedia);
  const constraint = {
    audio,
    video
  };
  const stream = shallowRef();

  async function _start() {
    if (!isSupported || stream.value) return;
    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);
    return stream.value;
  }

  async function _stop() {
    var _a2;

    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach(t => t.stop());
    stream.value = void 0;
  }

  function stop() {
    _stop();

    enabled.value = false;
  }

  async function start() {
    await _start();
    if (stream.value) enabled.value = true;
    return stream.value;
  }

  watch(enabled, v => {
    if (v) _start();else _stop();
  }, {
    immediate: true
  });
  return {
    isSupported,
    stream,
    start,
    stop,
    enabled
  };
}

function useDocumentVisibility({
  document = defaultDocument
} = {}) {
  if (!document) return ref("visible");
  const visibility = ref(document.visibilityState);
  useEventListener(document, "visibilitychange", () => {
    visibility.value = document.visibilityState;
  });
  return visibility;
}

var __defProp$d = Object.defineProperty;
var core_defProps$4 = Object.defineProperties;
var core_getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;

var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$f.call(b, prop)) __defNormalProp$d(a, prop, b[prop]);

  if (__getOwnPropSymbols$f) for (var prop of __getOwnPropSymbols$f(b)) {
    if (__propIsEnum$f.call(b, prop)) __defNormalProp$d(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps$4 = (a, b) => core_defProps$4(a, core_getOwnPropDescs$4(b));

function useDraggable(target, options = {}) {
  var _a, _b;

  const draggingElement = (_a = options.draggingElement) != null ? _a : defaultWindow;
  const position = ref((_b = options.initialValue) != null ? _b : {
    x: 0,
    y: 0
  });
  const pressedDelta = ref();

  const filterEvent = e => {
    if (options.pointerTypes) return options.pointerTypes.includes(e.pointerType);
    return true;
  };

  const handleEvent = e => {
    if (unref(options.preventDefault)) e.preventDefault();
    if (unref(options.stopPropagation)) e.stopPropagation();
  };

  const start = e => {
    var _a2;

    if (!filterEvent(e)) return;
    if (unref(options.exact) && e.target !== unref(target)) return;
    const rect = unref(target).getBoundingClientRect();
    const pos = {
      x: e.pageX - rect.left,
      y: e.pageY - rect.top
    };
    if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false) return;
    pressedDelta.value = pos;
    handleEvent(e);
  };

  const move = e => {
    var _a2;

    if (!filterEvent(e)) return;
    if (!pressedDelta.value) return;
    position.value = {
      x: e.pageX - pressedDelta.value.x,
      y: e.pageY - pressedDelta.value.y
    };
    (_a2 = options.onMove) == null ? void 0 : _a2.call(options, position.value, e);
    handleEvent(e);
  };

  const end = e => {
    var _a2;

    if (!filterEvent(e)) return;
    if (!pressedDelta.value) return;
    pressedDelta.value = void 0;
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, position.value, e);
    handleEvent(e);
  };

  if (isClient) {
    useEventListener(target, "pointerdown", start, true);
    useEventListener(draggingElement, "pointermove", move, true);
    useEventListener(draggingElement, "pointerup", end, true);
  }

  return core_spreadProps$4(__spreadValues$d({}, toRefs(position)), {
    position,
    isDragging: computed(() => !!pressedDelta.value),
    style: computed(() => `left:${position.value.x}px;top:${position.value.y}px;`)
  });
}

function useDropZone(target, onDrop) {
  const isOverDropZone = ref(false);
  let counter = 0;

  if (isClient) {
    useEventListener(target, "dragenter", event => {
      event.preventDefault();
      counter += 1;
      isOverDropZone.value = true;
    });
    useEventListener(target, "dragover", event => {
      event.preventDefault();
    });
    useEventListener(target, "dragleave", event => {
      event.preventDefault();
      counter -= 1;
      if (counter === 0) isOverDropZone.value = false;
    });
    useEventListener(target, "drop", event => {
      var _a, _b;

      event.preventDefault();
      counter = 0;
      isOverDropZone.value = false;
      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);

      if (files.length === 0) {
        onDrop(null);
        return;
      }

      onDrop(files);
    });
  }

  return {
    isOverDropZone
  };
}

var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;

var core_objRest$2 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (__hasOwnProp$e.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && __getOwnPropSymbols$e) for (var prop of __getOwnPropSymbols$e(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum$e.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function useResizeObserver(target, callback, options = {}) {
  const _a = options,
        {
    window = defaultWindow
  } = _a,
        observerOptions = core_objRest$2(_a, ["window"]);

  let observer;
  const isSupported = window && "ResizeObserver" in window;

  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };

  const stopWatch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => unrefElement(target), el => {
    cleanup();

    if (isSupported && window && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, {
    immediate: true,
    flush: "post"
  });

  const stop = () => {
    cleanup();
    stopWatch();
  };

  shared_tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width = ref(0);
  const x = ref(0);
  const y = ref(0);

  function update() {
    const el = unrefElement(target);

    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }

      return;
    }

    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }

  useResizeObserver(target, update);
  watch(() => unrefElement(target), ele => !ele && update());
  if (windowScroll) useEventListener("scroll", update, {
    passive: true
  });
  if (windowResize) useEventListener("resize", update, {
    passive: true
  });
  tryOnMounted(() => {
    if (immediate) update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}

function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window = defaultWindow
  } = options;
  const isActive = ref(false);
  let rafId = null;

  function loop() {
    if (!isActive.value || !window) return;
    fn();
    rafId = window.requestAnimationFrame(loop);
  }

  function resume() {
    if (!isActive.value && window) {
      isActive.value = true;
      loop();
    }
  }

  function pause() {
    isActive.value = false;

    if (rafId != null && window) {
      window.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }

  if (immediate) resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

var __defProp$c = Object.defineProperty;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;

var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$d.call(b, prop)) __defNormalProp$c(a, prop, b[prop]);

  if (__getOwnPropSymbols$d) for (var prop of __getOwnPropSymbols$d(b)) {
    if (__propIsEnum$d.call(b, prop)) __defNormalProp$c(a, prop, b[prop]);
  }
  return a;
};

function useElementByPoint(options) {
  const element = ref(null);
  const {
    x,
    y
  } = options;
  const controls = useRafFn(() => {
    element.value = document.elementFromPoint(unref(x), unref(y));
  });
  return __spreadValues$c({
    element
  }, controls);
}

function useElementHover(el) {
  const isHovered = ref(false);
  useEventListener(el, "mouseenter", () => isHovered.value = true);
  useEventListener(el, "mouseleave", () => isHovered.value = false);
  return isHovered;
}

function useElementSize(target, initialSize = {
  width: 0,
  height: 0
}, options = {}) {
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  useResizeObserver(target, ([entry]) => {
    width.value = entry.contentRect.width;
    height.value = entry.contentRect.height;
  }, options);
  watch(() => unrefElement(target), ele => {
    width.value = ele ? initialSize.width : 0;
    height.value = ele ? initialSize.height : 0;
  });
  return {
    width,
    height
  };
}

function useElementVisibility(element, {
  window = defaultWindow,
  scrollTarget
} = {}) {
  const elementIsVisible = ref(false);

  const testBounding = () => {
    if (!window) return;
    const document = window.document;

    if (!unref(element)) {
      elementIsVisible.value = false;
    } else {
      const rect = unref(element).getBoundingClientRect();
      elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;
    }
  };

  tryOnMounted(testBounding);
  if (window) tryOnMounted(() => useEventListener(unref(scrollTarget) || window, "scroll", testBounding, {
    capture: false,
    passive: true
  }));
  return elementIsVisible;
}

const events = new Map();

function useEventBus(key) {
  const scope = getCurrentScope();

  function on(listener) {
    var _a;

    const listeners = events.get(key) || [];
    listeners.push(listener);
    events.set(key, listeners);

    const _off = () => off(listener);

    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);
    return _off;
  }

  function once(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }

    return on(_listener);
  }

  function off(listener) {
    const listeners = events.get(key);
    if (!listeners) return;
    const index = listeners.indexOf(listener);
    if (index > -1) listeners.splice(index, 1);
    if (!listeners.length) events.delete(key);
  }

  function reset() {
    events.delete(key);
  }

  function emit(event, payload) {
    var _a;

    (_a = events.get(key)) == null ? void 0 : _a.forEach(v => v(event, payload));
  }

  return {
    on,
    once,
    off,
    emit,
    reset
  };
}

function useEventSource(url, events = [], options = {}) {
  const event = ref(null);
  const data = ref(null);
  const status = ref("CONNECTING");
  const eventSource = ref(null);
  const error = ref(null);
  const {
    withCredentials = false
  } = options;

  const close = () => {
    if (eventSource.value) {
      eventSource.value.close();
      eventSource.value = null;
      status.value = "CLOSED";
    }
  };

  const es = new EventSource(url, {
    withCredentials
  });
  eventSource.value = es;

  es.onopen = () => {
    status.value = "OPEN";
    error.value = null;
  };

  es.onerror = e => {
    status.value = "CLOSED";
    error.value = e;
  };

  es.onmessage = e => {
    event.value = null;
    data.value = e.data;
  };

  for (const event_name of events) {
    useEventListener(es, event_name, e => {
      event.value = event_name;
      data.value = e.data || null;
    });
  }

  tryOnScopeDispose(() => {
    close();
  });
  return {
    eventSource,
    event,
    data,
    status,
    error,
    close
  };
}

function useEyeDropper(options = {}) {
  const {
    initialValue = ""
  } = options;
  const isSupported = Boolean(typeof window !== "undefined" && "EyeDropper" in window);
  const sRGBHex = ref(initialValue);

  async function open(openOptions) {
    if (!isSupported) return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    sRGBHex.value = result.sRGBHex;
    return result;
  }

  return {
    isSupported,
    sRGBHex,
    open
  };
}

function useFavicon(newIcon = null, options = {}) {
  const {
    baseUrl = "",
    rel = "icon",
    document = defaultDocument
  } = options;
  const favicon = isRef(newIcon) ? newIcon : ref(newIcon);

  const applyIcon = icon => {
    document == null ? void 0 : document.head.querySelectorAll(`link[rel*="${rel}"]`).forEach(el => el.href = `${baseUrl}${icon}`);
  };

  watch(favicon, (i, o) => {
    if (isString(i) && i !== o) applyIcon(i);
  }, {
    immediate: true
  });
  return favicon;
}

var __defProp$b = Object.defineProperty;
var core_defProps$3 = Object.defineProperties;
var core_getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;

var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp$c.call(b, prop)) __defNormalProp$b(a, prop, b[prop]);

  if (__getOwnPropSymbols$c) for (var prop of __getOwnPropSymbols$c(b)) {
    if (__propIsEnum$c.call(b, prop)) __defNormalProp$b(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps$3 = (a, b) => core_defProps$3(a, core_getOwnPropDescs$3(b));

const payloadMapping = {
  json: "application/json",
  text: "text/plain",
  formData: "multipart/form-data"
};

function isFetchOptions(obj) {
  return containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch");
}

function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers) return Object.fromEntries([...headers.entries()]);
  return headers;
}

function createFetch(config = {}) {
  const _options = config.options || {};

  const _fetchOptions = config.fetchOptions || {};

  function useFactoryFetch(url, ...args) {
    const computedUrl = computed(() => config.baseUrl ? joinPaths(unref(config.baseUrl), unref(url)) : unref(url));
    let options = _options;
    let fetchOptions = _fetchOptions;

    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options = __spreadValues$b(__spreadValues$b({}, options), args[0]);
      } else {
        fetchOptions = core_spreadProps$3(__spreadValues$b(__spreadValues$b({}, fetchOptions), args[0]), {
          headers: __spreadValues$b(__spreadValues$b({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})
        });
      }
    }

    if (args.length > 1 && isFetchOptions(args[1])) options = __spreadValues$b(__spreadValues$b({}, options), args[1]);
    return useFetch(computedUrl, fetchOptions, options);
  }

  return useFactoryFetch;
}

function useFetch(url, ...args) {
  var _a;

  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options = {
    immediate: true,
    refetch: false,
    timeout: 0
  };
  const config = {
    method: "GET",
    type: "text",
    payload: void 0
  };

  if (args.length > 0) {
    if (isFetchOptions(args[0])) options = __spreadValues$b(__spreadValues$b({}, options), args[0]);else fetchOptions = args[0];
  }

  if (args.length > 1) {
    if (isFetchOptions(args[1])) options = __spreadValues$b(__spreadValues$b({}, options), args[1]);
  }

  const {
    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,
    initialData,
    timeout
  } = options;
  const responseEvent = createEventHook();
  const errorEvent = createEventHook();
  const finallyEvent = createEventHook();
  const isFinished = ref(false);
  const isFetching = ref(false);
  const aborted = ref(false);
  const statusCode = ref(null);
  const response = shallowRef(null);
  const error = shallowRef(null);
  const data = shallowRef(initialData);
  const canAbort = computed(() => supportsAbort && isFetching.value);
  let controller;
  let timer;

  const abort = () => {
    if (supportsAbort && controller) controller.abort();
  };

  const loading = isLoading => {
    isFetching.value = isLoading;
    isFinished.value = !isLoading;
  };

  if (timeout) timer = useTimeoutFn(abort, timeout, {
    immediate: false
  });

  const execute = async (throwOnFailed = false) => {
    var _a2;

    loading(true);
    error.value = null;
    statusCode.value = null;
    aborted.value = false;
    controller = void 0;

    if (supportsAbort) {
      controller = new AbortController();

      controller.signal.onabort = () => aborted.value = true;

      fetchOptions = core_spreadProps$3(__spreadValues$b({}, fetchOptions), {
        signal: controller.signal
      });
    }

    const defaultFetchOptions = {
      method: config.method,
      headers: {}
    };

    if (config.payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      if (config.payloadType) headers["Content-Type"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;
      defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(unref(config.payload)) : unref(config.payload);
    }

    let isCanceled = false;
    const context = {
      url: unref(url),
      options: __spreadValues$b(__spreadValues$b({}, defaultFetchOptions), fetchOptions),
      cancel: () => {
        isCanceled = true;
      }
    };
    if (options.beforeFetch) Object.assign(context, await options.beforeFetch(context));

    if (isCanceled || !fetch) {
      loading(false);
      return Promise.resolve(null);
    }

    let responseData = null;
    if (timer) timer.start();
    return new Promise((resolve, reject) => {
      var _a3;

      fetch(context.url, core_spreadProps$3(__spreadValues$b(__spreadValues$b({}, defaultFetchOptions), context.options), {
        headers: __spreadValues$b(__spreadValues$b({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))
      })).then(async fetchResponse => {
        response.value = fetchResponse;
        statusCode.value = fetchResponse.status;
        responseData = await fetchResponse[config.type]();
        if (options.afterFetch && statusCode.value >= 200 && statusCode.value < 300) ({
          data: responseData
        } = await options.afterFetch({
          data: responseData,
          response: fetchResponse
        }));
        data.value = responseData;
        if (!fetchResponse.ok) throw new Error(fetchResponse.statusText);
        responseEvent.trigger(fetchResponse);
        return resolve(fetchResponse);
      }).catch(async fetchError => {
        let errorData = fetchError.message || fetchError.name;
        if (options.onFetchError) ({
          data: responseData,
          error: errorData
        } = await options.onFetchError({
          data: responseData,
          error: fetchError,
          response: response.value
        }));
        data.value = responseData;
        error.value = errorData;
        errorEvent.trigger(fetchError);
        if (throwOnFailed) return reject(fetchError);
        return resolve(null);
      }).finally(() => {
        loading(false);
        if (timer) timer.stop();
        finallyEvent.trigger(null);
      });
    });
  };

  watch(() => [unref(url), unref(options.refetch)], () => unref(options.refetch) && execute(), {
    deep: true
  });
  const shell = {
    isFinished,
    statusCode,
    response,
    error,
    data,
    isFetching,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    json: setType("json"),
    text: setType("text"),
    blob: setType("blob"),
    arrayBuffer: setType("arrayBuffer"),
    formData: setType("formData")
  };

  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching.value) {
        config.method = method;
        config.payload = payload;
        config.payloadType = payloadType;

        if (isRef(config.payload)) {
          watch(() => [unref(config.payload), unref(options.refetch)], () => unref(options.refetch) && execute(), {
            deep: true
          });
        }

        if (!payloadType && unref(payload) && Object.getPrototypeOf(unref(payload)) === Object.prototype) config.payloadType = "json";
        return core_spreadProps$3(__spreadValues$b({}, shell), {
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }

        });
      }

      return void 0;
    };
  }

  function waitUntilFinished() {
    return new Promise((resolve, reject) => {
      until(isFinished).toBe(true).then(() => resolve(shell)).catch(error2 => reject(error2));
    });
  }

  function setType(type) {
    return () => {
      if (!isFetching.value) {
        config.type = type;
        return core_spreadProps$3(__spreadValues$b({}, shell), {
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }

        });
      }

      return void 0;
    };
  }

  if (options.immediate) setTimeout(execute, 0);
  return core_spreadProps$3(__spreadValues$b({}, shell), {
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }

  });
}

function joinPaths(start, end) {
  if (!start.endsWith("/") && !end.startsWith("/")) return `${start}/${end}`;
  return `${start}${end}`;
}

var __defProp$a = Object.defineProperty;
var core_getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var core_hasOwnProp$b = Object.prototype.hasOwnProperty;
var core_propIsEnum$b = Object.prototype.propertyIsEnumerable;

var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$b.call(b, prop)) __defNormalProp$a(a, prop, b[prop]);

  if (core_getOwnPropSymbols$b) for (var prop of core_getOwnPropSymbols$b(b)) {
    if (core_propIsEnum$b.call(b, prop)) __defNormalProp$a(a, prop, b[prop]);
  }
  return a;
};

const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*"
};

function useFileDialog(options = {}) {
  const {
    document = defaultDocument
  } = options;
  const files = ref(null);
  let input;

  if (document) {
    input = document.createElement("input");
    input.type = "file";

    input.onchange = event => {
      const result = event.target;
      files.value = result.files;
    };
  }

  const open = localOptions => {
    if (!input) return;

    const _options = __spreadValues$a(__spreadValues$a(__spreadValues$a({}, DEFAULT_OPTIONS), options), localOptions);

    input.multiple = _options.multiple;
    input.accept = _options.accept;
    input.capture = _options.capture;
    input.click();
  };

  const reset = () => {
    files.value = null;
    if (input) input.value = "";
  };

  return {
    files: readonly(files),
    open,
    reset
  };
}

var core_defProp$9 = Object.defineProperty;
var core_getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var core_hasOwnProp$a = Object.prototype.hasOwnProperty;
var core_propIsEnum$a = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$9 = (obj, key, value) => key in obj ? core_defProp$9(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$a.call(b, prop)) core_defNormalProp$9(a, prop, b[prop]);

  if (core_getOwnPropSymbols$a) for (var prop of core_getOwnPropSymbols$a(b)) {
    if (core_propIsEnum$a.call(b, prop)) core_defNormalProp$9(a, prop, b[prop]);
  }
  return a;
};

function useFileSystemAccess(options = {}) {
  const {
    window: _window = defaultWindow,
    dataType = "Text"
  } = unref(options);
  const window = _window;
  const isSupported = Boolean(window && "showSaveFilePicker" in window && "showOpenFilePicker" in window);
  const fileHandle = ref();
  const data = ref();
  const file = ref();
  const fileName = computed(() => {
    var _a, _b;

    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : "";
  });
  const fileMIME = computed(() => {
    var _a, _b;

    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : "";
  });
  const fileSize = computed(() => {
    var _a, _b;

    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;
  });
  const fileLastModified = computed(() => {
    var _a, _b;

    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;
  });

  async function open(_options = {}) {
    if (!isSupported) return;
    const [handle] = await window.showOpenFilePicker(core_spreadValues$9(core_spreadValues$9({}, unref(options)), _options));
    fileHandle.value = handle;
    await updateFile();
    await updateData();
  }

  async function create(_options = {}) {
    if (!isSupported) return;
    fileHandle.value = await window.showSaveFilePicker(core_spreadValues$9(core_spreadValues$9({}, unref(options)), _options));
    data.value = void 0;
    await updateFile();
    await updateData();
  }

  async function save(_options = {}) {
    if (!isSupported) return;
    if (!fileHandle.value) return saveAs(_options);

    if (data.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data.value);
      await writableStream.close();
    }

    await updateFile();
  }

  async function saveAs(_options = {}) {
    if (!isSupported) return;
    fileHandle.value = await window.showSaveFilePicker(core_spreadValues$9(core_spreadValues$9({}, unref(options)), _options));

    if (data.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data.value);
      await writableStream.close();
    }

    await updateFile();
  }

  async function updateFile() {
    var _a;

    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());
  }

  async function updateData() {
    var _a, _b;

    if (unref(dataType) === "Text") data.value = await ((_a = file.value) == null ? void 0 : _a.text());
    if (unref(dataType) === "ArrayBuffer") data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());
    if (unref(dataType) === "Blob") data.value = file.value;
  }

  watch(() => unref(dataType), updateData);
  return {
    isSupported,
    data,
    file,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open,
    create,
    save,
    saveAs,
    updateData
  };
}

function useFocus(target, options = {}) {
  const {
    initialValue = false
  } = options;
  const activeElement = useActiveElement(options);
  const targetElement = computed(() => unrefElement(target));
  const focused = computed({
    get() {
      return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;
    },

    set(value) {
      var _a, _b;

      if (!value && focused.value) (_a = targetElement.value) == null ? void 0 : _a.blur();
      if (value && !focused.value) (_b = targetElement.value) == null ? void 0 : _b.focus();
    }

  });
  watch(targetElement, () => {
    focused.value = initialValue;
  }, {
    immediate: true,
    flush: "post"
  });
  return {
    focused
  };
}

function useFocusWithin(target, options = {}) {
  const activeElement = useActiveElement(options);
  const targetElement = computed(() => unrefElement(target));
  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);
  return {
    focused
  };
}

function useFps(options) {
  var _a;

  const fps = ref(0);
  if (typeof performance === "undefined") return fps;
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;

    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}

const functionsMap = (/* unused pure expression or super */ null && ([["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]]));

function useFullscreen(target, options = {}) {
  const {
    document = defaultDocument,
    autoExit = false
  } = options;
  const targetRef = target || (document == null ? void 0 : document.querySelector("html"));
  const isFullscreen = ref(false);
  let isSupported = false;
  let map = functionsMap[0];

  if (!document) {
    isSupported = false;
  } else {
    for (const m of functionsMap) {
      if (m[1] in document) {
        map = m;
        isSupported = true;
        break;
      }
    }
  }

  const [REQUEST, EXIT, ELEMENT,, EVENT] = map;

  async function exit() {
    if (!isSupported) return;
    if (document == null ? void 0 : document[ELEMENT]) await document[EXIT]();
    isFullscreen.value = false;
  }

  async function enter() {
    if (!isSupported) return;
    await exit();
    const target2 = unrefElement(targetRef);

    if (target2) {
      await target2[REQUEST]();
      isFullscreen.value = true;
    }
  }

  async function toggle() {
    if (isFullscreen.value) await exit();else await enter();
  }

  if (document) {
    useEventListener(document, EVENT, () => {
      isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);
    }, false);
  }

  if (autoExit) tryOnScopeDispose(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}

function mapGamepadToXbox360Controller(gamepad) {
  return computed(() => {
    if (gamepad.value) {
      return {
        buttons: {
          a: gamepad.value.buttons[0],
          b: gamepad.value.buttons[1],
          x: gamepad.value.buttons[2],
          y: gamepad.value.buttons[3]
        },
        bumper: {
          left: gamepad.value.buttons[4],
          right: gamepad.value.buttons[5]
        },
        triggers: {
          left: gamepad.value.buttons[6],
          right: gamepad.value.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepad.value.axes[0],
            vertical: gamepad.value.axes[1],
            button: gamepad.value.buttons[10]
          },
          right: {
            horizontal: gamepad.value.axes[2],
            vertical: gamepad.value.axes[3],
            button: gamepad.value.buttons[11]
          }
        },
        dpad: {
          up: gamepad.value.buttons[12],
          down: gamepad.value.buttons[13],
          left: gamepad.value.buttons[14],
          right: gamepad.value.buttons[15]
        },
        back: gamepad.value.buttons[8],
        start: gamepad.value.buttons[9]
      };
    }

    return null;
  });
}

function useGamepad(options = {}) {
  const {
    navigator = defaultNavigator
  } = options;
  const isSupported = navigator && "getGamepads" in navigator;
  const gamepads = ref([]);
  const onConnectedHook = createEventHook();
  const onDisconnectedHook = createEventHook();

  const stateFromGamepad = gamepad => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator) hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators) hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      hapticActuators,
      index: gamepad.index,
      mapping: gamepad.mapping,
      connected: gamepad.connected,
      timestamp: gamepad.timestamp,
      axes: gamepad.axes.map(axes => axes),
      buttons: gamepad.buttons.map(button => ({
        pressed: button.pressed,
        touched: button.touched,
        value: button.value
      }))
    };
  };

  const updateGamepadState = () => {
    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];

    for (let i = 0; i < _gamepads.length; ++i) {
      const gamepad = _gamepads[i];

      if (gamepad) {
        const index = gamepads.value.findIndex(({
          index: index2
        }) => index2 === gamepad.index);
        if (index > -1) gamepads.value[index] = stateFromGamepad(gamepad);
      }
    }
  };

  const {
    isActive,
    pause,
    resume
  } = useRafFn(updateGamepadState);

  const onGamepadConnected = gamepad => {
    if (!gamepads.value.some(({
      index
    }) => index === gamepad.index)) {
      gamepads.value.push(stateFromGamepad(gamepad));
      onConnectedHook.trigger(gamepad.index);
    }

    resume();
  };

  const onGamepadDisconnected = gamepad => {
    gamepads.value = gamepads.value.filter(x => x.index !== gamepad.index);
    onDisconnectedHook.trigger(gamepad.index);
  };

  useEventListener("gamepadconnected", e => onGamepadConnected(e.gamepad));
  useEventListener("gamepaddisconnected", e => onGamepadDisconnected(e.gamepad));
  tryOnMounted(() => {
    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];

    if (_gamepads) {
      for (let i = 0; i < _gamepads.length; ++i) {
        const gamepad = _gamepads[i];
        if (gamepad) onGamepadConnected(gamepad);
      }
    }
  });
  pause();
  return {
    isSupported,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}

function useGeolocation(options = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator = defaultNavigator
  } = options;
  const isSupported = navigator && "geolocation" in navigator;
  const locatedAt = ref(null);
  const error = ref(null);
  const coords = ref({
    accuracy: 0,
    latitude: Infinity,
    longitude: Infinity,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });

  function updatePosition(position) {
    locatedAt.value = position.timestamp;
    coords.value = position.coords;
    error.value = null;
  }

  let watcher;

  if (isSupported) {
    watcher = navigator.geolocation.watchPosition(updatePosition, err => error.value = err, {
      enableHighAccuracy,
      maximumAge,
      timeout
    });
  }

  tryOnScopeDispose(() => {
    if (watcher && navigator) navigator.geolocation.clearWatch(watcher);
  });
  return {
    isSupported,
    coords,
    locatedAt,
    error
  };
}

const defaultEvents$1 = (/* unused pure expression or super */ null && (["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"]));
const oneMinute = 6e4;

function useIdle(timeout = oneMinute, options = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events = defaultEvents$1,
    window = defaultWindow,
    eventFilter = throttleFilter(50)
  } = options;
  const idle = ref(initialState);
  const lastActive = ref(timestamp());
  let timer;
  const onEvent = createFilterWrapper(eventFilter, () => {
    idle.value = false;
    lastActive.value = timestamp();
    clearTimeout(timer);
    timer = setTimeout(() => idle.value = true, timeout);
  });

  if (window) {
    const document = window.document;

    for (const event of events) useEventListener(window, event, onEvent, {
      passive: true
    });

    if (listenForVisibilityChange) {
      useEventListener(document, "visibilitychange", () => {
        if (!document.hidden) onEvent();
      });
    }
  }

  timer = setTimeout(() => idle.value = true, timeout);
  return {
    idle,
    lastActive
  };
}

var core_defProp$8 = Object.defineProperty;
var core_getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var core_hasOwnProp$9 = Object.prototype.hasOwnProperty;
var core_propIsEnum$9 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$8 = (obj, key, value) => key in obj ? core_defProp$8(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$9.call(b, prop)) core_defNormalProp$8(a, prop, b[prop]);

  if (core_getOwnPropSymbols$9) for (var prop of core_getOwnPropSymbols$9(b)) {
    if (core_propIsEnum$9.call(b, prop)) core_defNormalProp$8(a, prop, b[prop]);
  }
  return a;
};

async function loadImage(options) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const {
      src,
      srcset,
      sizes
    } = options;
    img.src = src;
    if (srcset) img.srcset = srcset;
    if (sizes) img.sizes = sizes;

    img.onload = () => resolve(img);

    img.onerror = reject;
  });
}

const useImage = (options, asyncStateOptions = {}) => {
  const state = useAsyncState(() => loadImage(unref(options)), void 0, core_spreadValues$8({
    resetOnExecute: true
  }, asyncStateOptions));
  watch(() => unref(options), () => state.execute(asyncStateOptions.delay), {
    deep: true
  });
  return state;
};

function useScroll(element, options = {}) {
  const {
    throttle = 0,
    idle = 200,
    onStop = noop,
    onScroll = noop,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    }
  } = options;
  const x = ref(0);
  const y = ref(0);
  const isScrolling = ref(false);
  const arrivedState = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  });

  if (element) {
    const onScrollEnd = useDebounceFn(e => {
      isScrolling.value = false;
      directions.left = false;
      directions.right = false;
      directions.top = false;
      directions.bottom = false;
      onStop(e);
    }, throttle + idle);

    const onScrollHandler = e => {
      const eventTarget = e.target === document ? e.target.documentElement : e.target;
      const scrollLeft = eventTarget.scrollLeft;
      directions.left = scrollLeft < x.value;
      directions.right = scrollLeft > x.value;
      arrivedState.left = scrollLeft <= 0 + (offset.left || 0);
      arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0);
      x.value = scrollLeft;
      let scrollTop = eventTarget.scrollTop;
      if (e.target === document && !scrollTop) scrollTop = document.body.scrollTop;
      directions.top = scrollTop < y.value;
      directions.bottom = scrollTop > y.value;
      arrivedState.top = scrollTop <= 0 + (offset.top || 0);
      arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0);
      y.value = scrollTop;
      isScrolling.value = true;
      onScrollEnd(e);
      onScroll(e);
    };

    useEventListener(element, "scroll", throttle ? useThrottleFn(onScrollHandler, throttle) : onScrollHandler, eventListenerOptions);
  }

  return {
    x,
    y,
    isScrolling,
    arrivedState,
    directions
  };
}

var core_defProp$7 = Object.defineProperty;
var core_defProps$2 = Object.defineProperties;
var core_getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var core_getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var core_hasOwnProp$8 = Object.prototype.hasOwnProperty;
var core_propIsEnum$8 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$7 = (obj, key, value) => key in obj ? core_defProp$7(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$8.call(b, prop)) core_defNormalProp$7(a, prop, b[prop]);

  if (core_getOwnPropSymbols$8) for (var prop of core_getOwnPropSymbols$8(b)) {
    if (core_propIsEnum$8.call(b, prop)) core_defNormalProp$7(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps$2 = (a, b) => core_defProps$2(a, core_getOwnPropDescs$2(b));

function useInfiniteScroll(element, onLoadMore, options = {}) {
  var _a, _b;

  const direction = (_a = options.direction) != null ? _a : "bottom";
  const state = reactive(useScroll(element, core_spreadProps$2(core_spreadValues$7({}, options), {
    offset: core_spreadValues$7({
      [direction]: (_b = options.distance) != null ? _b : 0
    }, options.offset)
  })));
  watch(() => state.arrivedState[direction], async v => {
    var _a2, _b2;

    if (v) {
      const elem = unref(element);
      const previous = {
        height: (_a2 = elem == null ? void 0 : elem.scrollHeight) != null ? _a2 : 0,
        width: (_b2 = elem == null ? void 0 : elem.scrollWidth) != null ? _b2 : 0
      };
      await onLoadMore(state);

      if (options.preserveScrollPosition && elem) {
        nextTick(() => {
          elem.scrollTo({
            top: elem.scrollHeight - previous.height,
            left: elem.scrollWidth - previous.width
          });
        });
      }
    }
  });
}

function useIntersectionObserver(target, callback, options = {}) {
  const {
    root,
    rootMargin = "0px",
    threshold = 0.1,
    window = defaultWindow
  } = options;
  const isSupported = window && "IntersectionObserver" in window;
  let cleanup = noop;
  const stopWatch = isSupported ? watch(() => ({
    el: unrefElement(target),
    root: unrefElement(root)
  }), ({
    el,
    root: root2
  }) => {
    cleanup();
    if (!el) return;
    const observer = new IntersectionObserver(callback, {
      root: root2,
      rootMargin,
      threshold
    });
    observer.observe(el);

    cleanup = () => {
      observer.disconnect();
      cleanup = noop;
    };
  }, {
    immediate: true,
    flush: "post"
  }) : noop;

  const stop = () => {
    cleanup();
    stopWatch();
  };

  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

const defaultEvents = (/* unused pure expression or super */ null && (["mousedown", "mouseup", "keydown", "keyup"]));

function useKeyModifier(modifier, options = {}) {
  const {
    events = defaultEvents,
    document = defaultDocument,
    initial = null
  } = options;
  const state = ref(initial);

  if (document) {
    events.forEach(listenerEvent => {
      useEventListener(document, listenerEvent, evt => {
        if (typeof evt.getModifierState === "function") state.value = evt.getModifierState(modifier);
      });
    });
  }

  return state;
}

function useLocalStorage(key, initialValue, options = {}) {
  const {
    window = defaultWindow
  } = options;
  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);
}

const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};

function useMagicKeys(options = {}) {
  const {
    reactive: useReactive = false,
    target = defaultWindow,
    aliasMap = DefaultMagicKeysAliasMap,
    passive = true,
    onEventFired = noop
  } = options;
  const current = reactive(new Set());
  const obj = {
    toJSON() {
      return {};
    },

    current
  };
  const refs = useReactive ? reactive(obj) : obj;
  const metaDeps = new Set();
  const usedKeys = new Set();

  function setRefs(key, value) {
    if (key in refs) {
      if (useReactive) refs[key] = value;else refs[key].value = value;
    }
  }

  function reset() {
    for (const key of usedKeys) setRefs(key, false);
  }

  function updateRefs(e, value) {
    var _a, _b;

    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values = [code, key].filter(Boolean);

    if (code) {
      if (value) current.add(e.code);else current.delete(e.code);
    }

    for (const key2 of values) {
      usedKeys.add(key2);
      setRefs(key2, value);
    }

    if (key === "meta" && !value) {
      metaDeps.forEach(key2 => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value) {
      [...current, ...values].forEach(key2 => metaDeps.add(key2));
    }
  }

  if (target) {
    useEventListener(target, "keydown", e => {
      updateRefs(e, true);
      return onEventFired(e);
    }, {
      passive
    });
    useEventListener(target, "keyup", e => {
      updateRefs(e, false);
      return onEventFired(e);
    }, {
      passive
    });
    useEventListener("blur", reset, {
      passive: true
    });
    useEventListener("focus", reset, {
      passive: true
    });
  }

  const proxy = new Proxy(refs, {
    get(target2, prop, rec) {
      if (typeof prop !== "string") return Reflect.get(target2, prop, rec);
      prop = prop.toLowerCase();
      if (prop in aliasMap) prop = aliasMap[prop];

      if (!(prop in refs)) {
        if (/[+_-]/.test(prop)) {
          const keys = prop.split(/[+_-]/g).map(i => i.trim());
          refs[prop] = computed(() => keys.every(key => unref(proxy[key])));
        } else {
          refs[prop] = ref(false);
        }
      }

      const r = Reflect.get(target2, prop, rec);
      return useReactive ? unref(r) : r;
    }

  });
  return proxy;
}

var core_defProp$6 = Object.defineProperty;
var core_getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var core_hasOwnProp$7 = Object.prototype.hasOwnProperty;
var core_propIsEnum$7 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$6 = (obj, key, value) => key in obj ? core_defProp$6(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$7.call(b, prop)) core_defNormalProp$6(a, prop, b[prop]);

  if (core_getOwnPropSymbols$7) for (var prop of core_getOwnPropSymbols$7(b)) {
    if (core_propIsEnum$7.call(b, prop)) core_defNormalProp$6(a, prop, b[prop]);
  }
  return a;
};

function usingElRef(source, cb) {
  if (unref(source)) cb(unref(source));
}

function timeRangeToArray(timeRanges) {
  let ranges = [];

  for (let i = 0; i < timeRanges.length; ++i) ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];

  return ranges;
}

function tracksToArray(tracks) {
  return Array.from(tracks).map(({
    label,
    kind,
    language,
    mode,
    activeCues,
    cues,
    inBandMetadataTrackDispatchType
  }, id) => ({
    id,
    label,
    kind,
    language,
    mode,
    activeCues,
    cues,
    inBandMetadataTrackDispatchType
  }));
}

const defaultOptions = {
  src: "",
  tracks: []
};

function useMediaControls(target, options = {}) {
  options = core_spreadValues$6(core_spreadValues$6({}, defaultOptions), options);
  const {
    document = defaultDocument
  } = options;
  const currentTime = ref(0);
  const duration = ref(0);
  const seeking = ref(false);
  const volume = ref(1);
  const waiting = ref(false);
  const ended = ref(false);
  const playing = ref(false);
  const rate = ref(1);
  const stalled = ref(false);
  const buffered = ref([]);
  const tracks = ref([]);
  const selectedTrack = ref(-1);
  const isPictureInPicture = ref(false);
  const muted = ref(false);
  const supportsPictureInPicture = document && "pictureInPictureEnabled" in document;
  const sourceErrorEvent = createEventHook();

  const disableTrack = track => {
    usingElRef(target, el => {
      if (track) {
        const id = isNumber(track) ? track : track.id;
        el.textTracks[id].mode = "disabled";
      } else {
        for (let i = 0; i < el.textTracks.length; ++i) el.textTracks[i].mode = "disabled";
      }

      selectedTrack.value = -1;
    });
  };

  const enableTrack = (track, disableTracks = true) => {
    usingElRef(target, el => {
      const id = isNumber(track) ? track : track.id;
      if (disableTracks) disableTrack();
      el.textTracks[id].mode = "showing";
      selectedTrack.value = id;
    });
  };

  const togglePictureInPicture = () => {
    return new Promise((resolve, reject) => {
      usingElRef(target, async el => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture.value) {
            el.requestPictureInPicture().then(resolve).catch(reject);
          } else {
            document.exitPictureInPicture().then(resolve).catch(reject);
          }
        }
      });
    });
  };

  watchEffect(() => {
    if (!document) return;
    const el = unref(target);
    if (!el) return;
    const src = unref(options.src);
    let sources = [];
    if (!src) return;
    if (isString(src)) sources = [{
      src
    }];else if (Array.isArray(src)) sources = src;else if (isObject(src)) sources = [src];
    el.querySelectorAll("source").forEach(e => {
      e.removeEventListener("error", sourceErrorEvent.trigger);
      e.remove();
    });
    sources.forEach(({
      src: src2,
      type
    }) => {
      const source = document.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type || "");
      source.addEventListener("error", sourceErrorEvent.trigger);
      el.appendChild(source);
    });
    el.load();
  });
  tryOnScopeDispose(() => {
    const el = unref(target);
    if (!el) return;
    el.querySelectorAll("source").forEach(e => e.removeEventListener("error", sourceErrorEvent.trigger));
  });
  watch(volume, vol => {
    const el = unref(target);
    if (!el) return;
    el.volume = vol;
  });
  watch(muted, mute => {
    const el = unref(target);
    if (!el) return;
    el.muted = mute;
  });
  watch(rate, rate2 => {
    const el = unref(target);
    if (!el) return;
    el.playbackRate = rate2;
  });
  watchEffect(() => {
    if (!document) return;
    const textTracks = unref(options.tracks);
    const el = unref(target);
    if (!textTracks || !textTracks.length || !el) return;
    el.querySelectorAll("track").forEach(e => e.remove());
    textTracks.forEach(({
      default: isDefault,
      kind,
      label,
      src,
      srcLang
    }, i) => {
      const track = document.createElement("track");
      track.default = isDefault || false;
      track.kind = kind;
      track.label = label;
      track.src = src;
      track.srclang = srcLang;
      if (track.default) selectedTrack.value = i;
      el.appendChild(track);
    });
  });
  const {
    ignoreUpdates: ignoreCurrentTimeUpdates
  } = watchIgnorable(currentTime, time => {
    const el = unref(target);
    if (!el) return;
    el.currentTime = time;
  });
  const {
    ignoreUpdates: ignorePlayingUpdates
  } = watchIgnorable(playing, isPlaying => {
    const el = unref(target);
    if (!el) return;
    isPlaying ? el.play() : el.pause();
  });
  useEventListener(target, "timeupdate", () => ignoreCurrentTimeUpdates(() => currentTime.value = unref(target).currentTime));
  useEventListener(target, "durationchange", () => duration.value = unref(target).duration);
  useEventListener(target, "progress", () => buffered.value = timeRangeToArray(unref(target).buffered));
  useEventListener(target, "seeking", () => seeking.value = true);
  useEventListener(target, "seeked", () => seeking.value = false);
  useEventListener(target, "waiting", () => waiting.value = true);
  useEventListener(target, "playing", () => waiting.value = false);
  useEventListener(target, "ratechange", () => rate.value = unref(target).playbackRate);
  useEventListener(target, "stalled", () => stalled.value = true);
  useEventListener(target, "ended", () => ended.value = true);
  useEventListener(target, "pause", () => ignorePlayingUpdates(() => playing.value = false));
  useEventListener(target, "play", () => ignorePlayingUpdates(() => playing.value = true));
  useEventListener(target, "enterpictureinpicture", () => isPictureInPicture.value = true);
  useEventListener(target, "leavepictureinpicture", () => isPictureInPicture.value = false);
  useEventListener(target, "volumechange", () => {
    const el = unref(target);
    if (!el) return;
    volume.value = el.volume;
    muted.value = el.muted;
  });
  const listeners = [];
  const stop = watch([target], () => {
    const el = unref(target);
    if (!el) return;
    stop();
    listeners[0] = useEventListener(el.textTracks, "addtrack", () => tracks.value = tracksToArray(el.textTracks));
    listeners[1] = useEventListener(el.textTracks, "removetrack", () => tracks.value = tracksToArray(el.textTracks));
    listeners[2] = useEventListener(el.textTracks, "change", () => tracks.value = tracksToArray(el.textTracks));
  });
  tryOnScopeDispose(() => listeners.forEach(listener => listener()));
  return {
    currentTime,
    duration,
    waiting,
    seeking,
    ended,
    stalled,
    buffered,
    playing,
    rate,
    volume,
    muted,
    tracks,
    selectedTrack,
    enableTrack,
    disableTrack,
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    onSourceError: sourceErrorEvent.on
  };
}

const getMapVue2Compat = () => {
  const data = reactive({});
  return {
    get: key => data[key],
    set: (key, value) => set(data, key, value),
    has: key => Object.prototype.hasOwnProperty.call(data, key),
    delete: key => del(data, key),
    clear: () => {
      Object.keys(data).forEach(key => {
        del(data, key);
      });
    }
  };
};

function useMemoize(resolver, options) {
  const initCache = () => {
    if (options == null ? void 0 : options.cache) return reactive(options.cache);
    if (isVue2) return getMapVue2Compat();
    return reactive(new Map());
  };

  const cache = initCache();

  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);

  const _loadData = (key, ...args) => {
    cache.set(key, resolver(...args));
    return cache.get(key);
  };

  const loadData = (...args) => _loadData(generateKey(...args), ...args);

  const deleteData = (...args) => {
    cache.delete(generateKey(...args));
  };

  const clearData = () => {
    cache.clear();
  };

  const memoized = (...args) => {
    const key = generateKey(...args);
    if (cache.has(key)) return cache.get(key);
    return _loadData(key, ...args);
  };

  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache;
  return memoized;
}

function useMemory(options = {}) {
  const memory = ref();
  const isSupported = typeof performance !== "undefined" && "memory" in performance;

  if (isSupported) {
    const {
      interval = 1e3
    } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, {
      immediate: options.immediate,
      immediateCallback: options.immediateCallback
    });
  }

  return {
    isSupported,
    memory
  };
}

function useMounted() {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  return isMounted;
}

function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = {
      x: 0,
      y: 0
    },
    window = defaultWindow,
    eventFilter
  } = options;
  const x = ref(initialValue.x);
  const y = ref(initialValue.y);
  const sourceType = ref(null);

  const mouseHandler = event => {
    if (type === "page") {
      x.value = event.pageX;
      y.value = event.pageY;
    } else if (type === "client") {
      x.value = event.clientX;
      y.value = event.clientY;
    }

    sourceType.value = "mouse";
  };

  const reset = () => {
    x.value = initialValue.x;
    y.value = initialValue.y;
  };

  const touchHandler = event => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];

      if (type === "page") {
        x.value = touch2.pageX;
        y.value = touch2.pageY;
      } else if (type === "client") {
        x.value = touch2.clientX;
        y.value = touch2.clientY;
      }

      sourceType.value = "touch";
    }
  };

  const mouseHandlerWrapper = event => {
    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
  };

  const touchHandlerWrapper = event => {
    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
  };

  if (window) {
    useEventListener(window, "mousemove", mouseHandlerWrapper, {
      passive: true
    });
    useEventListener(window, "dragover", mouseHandlerWrapper, {
      passive: true
    });

    if (touch) {
      useEventListener(window, "touchstart", touchHandlerWrapper, {
        passive: true
      });
      useEventListener(window, "touchmove", touchHandlerWrapper, {
        passive: true
      });
      if (resetOnTouchEnds) useEventListener(window, "touchend", reset, {
        passive: true
      });
    }
  }

  return {
    x,
    y,
    sourceType
  };
}

function useMouseInElement(target, options = {}) {
  const {
    handleOutside = true,
    window = defaultWindow
  } = options;
  const {
    x,
    y,
    sourceType
  } = useMouse(options);
  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);
  const elementX = ref(0);
  const elementY = ref(0);
  const elementPositionX = ref(0);
  const elementPositionY = ref(0);
  const elementHeight = ref(0);
  const elementWidth = ref(0);
  const isOutside = ref(true);

  let stop = () => {};

  if (window) {
    stop = watch([targetRef, x, y], () => {
      const el = unrefElement(targetRef);
      if (!el) return;
      const {
        left,
        top,
        width,
        height
      } = el.getBoundingClientRect();
      elementPositionX.value = left + window.pageXOffset;
      elementPositionY.value = top + window.pageYOffset;
      elementHeight.value = height;
      elementWidth.value = width;
      const elX = x.value - elementPositionX.value;
      const elY = y.value - elementPositionY.value;
      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;

      if (handleOutside || !isOutside.value) {
        elementX.value = elX;
        elementY.value = elY;
      }
    }, {
      immediate: true
    });
  }

  return {
    x,
    y,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}

function useMousePressed(options = {}) {
  const {
    touch = true,
    drag = true,
    initialValue = false,
    window = defaultWindow
  } = options;
  const pressed = ref(initialValue);
  const sourceType = ref(null);

  if (!window) {
    return {
      pressed,
      sourceType
    };
  }

  const onPressed = srcType => () => {
    pressed.value = true;
    sourceType.value = srcType;
  };

  const onReleased = () => {
    pressed.value = false;
    sourceType.value = null;
  };

  const target = computed(() => unrefElement(options.target) || window);
  useEventListener(target, "mousedown", onPressed("mouse"), {
    passive: true
  });
  useEventListener(window, "mouseleave", onReleased, {
    passive: true
  });
  useEventListener(window, "mouseup", onReleased, {
    passive: true
  });

  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), {
      passive: true
    });
    useEventListener(window, "drop", onReleased, {
      passive: true
    });
    useEventListener(window, "dragend", onReleased, {
      passive: true
    });
  }

  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), {
      passive: true
    });
    useEventListener(window, "touchend", onReleased, {
      passive: true
    });
    useEventListener(window, "touchcancel", onReleased, {
      passive: true
    });
  }

  return {
    pressed,
    sourceType
  };
}

var core_getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var core_hasOwnProp$6 = Object.prototype.hasOwnProperty;
var core_propIsEnum$6 = Object.prototype.propertyIsEnumerable;

var core_objRest$1 = (source, exclude) => {
  var target = {};

  for (var prop in source) if (core_hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && core_getOwnPropSymbols$6) for (var prop of core_getOwnPropSymbols$6(source)) {
    if (exclude.indexOf(prop) < 0 && core_propIsEnum$6.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

function useMutationObserver(target, callback, options = {}) {
  const _a = options,
        {
    window = defaultWindow
  } = _a,
        mutationOptions = core_objRest$1(_a, ["window"]);

  let observer;
  const isSupported = window && "MutationObserver" in window;

  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };

  const stopWatch = watch(() => unrefElement(target), el => {
    cleanup();

    if (isSupported && window && el) {
      observer = new MutationObserver(callback);
      observer.observe(el, mutationOptions);
    }
  }, {
    immediate: true
  });

  const stop = () => {
    cleanup();
    stopWatch();
  };

  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}

const useNavigatorLanguage = (options = {}) => {
  const {
    window = defaultWindow
  } = options;
  const navigator = window == null ? void 0 : window.navigator;
  const isSupported = Boolean(navigator && "language" in navigator);
  const language = ref(navigator == null ? void 0 : navigator.language);
  useEventListener(window, "languagechange", () => {
    if (navigator) language.value = navigator.language;
  });
  return {
    isSupported,
    language
  };
};

function useNetwork(options = {}) {
  const {
    window = defaultWindow
  } = options;
  const navigator = window == null ? void 0 : window.navigator;
  const isSupported = Boolean(navigator && "connection" in navigator);
  const isOnline = ref(true);
  const saveData = ref(false);
  const offlineAt = ref(void 0);
  const onlineAt = ref(void 0);
  const downlink = ref(void 0);
  const downlinkMax = ref(void 0);
  const rtt = ref(void 0);
  const effectiveType = ref(void 0);
  const type = ref("unknown");
  const connection = isSupported && navigator.connection;

  function updateNetworkInformation() {
    if (!navigator) return;
    isOnline.value = navigator.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    onlineAt.value = isOnline.value ? Date.now() : void 0;

    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type.value = connection.type;
    }
  }

  if (window) {
    useEventListener(window, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    });
    useEventListener(window, "online", () => {
      isOnline.value = true;
      onlineAt.value = Date.now();
    });
  }

  if (connection) useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline,
    saveData,
    offlineAt,
    onlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type
  };
}

var core_defProp$5 = Object.defineProperty;
var core_getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var core_hasOwnProp$5 = Object.prototype.hasOwnProperty;
var core_propIsEnum$5 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$5 = (obj, key, value) => key in obj ? core_defProp$5(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$5.call(b, prop)) core_defNormalProp$5(a, prop, b[prop]);

  if (core_getOwnPropSymbols$5) for (var prop of core_getOwnPropSymbols$5(b)) {
    if (core_propIsEnum$5.call(b, prop)) core_defNormalProp$5(a, prop, b[prop]);
  }
  return a;
};

function useNow(options = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame"
  } = options;
  const now = ref(new Date());

  const update = () => now.value = new Date();

  const controls = interval === "requestAnimationFrame" ? useRafFn(update, {
    immediate: true
  }) : useIntervalFn(update, interval, {
    immediate: true
  });

  if (exposeControls) {
    return core_spreadValues$5({
      now
    }, controls);
  } else {
    return now;
  }
}

function useObjectUrl(object) {
  const url = ref();

  const release = () => {
    if (url.value) URL.revokeObjectURL(url.value);
    url.value = void 0;
  };

  watch(() => unref(object), newObject => {
    release();
    if (newObject) url.value = URL.createObjectURL(newObject);
  }, {
    immediate: true
  });
  tryOnScopeDispose(release);
  return readonly(url);
}

function useOffsetPagination(options) {
  const {
    total = Infinity,
    pageSize = 10,
    page = 1,
    onPageChange = noop,
    onPageSizeChange = noop,
    onPageCountChange = noop
  } = options;
  const currentPageSize = useClamp(pageSize, 1, Infinity);
  const pageCount = computed(() => Math.ceil(unref(total) / unref(currentPageSize)));
  const currentPage = useClamp(page, 1, pageCount);
  const isFirstPage = computed(() => currentPage.value === 1);
  const isLastPage = computed(() => currentPage.value === pageCount.value);
  if (isRef(page)) syncRef(page, currentPage);
  if (isRef(pageSize)) syncRef(pageSize, currentPageSize);

  function prev() {
    currentPage.value--;
  }

  function next() {
    currentPage.value++;
  }

  const returnValue = {
    currentPage,
    currentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev,
    next
  };
  watch(currentPage, () => {
    onPageChange(reactive(returnValue));
  });
  watch(currentPageSize, () => {
    onPageSizeChange(reactive(returnValue));
  });
  watch(pageCount, () => {
    onPageCountChange(reactive(returnValue));
  });
  return returnValue;
}

function useOnline(options = {}) {
  const {
    isOnline
  } = useNetwork(options);
  return isOnline;
}

function usePageLeave(options = {}) {
  const {
    window = defaultWindow
  } = options;
  const isLeft = ref(false);

  const handler = event => {
    if (!window) return;
    event = event || window.event;
    const from = event.relatedTarget || event.toElement;
    isLeft.value = !from;
  };

  if (window) {
    useEventListener(window, "mouseout", handler, {
      passive: true
    });
    useEventListener(window.document, "mouseleave", handler, {
      passive: true
    });
    useEventListener(window.document, "mouseenter", handler, {
      passive: true
    });
  }

  return isLeft;
}

function useParallax(target, options = {}) {
  const {
    deviceOrientationTiltAdjust = i => i,
    deviceOrientationRollAdjust = i => i,
    mouseTiltAdjust = i => i,
    mouseRollAdjust = i => i,
    window = defaultWindow
  } = options;
  const orientation = reactive(useDeviceOrientation({
    window
  }));
  const {
    elementX: x,
    elementY: y,
    elementWidth: width,
    elementHeight: height
  } = useMouseInElement(target, {
    handleOutside: false,
    window
  });
  const source = computed(() => {
    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) return "deviceOrientation";
    return "mouse";
  });
  const roll = computed(() => {
    if (source.value === "deviceOrientation") {
      const value = -orientation.beta / 90;
      return deviceOrientationRollAdjust(value);
    } else {
      const value = -(y.value - height.value / 2) / height.value;
      return mouseRollAdjust(value);
    }
  });
  const tilt = computed(() => {
    if (source.value === "deviceOrientation") {
      const value = orientation.gamma / 90;
      return deviceOrientationTiltAdjust(value);
    } else {
      const value = (x.value - width.value / 2) / width.value;
      return mouseTiltAdjust(value);
    }
  });
  return {
    roll,
    tilt,
    source
  };
}

var core_defProp$4 = Object.defineProperty;
var core_defProps$1 = Object.defineProperties;
var core_getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var core_getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var core_hasOwnProp$4 = Object.prototype.hasOwnProperty;
var core_propIsEnum$4 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$4 = (obj, key, value) => key in obj ? core_defProp$4(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$4.call(b, prop)) core_defNormalProp$4(a, prop, b[prop]);

  if (core_getOwnPropSymbols$4) for (var prop of core_getOwnPropSymbols$4(b)) {
    if (core_propIsEnum$4.call(b, prop)) core_defNormalProp$4(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps$1 = (a, b) => core_defProps$1(a, core_getOwnPropDescs$1(b));

const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */(/* unused pure expression or super */ null && (Object.keys(defaultState)));

function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = ref(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);

  const handler = event => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType)) return;
    state.value = objectPick(event, keys, false);
  };

  if (target) {
    useEventListener(target, "pointerdown", handler, {
      passive: true
    });
    useEventListener(target, "pointermove", handler, {
      passive: true
    });
    useEventListener(target, "pointerleave", () => isInside.value = false, {
      passive: true
    });
  }

  return core_spreadProps$1(core_spreadValues$4({}, toRefs(state)), {
    isInside
  });
}

var SwipeDirection;

(function (SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));

function useSwipe(target, options = {}) {
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    passive = true,
    window = defaultWindow
  } = options;
  const coordsStart = reactive({
    x: 0,
    y: 0
  });
  const coordsEnd = reactive({
    x: 0,
    y: 0
  });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const {
    max,
    abs
  } = Math;
  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = ref(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value) return SwipeDirection.NONE;

    if (abs(diffX.value) > abs(diffY.value)) {
      return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
    } else {
      return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
    }
  });

  const getTouchEventCoords = e => [e.touches[0].clientX, e.touches[0].clientY];

  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };

  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };

  let listenerOptions;
  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);
  if (!passive) listenerOptions = isPassiveEventSupported ? {
    passive: false,
    capture: true
  } : {
    capture: true
  };else listenerOptions = isPassiveEventSupported ? {
    passive: true
  } : {
    capture: false
  };

  const onTouchEnd = e => {
    if (isSwiping.value) onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  };

  const stops = [useEventListener(target, "touchstart", e => {
    if (listenerOptions.capture && !listenerOptions.passive) e.preventDefault();
    const [x, y] = getTouchEventCoords(e);
    updateCoordsStart(x, y);
    updateCoordsEnd(x, y);
    onSwipeStart == null ? void 0 : onSwipeStart(e);
  }, listenerOptions), useEventListener(target, "touchmove", e => {
    const [x, y] = getTouchEventCoords(e);
    updateCoordsEnd(x, y);
    if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
    if (isSwiping.value) onSwipe == null ? void 0 : onSwipe(e);
  }, listenerOptions), useEventListener(target, "touchend", onTouchEnd, listenerOptions), useEventListener(target, "touchcancel", onTouchEnd, listenerOptions)];

  const stop = () => stops.forEach(s => s());

  return {
    isPassiveEventSupported,
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop
  };
}

function checkPassiveEventSupport(document) {
  if (!document) return false;
  let supportsPassive = false;
  const optionsBlock = {
    get passive() {
      supportsPassive = true;
      return false;
    }

  };
  document.addEventListener("x", noop, optionsBlock);
  document.removeEventListener("x", noop);
  return supportsPassive;
}

function usePointerSwipe(target, options = {}) {
  const targetRef = ref(target);
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart
  } = options;
  const posStart = reactive({
    x: 0,
    y: 0
  });

  const updatePosStart = (x, y) => {
    posStart.x = x;
    posStart.y = y;
  };

  const posEnd = reactive({
    x: 0,
    y: 0
  });

  const updatePosEnd = (x, y) => {
    posEnd.x = x;
    posEnd.y = y;
  };

  const distanceX = computed(() => posStart.x - posEnd.x);
  const distanceY = computed(() => posStart.y - posEnd.y);
  const {
    max,
    abs
  } = Math;
  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);
  const isSwiping = ref(false);
  const isPointerDown = ref(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value) return SwipeDirection.NONE;

    if (abs(distanceX.value) > abs(distanceY.value)) {
      return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
    } else {
      return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
    }
  });

  const filterEvent = e => {
    if (options.pointerTypes) return options.pointerTypes.includes(e.pointerType);
    return true;
  };

  const stops = [useEventListener(target, "pointerdown", e => {
    var _a, _b;

    if (!filterEvent(e)) return;
    isPointerDown.value = true;
    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "none");
    const eventTarget = e.target;
    eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
    const {
      clientX: x,
      clientY: y
    } = e;
    updatePosStart(x, y);
    updatePosEnd(x, y);
    onSwipeStart == null ? void 0 : onSwipeStart(e);
  }), useEventListener(target, "pointermove", e => {
    if (!filterEvent(e)) return;
    if (!isPointerDown.value) return;
    const {
      clientX: x,
      clientY: y
    } = e;
    updatePosEnd(x, y);
    if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
    if (isSwiping.value) onSwipe == null ? void 0 : onSwipe(e);
  }), useEventListener(target, "pointerup", e => {
    var _a, _b;

    if (!filterEvent(e)) return;
    if (isSwiping.value) onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isPointerDown.value = false;
    isSwiping.value = false;
    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "initial");
  })];

  const stop = () => stops.forEach(s => s());

  return {
    isSwiping: readonly(isSwiping),
    direction: readonly(direction),
    posStart: readonly(posStart),
    posEnd: readonly(posEnd),
    distanceX,
    distanceY,
    stop
  };
}

function usePreferredColorScheme(options) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options);
  return computed(() => {
    if (isDark.value) return "dark";
    if (isLight.value) return "light";
    return "no-preference";
  });
}

function usePreferredLanguages(options = {}) {
  const {
    window = defaultWindow
  } = options;
  if (!window) return ref(["en"]);
  const navigator = window.navigator;
  const value = ref(navigator.languages);
  useEventListener(window, "languagechange", () => {
    value.value = navigator.languages;
  });
  return value;
}

const useScreenOrientation = (options = {}) => {
  const {
    window = defaultWindow
  } = options;
  const isSupported = !!(window && "screen" in window && "orientation" in window.screen);
  const screenOrientation = isSupported ? window.screen.orientation : {};
  const orientation = ref(screenOrientation.type);
  const angle = ref(screenOrientation.angle || 0);

  if (isSupported) {
    useEventListener(window, "orientationchange", () => {
      orientation.value = screenOrientation.type;
      angle.value = screenOrientation.angle;
    });
  }

  const lockOrientation = type => {
    if (!isSupported) return Promise.reject(new Error("Not supported"));
    return screenOrientation.lock(type);
  };

  const unlockOrientation = () => {
    if (isSupported) screenOrientation.unlock();
  };

  return {
    isSupported,
    orientation,
    angle,
    lockOrientation,
    unlockOrientation
  };
};

const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";

function useScreenSafeArea() {
  const top = ref("");
  const right = ref("");
  const bottom = ref("");
  const left = ref("");

  if (isClient) {
    const topCssVar = useCssVar(topVarName);
    const rightCssVar = useCssVar(rightVarName);
    const bottomCssVar = useCssVar(bottomVarName);
    const leftCssVar = useCssVar(leftVarName);
    topCssVar.value = "env(safe-area-inset-top, 0px)";
    rightCssVar.value = "env(safe-area-inset-right, 0px)";
    bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
    leftCssVar.value = "env(safe-area-inset-left, 0px)";
    update();
    useEventListener("resize", useDebounceFn(update));
  }

  function update() {
    top.value = getValue(topVarName);
    right.value = getValue(rightVarName);
    bottom.value = getValue(bottomVarName);
    left.value = getValue(leftVarName);
  }

  return {
    top,
    right,
    bottom,
    left,
    update
  };
}

function getValue(position) {
  return getComputedStyle(document.documentElement).getPropertyValue(position);
}

function useScriptTag(src, onLoaded = noop, options = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document = defaultDocument,
    attrs = {}
  } = options;
  const scriptTag = ref(null);
  let _promise = null;

  const loadScript = waitForScriptLoad => new Promise((resolve, reject) => {
    const resolveWithElement = el2 => {
      scriptTag.value = el2;
      resolve(el2);
      return el2;
    };

    if (!document) {
      resolve(false);
      return;
    }

    let shouldAppend = false;
    let el = document.querySelector(`script[src="${src}"]`);

    if (!el) {
      el = document.createElement("script");
      el.type = type;
      el.async = async;
      el.src = unref(src);
      if (defer) el.defer = defer;
      if (crossOrigin) el.crossOrigin = crossOrigin;
      if (noModule) el.noModule = noModule;
      if (referrerPolicy) el.referrerPolicy = referrerPolicy;
      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }

    el.addEventListener("error", event => reject(event));
    el.addEventListener("abort", event => reject(event));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend) el = document.head.appendChild(el);
    if (!waitForScriptLoad) resolveWithElement(el);
  });

  const load = (waitForScriptLoad = true) => {
    if (!_promise) _promise = loadScript(waitForScriptLoad);
    return _promise;
  };

  const unload = () => {
    if (!document) return;
    _promise = null;
    if (scriptTag.value) scriptTag.value = null;
    const el = document.querySelector(`script[src="${src}"]`);
    if (el) document.head.removeChild(el);
  };

  if (immediate && !manual) tryOnMounted(load);
  if (!manual) tryOnUnmounted(unload);
  return {
    scriptTag,
    load,
    unload
  };
}

function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  if (e.touches.length > 1) return true;
  if (e.preventDefault) e.preventDefault();
  return false;
}

function useScrollLock(element, initialState = false) {
  const isLocked = ref(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow;
  watch(() => unref(element), el => {
    if (el) {
      const ele = el;
      initialOverflow = ele.style.overflow;
      if (isLocked.value) ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });

  const lock = () => {
    const ele = unref(element);
    if (!ele || isLocked.value) return;

    if (isIOS) {
      stopTouchMoveListener = useEventListener(ele, "touchmove", preventDefault, {
        passive: false
      });
    }

    ele.style.overflow = "hidden";
    isLocked.value = true;
  };

  const unlock = () => {
    const ele = unref(element);
    if (!ele || !isLocked.value) return;
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    ele.style.overflow = initialOverflow;
    isLocked.value = false;
  };

  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },

    set(v) {
      if (v) lock();else unlock();
    }

  });
}

function useSessionStorage(key, initialValue, options = {}) {
  const {
    window = defaultWindow
  } = options;
  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);
}

var core_defProp$3 = Object.defineProperty;
var core_getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var core_hasOwnProp$3 = Object.prototype.hasOwnProperty;
var core_propIsEnum$3 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$3 = (obj, key, value) => key in obj ? core_defProp$3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$3.call(b, prop)) core_defNormalProp$3(a, prop, b[prop]);

  if (core_getOwnPropSymbols$3) for (var prop of core_getOwnPropSymbols$3(b)) {
    if (core_propIsEnum$3.call(b, prop)) core_defNormalProp$3(a, prop, b[prop]);
  }
  return a;
};

function useShare(shareOptions = {}, options = {}) {
  const {
    navigator = defaultNavigator
  } = options;
  const _navigator = navigator;
  const isSupported = _navigator && "canShare" in _navigator;

  const share = async (overrideOptions = {}) => {
    if (isSupported) {
      const data = core_spreadValues$3(core_spreadValues$3({}, unref(shareOptions)), unref(overrideOptions));

      let granted = true;
      if (data.files && _navigator.canShare) granted = _navigator.canShare({
        files: data.files
      });
      if (granted) return _navigator.share(data);
    }
  };

  return {
    isSupported,
    share
  };
}

function useSpeechRecognition(options = {}) {
  const {
    interimResults = true,
    continuous = true,
    window = defaultWindow
  } = options;
  const lang = ref(options.lang || "en-US");
  const isListening = ref(false);
  const isFinal = ref(false);
  const result = ref("");
  const error = shallowRef(void 0);

  const toggle = (value = !isListening.value) => {
    isListening.value = value;
  };

  const start = () => {
    isListening.value = true;
  };

  const stop = () => {
    isListening.value = false;
  };

  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);
  const isSupported = Boolean(SpeechRecognition);
  let recognition;

  if (isSupported) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = unref(lang);

    recognition.onstart = () => {
      isFinal.value = false;
    };

    watch(lang, lang2 => {
      if (recognition && !isListening.value) recognition.lang = lang2;
    });

    recognition.onresult = event => {
      const transcript = Array.from(event.results).map(result2 => {
        isFinal.value = result2.isFinal;
        return result2[0];
      }).map(result2 => result2.transcript).join("");
      result.value = transcript;
      error.value = void 0;
    };

    recognition.onerror = event => {
      error.value = event;
    };

    recognition.onend = () => {
      isListening.value = false;
      recognition.lang = unref(lang);
    };

    watch(isListening, () => {
      if (isListening.value) recognition.start();else recognition.stop();
    });
  }

  tryOnScopeDispose(() => {
    isListening.value = false;
  });
  return {
    isSupported,
    isListening,
    isFinal,
    recognition,
    result,
    error,
    toggle,
    start,
    stop
  };
}

function useSpeechSynthesis(text, options = {}) {
  var _a, _b;

  const {
    pitch = 1,
    rate = 1,
    volume = 1,
    window = defaultWindow
  } = options;
  const synth = window && window.speechSynthesis;
  const isSupported = Boolean(synth);
  const isPlaying = ref(false);
  const status = ref("init");
  const voiceInfo = {
    lang: ((_a = options.voice) == null ? void 0 : _a.lang) || "default",
    name: ((_b = options.voice) == null ? void 0 : _b.name) || ""
  };
  const spokenText = ref(text || "");
  const lang = ref(options.lang || "en-US");
  const error = shallowRef(void 0);

  const toggle = (value = !isPlaying.value) => {
    isPlaying.value = value;
  };

  const bindEventsForUtterance = utterance2 => {
    utterance2.lang = unref(lang);
    options.voice && (utterance2.voice = options.voice);
    utterance2.pitch = pitch;
    utterance2.rate = rate;
    utterance2.volume = volume;

    utterance2.onstart = () => {
      isPlaying.value = true;
      status.value = "play";
    };

    utterance2.onpause = () => {
      isPlaying.value = false;
      status.value = "pause";
    };

    utterance2.onresume = () => {
      isPlaying.value = true;
      status.value = "play";
    };

    utterance2.onend = () => {
      isPlaying.value = false;
      status.value = "end";
    };

    utterance2.onerror = event => {
      error.value = event;
    };

    utterance2.onend = () => {
      isPlaying.value = false;
      utterance2.lang = unref(lang);
    };
  };

  const utterance = computed(() => {
    isPlaying.value = false;
    status.value = "init";
    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });

  const speak = () => {
    synth.cancel();
    utterance && synth.speak(utterance.value);
  };

  if (isSupported) {
    bindEventsForUtterance(utterance.value);
    watch(lang, lang2 => {
      if (utterance.value && !isPlaying.value) utterance.value.lang = lang2;
    });
    watch(isPlaying, () => {
      if (isPlaying.value) synth.resume();else synth.pause();
    });
  }

  tryOnScopeDispose(() => {
    isPlaying.value = false;
  });
  return {
    isSupported,
    isPlaying,
    status,
    voiceInfo,
    utterance,
    error,
    toggle,
    speak
  };
}

function useStepper(steps, initialStep) {
  const stepsRef = ref(steps);
  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));
  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));
  const current = computed(() => at(index.value));
  const isFirst = computed(() => index.value === 0);
  const isLast = computed(() => index.value === stepNames.value.length - 1);
  const next = computed(() => stepNames.value[index.value + 1]);
  const previous = computed(() => stepNames.value[index.value - 1]);

  function at(index2) {
    if (Array.isArray(stepsRef.value)) return stepsRef.value[index2];
    return stepsRef.value[stepNames.value[index2]];
  }

  function get(step) {
    if (!stepNames.value.includes(step)) return;
    return at(stepNames.value.indexOf(step));
  }

  function goTo(step) {
    if (stepNames.value.includes(step)) index.value = stepNames.value.indexOf(step);
  }

  function goToNext() {
    if (isLast.value) return;
    index.value++;
  }

  function goToPrevious() {
    if (isFirst.value) return;
    index.value--;
  }

  function goBackTo(step) {
    if (isAfter(step)) goTo(step);
  }

  function isNext(step) {
    return stepNames.value.indexOf(step) === index.value + 1;
  }

  function isPrevious(step) {
    return stepNames.value.indexOf(step) === index.value - 1;
  }

  function isCurrent(step) {
    return stepNames.value.indexOf(step) === index.value;
  }

  function isBefore(step) {
    return index.value < stepNames.value.indexOf(step);
  }

  function isAfter(step) {
    return index.value > stepNames.value.indexOf(step);
  }

  return {
    steps: stepsRef,
    stepNames,
    index,
    current,
    next,
    previous,
    isFirst,
    isLast,
    at,
    get,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}

function useStorageAsync(key, initialValue, storage, options = {}) {
  var _a;

  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window = defaultWindow,
    eventFilter,
    onError = e => {
      console.error(e);
    }
  } = options;
  const rawInit = unref(initialValue);
  const type = guessSerializerType(rawInit);
  const data = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];

  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;

        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }

  async function read(event) {
    if (!storage || event && event.key !== key) return;

    try {
      const rawValue = event ? event.newValue : await storage.getItem(key);

      if (rawValue == null) {
        data.value = rawInit;
        if (writeDefaults && rawInit !== null) await storage.setItem(key, await serializer.write(rawInit));
      } else {
        data.value = await serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    }
  }

  read();
  if (window && listenToStorageChanges) useEventListener(window, "storage", e => setTimeout(() => read(e), 0));

  if (storage) {
    watchWithFilter(data, async () => {
      try {
        if (data.value == null) await storage.removeItem(key);else await storage.setItem(key, await serializer.write(data.value));
      } catch (e) {
        onError(e);
      }
    }, {
      flush,
      deep,
      eventFilter
    });
  }

  return data;
}

let _id = 0;

function useStyleTag(css, options = {}) {
  const isLoaded = ref(false);
  const {
    document = defaultDocument,
    immediate = true,
    manual = false,
    id = `vueuse_styletag_${++_id}`
  } = options;
  const cssRef = ref(css);

  let stop = () => {};

  const load = () => {
    if (!document) return;
    const el = document.getElementById(id) || document.createElement("style");
    el.type = "text/css";
    el.id = id;
    if (options.media) el.media = options.media;
    document.head.appendChild(el);
    if (isLoaded.value) return;
    stop = watch(cssRef, value => {
      el.innerText = value;
    }, {
      immediate: true
    });
    isLoaded.value = true;
  };

  const unload = () => {
    if (!document || !isLoaded.value) return;
    stop();
    document.head.removeChild(document.getElementById(id));
    isLoaded.value = false;
  };

  if (immediate && !manual) tryOnMounted(load);
  if (!manual) tryOnScopeDispose(unload);
  return {
    id,
    css: cssRef,
    unload,
    load,
    isLoaded: readonly(isLoaded)
  };
}

function useTemplateRefsList() {
  const refs = ref([]);

  refs.value.set = el => {
    if (el) refs.value.push(el);
  };

  onBeforeUpdate(() => {
    refs.value.length = 0;
  });
  return refs;
}

function getRangesFromSelection(selection) {
  var _a;

  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;
  const ranges = new Array(rangeCount);

  for (let i = 0; i < rangeCount; i++) {
    const range = selection.getRangeAt(i);
    ranges[i] = range;
  }

  return ranges;
}

function useTextSelection(options = {}) {
  const {
    window = defaultWindow
  } = options;
  const selection = ref(null);
  const text = computed(() => {
    var _a, _b;

    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : "";
  });
  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);
  const rects = computed(() => ranges.value.map(range => range.getBoundingClientRect()));

  function onSelectionChange() {
    selection.value = null;
    if (window) selection.value = window.getSelection();
  }

  if (window) useEventListener(window.document, "selectionchange", onSelectionChange);
  return {
    text,
    rects,
    ranges,
    selection
  };
}

function useTextareaAutosize(options) {
  const textarea = ref(options == null ? void 0 : options.element);
  const input = ref(options == null ? void 0 : options.input);

  function triggerResize() {
    var _a, _b;

    if (!textarea.value) return;
    textarea.value.style.height = "1px";
    textarea.value.style.height = `${(_a = textarea.value) == null ? void 0 : _a.scrollHeight}px`;
    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);
  }

  watch([input, textarea], triggerResize, {
    immediate: true
  });
  if (options == null ? void 0 : options.watch) watch(options.watch, triggerResize, {
    immediate: true,
    deep: true
  });
  return {
    textarea,
    input,
    triggerResize
  };
}

var core_defProp$2 = Object.defineProperty;
var core_defProps = Object.defineProperties;
var core_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var core_getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var core_hasOwnProp$2 = Object.prototype.hasOwnProperty;
var core_propIsEnum$2 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$2 = (obj, key, value) => key in obj ? core_defProp$2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$2.call(b, prop)) core_defNormalProp$2(a, prop, b[prop]);

  if (core_getOwnPropSymbols$2) for (var prop of core_getOwnPropSymbols$2(b)) {
    if (core_propIsEnum$2.call(b, prop)) core_defNormalProp$2(a, prop, b[prop]);
  }
  return a;
};

var core_spreadProps = (a, b) => core_defProps(a, core_getOwnPropDescs(b));

function useThrottledRefHistory(source, options = {}) {
  const {
    throttle = 200,
    trailing = true
  } = options;
  const filter = throttleFilter(throttle, trailing);
  const history = useRefHistory(source, core_spreadProps(core_spreadValues$2({}, options), {
    eventFilter: filter
  }));
  return core_spreadValues$2({}, history);
}

var core_defProp$1 = Object.defineProperty;
var core_getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var core_hasOwnProp$1 = Object.prototype.hasOwnProperty;
var core_propIsEnum$1 = Object.prototype.propertyIsEnumerable;

var core_defNormalProp$1 = (obj, key, value) => key in obj ? core_defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp$1.call(b, prop)) core_defNormalProp$1(a, prop, b[prop]);

  if (core_getOwnPropSymbols$1) for (var prop of core_getOwnPropSymbols$1(b)) {
    if (core_propIsEnum$1.call(b, prop)) core_defNormalProp$1(a, prop, b[prop]);
  }
  return a;
};

var core_objRest = (source, exclude) => {
  var target = {};

  for (var prop in source) if (core_hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];

  if (source != null && core_getOwnPropSymbols$1) for (var prop of core_getOwnPropSymbols$1(source)) {
    if (exclude.indexOf(prop) < 0 && core_propIsEnum$1.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};

const UNITS = [{
  max: 6e4,
  value: 1e3,
  name: "second"
}, {
  max: 276e4,
  value: 6e4,
  name: "minute"
}, {
  max: 72e6,
  value: 36e5,
  name: "hour"
}, {
  max: 5184e5,
  value: 864e5,
  name: "day"
}, {
  max: 24192e5,
  value: 6048e5,
  name: "week"
}, {
  max: 28512e6,
  value: 2592e6,
  name: "month"
}, {
  max: Infinity,
  value: 31536e6,
  name: "year"
}];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: n => n.match(/\d/) ? `${n} ago` : n,
  future: n => n.match(/\d/) ? `in ${n}` : n,
  month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
  year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
  day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
  week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
  hour: n => `${n} hour${n > 1 ? "s" : ""}`,
  minute: n => `${n} minute${n > 1 ? "s" : ""}`,
  second: n => `${n} second${n > 1 ? "s" : ""}`
};

const DEFAULT_FORMATTER = date => date.toISOString().slice(0, 10);

function useTimeAgo(time, options = {}) {
  const {
    controls: exposeControls = false,
    max,
    updateInterval = 3e4,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER
  } = options;
  const {
    abs,
    round
  } = Math;

  const _a = useNow({
    interval: updateInterval,
    controls: true
  }),
        {
    now
  } = _a,
        controls = core_objRest(_a, ["now"]);

  function getTimeago(from, now2) {
    var _a2;

    const diff = +now2 - +from;
    const absDiff = abs(diff);
    if (absDiff < 6e4) return messages.justNow;
    if (typeof max === "number" && absDiff > max) return fullDateFormatter(new Date(from));

    if (typeof max === "string") {
      const unitMax = (_a2 = UNITS.find(i => i.name === max)) == null ? void 0 : _a2.max;
      if (unitMax && absDiff > unitMax) return fullDateFormatter(new Date(from));
    }

    for (const unit of UNITS) {
      if (absDiff < unit.max) return format(diff, unit);
    }
  }

  function applyFormat(name, val, isPast) {
    const formatter = messages[name];
    if (typeof formatter === "function") return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }

  function format(diff, unit) {
    const val = round(abs(diff) / unit.value);
    const past = diff > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }

  const timeAgo = computed(() => getTimeago(new Date(unref(time)), unref(now.value)));

  if (exposeControls) {
    return core_spreadValues$1({
      timeAgo
    }, controls);
  } else {
    return timeAgo;
  }
}

function useTimeoutPoll(fn, interval, timeoutPollOptions) {
  const {
    start
  } = useTimeoutFn(loop, interval);
  const isActive = ref(false);

  async function loop() {
    if (!isActive.value) return;
    await fn();
    start();
  }

  function resume() {
    if (!isActive.value) {
      isActive.value = true;
      loop();
    }
  }

  function pause() {
    isActive.value = false;
  }

  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate) resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

var core_defProp = Object.defineProperty;
var core_getOwnPropSymbols = Object.getOwnPropertySymbols;
var core_hasOwnProp = Object.prototype.hasOwnProperty;
var core_propIsEnum = Object.prototype.propertyIsEnumerable;

var core_defNormalProp = (obj, key, value) => key in obj ? core_defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;

var core_spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (core_hasOwnProp.call(b, prop)) core_defNormalProp(a, prop, b[prop]);

  if (core_getOwnPropSymbols) for (var prop of core_getOwnPropSymbols(b)) {
    if (core_propIsEnum.call(b, prop)) core_defNormalProp(a, prop, b[prop]);
  }
  return a;
};

function useTimestamp(options = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame"
  } = options;
  const ts = ref(timestamp() + offset);

  const update = () => ts.value = timestamp() + offset;

  const controls = interval === "requestAnimationFrame" ? useRafFn(update, {
    immediate
  }) : useIntervalFn(update, interval, {
    immediate
  });

  if (exposeControls) {
    return core_spreadValues({
      timestamp: ts
    }, controls);
  } else {
    return ts;
  }
}

function useTitle(newTitle = null, options = {}) {
  var _a, _b;

  const {
    document = defaultDocument,
    observe = false,
    titleTemplate = "%s"
  } = options;
  const title = ref((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);
  watch(title, (t, o) => {
    if (isString(t) && t !== o && document) document.title = titleTemplate.replace("%s", t);
  }, {
    immediate: true
  });

  if (observe && document) {
    useMutationObserver((_b = document.head) == null ? void 0 : _b.querySelector("title"), () => {
      if (document && document.title !== title.value) title.value = titleTemplate.replace("%s", document.title);
    }, {
      childList: true
    });
  }

  return title;
}

const TransitionPresets = {
  linear: shared_identity,
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};

function createEasingFunction([p0, p1, p2, p3]) {
  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;

  const b = (a1, a2) => 3 * a2 - 6 * a1;

  const c = a1 => 3 * a1;

  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;

  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);

  const getTforX = x => {
    let aGuessT = x;

    for (let i = 0; i < 4; ++i) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0) return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  };

  return x => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}

function useTransition(source, options = {}) {
  const {
    delay = 0,
    disabled = false,
    duration = 1e3,
    onFinished = noop,
    onStarted = noop,
    transition = identity
  } = options;
  const currentTransition = computed(() => {
    const t = unref(transition);
    return isFunction(t) ? t : createEasingFunction(t);
  });
  const sourceValue = computed(() => {
    const s = unref(source);
    return isNumber(s) ? s : s.map(unref);
  });
  const sourceVector = computed(() => isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);
  const outputVector = ref(sourceVector.value.slice(0));
  let currentDuration;
  let diffVector;
  let endAt;
  let startAt;
  let startVector;
  const {
    resume,
    pause
  } = useRafFn(() => {
    const now = Date.now();
    const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);
    outputVector.value = startVector.map((val, i) => {
      var _a;

      return val + ((_a = diffVector[i]) != null ? _a : 0) * currentTransition.value(progress);
    });

    if (progress >= 1) {
      pause();
      onFinished();
    }
  }, {
    immediate: false
  });

  const start = () => {
    pause();
    currentDuration = unref(duration);
    diffVector = outputVector.value.map((n, i) => {
      var _a, _b;

      return ((_a = sourceVector.value[i]) != null ? _a : 0) - ((_b = outputVector.value[i]) != null ? _b : 0);
    });
    startVector = outputVector.value.slice(0);
    startAt = Date.now();
    endAt = startAt + currentDuration;
    resume();
    onStarted();
  };

  const timeout = useTimeoutFn(start, delay, {
    immediate: false
  });
  watch(sourceVector, () => {
    if (unref(disabled)) {
      outputVector.value = sourceVector.value.slice(0);
    } else {
      if (unref(delay) <= 0) start();else timeout.start();
    }
  }, {
    deep: true
  });
  return computed(() => {
    const targetVector = unref(disabled) ? sourceVector : outputVector;
    return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;
  });
}

function useUrlSearchParams(mode = "history", options = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    window = defaultWindow
  } = options;
  if (!window) return reactive(initialValue);
  const state = reactive({});

  function getRawParams() {
    if (mode === "history") {
      return window.location.search || "";
    } else if (mode === "hash") {
      const hash = window.location.hash || "";
      const index = hash.indexOf("?");
      return index > 0 ? hash.slice(index) : "";
    } else {
      return (window.location.hash || "").replace(/^#/, "");
    }
  }

  function constructQuery(params) {
    const stringified = params.toString();
    if (mode === "history") return `${stringified ? `?${stringified}` : ""}${location.hash || ""}`;
    if (mode === "hash-params") return `${location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window.location.hash || "#";
    const index = hash.indexOf("?");
    if (index > 0) return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
    return `${hash}${stringified ? `?${stringified}` : ""}`;
  }

  function read() {
    return new URLSearchParams(getRawParams());
  }

  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));

    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
      unusedKeys.delete(key);
    }

    Array.from(unusedKeys).forEach(key => delete state[key]);
  }

  const {
    pause,
    resume
  } = pausableWatch(state, () => {
    const params = new URLSearchParams("");
    Object.keys(state).forEach(key => {
      const mapEntry = state[key];
      if (Array.isArray(mapEntry)) mapEntry.forEach(value => params.append(key, value));else if (removeNullishValues && mapEntry == null) params.delete(key);else if (removeFalsyValues && !mapEntry) params.delete(key);else params.set(key, mapEntry);
    });
    write(params);
  }, {
    deep: true
  });

  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate) updateState(params);
    window.history.replaceState(window.history.state, window.document.title, window.location.pathname + constructQuery(params));
    resume();
  }

  function onChanged() {
    write(read(), true);
  }

  useEventListener(window, "popstate", onChanged, false);
  if (mode !== "history") useEventListener(window, "hashchange", onChanged, false);
  const initial = read();
  if (initial.keys().next().value) updateState(initial);else Object.assign(state, initialValue);
  return state;
}

function useUserMedia(options = {}) {
  var _a, _b, _c;

  const enabled = ref((_a = options.enabled) != null ? _a : false);
  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);
  const videoDeviceId = ref(options.videoDeviceId);
  const audioDeviceId = ref(options.audioDeviceId);
  const {
    navigator = defaultNavigator
  } = options;
  const isSupported = Boolean((_c = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _c.getUserMedia);
  const stream = shallowRef();

  function getDeviceOptions(device) {
    if (device.value === "none" || device.value === false) return false;
    if (device.value == null) return true;
    return {
      deviceId: device.value
    };
  }

  async function _start() {
    if (!isSupported || stream.value) return;
    stream.value = await navigator.mediaDevices.getUserMedia({
      video: getDeviceOptions(videoDeviceId),
      audio: getDeviceOptions(audioDeviceId)
    });
    return stream.value;
  }

  async function _stop() {
    var _a2;

    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach(t => t.stop());
    stream.value = void 0;
  }

  function stop() {
    _stop();

    enabled.value = false;
  }

  async function start() {
    await _start();
    if (stream.value) enabled.value = true;
    return stream.value;
  }

  async function restart() {
    _stop();

    return await start();
  }

  watch(enabled, v => {
    if (v) _start();else _stop();
  }, {
    immediate: true
  });
  watch([videoDeviceId, audioDeviceId], () => {
    if (autoSwitch.value && stream.value) restart();
  }, {
    immediate: true
  });
  return {
    isSupported,
    stream,
    start,
    stop,
    restart,
    videoDeviceId,
    audioDeviceId,
    enabled,
    autoSwitch
  };
}

function useVModel(props, key, emit, options = {}) {
  var _a, _b, _c, _d, _e;

  const {
    passive = false,
    eventName,
    deep = false,
    defaultValue
  } = options;
  const vm = getCurrentInstance();

  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));

  let event = eventName;

  if (!key) {
    if (isVue2) {
      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;
      key = (modelOptions == null ? void 0 : modelOptions.value) || "value";
      if (!eventName) event = (modelOptions == null ? void 0 : modelOptions.event) || "input";
    } else {
      key = "modelValue";
    }
  }

  event = eventName || event || `update:${key.toString()}`;

  const getValue = () => isDef(props[key]) ? props[key] : defaultValue;

  if (passive) {
    const proxy = ref(getValue());
    watch(() => props[key], v => proxy.value = v);
    watch(proxy, v => {
      if (v !== props[key] || deep) _emit(event, v);
    }, {
      deep
    });
    return proxy;
  } else {
    return computed({
      get() {
        return getValue();
      },

      set(value) {
        _emit(event, value);
      }

    });
  }
}

function useVModels(props, emit, options = {}) {
  const ret = {};

  for (const key in props) ret[key] = useVModel(props, key, emit, options);

  return ret;
}

function useVibrate(options) {
  const {
    pattern = [],
    interval = 0,
    navigator = defaultNavigator
  } = options || {};
  const isSupported = typeof navigator !== "undefined" && "vibrate" in navigator;
  const patternRef = ref(pattern);
  let intervalControls;

  const vibrate = (pattern2 = patternRef.value) => {
    if (isSupported) navigator.vibrate(pattern2);
  };

  const stop = () => {
    if (isSupported) navigator.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  };

  if (interval > 0) {
    intervalControls = useIntervalFn(vibrate, interval, {
      immediate: false,
      immediateCallback: false
    });
  }

  return {
    isSupported,
    pattern,
    intervalControls,
    vibrate,
    stop
  };
}

function useVirtualList(list, options) {
  const containerRef = ref();
  const size = useElementSize(containerRef);
  const currentList = ref([]);
  const source = shallowRef(list);
  const state = ref({
    start: 0,
    end: 10
  });
  const {
    itemHeight,
    overscan = 5
  } = options;

  const getViewCapacity = containerHeight => {
    if (typeof itemHeight === "number") return Math.ceil(containerHeight / itemHeight);
    const {
      start = 0
    } = state.value;
    let sum = 0;
    let capacity = 0;

    for (let i = start; i < source.value.length; i++) {
      const height = itemHeight(i);
      sum += height;

      if (sum >= containerHeight) {
        capacity = i;
        break;
      }
    }

    return capacity - start;
  };

  const getOffset = scrollTop => {
    if (typeof itemHeight === "number") return Math.floor(scrollTop / itemHeight) + 1;
    let sum = 0;
    let offset = 0;

    for (let i = 0; i < source.value.length; i++) {
      const height = itemHeight(i);
      sum += height;

      if (sum >= scrollTop) {
        offset = i;
        break;
      }
    }

    return offset + 1;
  };

  const calculateRange = () => {
    const element = containerRef.value;

    if (element) {
      const offset = getOffset(element.scrollTop);
      const viewCapacity = getViewCapacity(element.clientHeight);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      state.value = {
        start: from < 0 ? 0 : from,
        end: to > source.value.length ? source.value.length : to
      };
      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({
        data: ele,
        index: index + state.value.start
      }));
    }
  };

  watch([size.width, size.height, list], () => {
    calculateRange();
  });
  const totalHeight = computed(() => {
    if (typeof itemHeight === "number") return source.value.length * itemHeight;
    return source.value.reduce((sum, _, index) => sum + itemHeight(index), 0);
  });

  const getDistanceTop = index => {
    if (typeof itemHeight === "number") {
      const height2 = index * itemHeight;
      return height2;
    }

    const height = source.value.slice(0, index).reduce((sum, _, i) => sum + itemHeight(i), 0);
    return height;
  };

  const scrollTo = index => {
    if (containerRef.value) {
      containerRef.value.scrollTop = getDistanceTop(index);
      calculateRange();
    }
  };

  const offsetTop = computed(() => getDistanceTop(state.value.start));
  const wrapperProps = computed(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight.value - offsetTop.value}px`,
        marginTop: `${offsetTop.value}px`
      }
    };
  });
  const containerStyle = {
    overflowY: "auto"
  };
  return {
    list: currentList,
    scrollTo,
    containerProps: {
      ref: containerRef,
      onScroll: () => {
        calculateRange();
      },
      style: containerStyle
    },
    wrapperProps
  };
}

const useWakeLock = (options = {}) => {
  const {
    navigator = defaultNavigator,
    document = defaultDocument
  } = options;
  let wakeLock;
  const isSupported = navigator && "wakeLock" in navigator;
  const isActive = ref(false);

  async function onVisibilityChange() {
    if (!isSupported || !wakeLock) return;
    if (document && document.visibilityState === "visible") wakeLock = await navigator.wakeLock.request("screen");
    isActive.value = !wakeLock.released;
  }

  if (document) useEventListener(document, "visibilitychange", onVisibilityChange, {
    passive: true
  });

  async function request(type) {
    if (!isSupported) return;
    wakeLock = await navigator.wakeLock.request(type);
    isActive.value = !wakeLock.released;
  }

  async function release() {
    if (!isSupported || !wakeLock) return;
    await wakeLock.release();
    isActive.value = !wakeLock.released;
    wakeLock = null;
  }

  return {
    isSupported,
    isActive,
    request,
    release
  };
};

const useWebNotification = (defaultOptions = {}) => {
  const {
    window = defaultWindow
  } = defaultOptions;
  const isSupported = !!window && "Notification" in window;
  const notification = ref(null);

  const requestPermission = async () => {
    if (!isSupported) return;
    if ("permission" in Notification && Notification.permission !== "denied") await Notification.requestPermission();
  };

  const onClick = createEventHook();
  const onShow = createEventHook();
  const onError = createEventHook();
  const onClose = createEventHook();

  const show = async overrides => {
    if (!isSupported) return;
    await requestPermission();
    const options = Object.assign({}, defaultOptions, overrides);
    notification.value = new Notification(options.title || "", options);

    notification.value.onclick = event => onClick.trigger(event);

    notification.value.onshow = event => onShow.trigger(event);

    notification.value.onerror = event => onError.trigger(event);

    notification.value.onclose = event => onClose.trigger(event);

    return notification.value;
  };

  const close = () => {
    if (notification.value) notification.value.close();
    notification.value = null;
  };

  tryOnMounted(async () => {
    if (isSupported) await requestPermission();
  });
  tryOnScopeDispose(close);

  if (isSupported && window) {
    const document = window.document;
    useEventListener(document, "visibilitychange", e => {
      e.preventDefault();

      if (document.visibilityState === "visible") {
        close();
      }
    });
  }

  return {
    isSupported,
    notification,
    show,
    close,
    onClick,
    onShow,
    onError,
    onClose
  };
};

function resolveNestedOptions(options) {
  if (options === true) return {};
  return options;
}

function useWebSocket(url, options = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoClose = true,
    protocols = []
  } = options;
  const data = ref(null);
  const status = ref("CONNECTING");
  const wsRef = ref();
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];

  const close = (code = 1e3, reason) => {
    if (!wsRef.value) return;
    explicitlyClosed = true;
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRef.value.close(code, reason);
  };

  const _sendBuffer = () => {
    if (bufferedData.length && wsRef.value && status.value === "OPEN") {
      for (const buffer of bufferedData) wsRef.value.send(buffer);

      bufferedData = [];
    }
  };

  const send = (data2, useBuffer = true) => {
    if (!wsRef.value || status.value !== "OPEN") {
      if (useBuffer) bufferedData.push(data2);
      return false;
    }

    _sendBuffer();

    wsRef.value.send(data2);
    return true;
  };

  const _init = () => {
    const ws = new WebSocket(url, protocols);
    wsRef.value = ws;
    status.value = "CONNECTING";
    explicitlyClosed = false;

    ws.onopen = () => {
      status.value = "OPEN";
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();

      _sendBuffer();
    };

    ws.onclose = ev => {
      status.value = "CLOSED";
      wsRef.value = void 0;
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);

      if (!explicitlyClosed && options.autoReconnect) {
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions(options.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries)) setTimeout(_init, delay);else if (typeof retries === "function" && retries()) setTimeout(_init, delay);else onFailed == null ? void 0 : onFailed();
      }
    };

    ws.onerror = e => {
      onError == null ? void 0 : onError(ws, e);
    };

    ws.onmessage = e => {
      data.value = e.data;
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  };

  if (options.heartbeat) {
    const {
      message = "ping",
      interval = 1e3
    } = resolveNestedOptions(options.heartbeat);
    const {
      pause,
      resume
    } = useIntervalFn(() => send(message, false), interval, {
      immediate: false
    });
    heartbeatPause = pause;
    heartbeatResume = resume;
  }

  if (immediate) _init();

  if (autoClose) {
    useEventListener(window, "beforeunload", () => close());
    tryOnScopeDispose(close);
  }

  const open = () => {
    close();
    retried = 0;

    _init();
  };

  return {
    data,
    status,
    close,
    send,
    open,
    ws: wsRef
  };
}

function useWebWorker(url, workerOptions, options = {}) {
  const {
    window = defaultWindow
  } = options;
  const data = ref(null);
  const worker = shallowRef();

  const post = function post2(val) {
    if (!worker.value) return;
    worker.value.postMessage(val);
  };

  const terminate = function terminate2() {
    if (!worker.value) return;
    worker.value.terminate();
  };

  if (window) {
    worker.value = new Worker(url, workerOptions);

    worker.value.onmessage = e => {
      data.value = e.data;
    };

    tryOnScopeDispose(() => {
      if (worker.value) worker.value.terminate();
    });
  }

  return {
    data,
    post,
    terminate,
    worker
  };
}

const jobRunner = userFunc => e => {
  const userFuncArgs = e.data[0];
  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then(result => {
    postMessage(["SUCCESS", result]);
  }).catch(error => {
    postMessage(["ERROR", error]);
  });
};

const depsParser = deps => {
  if (deps.length === 0) return "";
  const depsString = deps.map(dep => `'${dep}'`).toString();
  return `importScripts(${depsString})`;
};

const createWorkerBlobUrl = (fn, deps) => {
  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], {
    type: "text/javascript"
  });
  const url = URL.createObjectURL(blob);
  return url;
};

const useWebWorkerFn = (fn, options = {}) => {
  const {
    dependencies = [],
    timeout,
    window = defaultWindow
  } = options;
  const worker = ref();
  const workerStatus = ref("PENDING");
  const promise = ref({});
  const timeoutId = ref();

  const workerTerminate = (status = "PENDING") => {
    if (worker.value && worker.value._url && window) {
      worker.value.terminate();
      URL.revokeObjectURL(worker.value._url);
      promise.value = {};
      worker.value = void 0;
      window.clearTimeout(timeoutId.value);
      workerStatus.value = status;
    }
  };

  workerTerminate();
  tryOnScopeDispose(workerTerminate);

  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;

    newWorker.onmessage = e => {
      const {
        resolve = () => {},
        reject = () => {}
      } = promise.value;
      const [status, result] = e.data;

      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;

        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };

    newWorker.onerror = e => {
      const {
        reject = () => {}
      } = promise.value;
      reject(e);
      workerTerminate("ERROR");
    };

    if (timeout) {
      timeoutId.value = setTimeout(() => workerTerminate("TIMEOUT_EXPIRED"), timeout);
    }

    return newWorker;
  };

  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    promise.value = {
      resolve,
      reject
    };
    worker.value && worker.value.postMessage([[...fnArgs]]);
    workerStatus.value = "RUNNING";
  });

  const workerFn = (...fnArgs) => {
    if (workerStatus.value === "RUNNING") {
      console.error("[useWebWorkerFn] You can only run one instance of the worker at a time.");
      return Promise.reject();
    }

    worker.value = generateWorker();
    return callWorker(...fnArgs);
  };

  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
};

function useWindowFocus({
  window = defaultWindow
} = {}) {
  if (!window) return ref(false);
  const focused = ref(window.document.hasFocus());
  useEventListener(window, "blur", () => {
    focused.value = false;
  });
  useEventListener(window, "focus", () => {
    focused.value = true;
  });
  return focused;
}

function useWindowScroll({
  window = defaultWindow
} = {}) {
  if (!window) {
    return {
      x: ref(0),
      y: ref(0)
    };
  }

  const x = ref(window.pageXOffset);
  const y = ref(window.pageYOffset);
  useEventListener("scroll", () => {
    x.value = window.pageXOffset;
    y.value = window.pageYOffset;
  }, {
    capture: false,
    passive: true
  });
  return {
    x,
    y
  };
}

function useWindowSize(options = {}) {
  const {
    window = defaultWindow,
    initialWidth = Infinity,
    initialHeight = Infinity,
    listenOrientation = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);

  const update = () => {
    if (window) {
      width.value = window.innerWidth;
      height.value = window.innerHeight;
    }
  };

  update();
  tryOnMounted(update);
  useEventListener("resize", update, {
    passive: true
  });
  if (listenOrientation) useEventListener("orientationchange", update, {
    passive: true
  });
  return {
    width,
    height
  };
}


;// CONCATENATED MODULE: ./node_modules/lodash-es/fromPairs.js
/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs == null ? 0 : pairs.length,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }

  return result;
}

/* harmony default export */ var lodash_es_fromPairs = (fromPairs);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/vue/props2.mjs





const wrapperKey = Symbol();
const propKey = "__elPropsReservedKey";

function buildProp(option, key) {
  if (!shared_esm_bundler_isObject(option) || !!option[propKey]) return option;
  const {
    values,
    required,
    default: defaultValue,
    type,
    validator
  } = option;

  const _validator = values || validator ? val => {
    let valid = false;
    let allowedValues = [];

    if (values) {
      allowedValues = Array.from(values);

      if (shared_esm_bundler_hasOwn(option, "default")) {
        allowedValues.push(defaultValue);
      }

      valid || (valid = allowedValues.includes(val));
    }

    if (validator) valid || (valid = validator(val));

    if (!valid && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map(value => JSON.stringify(value)).join(", ");
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.warn)(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }

    return valid;
  } : void 0;

  const prop = {
    type: shared_esm_bundler_isObject(type) && Object.getOwnPropertySymbols(type).includes(wrapperKey) ? type[wrapperKey] : type,
    required: !!required,
    validator: _validator,
    [propKey]: true
  };
  if (shared_esm_bundler_hasOwn(option, "default")) prop.default = defaultValue;
  return prop;
}

const buildProps = props => lodash_es_fromPairs(Object.entries(props).map(([key, option]) => [key, buildProp(option, key)]));

const definePropType = val => ({
  [wrapperKey]: val
});


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-timeout/index2.mjs


function index2_useTimeout() {
  let timeoutHandle;

  const registerTimeout = (fn, delay) => {
    cancelTimeout();
    timeoutHandle = window.setTimeout(fn, delay);
  };

  const cancelTimeout = () => window.clearTimeout(timeoutHandle);

  shared_tryOnScopeDispose(() => cancelTimeout());
  return {
    registerTimeout,
    cancelTimeout
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-delayed-toggle/index2.mjs




const useDelayedToggleProps = buildProps({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  }
});

const useDelayedToggle = ({
  showAfter,
  hideAfter,
  open,
  close
}) => {
  const {
    registerTimeout
  } = index2_useTimeout();

  const onOpen = () => {
    registerTimeout(() => {
      open();
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showAfter));
  };

  const onClose = () => {
    registerTimeout(() => {
      close();
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(hideAfter));
  };

  return {
    onOpen,
    onClose
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@popperjs/core/dist/index.mjs
var E = "top",
    R = "bottom",
    W = "right",
    P = "left",
    me = "auto",
    G = [E, R, W, P],
    U = "start",
    J = "end",
    Xe = "clippingParents",
    je = "viewport",
    K = "popper",
    Ye = "reference",
    De = G.reduce(function (t, e) {
  return t.concat([e + "-" + U, e + "-" + J]);
}, []),
    Ee = [].concat(G, [me]).reduce(function (t, e) {
  return t.concat([e, e + "-" + U, e + "-" + J]);
}, []),
    Ge = "beforeRead",
    Je = "read",
    Ke = "afterRead",
    Qe = "beforeMain",
    Ze = "main",
    et = "afterMain",
    tt = "beforeWrite",
    nt = "write",
    rt = "afterWrite",
    ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];

function C(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}

function H(t) {
  if (t == null) return window;

  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }

  return t;
}

function Q(t) {
  var e = H(t).Element;
  return t instanceof e || t instanceof Element;
}

function B(t) {
  var e = H(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}

function Pe(t) {
  if (typeof ShadowRoot == "undefined") return !1;
  var e = H(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}

function Mt(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function (n) {
    var r = e.styles[n] || {},
        o = e.attributes[n] || {},
        i = e.elements[n];
    !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function (a) {
      var s = o[a];
      s === !1 ? i.removeAttribute(a) : i.setAttribute(a, s === !0 ? "" : s);
    }));
  });
}

function Rt(t) {
  var e = t.state,
      n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () {
    Object.keys(e.elements).forEach(function (r) {
      var o = e.elements[r],
          i = e.attributes[r] || {},
          a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
          s = a.reduce(function (f, c) {
        return f[c] = "", f;
      }, {});
      !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function (f) {
        o.removeAttribute(f);
      }));
    });
  };
}

var Ae = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Mt,
  effect: Rt,
  requires: ["computeStyles"]
};

function q(t) {
  return t.split("-")[0];
}

var X = Math.max,
    ve = Math.min,
    Z = Math.round;

function ee(t, e) {
  e === void 0 && (e = !1);
  var n = t.getBoundingClientRect(),
      r = 1,
      o = 1;

  if (B(t) && e) {
    var i = t.offsetHeight,
        a = t.offsetWidth;
    a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
  }

  return {
    width: n.width / r,
    height: n.height / o,
    top: n.top / o,
    right: n.right / r,
    bottom: n.bottom / o,
    left: n.left / r,
    x: n.left / r,
    y: n.top / o
  };
}

function ke(t) {
  var e = ee(t),
      n = t.offsetWidth,
      r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}

function it(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e)) return !0;

  if (n && Pe(n)) {
    var r = e;

    do {
      if (r && t.isSameNode(r)) return !0;
      r = r.parentNode || r.host;
    } while (r);
  }

  return !1;
}

function N(t) {
  return H(t).getComputedStyle(t);
}

function Wt(t) {
  return ["table", "td", "th"].indexOf(C(t)) >= 0;
}

function I(t) {
  return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}

function ge(t) {
  return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
}

function at(t) {
  return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
}

function Bt(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1,
      n = navigator.userAgent.indexOf("Trident") !== -1;

  if (n && B(t)) {
    var r = N(t);
    if (r.position === "fixed") return null;
  }

  var o = ge(t);

  for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0;) {
    var i = N(o);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o;
    o = o.parentNode;
  }

  return null;
}

function se(t) {
  for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static";) n = at(n);

  return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
}

function Le(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}

function fe(t, e, n) {
  return X(t, ve(e, n));
}

function St(t, e, n) {
  var r = fe(t, e, n);
  return r > n ? n : r;
}

function st() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function ft(t) {
  return Object.assign({}, st(), t);
}

function ct(t, e) {
  return e.reduce(function (n, r) {
    return n[r] = t, n;
  }, {});
}

var Tt = function (t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, ft(typeof t != "number" ? t : ct(t, G));
};

function Ht(t) {
  var e,
      n = t.state,
      r = t.name,
      o = t.options,
      i = n.elements.arrow,
      a = n.modifiersData.popperOffsets,
      s = q(n.placement),
      f = Le(s),
      c = [P, W].indexOf(s) >= 0,
      u = c ? "height" : "width";

  if (!(!i || !a)) {
    var m = Tt(o.padding, n),
        v = ke(i),
        l = f === "y" ? E : P,
        h = f === "y" ? R : W,
        p = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u],
        g = a[f] - n.rects.reference[f],
        x = se(i),
        y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0,
        $ = p / 2 - g / 2,
        d = m[l],
        b = y - v[u] - m[h],
        w = y / 2 - v[u] / 2 + $,
        O = fe(d, w, b),
        j = f;
    n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
  }
}

function Ct(t) {
  var e = t.state,
      n = t.options,
      r = n.element,
      o = r === void 0 ? "[data-popper-arrow]" : r;
  o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
}

var pt = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Ht,
  effect: Ct,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

function te(t) {
  return t.split("-")[1];
}

var qt = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};

function Vt(t) {
  var e = t.x,
      n = t.y,
      r = window,
      o = r.devicePixelRatio || 1;
  return {
    x: Z(e * o) / o || 0,
    y: Z(n * o) / o || 0
  };
}

function ut(t) {
  var e,
      n = t.popper,
      r = t.popperRect,
      o = t.placement,
      i = t.variation,
      a = t.offsets,
      s = t.position,
      f = t.gpuAcceleration,
      c = t.adaptive,
      u = t.roundOffsets,
      m = t.isFixed,
      v = a.x,
      l = v === void 0 ? 0 : v,
      h = a.y,
      p = h === void 0 ? 0 : h,
      g = typeof u == "function" ? u({
    x: l,
    y: p
  }) : {
    x: l,
    y: p
  };
  l = g.x, p = g.y;
  var x = a.hasOwnProperty("x"),
      y = a.hasOwnProperty("y"),
      $ = P,
      d = E,
      b = window;

  if (c) {
    var w = se(n),
        O = "clientHeight",
        j = "clientWidth";

    if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
      d = R;
      var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
      p -= A - r.height, p *= f ? 1 : -1;
    }

    if (o === P || (o === E || o === R) && i === J) {
      $ = W;
      var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
      l -= k - r.width, l *= f ? 1 : -1;
    }
  }

  var D = Object.assign({
    position: s
  }, c && qt),
      S = u === !0 ? Vt({
    x: l,
    y: p
  }) : {
    x: l,
    y: p
  };

  if (l = S.x, p = S.y, f) {
    var L;
    return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p + "px)" : "translate3d(" + l + "px, " + p + "px, 0)", L));
  }

  return Object.assign({}, D, (e = {}, e[d] = y ? p + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
}

function Nt(t) {
  var e = t.state,
      n = t.options,
      r = n.gpuAcceleration,
      o = r === void 0 ? !0 : r,
      i = n.adaptive,
      a = i === void 0 ? !0 : i,
      s = n.roundOffsets,
      f = s === void 0 ? !0 : s,
      c = {
    placement: q(e.placement),
    variation: te(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: o,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: a,
    roundOffsets: f
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: f
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}

var Me = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Nt,
  data: {}
},
    ye = {
  passive: !0
};

function It(t) {
  var e = t.state,
      n = t.instance,
      r = t.options,
      o = r.scroll,
      i = o === void 0 ? !0 : o,
      a = r.resize,
      s = a === void 0 ? !0 : a,
      f = H(e.elements.popper),
      c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c.forEach(function (u) {
    u.addEventListener("scroll", n.update, ye);
  }), s && f.addEventListener("resize", n.update, ye), function () {
    i && c.forEach(function (u) {
      u.removeEventListener("scroll", n.update, ye);
    }), s && f.removeEventListener("resize", n.update, ye);
  };
}

var Re = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: It,
  data: {}
},
    _t = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};

function be(t) {
  return t.replace(/left|right|bottom|top/g, function (e) {
    return _t[e];
  });
}

var zt = {
  start: "end",
  end: "start"
};

function lt(t) {
  return t.replace(/start|end/g, function (e) {
    return zt[e];
  });
}

function We(t) {
  var e = H(t),
      n = e.pageXOffset,
      r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}

function Be(t) {
  return ee(I(t)).left + We(t).scrollLeft;
}

function Ft(t) {
  var e = H(t),
      n = I(t),
      r = e.visualViewport,
      o = n.clientWidth,
      i = n.clientHeight,
      a = 0,
      s = 0;
  return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), {
    width: o,
    height: i,
    x: a + Be(t),
    y: s
  };
}

function Ut(t) {
  var e,
      n = I(t),
      r = We(t),
      o = (e = t.ownerDocument) == null ? void 0 : e.body,
      i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0),
      a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0),
      s = -r.scrollLeft + Be(t),
      f = -r.scrollTop;
  return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), {
    width: i,
    height: a,
    x: s,
    y: f
  };
}

function Se(t) {
  var e = N(t),
      n = e.overflow,
      r = e.overflowX,
      o = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}

function dt(t) {
  return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
}

function ce(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = dt(t),
      o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
      i = H(r),
      a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r,
      s = e.concat(a);
  return o ? s : s.concat(ce(ge(a)));
}

function Te(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}

function Xt(t) {
  var e = ee(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}

function ht(t, e) {
  return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
}

function Yt(t) {
  var e = ce(ge(t)),
      n = ["absolute", "fixed"].indexOf(N(t).position) >= 0,
      r = n && B(t) ? se(t) : t;
  return Q(r) ? e.filter(function (o) {
    return Q(o) && it(o, r) && C(o) !== "body";
  }) : [];
}

function Gt(t, e, n) {
  var r = e === "clippingParents" ? Yt(t) : [].concat(e),
      o = [].concat(r, [n]),
      i = o[0],
      a = o.reduce(function (s, f) {
    var c = ht(t, f);
    return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
  }, ht(t, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}

function mt(t) {
  var e = t.reference,
      n = t.element,
      r = t.placement,
      o = r ? q(r) : null,
      i = r ? te(r) : null,
      a = e.x + e.width / 2 - n.width / 2,
      s = e.y + e.height / 2 - n.height / 2,
      f;

  switch (o) {
    case E:
      f = {
        x: a,
        y: e.y - n.height
      };
      break;

    case R:
      f = {
        x: a,
        y: e.y + e.height
      };
      break;

    case W:
      f = {
        x: e.x + e.width,
        y: s
      };
      break;

    case P:
      f = {
        x: e.x - n.width,
        y: s
      };
      break;

    default:
      f = {
        x: e.x,
        y: e.y
      };
  }

  var c = o ? Le(o) : null;

  if (c != null) {
    var u = c === "y" ? "height" : "width";

    switch (i) {
      case U:
        f[c] = f[c] - (e[u] / 2 - n[u] / 2);
        break;

      case J:
        f[c] = f[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }

  return f;
}

function ne(t, e) {
  e === void 0 && (e = {});
  var n = e,
      r = n.placement,
      o = r === void 0 ? t.placement : r,
      i = n.boundary,
      a = i === void 0 ? Xe : i,
      s = n.rootBoundary,
      f = s === void 0 ? je : s,
      c = n.elementContext,
      u = c === void 0 ? K : c,
      m = n.altBoundary,
      v = m === void 0 ? !1 : m,
      l = n.padding,
      h = l === void 0 ? 0 : l,
      p = ft(typeof h != "number" ? h : ct(h, G)),
      g = u === K ? Ye : K,
      x = t.rects.popper,
      y = t.elements[v ? g : u],
      $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f),
      d = ee(t.elements.reference),
      b = mt({
    reference: d,
    element: x,
    strategy: "absolute",
    placement: o
  }),
      w = Te(Object.assign({}, x, b)),
      O = u === K ? w : d,
      j = {
    top: $.top - O.top + p.top,
    bottom: O.bottom - $.bottom + p.bottom,
    left: $.left - O.left + p.left,
    right: O.right - $.right + p.right
  },
      A = t.modifiersData.offset;

  if (u === K && A) {
    var k = A[o];
    Object.keys(j).forEach(function (D) {
      var S = [W, R].indexOf(D) >= 0 ? 1 : -1,
          L = [E, R].indexOf(D) >= 0 ? "y" : "x";
      j[D] += k[L] * S;
    });
  }

  return j;
}

function Jt(t, e) {
  e === void 0 && (e = {});
  var n = e,
      r = n.placement,
      o = n.boundary,
      i = n.rootBoundary,
      a = n.padding,
      s = n.flipVariations,
      f = n.allowedAutoPlacements,
      c = f === void 0 ? Ee : f,
      u = te(r),
      m = u ? s ? De : De.filter(function (h) {
    return te(h) === u;
  }) : G,
      v = m.filter(function (h) {
    return c.indexOf(h) >= 0;
  });
  v.length === 0 && (v = m);
  var l = v.reduce(function (h, p) {
    return h[p] = ne(t, {
      placement: p,
      boundary: o,
      rootBoundary: i,
      padding: a
    })[q(p)], h;
  }, {});
  return Object.keys(l).sort(function (h, p) {
    return l[h] - l[p];
  });
}

function Kt(t) {
  if (q(t) === me) return [];
  var e = be(t);
  return [lt(t), e, lt(e)];
}

function Qt(t) {
  var e = t.state,
      n = t.options,
      r = t.name;

  if (!e.modifiersData[r]._skip) {
    for (var o = n.mainAxis, i = o === void 0 ? !0 : o, a = n.altAxis, s = a === void 0 ? !0 : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h = l === void 0 ? !0 : l, p = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function (z, V) {
      return z.concat(q(V) === me ? Jt(e, {
        placement: V,
        boundary: u,
        rootBoundary: m,
        padding: c,
        flipVariations: h,
        allowedAutoPlacements: p
      }) : V);
    }, []), b = e.rects.reference, w = e.rects.popper, O = new Map(), j = !0, A = d[0], k = 0; k < d.length; k++) {
      var D = d[k],
          S = q(D),
          L = te(D) === U,
          re = [E, R].indexOf(S) >= 0,
          oe = re ? "width" : "height",
          M = ne(e, {
        placement: D,
        boundary: u,
        rootBoundary: m,
        altBoundary: v,
        padding: c
      }),
          T = re ? L ? W : P : L ? R : E;
      b[oe] > w[oe] && (T = be(T));
      var pe = be(T),
          _ = [];

      if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function (z) {
        return z;
      })) {
        A = D, j = !1;
        break;
      }

      O.set(D, _);
    }

    if (j) for (var ue = h ? 3 : 1, xe = function (z) {
      var V = d.find(function (de) {
        var ae = O.get(de);
        if (ae) return ae.slice(0, z).every(function (Y) {
          return Y;
        });
      });
      if (V) return A = V, "break";
    }, ie = ue; ie > 0; ie--) {
      var le = xe(ie);
      if (le === "break") break;
    }
    e.placement !== A && (e.modifiersData[r]._skip = !0, e.placement = A, e.reset = !0);
  }
}

var vt = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Qt,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};

function gt(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}

function yt(t) {
  return [E, W, R, P].some(function (e) {
    return t[e] >= 0;
  });
}

function Zt(t) {
  var e = t.state,
      n = t.name,
      r = e.rects.reference,
      o = e.rects.popper,
      i = e.modifiersData.preventOverflow,
      a = ne(e, {
    elementContext: "reference"
  }),
      s = ne(e, {
    altBoundary: !0
  }),
      f = gt(a, r),
      c = gt(s, o, i),
      u = yt(f),
      m = yt(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: f,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: m
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": m
  });
}

var bt = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Zt
};

function en(t, e, n) {
  var r = q(t),
      o = [P, E].indexOf(r) >= 0 ? -1 : 1,
      i = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n,
      a = i[0],
      s = i[1];
  return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? {
    x: s,
    y: a
  } : {
    x: a,
    y: s
  };
}

function tn(t) {
  var e = t.state,
      n = t.options,
      r = t.name,
      o = n.offset,
      i = o === void 0 ? [0, 0] : o,
      a = Ee.reduce(function (u, m) {
    return u[m] = en(m, e.rects, i), u;
  }, {}),
      s = a[e.placement],
      f = s.x,
      c = s.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
}

var wt = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: tn
};

function nn(t) {
  var e = t.state,
      n = t.name;
  e.modifiersData[n] = mt({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}

var He = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: nn,
  data: {}
};

function rn(t) {
  return t === "x" ? "y" : "x";
}

function on(t) {
  var e = t.state,
      n = t.options,
      r = t.name,
      o = n.mainAxis,
      i = o === void 0 ? !0 : o,
      a = n.altAxis,
      s = a === void 0 ? !1 : a,
      f = n.boundary,
      c = n.rootBoundary,
      u = n.altBoundary,
      m = n.padding,
      v = n.tether,
      l = v === void 0 ? !0 : v,
      h = n.tetherOffset,
      p = h === void 0 ? 0 : h,
      g = ne(e, {
    boundary: f,
    rootBoundary: c,
    padding: m,
    altBoundary: u
  }),
      x = q(e.placement),
      y = te(e.placement),
      $ = !y,
      d = Le(x),
      b = rn(d),
      w = e.modifiersData.popperOffsets,
      O = e.rects.reference,
      j = e.rects.popper,
      A = typeof p == "function" ? p(Object.assign({}, e.rects, {
    placement: e.placement
  })) : p,
      k = typeof A == "number" ? {
    mainAxis: A,
    altAxis: A
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, A),
      D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
      S = {
    x: 0,
    y: 0
  };

  if (w) {
    if (i) {
      var L,
          re = d === "y" ? E : P,
          oe = d === "y" ? R : W,
          M = d === "y" ? "height" : "width",
          T = w[d],
          pe = T + g[re],
          _ = T - g[oe],
          ue = l ? -j[M] / 2 : 0,
          xe = y === U ? O[M] : j[M],
          ie = y === U ? -j[M] : -O[M],
          le = e.elements.arrow,
          z = l && le ? ke(le) : {
        width: 0,
        height: 0
      },
          V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(),
          de = V[re],
          ae = V[oe],
          Y = fe(0, O[M], z[M]),
          jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis,
          Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis,
          Oe = e.elements.arrow && se(e.elements.arrow),
          Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0,
          Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0,
          Pt = T + jt - Ce - Et,
          At = T + Dt - Ce,
          qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);

      w[d] = qe, S[d] = qe - T;
    }

    if (s) {
      var Ve,
          kt = d === "x" ? E : P,
          Lt = d === "x" ? R : W,
          F = w[b],
          he = b === "y" ? "height" : "width",
          Ne = F + g[kt],
          Ie = F - g[Lt],
          $e = [E, P].indexOf(x) !== -1,
          _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0,
          ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis,
          Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie,
          Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);

      w[b] = Ue, S[b] = Ue - F;
    }

    e.modifiersData[r] = S;
  }
}

var xt = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: on,
  requiresIfExists: ["offset"]
};

function an(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}

function sn(t) {
  return t === H(t) || !B(t) ? We(t) : an(t);
}

function fn(t) {
  var e = t.getBoundingClientRect(),
      n = Z(e.width) / t.offsetWidth || 1,
      r = Z(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}

function cn(t, e, n) {
  n === void 0 && (n = !1);
  var r = B(e),
      o = B(e) && fn(e),
      i = I(e),
      a = ee(t, o),
      s = {
    scrollLeft: 0,
    scrollTop: 0
  },
      f = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, !0), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), {
    x: a.left + s.scrollLeft - f.x,
    y: a.top + s.scrollTop - f.y,
    width: a.width,
    height: a.height
  };
}

function pn(t) {
  var e = new Map(),
      n = new Set(),
      r = [];
  t.forEach(function (i) {
    e.set(i.name, i);
  });

  function o(i) {
    n.add(i.name);
    var a = [].concat(i.requires || [], i.requiresIfExists || []);
    a.forEach(function (s) {
      if (!n.has(s)) {
        var f = e.get(s);
        f && o(f);
      }
    }), r.push(i);
  }

  return t.forEach(function (i) {
    n.has(i.name) || o(i);
  }), r;
}

function un(t) {
  var e = pn(t);
  return ot.reduce(function (n, r) {
    return n.concat(e.filter(function (o) {
      return o.phase === r;
    }));
  }, []);
}

function ln(t) {
  var e;
  return function () {
    return e || (e = new Promise(function (n) {
      Promise.resolve().then(function () {
        e = void 0, n(t());
      });
    })), e;
  };
}

function dn(t) {
  var e = t.reduce(function (n, r) {
    var o = n[r.name];
    return n[r.name] = o ? Object.assign({}, o, r, {
      options: Object.assign({}, o.options, r.options),
      data: Object.assign({}, o.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function (n) {
    return e[n];
  });
}

var Ot = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};

function $t() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];

  return !e.some(function (r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}

function we(t) {
  t === void 0 && (t = {});
  var e = t,
      n = e.defaultModifiers,
      r = n === void 0 ? [] : n,
      o = e.defaultOptions,
      i = o === void 0 ? Ot : o;
  return function (a, s, f) {
    f === void 0 && (f = i);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Ot, i),
      modifiersData: {},
      elements: {
        reference: a,
        popper: s
      },
      attributes: {},
      styles: {}
    },
        u = [],
        m = !1,
        v = {
      state: c,
      setOptions: function (p) {
        var g = typeof p == "function" ? p(c.options) : p;
        h(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = {
          reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [],
          popper: ce(s)
        };
        var x = un(dn([].concat(r, c.options.modifiers)));
        return c.orderedModifiers = x.filter(function (y) {
          return y.enabled;
        }), l(), v.update();
      },
      forceUpdate: function () {
        if (!m) {
          var p = c.elements,
              g = p.reference,
              x = p.popper;

          if ($t(g, x)) {
            c.rects = {
              reference: cn(g, se(x), c.options.strategy === "fixed"),
              popper: ke(x)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function (j) {
              return c.modifiersData[j.name] = Object.assign({}, j.data);
            });

            for (var y = 0; y < c.orderedModifiers.length; y++) {
              if (c.reset === !0) {
                c.reset = !1, y = -1;
                continue;
              }

              var $ = c.orderedModifiers[y],
                  d = $.fn,
                  b = $.options,
                  w = b === void 0 ? {} : b,
                  O = $.name;
              typeof d == "function" && (c = d({
                state: c,
                options: w,
                name: O,
                instance: v
              }) || c);
            }
          }
        }
      },
      update: ln(function () {
        return new Promise(function (p) {
          v.forceUpdate(), p(c);
        });
      }),
      destroy: function () {
        h(), m = !0;
      }
    };
    if (!$t(a, s)) return v;
    v.setOptions(f).then(function (p) {
      !m && f.onFirstUpdate && f.onFirstUpdate(p);
    });

    function l() {
      c.orderedModifiers.forEach(function (p) {
        var g = p.name,
            x = p.options,
            y = x === void 0 ? {} : x,
            $ = p.effect;

        if (typeof $ == "function") {
          var d = $({
            state: c,
            name: g,
            instance: v,
            options: y
          }),
              b = function () {};

          u.push(d || b);
        }
      });
    }

    function h() {
      u.forEach(function (p) {
        return p();
      }), u = [];
    }

    return v;
  };
}

var hn = we(),
    mn = [Re, He, Me, Ae],
    vn = we({
  defaultModifiers: mn
}),
    gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt],
    yn = we({
  defaultModifiers: gn
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/content3.mjs



const POSITIONING_STRATEGIES = ["fixed", "absolute"];
const usePopperCoreConfigProps = buildProps({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: definePropType(Array),
    default: () => []
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Ee,
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: POSITIONING_STRATEGIES,
    default: "absolute"
  }
});
const usePopperContentProps = buildProps({ ...usePopperCoreConfigProps,
  style: {
    type: definePropType([String, Array, Object])
  },
  className: {
    type: definePropType([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: true
  },
  pure: Boolean,
  popperClass: {
    type: definePropType([String, Array, Object])
  },
  popperStyle: {
    type: definePropType([String, Array, Object])
  },
  referenceEl: {
    type: definePropType(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  zIndex: Number
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/rand2.mjs
const generateId = () => Math.floor(Math.random() * 1e4);

const getRandomInt = max => Math.floor(Math.random() * Math.floor(max));


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-popper-container/index2.mjs




let cachedContainer;
const POPPER_CONTAINER_ID = `el-popper-container-${generateId()}`;
const POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;

const createContainer = () => {
  const container = document.createElement("div");
  container.id = POPPER_CONTAINER_ID;
  document.body.appendChild(container);
  return container;
};

const usePopperContainer = () => {
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeMount)(() => {
    if (!shared_isClient) return;

    if ( false || !cachedContainer || !document.body.querySelector(POPPER_CONTAINER_SELECTOR)) {
      cachedContainer = createContainer();
    }
  });
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/trigger3.mjs


const usePopperTriggerProps = buildProps({
  virtualRef: {
    type: definePropType(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  onBlur: Function,
  onContextmenu: Function,
  id: String,
  open: Boolean
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/src/tooltip3.mjs








const triggers = (/* unused pure expression or super */ null && (["hover", "focus", "click", "contextmenu"]));
const useTooltipContentProps = buildProps({ ...useDelayedToggleProps,
  ...usePopperContentProps,
  appendTo: {
    type: definePropType([String, Object]),
    default: POPPER_CONTAINER_SELECTOR
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: false
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: definePropType(Boolean),
    default: null
  },
  transition: {
    type: String,
    default: "el-fade-in-linear"
  },
  teleported: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean
  }
});
const useTooltipTriggerProps = buildProps({ ...usePopperTriggerProps,
  disabled: Boolean,
  trigger: {
    type: definePropType([String, Array]),
    default: "hover"
  }
});
const useTooltipProps = buildProps({
  openDelay: {
    type: Number
  },
  visibleArrow: {
    type: Boolean,
    default: void 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  showArrow: {
    type: Boolean,
    default: true
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/src/tokens2.mjs
const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/utils2.mjs


const buildPopperOptions = (props, arrowProps) => {
  const {
    placement,
    strategy,
    popperOptions
  } = props;
  const options = {
    placement,
    strategy,
    ...popperOptions,
    modifiers: genModifiers(props)
  };
  attachArrow(options, arrowProps);
  deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
  return options;
};

const unwrapMeasurableEl = $el => {
  if (!shared_isClient) return;
  return unrefElement($el);
};

function genModifiers(options) {
  const {
    offset,
    gpuAcceleration,
    fallbackPlacements
  } = options;
  return [{
    name: "offset",
    options: {
      offset: [0, offset != null ? offset : 12]
    }
  }, {
    name: "preventOverflow",
    options: {
      padding: {
        top: 2,
        bottom: 2,
        left: 5,
        right: 5
      }
    }
  }, {
    name: "flip",
    options: {
      padding: 5,
      fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
    }
  }, {
    name: "computeStyles",
    options: {
      gpuAcceleration,
      adaptive: gpuAcceleration
    }
  }];
}

function attachArrow(options, {
  arrowEl,
  arrowOffset
}) {
  options.modifiers.push({
    name: "arrow",
    options: {
      element: arrowEl,
      padding: arrowOffset != null ? arrowOffset : 5
    }
  });
}

function deriveExtraModifiers(options, modifiers) {
  if (modifiers) {
    options.modifiers = [...options.modifiers, ...(modifiers != null ? modifiers : [])];
  }
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/form2.mjs
const formContextKey = Symbol("formContextKey");
const formItemContextKey = Symbol("formItemContextKey");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/config-provider2.mjs
const configProviderContextKey = Symbol();

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/error2.mjs




class ElementPlusError extends Error {
  constructor(m) {
    super(m);
    this.name = "ElementPlusError";
  }

}

function throwError(scope, m) {
  throw new ElementPlusError(`[${scope}] ${m}`);
}

function error2_debugWarn(scope, message) {
  if (false) {}
}


;// CONCATENATED MODULE: ./node_modules/lodash-es/isArray.js
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray_isArray = Array.isArray;
/* harmony default export */ var lodash_es_isArray = (isArray_isArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_freeGlobal.js
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/* harmony default export */ var _freeGlobal = (freeGlobal);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_root.js

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = _freeGlobal || freeSelf || Function('return this')();
/* harmony default export */ var _root = (root);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Symbol.js

/** Built-in value references. */

var _Symbol_Symbol = _root.Symbol;
/* harmony default export */ var _Symbol = (_Symbol_Symbol);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getRawTag.js

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/* harmony default export */ var _getRawTag = (getRawTag);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var _objectToString_objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function _objectToString_objectToString(value) {
  return _objectToString_nativeObjectToString.call(value);
}

/* harmony default export */ var _objectToString = (_objectToString_objectToString);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetTag.js



/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
}

/* harmony default export */ var _baseGetTag = (baseGetTag);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isObjectLike.js
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isSymbol.js


/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol_isSymbol(value) {
  return typeof value == 'symbol' || lodash_es_isObjectLike(value) && _baseGetTag(value) == symbolTag;
}

/* harmony default export */ var lodash_es_isSymbol = (isSymbol_isSymbol);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_isKey.js


/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (lodash_es_isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || lodash_es_isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/* harmony default export */ var _isKey = (isKey);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isObject.js
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject_isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ var lodash_es_isObject = (isObject_isObject);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isFunction.js


/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction_isFunction(value) {
  if (!lodash_es_isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ var lodash_es_isFunction = (isFunction_isFunction);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_coreJsData.js

/** Used to detect overreaching core-js shims. */

var coreJsData = _root["__core-js_shared__"];
/* harmony default export */ var _coreJsData = (coreJsData);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_isMasked.js

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/* harmony default export */ var _isMasked = (isMasked);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/* harmony default export */ var _toSource = (toSource);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsNative.js




/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var _baseIsNative_funcProto = Function.prototype,
    _baseIsNative_objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;
/** Used to check objects for own properties. */

var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!lodash_es_isObject(value) || _isMasked(value)) {
    return false;
  }

  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

/* harmony default export */ var _baseIsNative = (baseIsNative);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getValue.js
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function _getValue_getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ var _getValue = (_getValue_getValue);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getNative.js


/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

/* harmony default export */ var _getNative = (getNative);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeCreate.js

/* Built-in method references that are verified to be native. */

var nativeCreate = _getNative(Object, 'create');
/* harmony default export */ var _nativeCreate = (nativeCreate);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_hashClear.js

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

/* harmony default export */ var _hashClear = (hashClear);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_hashDelete.js
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _hashDelete = (hashDelete);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_hashGet.js

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var _hashGet_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ var _hashGet = (hashGet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_hashHas.js

/** Used for built-in method references. */

var _hashHas_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? data[key] !== undefined : _hashHas_hasOwnProperty.call(data, key);
}

/* harmony default export */ var _hashHas = (hashHas);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_hashSet.js

/** Used to stand-in for `undefined` hash values. */

var _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate && value === undefined ? _hashSet_HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ var _hashSet = (hashSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Hash.js





/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;
/* harmony default export */ var _Hash = (Hash);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheClear.js
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ var _listCacheClear = (listCacheClear);
;// CONCATENATED MODULE: ./node_modules/lodash-es/eq.js
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/* harmony default export */ var lodash_es_eq = (eq);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_assocIndexOf.js

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (lodash_es_eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/* harmony default export */ var _assocIndexOf = (assocIndexOf);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheDelete.js

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/* harmony default export */ var _listCacheDelete = (listCacheDelete);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheGet.js

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ var _listCacheGet = (listCacheGet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheHas.js

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

/* harmony default export */ var _listCacheHas = (listCacheHas);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheSet.js

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/* harmony default export */ var _listCacheSet = (listCacheSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_ListCache.js





/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;
/* harmony default export */ var _ListCache = (ListCache);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Map.js


/* Built-in method references that are verified to be native. */

var _Map_Map = _getNative(_root, 'Map');
/* harmony default export */ var _Map = (_Map_Map);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheClear.js



/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash(),
    'map': new (_Map || _ListCache)(),
    'string': new _Hash()
  };
}

/* harmony default export */ var _mapCacheClear = (mapCacheClear);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_isKeyable.js
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/* harmony default export */ var _isKeyable = (isKeyable);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getMapData.js

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/* harmony default export */ var _getMapData = (getMapData);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheDelete.js

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _mapCacheDelete = (mapCacheDelete);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheGet.js

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

/* harmony default export */ var _mapCacheGet = (mapCacheGet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheHas.js

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

/* harmony default export */ var _mapCacheHas = (mapCacheHas);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheSet.js

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ var _mapCacheSet = (mapCacheSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_MapCache.js





/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;
/* harmony default export */ var _MapCache = (MapCache);
;// CONCATENATED MODULE: ./node_modules/lodash-es/memoize.js


/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || _MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = _MapCache;
/* harmony default export */ var lodash_es_memoize = (memoize);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_memoizeCapped.js

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = lodash_es_memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/* harmony default export */ var _memoizeCapped = (memoizeCapped);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToPath.js

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = _memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
/* harmony default export */ var _stringToPath = (stringToPath);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayMap.js
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/* harmony default export */ var _arrayMap = (arrayMap);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseToString.js




/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (lodash_es_isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }

  if (lodash_es_isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/* harmony default export */ var _baseToString = (baseToString);
;// CONCATENATED MODULE: ./node_modules/lodash-es/toString.js

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString_toString(value) {
  return value == null ? '' : _baseToString(value);
}

/* harmony default export */ var lodash_es_toString = (toString_toString);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_castPath.js




/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (lodash_es_isArray(value)) {
    return value;
  }

  return _isKey(value, object) ? [value] : _stringToPath(lodash_es_toString(value));
}

/* harmony default export */ var _castPath = (castPath);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_toKey.js

/** Used as references for various `Number` constants. */

var _toKey_INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || lodash_es_isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -_toKey_INFINITY ? '-0' : result;
}

/* harmony default export */ var _toKey = (toKey);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGet.js


/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = _castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/* harmony default export */ var _baseGet = (baseGet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/get.js

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get_get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ var lodash_es_get = (get_get);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_defineProperty.js


var defineProperty = function () {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/* harmony default export */ var _defineProperty = (defineProperty);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignValue.js

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ var _baseAssignValue = (baseAssignValue);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_assignValue.js


/** Used for built-in method references. */

var _assignValue_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) || value === undefined && !(key in object)) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignValue = (assignValue);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/* harmony default export */ var _isIndex = (isIndex);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSet.js





/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */

function baseSet(object, path, value, customizer) {
  if (!lodash_es_isObject(object)) {
    return object;
  }

  path = _castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = _toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = lodash_es_isObject(objValue) ? objValue : _isIndex(path[index + 1]) ? [] : {};
      }
    }

    _assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

/* harmony default export */ var _baseSet = (baseSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/set.js

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */

function set_set(object, path, value) {
  return object == null ? object : _baseSet(object, path, value);
}

/* harmony default export */ var lodash_es_set = (set_set);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/objects2.mjs



const objects2_keysOf = arr => Object.keys(arr);

const objects2_entriesOf = arr => Object.entries(arr);

const getProp = (obj, path, defaultValue) => {
  return {
    get value() {
      return lodash_es_get(obj, path, defaultValue);
    },

    set value(val) {
      lodash_es_set(obj, path, val);
    }

  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-global-config/index2.mjs






const globalConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();

function useGlobalConfig(key, defaultValue = void 0) {
  const config = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)() ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(configProviderContextKey, globalConfig) : globalConfig;

  if (key) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b;

      return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;
    });
  } else {
    return config;
  }
}

const provideGlobalConfig = (config, app, global = false) => {
  var _a;

  const inSetup = !!(0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const oldConfig = inSetup ? useGlobalConfig() : void 0;
  const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? external_commonjs_vue_commonjs2_vue_root_Vue_.provide : void 0;

  if (!provideFn) {
    error2_debugWarn("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }

  const context = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const cfg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(config);
    if (!(oldConfig == null ? void 0 : oldConfig.value)) return cfg;
    return mergeConfig(oldConfig.value, cfg);
  });
  provideFn(configProviderContextKey, context);

  if (global || !globalConfig.value) {
    globalConfig.value = context.value;
  }

  return context;
};

const mergeConfig = (a, b) => {
  var _a;

  const keys = [... /* @__PURE__ */new Set([...objects2_keysOf(a), ...objects2_keysOf(b)])];
  const obj = {};

  for (const key of keys) {
    obj[key] = (_a = b[key]) != null ? _a : a[key];
  }

  return obj;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-z-index/index2.mjs


const zIndex = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);

const useZIndex = () => {
  const initialZIndex = useGlobalConfig("zIndex", 2e3);
  const currentZIndex = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => initialZIndex.value + zIndex.value);

  const nextZIndex = () => {
    zIndex.value++;
    return currentZIndex.value;
  };

  return {
    initialZIndex,
    currentZIndex,
    nextZIndex
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-namespace/index2.mjs


const defaultNamespace = "el";
const statePrefix = "is-";

const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;

  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }

  if (element) {
    cls += `__${element}`;
  }

  if (modifier) {
    cls += `--${modifier}`;
  }

  return cls;
};

const useNamespace = block => {
  const globalConfig = useGlobalConfig("namespace");
  const namespace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => globalConfig.value || defaultNamespace);

  const b = (blockSuffix = "") => _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, blockSuffix, "", "");

  const e = element => element ? _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, "", element, "") : "";

  const m = modifier => modifier ? _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, "", "", modifier) : "";

  const be = (blockSuffix, element) => blockSuffix && element ? _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, blockSuffix, element, "") : "";

  const em = (element, modifier) => element && modifier ? _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, "", element, modifier) : "";

  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, blockSuffix, "", modifier) : "";

  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(namespace), block, blockSuffix, element, modifier) : "";

  const is = (name, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name && state ? `${statePrefix}${name}` : "";
  };

  const cssVar = object => {
    const styles = {};

    for (const key in object) {
      styles[`--${namespace.value}-${key}`] = object[key];
    }

    return styles;
  };

  const cssVarBlock = object => {
    const styles = {};

    for (const key in object) {
      styles[`--${namespace.value}-${block}-${key}`] = object[key];
    }

    return styles;
  };

  const cssVarName = name => `--${namespace.value}-${name}`;

  const cssVarBlockName = name => `--${namespace.value}-${block}-${name}`;

  return {
    namespace,
    b,
    e,
    m,
    be,
    em,
    bm,
    bem,
    is,
    cssVar,
    cssVarName,
    cssVarBlock,
    cssVarBlockName
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/content4.mjs











const content4_default_ = {
  name: "ElPopperContent"
};

const content4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...content4_default_,
  props: usePopperContentProps,
  emits: ["mouseenter", "mouseleave"],

  setup(__props, {
    expose
  }) {
    const props = __props;
    const {
      popperInstanceRef,
      contentRef,
      triggerRef
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(POPPER_INJECTION_KEY, void 0);
    const formItemContext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, void 0);
    const {
      nextZIndex
    } = useZIndex();
    const ns = useNamespace("popper");
    const popperContentRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const arrowRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const arrowOffset = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(POPPER_CONTENT_INJECTION_KEY, {
      arrowRef,
      arrowOffset
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(formItemContextKey, { ...formItemContext,
      addInputId: () => void 0,
      removeInputId: () => void 0
    });
    const contentZIndex = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(props.zIndex || nextZIndex());
    const computedReference = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => unwrapMeasurableEl(props.referenceEl) || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(triggerRef));
    const contentStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [{
      zIndex: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(contentZIndex)
    }, props.popperStyle]);
    const contentClass = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [ns.b(), ns.is("pure", props.pure), ns.is(props.effect), props.popperClass]);

    const createPopperInstance = ({
      referenceEl,
      popperContentEl,
      arrowEl
    }) => {
      const options = buildPopperOptions(props, {
        arrowEl,
        arrowOffset: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(arrowOffset)
      });
      return yn(referenceEl, popperContentEl, options);
    };

    const updatePopper = (shouldUpdateZIndex = true) => {
      var _a;

      (_a = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(popperInstanceRef)) == null ? void 0 : _a.update();
      shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex());
    };

    const togglePopperAlive = () => {
      var _a, _b;

      const monitorable = {
        name: "eventListeners",
        enabled: props.visible
      };
      (_b = (_a = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(popperInstanceRef)) == null ? void 0 : _a.setOptions) == null ? void 0 : _b.call(_a, options => ({ ...options,
        modifiers: [...(options.modifiers || []), monitorable]
      }));
      updatePopper(false);
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      let updateHandle;
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computedReference, referenceEl => {
        var _a;

        updateHandle == null ? void 0 : updateHandle();
        const popperInstance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(popperInstanceRef);
        (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);

        if (referenceEl) {
          const popperContentEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(popperContentRef);
          contentRef.value = popperContentEl;
          popperInstanceRef.value = createPopperInstance({
            referenceEl,
            popperContentEl,
            arrowEl: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(arrowRef)
          });
          updateHandle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {
            immediate: true
          });
        } else {
          popperInstanceRef.value = void 0;
        }
      }, {
        immediate: true
      });
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.visible, togglePopperAlive, {
        immediate: true
      });
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => buildPopperOptions(props, {
        arrowEl: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(arrowRef),
        arrowOffset: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(arrowOffset)
      }), option => {
        var _a;

        return (_a = popperInstanceRef.value) == null ? void 0 : _a.setOptions(option);
      });
    });
    expose({
      popperContentRef,
      popperInstanceRef,
      updatePopper,
      contentStyle
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        ref_key: "popperContentRef",
        ref: popperContentRef,
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(contentStyle)),
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(contentClass)),
        role: "tooltip",
        onMouseenter: _cache[0] || (_cache[0] = e => _ctx.$emit("mouseenter", e)),
        onMouseleave: _cache[1] || (_cache[1] = e => _ctx.$emit("mouseleave", e))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 38);
    };
  }

});

var ElPopperContent = /* @__PURE__ */_export_sfc(content4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/visual-hidden/src/visual-hidden2.mjs



const visual_hidden2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElVisuallyHidden",
  props: {
    style: {
      type: [String, Object, Array]
    }
  },

  setup(props) {
    return {
      computedStyle: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
        return [props.style, {
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal"
        }];
      })
    };
  }

});

function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)(_ctx.$attrs, {
    style: _ctx.computedStyle
  }), [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 16);
}

var ElVisuallyHidden = /* @__PURE__ */_export_sfc(visual_hidden2_sfc_main, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/constants/aria2.mjs
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/dom/event2.mjs
const event2_on = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.addEventListener(event, handler, useCapture);
  }
};

const off = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);
  }
};

const once = (el, event, fn) => {
  const listener = function (...args) {
    if (fn) {
      fn.apply(this, args);
    }

    off(el, event, listener);
  };

  event2_on(el, event, listener);
};

const composeEventHandlers = (theirsHandler, oursHandler, {
  checkForDefaultPrevented = true
} = {}) => {
  const handleEvent = event => {
    const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);

    if (checkForDefaultPrevented === false || !shouldPrevent) {
      return oursHandler == null ? void 0 : oursHandler(event);
    }
  };

  return handleEvent;
};

const whenMouse = handler => {
  return e => e.pointerType === "mouse" ? handler(e) : void 0;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-escape-keydown/index2.mjs






const useEscapeKeydown = handler => {
  const cachedHandler = e => {
    const event = e;

    if (event.key === EVENT_CODE.esc) {
      handler == null ? void 0 : handler(event);
    }
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
    event2_on(document, "keydown", cachedHandler);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
    off(document, "keydown", cachedHandler);
  });
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/src/content2.mjs














const content2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTooltipContent",
  components: {
    ElPopperContent: ElPopperContent,
    ElVisuallyHidden: ElVisuallyHidden
  },
  inheritAttrs: false,
  props: useTooltipContentProps,

  setup(props) {
    const contentRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const intermediateOpen = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const entering = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const leaving = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const destroyed = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const {
      controlled,
      id,
      open,
      trigger,
      onClose,
      onOpen,
      onShow,
      onHide,
      onBeforeShow,
      onBeforeHide
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (false) {}

      return props.persistent;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      destroyed.value = true;
    });
    const shouldRender = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(persistentRef) ? true : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(open);
    });
    const shouldShow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.disabled ? false : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(open);
    });
    const contentStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      return (_a = props.style) != null ? _a : {};
    });
    const ariaHidden = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(open));
    useEscapeKeydown(onClose);

    const onTransitionLeave = () => {
      onHide();
    };

    const stopWhenControlled = () => {
      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(controlled)) return true;
    };

    const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(trigger) === "hover") {
        onOpen();
      }
    });
    const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(trigger) === "hover") {
        onClose();
      }
    });

    const onBeforeEnter = () => {
      var _a, _b;

      (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
      onBeforeShow == null ? void 0 : onBeforeShow();
    };

    const onBeforeLeave = () => {
      onBeforeHide == null ? void 0 : onBeforeHide();
    };

    const onAfterShow = () => {
      onShow();
    };

    let stopHandle;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(open), val => {
      if (val) {
        stopHandle = onClickOutside((0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
          var _a;

          return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
        }), () => {
          if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(controlled)) return;
          const $trigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(trigger);

          if ($trigger !== "hover") {
            onClose();
          }
        });
      } else {
        stopHandle == null ? void 0 : stopHandle();
      }
    }, {
      flush: "post"
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      destroyed,
      shouldRender,
      shouldShow,
      open,
      onAfterShow,
      onBeforeEnter,
      onBeforeLeave,
      onContentEnter,
      onContentLeave,
      onTransitionLeave
    };
  }

});

function content2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_visually_hidden = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-visually-hidden");

  const _component_el_popper_content = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-popper-content");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
    disabled: !_ctx.teleported,
    to: _ctx.appendTo
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
    name: _ctx.transition,
    onAfterLeave: _ctx.onTransitionLeave,
    onBeforeEnter: _ctx.onBeforeEnter,
    onAfterEnter: _ctx.onAfterShow,
    onBeforeLeave: _ctx.onBeforeLeave
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.shouldRender ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_popper_content, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
      key: 0,
      ref: "contentRef"
    }, _ctx.$attrs, {
      "aria-hidden": _ctx.ariaHidden,
      "boundaries-padding": _ctx.boundariesPadding,
      "fallback-placements": _ctx.fallbackPlacements,
      "gpu-acceleration": _ctx.gpuAcceleration,
      offset: _ctx.offset,
      placement: _ctx.placement,
      "popper-options": _ctx.popperOptions,
      strategy: _ctx.strategy,
      effect: _ctx.effect,
      enterable: _ctx.enterable,
      pure: _ctx.pure,
      "popper-class": _ctx.popperClass,
      "popper-style": [_ctx.popperStyle, _ctx.contentStyle],
      "reference-el": _ctx.referenceEl,
      visible: _ctx.shouldShow,
      "z-index": _ctx.zIndex,
      onMouseenter: _ctx.onContentEnter,
      onMouseleave: _ctx.onContentLeave
    }), {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" Workaround bug #6378 "), !_ctx.destroyed ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_visually_hidden, {
        id: _ctx.id,
        role: "tooltip"
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.ariaLabel), 1)]),
        _: 1
      }, 8, ["id"])], 64)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      _: 3
    }, 16, ["aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "visible", "z-index", "onMouseenter", "onMouseleave"])), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.shouldShow]]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
    _: 3
  }, 8, ["name", "onAfterLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"])], 8, ["disabled", "to"]);
}

var ElTooltipContent = /* @__PURE__ */_export_sfc(content2_sfc_main, [["render", content2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/src/utils2.mjs




const isTriggerType = (trigger, type) => {
  if (shared_esm_bundler_isArray(trigger)) {
    return trigger.includes(type);
  }

  return trigger === type;
};

const whenTrigger = (trigger, type, handler) => {
  return e => {
    isTriggerType((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(trigger), type) && handler(e);
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-forward-ref/index2.mjs

const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");

const useForwardRef = forwardRef => {
  const setForwardRef = el => {
    forwardRef.value = el;
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(FORWARD_REF_INJECTION_KEY, {
    setForwardRef
  });
};

const useForwardRefDirective = setForwardRef => {
  return {
    mounted(el) {
      setForwardRef(el);
    },

    updated(el) {
      setForwardRef(el);
    },

    unmounted() {
      setForwardRef(null);
    }

  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/types2.mjs






const isUndefined = val => val === void 0;

const isEmpty = val => !val && val !== 0 || shared_esm_bundler_isArray(val) && val.length === 0 || shared_esm_bundler_isObject(val) && !Object.keys(val).length;

const isElement = e => {
  if (typeof Element === "undefined") return false;
  return e instanceof Element;
};

const isPropAbsent = prop => {
  return isNil(prop);
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/slot/src/only-child.mjs






const NAME = "ElOnlyChild";
const OnlyChild = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: NAME,

  setup(_, {
    slots,
    attrs
  }) {
    var _a;

    const forwardRefInjection = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(FORWARD_REF_INJECTION_KEY);
    const forwardRefDirective = useForwardRefDirective((_a = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a : NOOP);
    return () => {
      var _a2;

      const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
      if (!defaultSlot) return null;

      if (defaultSlot.length > 1) {
        error2_debugWarn(NAME, "requires exact only one valid child.");
        return null;
      }

      const firstLegitNode = findFirstLegitChild(defaultSlot);

      if (!firstLegitNode) {
        error2_debugWarn(NAME, "no valid child node found");
        return null;
      }

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.cloneVNode)(firstLegitNode, attrs), [[forwardRefDirective]]);
    };
  }

});

function findFirstLegitChild(node) {
  if (!node) return null;
  const children = node;

  for (const child of children) {
    if (shared_esm_bundler_isObject(child)) {
      switch (child.type) {
        case external_commonjs_vue_commonjs2_vue_root_Vue_.Comment:
          continue;

        case external_commonjs_vue_commonjs2_vue_root_Vue_.Text:
          return wrapTextContent(child);

        case "svg":
          return wrapTextContent(child);

        case external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment:
          return findFirstLegitChild(child.children);

        default:
          return child;
      }
    }

    return wrapTextContent(child);
  }

  return null;
}

function wrapTextContent(s) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)("span", {
    "class": "el-only-child__content"
  }, [s]);
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/trigger4.mjs












const trigger4_default_ = {
  name: "ElPopperTrigger",
  inheritAttrs: false
};

const trigger4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...trigger4_default_,
  props: usePopperTriggerProps,

  setup(__props, {
    expose
  }) {
    const props = __props;
    const {
      triggerRef
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(POPPER_INJECTION_KEY, void 0);
    useForwardRef(triggerRef);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.virtualRef, virtualEl => {
        if (virtualEl) {
          triggerRef.value = unrefElement(virtualEl);
        }
      }, {
        immediate: true
      });
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => triggerRef.value, (el, prevEl) => {
        if (isElement(el)) {
          ;
          ["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"].forEach(eventName => {
            var _a;

            const handler = props[eventName];

            if (handler) {
              ;
              el.addEventListener(eventName.slice(2).toLowerCase(), handler);
              (_a = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a.call(prevEl, eventName.slice(2).toLowerCase(), handler);
            }
          });
        }
      }, {
        immediate: true
      });
    });
    expose({
      triggerRef
    });
    return (_ctx, _cache) => {
      return !_ctx.virtualTriggering ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(OnlyChild), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
        key: 0
      }, _ctx.$attrs, {
        "aria-describedby": _ctx.open ? _ctx.id : void 0
      }), {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["aria-describedby"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true);
    };
  }

});

var ElPopperTrigger = /* @__PURE__ */_export_sfc(trigger4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/src/trigger2.mjs














const trigger2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTooltipTrigger",
  components: {
    ElPopperTrigger: ElPopperTrigger
  },
  props: useTooltipTriggerProps,

  setup(props) {
    const ns = useNamespace("tooltip");
    const {
      controlled,
      id,
      open,
      onOpen,
      onClose,
      onToggle
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TOOLTIP_INJECTION_KEY, void 0);
    const triggerRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

    const stopWhenControlledOrDisabled = () => {
      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(controlled) || props.disabled) {
        return true;
      }
    };

    const trigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "trigger");
    const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
    const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
    const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", e => {
      if (e.button === 0) {
        onToggle(e);
      }
    }));
    const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
    const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
    const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", e => {
      e.preventDefault();
      onToggle(e);
    }));
    const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, e => {
      const {
        code
      } = e;

      if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
        onToggle(e);
      }
    });
    return {
      onBlur,
      onContextMenu,
      onFocus,
      onMouseenter,
      onMouseleave,
      onClick,
      onKeydown,
      open,
      id,
      triggerRef,
      ns
    };
  }

});

function trigger2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper_trigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-popper-trigger");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_popper_trigger, {
    id: _ctx.id,
    "virtual-ref": _ctx.virtualRef,
    open: _ctx.open,
    "virtual-triggering": _ctx.virtualTriggering,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("trigger")),
    onBlur: _ctx.onBlur,
    onClick: _ctx.onClick,
    onContextmenu: _ctx.onContextMenu,
    onFocus: _ctx.onFocus,
    onMouseenter: _ctx.onMouseenter,
    onMouseleave: _ctx.onMouseleave,
    onKeydown: _ctx.onKeydown
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")]),
    _: 3
  }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
}

var ElTooltipTrigger = /* @__PURE__ */_export_sfc(trigger2_sfc_main, [["render", trigger2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-model-toggle/index2.mjs






const _prop = buildProp({
  type: definePropType(Boolean),
  default: null
});

const _event = buildProp({
  type: definePropType(Function)
});

const createModelToggleComposable = name => {
  const useModelToggleProps2 = {
    [name]: _prop,
    [`onUpdate:${name}`]: _event
  };
  const useModelToggleEmits2 = [`update:${name}`];

  const useModelToggle2 = ({
    indicator,
    shouldHideWhenRouteChanges,
    shouldProceed,
    onShow,
    onHide
  }) => {
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const props = instance.props;
    const {
      emit
    } = instance;
    const updateEventKey = `update:${name}`;
    const hasUpdateHandler = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => shared_esm_bundler_isFunction(props[`onUpdate:${name}`]));
    const isModelBindingAbsent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props[name] === null);

    const doShow = () => {
      if (indicator.value === true) {
        return;
      }

      indicator.value = true;

      if (shared_esm_bundler_isFunction(onShow)) {
        onShow();
      }
    };

    const doHide = () => {
      if (indicator.value === false) {
        return;
      }

      indicator.value = false;

      if (shared_esm_bundler_isFunction(onHide)) {
        onHide();
      }
    };

    const show = () => {
      if (props.disabled === true || shared_esm_bundler_isFunction(shouldProceed) && !shouldProceed()) return;
      const shouldEmit = hasUpdateHandler.value && shared_isClient;

      if (shouldEmit) {
        emit(updateEventKey, true);
      }

      if (isModelBindingAbsent.value || !shouldEmit) {
        doShow();
      }
    };

    const hide = () => {
      if (props.disabled === true || !shared_isClient) return;
      const shouldEmit = hasUpdateHandler.value && shared_isClient;

      if (shouldEmit) {
        emit(updateEventKey, false);
      }

      if (isModelBindingAbsent.value || !shouldEmit) {
        doHide();
      }
    };

    const onChange = val => {
      if (!shared_isBoolean(val)) return;

      if (props.disabled && val) {
        if (hasUpdateHandler.value) {
          emit(updateEventKey, false);
        }
      } else if (indicator.value !== val) {
        if (val) {
          doShow();
        } else {
          doHide();
        }
      }
    };

    const toggle = () => {
      if (indicator.value) {
        hide();
      } else {
        show();
      }
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], onChange);

    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => ({ ...instance.proxy.$route
      }), () => {
        if (shouldHideWhenRouteChanges.value && indicator.value) {
          hide();
        }
      });
    }

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      onChange(props[name]);
    });
    return {
      hide,
      show,
      toggle
    };
  };

  return {
    useModelToggle: useModelToggle2,
    useModelToggleProps: useModelToggleProps2,
    useModelToggleEmits: useModelToggleEmits2
  };
};

const {
  useModelToggle,
  useModelToggleProps,
  useModelToggleEmits
} = createModelToggleComposable("modelValue");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/arrow3.mjs


const usePopperArrowProps = buildProps({
  arrowOffset: {
    type: Number,
    default: 5
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/src/arrow4.mjs







const arrow4_default_ = {
  name: "ElPopperArrow",
  inheritAttrs: false
};

const arrow4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...arrow4_default_,
  props: usePopperArrowProps,

  setup(__props, {
    expose
  }) {
    const props = __props;
    const ns = useNamespace("popper");
    const {
      arrowOffset,
      arrowRef
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(POPPER_CONTENT_INJECTION_KEY, void 0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.arrowOffset, val => {
      arrowOffset.value = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      arrowRef.value = void 0;
    });
    expose({
      arrowRef
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        ref_key: "arrowRef",
        ref: arrowRef,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("arrow")),
        "data-popper-arrow": ""
      }, null, 2);
    };
  }

});

var ElPopperArrow = /* @__PURE__ */_export_sfc(arrow4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-id/index2.mjs




const defaultIdInjection = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
};
const ID_INJECTION_KEY = Symbol("elIdInjection");

const useId = deterministicId => {
  const idInjection = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(ID_INJECTION_KEY, defaultIdInjection);

  if (!shared_isClient && idInjection === defaultIdInjection) {
    error2_debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  }

  const idRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(deterministicId) || `el-id-${idInjection.prefix}-${idInjection.current++}`);
  return idRef;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/src/tooltip4.mjs


















const {
  useModelToggleProps: tooltip4_useModelToggleProps,
  useModelToggle: tooltip4_useModelToggle,
  useModelToggleEmits: tooltip4_useModelToggleEmits
} = createModelToggleComposable("visible");

const tooltip4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTooltip",
  components: {
    ElPopper: ElPopper,
    ElPopperArrow: ElPopperArrow,
    ElTooltipContent: ElTooltipContent,
    ElTooltipTrigger: ElTooltipTrigger
  },
  props: { ...tooltip4_useModelToggleProps,
    ...useTooltipContentProps,
    ...useTooltipTriggerProps,
    ...usePopperArrowProps,
    ...useTooltipProps
  },
  emits: [...tooltip4_useModelToggleEmits, "before-show", "before-hide", "show", "hide"],

  setup(props, {
    emit
  }) {
    usePopperContainer();
    const compatShowAfter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (!isUndefined(props.openDelay)) {
        error2_debugWarn("ElTooltip", "open-delay is about to be deprecated in the next major version, please use `show-after` instead");
      }

      return props.openDelay || props.showAfter;
    });
    const compatShowArrow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (!isUndefined(props.visibleArrow)) {
        error2_debugWarn("ElTooltip", "`visible-arrow` is about to be deprecated in the next major version, please use `show-arrow` instead");
      }

      return shared_isBoolean(props.visibleArrow) ? props.visibleArrow : props.showArrow;
    });
    const id = useId();
    const popperRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

    const updatePopper = () => {
      var _a;

      const popperComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(popperRef);

      if (popperComponent) {
        (_a = popperComponent.popperInstanceRef) == null ? void 0 : _a.update();
      }
    };

    const open = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const {
      show,
      hide
    } = tooltip4_useModelToggle({
      indicator: open
    });
    const {
      onOpen,
      onClose
    } = useDelayedToggle({
      showAfter: compatShowAfter,
      hideAfter: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "hideAfter"),
      open: show,
      close: hide
    });
    const controlled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => shared_isBoolean(props.visible));
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(TOOLTIP_INJECTION_KEY, {
      controlled,
      id,
      open: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.readonly)(open),
      trigger: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "trigger"),
      onOpen,
      onClose,
      onToggle: () => {
        if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(open)) {
          onClose();
        } else {
          onOpen();
        }
      },
      onShow: () => {
        emit("show");
      },
      onHide: () => {
        emit("hide");
      },
      onBeforeShow: () => {
        emit("before-show");
      },
      onBeforeHide: () => {
        emit("before-hide");
      },
      updatePopper
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.disabled, disabled => {
      if (disabled && open.value) {
        open.value = false;
      }
    });
    return {
      compatShowAfter,
      compatShowArrow,
      popperRef,
      open,
      hide,
      updatePopper,
      onOpen,
      onClose
    };
  }

});

const _hoisted_1 = ["innerHTML"];
const _hoisted_2 = {
  key: 1
};

function tooltip4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip_trigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tooltip-trigger");

  const _component_el_popper_arrow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-popper-arrow");

  const _component_el_tooltip_content = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tooltip-content");

  const _component_el_popper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-popper");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_popper, {
    ref: "popperRef"
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_tooltip_trigger, {
      disabled: _ctx.disabled,
      trigger: _ctx.trigger,
      "virtual-ref": _ctx.virtualRef,
      "virtual-triggering": _ctx.virtualTriggering
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.$slots.default ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {
        key: 0
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      _: 3
    }, 8, ["disabled", "trigger", "virtual-ref", "virtual-triggering"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_tooltip_content, {
      "aria-label": _ctx.ariaLabel,
      "boundaries-padding": _ctx.boundariesPadding,
      content: _ctx.content,
      disabled: _ctx.disabled,
      effect: _ctx.effect,
      enterable: _ctx.enterable,
      "fallback-placements": _ctx.fallbackPlacements,
      "hide-after": _ctx.hideAfter,
      "gpu-acceleration": _ctx.gpuAcceleration,
      offset: _ctx.offset,
      persistent: _ctx.persistent,
      "popper-class": _ctx.popperClass,
      "popper-style": _ctx.popperStyle,
      placement: _ctx.placement,
      "popper-options": _ctx.popperOptions,
      pure: _ctx.pure,
      "raw-content": _ctx.rawContent,
      "reference-el": _ctx.referenceEl,
      "show-after": _ctx.compatShowAfter,
      strategy: _ctx.strategy,
      teleported: _ctx.teleported,
      transition: _ctx.transition,
      "z-index": _ctx.zIndex,
      "append-to": _ctx.appendTo
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "content", {}, () => [_ctx.rawContent ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 0,
        innerHTML: _ctx.content
      }, null, 8, _hoisted_1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", _hoisted_2, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.content), 1))]), _ctx.compatShowArrow ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_popper_arrow, {
        key: 0,
        "arrow-offset": _ctx.arrowOffset
      }, null, 8, ["arrow-offset"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      _: 3
    }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "show-after", "strategy", "teleported", "transition", "z-index", "append-to"])]),
    _: 3
  }, 512);
}

var Tooltip = /* @__PURE__ */_export_sfc(tooltip4_sfc_main, [["render", tooltip4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/index2.mjs





const ElTooltip = withInstall(Tooltip);

;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/_virtual/plugin-vue_export-helper.mjs
var plugin_vue_export_helper_export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;

  for (const [key, val] of props) {
    target[key] = val;
  }

  return target;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/close.mjs



const close_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "Close"
});

const close_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const close_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1);

const _hoisted_3 = [close_hoisted_2];

function close_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", close_hoisted_1, _hoisted_3);
}

var close_close = /* @__PURE__ */plugin_vue_export_helper_export_sfc(close_sfc_main, [["render", close_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/success-filled.mjs



const success_filled_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "SuccessFilled"
});

const success_filled_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const success_filled_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1);

const success_filled_hoisted_3 = [success_filled_hoisted_2];

function success_filled_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", success_filled_hoisted_1, success_filled_hoisted_3);
}

var successFilled = /* @__PURE__ */plugin_vue_export_helper_export_sfc(success_filled_sfc_main, [["render", success_filled_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/info-filled.mjs



const info_filled_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "InfoFilled"
});

const info_filled_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const info_filled_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1);

const info_filled_hoisted_3 = [info_filled_hoisted_2];

function info_filled_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", info_filled_hoisted_1, info_filled_hoisted_3);
}

var infoFilled = /* @__PURE__ */plugin_vue_export_helper_export_sfc(info_filled_sfc_main, [["render", info_filled_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/warning-filled.mjs



const warning_filled_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "WarningFilled"
});

const warning_filled_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const warning_filled_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
}, null, -1);

const warning_filled_hoisted_3 = [warning_filled_hoisted_2];

function warning_filled_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", warning_filled_hoisted_1, warning_filled_hoisted_3);
}

var warningFilled = /* @__PURE__ */plugin_vue_export_helper_export_sfc(warning_filled_sfc_main, [["render", warning_filled_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/circle-close-filled.mjs



const circle_close_filled_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "CircleCloseFilled"
});

const circle_close_filled_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const circle_close_filled_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
}, null, -1);

const circle_close_filled_hoisted_3 = [circle_close_filled_hoisted_2];

function circle_close_filled_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", circle_close_filled_hoisted_1, circle_close_filled_hoisted_3);
}

var circleCloseFilled = /* @__PURE__ */plugin_vue_export_helper_export_sfc(circle_close_filled_sfc_main, [["render", circle_close_filled_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/loading.mjs



const loading_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "Loading"
});

const loading_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const loading_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
}, null, -1);

const loading_hoisted_3 = [loading_hoisted_2];

function loading_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", loading_hoisted_1, loading_hoisted_3);
}

var loading = /* @__PURE__ */plugin_vue_export_helper_export_sfc(loading_sfc_main, [["render", loading_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/circle-check.mjs



const circle_check_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "CircleCheck"
});

const circle_check_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const circle_check_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);

const circle_check_hoisted_3 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
}, null, -1);

const _hoisted_4 = [circle_check_hoisted_2, circle_check_hoisted_3];

function circle_check_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", circle_check_hoisted_1, _hoisted_4);
}

var circleCheck = /* @__PURE__ */plugin_vue_export_helper_export_sfc(circle_check_sfc_main, [["render", circle_check_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/circle-close.mjs



const circle_close_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "CircleClose"
});

const circle_close_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const circle_close_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
}, null, -1);

const circle_close_hoisted_3 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);

const circle_close_hoisted_4 = [circle_close_hoisted_2, circle_close_hoisted_3];

function circle_close_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", circle_close_hoisted_1, circle_close_hoisted_4);
}

var circleClose = /* @__PURE__ */plugin_vue_export_helper_export_sfc(circle_close_sfc_main, [["render", circle_close_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/vue/icon2.mjs


const iconPropType = definePropType([String, Object, Function]);
const CloseComponents = {
  Close: close_close
};
const TypeComponents = {
  Close: close_close,
  SuccessFilled: successFilled,
  InfoFilled: infoFilled,
  WarningFilled: warningFilled,
  CircleCloseFilled: circleCloseFilled
};
const TypeComponentsMap = {
  success: successFilled,
  warning: warningFilled,
  error: circleCloseFilled,
  info: infoFilled
};
const ValidateComponentsMap = {
  validating: loading,
  success: circleCheck,
  error: circleClose
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/collection/src/collection4.mjs



const collection4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  inheritAttrs: false
});

function collection4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default");
}

var Collection = /* @__PURE__ */_export_sfc(collection4_sfc_main, [["render", collection4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/collection/src/collection-item2.mjs



const collection_item2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElCollectionItem",
  inheritAttrs: false
});

function collection_item2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default");
}

var CollectionItem = /* @__PURE__ */_export_sfc(collection_item2_sfc_main, [["render", collection_item2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/collection/src/collection3.mjs



const COLLECTION_ITEM_SIGN = `data-el-collection-item`;

const createCollectionWithScope = name => {
  const COLLECTION_NAME = `El${name}Collection`;
  const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
  const COLLECTION_INJECTION_KEY = Symbol(COLLECTION_NAME);
  const COLLECTION_ITEM_INJECTION_KEY = Symbol(COLLECTION_ITEM_NAME);
  const ElCollection = { ...Collection,
    name: COLLECTION_NAME,

    setup() {
      const collectionRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
      const itemMap = /* @__PURE__ */new Map();

      const getItems = () => {
        const collectionEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(collectionRef);
        if (!collectionEl) return [];
        const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
        const items = [...itemMap.values()];
        const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref));
        return orderedItems;
      };

      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(COLLECTION_INJECTION_KEY, {
        itemMap,
        getItems,
        collectionRef
      });
    }

  };
  const ElCollectionItem = { ...CollectionItem,
    name: COLLECTION_ITEM_NAME,

    setup(_, {
      attrs
    }) {
      const collectionItemRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
      const collectionInjection = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(COLLECTION_INJECTION_KEY, void 0);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(COLLECTION_ITEM_INJECTION_KEY, {
        collectionItemRef
      });
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
        const collectionItemEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(collectionItemRef);

        if (collectionItemEl) {
          collectionInjection.itemMap.set(collectionItemEl, {
            ref: collectionItemEl,
            ...attrs
          });
        }
      });
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
        const collectionItemEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(collectionItemRef);
        collectionInjection.itemMap.delete(collectionItemEl);
      });
    }

  };
  return {
    COLLECTION_INJECTION_KEY,
    COLLECTION_ITEM_INJECTION_KEY,
    ElCollection,
    ElCollectionItem
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dropdown/src/dropdown3.mjs









const dropdownProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  effect: { ...useTooltipContentProps.effect,
    default: "light"
  },
  type: {
    type: definePropType(String)
  },
  placement: {
    type: definePropType(String),
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: true
  },
  loop: {
    type: Boolean
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: definePropType([Number, String]),
    default: 0
  },
  maxHeight: {
    type: definePropType([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  buttonProps: {
    type: definePropType(Object)
  }
});
const dropdownItemProps = buildProps({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: iconPropType
  }
});
const dropdownMenuProps = buildProps({
  onKeydown: {
    type: definePropType(Function)
  }
});
const FIRST_KEYS = [EVENT_CODE.down, EVENT_CODE.pageDown, EVENT_CODE.home];
const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
const {
  ElCollection,
  ElCollectionItem,
  COLLECTION_INJECTION_KEY,
  COLLECTION_ITEM_INJECTION_KEY
} = createCollectionWithScope("Dropdown");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popover/src/popover2.mjs






const usePopoverProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  placement: dropdownProps.placement,
  disabled: useTooltipTriggerProps.disabled,
  visible: useTooltipContentProps.visible,
  transition: useTooltipContentProps.transition,
  popperOptions: dropdownProps.popperOptions,
  tabindex: dropdownProps.tabindex,
  content: useTooltipContentProps.content,
  popperStyle: useTooltipContentProps.popperStyle,
  popperClass: useTooltipContentProps.popperClass,
  enterable: { ...useTooltipContentProps.enterable,
    default: true
  },
  effect: { ...useTooltipContentProps.effect,
    default: "light"
  },
  teleported: useTooltipContentProps.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popover/src/index2.mjs








const emits = ["update:visible", "before-enter", "before-leave", "after-enter", "after-leave"];
const COMPONENT_NAME = "ElPopover";

const index2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: COMPONENT_NAME,
  components: {
    ElTooltip: ElTooltip
  },
  props: usePopoverProps,
  emits,

  setup(props, {
    emit
  }) {
    const ns = useNamespace("popover");
    const tooltipRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const popperRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      return (_a = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(tooltipRef)) == null ? void 0 : _a.popperRef;
    });
    const width = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (shared_esm_bundler_isString(props.width)) {
        return props.width;
      }

      return `${props.width}px`;
    });
    const style = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return [{
        width: width.value
      }, props.popperStyle];
    });
    const kls = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return [ns.b(), props.popperClass, {
        [ns.m("plain")]: !!props.content
      }];
    });
    const gpuAcceleration = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.transition === "el-fade-in-linear";
    });

    const hide = () => {
      var _a;

      (_a = tooltipRef.value) == null ? void 0 : _a.hide();
    };

    const beforeEnter = () => {
      emit("before-enter");
    };

    const beforeLeave = () => {
      emit("before-leave");
    };

    const afterEnter = () => {
      emit("after-enter");
    };

    const afterLeave = () => {
      emit("update:visible", false);
      emit("after-leave");
    };

    return {
      ns,
      kls,
      gpuAcceleration,
      style,
      tooltipRef,
      popperRef,
      hide,
      beforeEnter,
      beforeLeave,
      afterEnter,
      afterLeave
    };
  }

});

function index2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tooltip");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tooltip, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
    ref: "tooltipRef"
  }, _ctx.$attrs, {
    trigger: _ctx.trigger,
    placement: _ctx.placement,
    disabled: _ctx.disabled,
    visible: _ctx.visible,
    transition: _ctx.transition,
    "popper-options": _ctx.popperOptions,
    tabindex: _ctx.tabindex,
    content: _ctx.content,
    offset: _ctx.offset,
    "show-after": _ctx.showAfter,
    "hide-after": _ctx.hideAfter,
    "auto-close": _ctx.autoClose,
    "show-arrow": _ctx.showArrow,
    "aria-label": _ctx.title,
    effect: _ctx.effect,
    enterable: _ctx.enterable,
    "popper-class": _ctx.kls,
    "popper-style": _ctx.style,
    teleported: _ctx.teleported,
    persistent: _ctx.persistent,
    "gpu-acceleration": _ctx.gpuAcceleration,
    onBeforeShow: _ctx.beforeEnter,
    onBeforeHide: _ctx.beforeLeave,
    onShow: _ctx.afterEnter,
    onHide: _ctx.afterLeave
  }), {
    content: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.title ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 0,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("title")),
      role: "title"
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.title), 3)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.content), 1)])]),
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.$slots.reference ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "reference", {
      key: 0
    }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
    _: 3
  }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onBeforeShow", "onBeforeHide", "onShow", "onHide"]);
}

var Popover = /* @__PURE__ */_export_sfc(index2_sfc_main, [["render", index2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/index.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popover/src/directive2.mjs
const attachEvents = (el, binding) => {
  const popperComponent = binding.arg || binding.value;
  const popover = popperComponent == null ? void 0 : popperComponent.popperRef;

  if (popover) {
    popover.triggerRef = el;
  }
};

var PopoverDirective = {
  mounted(el, binding) {
    attachEvents(el, binding);
  },

  updated(el, binding) {
    attachEvents(el, binding);
  }

};
const VPopover = "popover";

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popover/index2.mjs



Popover.install = app => {
  app.component(Popover.name, Popover);
};

PopoverDirective.install = app => {
  app.directive(VPopover, PopoverDirective);
};

const _PopoverDirective = PopoverDirective;
Popover.directive = _PopoverDirective;
const _Popover = Popover;
const ElPopover = _Popover;
const ElPopoverDirective = (/* unused pure expression or super */ null && (_PopoverDirective));

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/base.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/base/style/css2.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-popover.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-popper.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popper/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popover/style/css2.mjs



;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/popover/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/row2.mjs
const rowContextKey = Symbol("rowContextKey");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/row/src/row.mjs







const rowProps = buildProps({
  tag: {
    type: String,
    default: "div"
  },
  gutter: {
    type: Number,
    default: 0
  },
  justify: {
    type: String,
    values: ["start", "center", "end", "space-around", "space-between", "space-evenly"],
    default: "start"
  },
  align: {
    type: String,
    values: ["top", "middle", "bottom"],
    default: "top"
  }
});
const Row = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElRow",
  props: rowProps,

  setup(props, {
    slots
  }) {
    const ns = useNamespace("row");
    const gutter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.gutter);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(rowContextKey, {
      gutter
    });
    const style = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const styles = {
        marginLeft: "",
        marginRight: ""
      };

      if (props.gutter) {
        styles.marginLeft = `-${props.gutter / 2}px`;
        styles.marginRight = styles.marginLeft;
      }

      return styles;
    });
    return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(props.tag, {
      "class": [ns.b(), ns.is(`justify-${props.justify}`, props.justify !== "start"), ns.is(`align-${props.align}`, props.align !== "top")],
      "style": style.value
    }, {
      default: () => {
        var _a;

        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    });
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/row/index2.mjs




const ElRow = withInstall(Row);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-row.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/row/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/row/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/typescript2.mjs
const mutable = val => val;


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/col/src/col.mjs








const colProps = buildProps({
  tag: {
    type: String,
    default: "div"
  },
  span: {
    type: Number,
    default: 24
  },
  offset: {
    type: Number,
    default: 0
  },
  pull: {
    type: Number,
    default: 0
  },
  push: {
    type: Number,
    default: 0
  },
  xs: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  sm: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  md: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  lg: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  },
  xl: {
    type: definePropType([Number, Object]),
    default: () => mutable({})
  }
});
var Col = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElCol",
  props: colProps,

  setup(props, {
    slots
  }) {
    const {
      gutter
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(rowContextKey, {
      gutter: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => 0)
    });
    const ns = useNamespace("col");
    const style = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (gutter.value) {
        return {
          paddingLeft: `${gutter.value / 2}px`,
          paddingRight: `${gutter.value / 2}px`
        };
      }

      return {};
    });
    const classes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const classes2 = [];
      const pos = ["span", "offset", "pull", "push"];
      pos.forEach(prop => {
        const size = props[prop];

        if (typeof size === "number") {
          if (prop === "span") classes2.push(ns.b(`${props[prop]}`));else if (size > 0) classes2.push(ns.b(`${prop}-${props[prop]}`));
        }
      });
      const sizes = ["xs", "sm", "md", "lg", "xl"];
      sizes.forEach(size => {
        if (typeof props[size] === "number") {
          classes2.push(ns.b(`${size}-${props[size]}`));
        } else if (typeof props[size] === "object") {
          const sizeProps = props[size];
          Object.keys(sizeProps).forEach(prop => {
            classes2.push(prop !== "span" ? ns.b(`${size}-${prop}-${sizeProps[prop]}`) : ns.b(`${size}-${sizeProps[prop]}`));
          });
        }
      });

      if (gutter.value) {
        classes2.push(ns.is("guttered"));
      }

      return classes2;
    });
    return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(props.tag, {
      "class": [ns.b(), classes.value],
      "style": style.value
    }, slots);
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/col/index2.mjs




const ElCol = withInstall(Col);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-col.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/col/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/col/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/lodash-es/isNil.js
/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil_isNil(value) {
  return value == null;
}

/* harmony default export */ var lodash_es_isNil = (isNil_isNil);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/icon/src/icon3.mjs


const iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/dom/style2.mjs







const SCOPE = "utils/dom/style";

const classNameToArray = (cls = "") => cls.split(" ").filter(item => !!item.trim());

const hasClass = (el, cls) => {
  if (!el || !cls) return false;
  if (cls.includes(" ")) throw new Error("className should not contain space.");
  return el.classList.contains(cls);
};

const addClass = (el, cls) => {
  if (!el || !cls.trim()) return;
  el.classList.add(...classNameToArray(cls));
};

const removeClass = (el, cls) => {
  if (!el || !cls.trim()) return;
  el.classList.remove(...classNameToArray(cls));
};

const style2_getStyle = (element, styleName) => {
  var _a;

  if (!shared_isClient || !element || !styleName) return "";
  let key = shared_esm_bundler_camelize(styleName);
  if (key === "float") key = "cssFloat";

  try {
    const style = element.style[styleName];
    if (style) return style;
    const computed = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, "");
    return computed ? computed[styleName] : "";
  } catch (e) {
    return element.style[styleName];
  }
};

const setStyle = (element, styleName, value) => {
  if (!element || !styleName) return;

  if (isObject(styleName)) {
    entriesOf(styleName).forEach(([prop, value2]) => setStyle(element, prop, value2));
  } else {
    const key = camelize(styleName);
    element.style[key] = value;
  }
};

const removeStyle = (element, style) => {
  if (!element || !style) return;

  if (isObject(style)) {
    keysOf(style).forEach(prop => removeStyle(element, prop));
  } else {
    setStyle(element, style, "");
  }
};

function addUnit(value, defaultUnit = "px") {
  if (!value) return "";

  if (shared_esm_bundler_isString(value)) {
    return value;
  } else if (shared_isNumber(value)) {
    return `${value}${defaultUnit}`;
  }

  error2_debugWarn(SCOPE, "binding value must be a string or number");
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/icon/src/icon4.mjs








const icon4_default_ = {
  name: "ElIcon",
  inheritAttrs: false
};

const icon4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...icon4_default_,
  props: iconProps,

  setup(__props) {
    const props = __props;
    const ns = useNamespace("icon");
    const style = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (!props.size && !props.color) return {};
      return {
        fontSize: isUndefined(props.size) ? void 0 : addUnit(props.size),
        "--color": props.color
      };
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("i", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).b(),
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(style)
      }, _ctx.$attrs), [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 16);
    };
  }

});

var Icon = /* @__PURE__ */_export_sfc(icon4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/icon/index2.mjs




const ElIcon = withInstall(Icon);

;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/view.mjs



const view_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "View"
});

const view_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const view_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1);

const view_hoisted_3 = [view_hoisted_2];

function view_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", view_hoisted_1, view_hoisted_3);
}

var view = /* @__PURE__ */plugin_vue_export_helper_export_sfc(view_sfc_main, [["render", view_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/hide.mjs



const hide_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "Hide"
});

const hide_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const hide_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
  fill: "currentColor"
}, null, -1);

const hide_hoisted_3 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
  fill: "currentColor"
}, null, -1);

const hide_hoisted_4 = [hide_hoisted_2, hide_hoisted_3];

function hide_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", hide_hoisted_1, hide_hoisted_4);
}

var hide = /* @__PURE__ */plugin_vue_export_helper_export_sfc(hide_sfc_main, [["render", hide_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/input/src/utils2.mjs


let hiddenTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];

function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map(name => `${name}:${style.getPropertyValue(name)}`).join(";");
  return {
    contextStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
}

function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }

  const {
    paddingSize,
    borderSize,
    boxSizing,
    contextStyle
  } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea.scrollHeight;
  const result = {};

  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }

  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (shared_isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;

    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }

    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }

  if (shared_isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;

    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }

    height = Math.min(maxHeight, height);
  }

  result.height = `${height}px`;
  (_a = hiddenTextarea.parentNode) == null ? void 0 : _a.removeChild(hiddenTextarea);
  hiddenTextarea = void 0;
  return result;
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-prop/index2.mjs


const useProp = name => {
  const vm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    var _a, _b;

    return (_b = (_a = vm.proxy) == null ? void 0 : _a.$props[name]) != null ? _b : void 0;
  });
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/constants/size2.mjs
const componentSizes = ["", "default", "small", "large"];
const componentSizeMap = {
  large: 40,
  default: 32,
  small: 24
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-common-props/index2.mjs









const useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});

const useSize = (fallback, ignore = {}) => {
  const emptyRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(void 0);
  const size = ignore.prop ? emptyRef : useProp("size");
  const globalConfig = ignore.global ? emptyRef : useGlobalConfig("size");
  const form = ignore.form ? {
    size: void 0
  } : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, void 0);
  const formItem = ignore.formItem ? {
    size: void 0
  } : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, void 0);
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => size.value || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig.value || "");
};

const useDisabled = fallback => {
  const disabled = useProp("disabled");
  const form = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, void 0);
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => disabled.value || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(fallback) || (form == null ? void 0 : form.disabled) || false);
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/constants/event2.mjs
const UPDATE_MODEL_EVENT = "update:modelValue";
const CHANGE_EVENT = "change";
const INPUT_EVENT = "input";

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/input/src/input3.mjs









const inputProps = buildProps({
  id: {
    type: String,
    default: void 0
  },
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: definePropType([String, Number, Object]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: definePropType([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String,
    default: ""
  },
  readonly: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  suffixIcon: {
    type: iconPropType,
    default: ""
  },
  prefixIcon: {
    type: iconPropType,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: definePropType([Object, Array, String]),
    default: () => mutable({})
  }
});
const inputEmits = {
  [UPDATE_MODEL_EVENT]: value => shared_esm_bundler_isString(value),
  input: value => shared_esm_bundler_isString(value),
  change: value => shared_esm_bundler_isString(value),
  focus: evt => evt instanceof FocusEvent,
  blur: evt => evt instanceof FocusEvent,
  clear: () => true,
  mouseleave: evt => evt instanceof MouseEvent,
  mouseenter: evt => evt instanceof MouseEvent,
  keydown: evt => evt instanceof Event,
  compositionstart: evt => evt instanceof CompositionEvent,
  compositionupdate: evt => evt instanceof CompositionEvent,
  compositionend: evt => evt instanceof CompositionEvent
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-attrs/index2.mjs




const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;

const useAttrs = (params = {}) => {
  const {
    excludeListeners = false,
    excludeKeys = []
  } = params;
  const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();

  if (!instance) {
    error2_debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ({}));
  }

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    var _a;

    return lodash_es_fromPairs(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key]) => !allExcludeKeys.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
  });
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-form-item/index2.mjs






const useFormItem = () => {
  const form = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, void 0);
  const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, void 0);
  return {
    form,
    formItem
  };
};

const useFormItemInputId = (props, {
  formItemContext,
  disableIdGeneration,
  disableIdManagement
}) => {
  if (!disableIdGeneration) {
    disableIdGeneration = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  }

  if (!disableIdManagement) {
    disableIdManagement = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  }

  const inputId = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
  let idUnwatch = void 0;
  const isLabeledByFormItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    var _a;

    return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a = formItemContext.inputIds) == null ? void 0 : _a.length) <= 1);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
    idUnwatch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
      const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;

      if (newId !== inputId.value) {
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);

          if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
            formItemContext.addInputId(newId);
          }
        }

        inputId.value = newId;
      }
    }, {
      immediate: true
    });
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
    idUnwatch && idUnwatch();

    if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
      inputId.value && formItemContext.removeInputId(inputId.value);
    }
  });
  return {
    isLabeledByFormItem,
    inputId
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-cursor/index2.mjs


function useCursor(input) {
  const selectionRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();

  function recordCursor() {
    if (input.value == void 0) return;
    const {
      selectionStart,
      selectionEnd,
      value
    } = input.value;
    if (selectionStart == null || selectionEnd == null) return;
    const beforeTxt = value.slice(0, Math.max(0, selectionStart));
    const afterTxt = value.slice(Math.max(0, selectionEnd));
    selectionRef.value = {
      selectionStart,
      selectionEnd,
      value,
      beforeTxt,
      afterTxt
    };
  }

  function setCursor() {
    if (input.value == void 0 || selectionRef.value == void 0) return;
    const {
      value
    } = input.value;
    const {
      beforeTxt,
      afterTxt,
      selectionStart
    } = selectionRef.value;
    if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0) return;
    let startPos = value.length;

    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else {
      const beforeLastChar = beforeTxt[selectionStart - 1];
      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);

      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }

    input.value.setSelectionRange(startPos, startPos);
  }

  return [recordCursor, setCursor];
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/i18n2.mjs
const isKorean = text => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/input/src/input4.mjs





















const input4_hoisted_1 = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const input4_hoisted_2 = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const input4_default_ = {
  name: "ElInput",
  inheritAttrs: false
};

const input4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...input4_default_,
  props: inputProps,
  emits: inputEmits,

  setup(__props, {
    expose,
    emit
  }) {
    const props = __props;
    const PENDANT_MAP = {
      suffix: "append",
      prefix: "prepend"
    };
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const rawAttrs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.useAttrs)();
    const slots = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.useSlots)();
    const attrs = useAttrs();
    const {
      form,
      formItem
    } = useFormItem();
    const {
      inputId
    } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const inputSize = useSize();
    const inputDisabled = useDisabled();
    const nsInput = useNamespace("input");
    const nsTextarea = useNamespace("textarea");
    const input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.shallowRef)();
    const textarea = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.shallowRef)();
    const focused = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const hovering = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const isComposing = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const passwordVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const countStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const textareaCalcStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.shallowRef)(props.inputStyle);

    const _ref = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => input.value || textarea.value);

    const needStatusIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;
    });
    const validateState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => (formItem == null ? void 0 : formItem.validateState) || "");
    const validateIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ValidateComponentsMap[validateState.value]);
    const passwordIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => passwordVisible.value ? view : hide);
    const containerStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [rawAttrs.style, props.inputStyle]);
    const textareaStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [props.inputStyle, textareaCalcStyle.value, {
      resize: props.resize
    }]);
    const nativeInputValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => lodash_es_isNil(props.modelValue) ? "" : String(props.modelValue));
    const showClear = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
    const showPwdVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.showPassword && !inputDisabled.value && !props.readonly && (!!nativeInputValue.value || focused.value));
    const isWordLimitVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
    const textLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => Array.from(nativeInputValue.value).length);
    const inputExceed = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
    const suffixVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
    const [recordCursor, setCursor] = useCursor(input);
    useResizeObserver(textarea, entries => {
      if (!isWordLimitVisible.value || props.resize !== "both") return;
      const entry = entries[0];
      const {
        width
      } = entry.contentRect;
      countStyle.value = {
        right: `calc(100% - ${width + 15 + 6}px)`
      };
    });

    const resizeTextarea = () => {
      const {
        type,
        autosize
      } = props;
      if (!shared_isClient || type !== "textarea") return;

      if (autosize) {
        const minRows = shared_esm_bundler_isObject(autosize) ? autosize.minRows : void 0;
        const maxRows = shared_esm_bundler_isObject(autosize) ? autosize.maxRows : void 0;
        textareaCalcStyle.value = { ...calcTextareaHeight(textarea.value, minRows, maxRows)
        };
      } else {
        textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };

    const setNativeInputValue = () => {
      const input2 = _ref.value;
      if (!input2 || input2.value === nativeInputValue.value) return;
      input2.value = nativeInputValue.value;
    };

    const calcIconOffset = place => {
      const {
        el
      } = instance.vnode;
      if (!el) return;
      const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place)}`));
      const target = elList.find(item => item.parentNode === el);
      if (!target) return;
      const pendant = PENDANT_MAP[place];

      if (slots[pendant]) {
        target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.${nsInput.be("group", pendant)}`).offsetWidth}px)`;
      } else {
        target.removeAttribute("style");
      }
    };

    const updateIconOffset = () => {
      calcIconOffset("prefix");
      calcIconOffset("suffix");
    };

    const handleInput = async event => {
      recordCursor();
      let {
        value
      } = event.target;

      if (props.formatter) {
        value = props.parser ? props.parser(value) : value;
        value = props.formatter(value);
      }

      if (isComposing.value) return;
      if (value === nativeInputValue.value) return;
      emit(UPDATE_MODEL_EVENT, value);
      emit("input", value);
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      setNativeInputValue();
      setCursor();
    };

    const handleChange = event => {
      emit("change", event.target.value);
    };

    const handleCompositionStart = event => {
      emit("compositionstart", event);
      isComposing.value = true;
    };

    const handleCompositionUpdate = event => {
      var _a;

      emit("compositionupdate", event);
      const text = (_a = event.target) == null ? void 0 : _a.value;
      const lastCharacter = text[text.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };

    const handleCompositionEnd = event => {
      emit("compositionend", event);

      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event);
      }
    };

    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus();
    };

    const focus = async () => {
      var _a;

      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      (_a = _ref.value) == null ? void 0 : _a.focus();
    };

    const blur = () => {
      var _a;

      return (_a = _ref.value) == null ? void 0 : _a.blur();
    };

    const handleFocus = event => {
      focused.value = true;
      emit("focus", event);
    };

    const handleBlur = event => {
      var _a;

      focused.value = false;
      emit("blur", event);

      if (props.validateEvent) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "blur").catch(err => error2_debugWarn(err));
      }
    };

    const handleMouseLeave = evt => {
      hovering.value = false;
      emit("mouseleave", evt);
    };

    const handleMouseEnter = evt => {
      hovering.value = true;
      emit("mouseenter", evt);
    };

    const handleKeydown = evt => {
      emit("keydown", evt);
    };

    const select = () => {
      var _a;

      (_a = _ref.value) == null ? void 0 : _a.select();
    };

    const clear = () => {
      emit(UPDATE_MODEL_EVENT, "");
      emit("change", "");
      emit("clear");
      emit("input", "");
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      var _a;

      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => resizeTextarea());

      if (props.validateEvent) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch(err => error2_debugWarn(err));
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(nativeInputValue, () => setNativeInputValue());
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, async () => {
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      setNativeInputValue();
      resizeTextarea();
      updateIconOffset();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(async () => {
      if (!props.formatter && props.parser) {
        error2_debugWarn("ElInput", "If you set the parser, you also need to set the formatter.");
      }

      setNativeInputValue();
      updateIconOffset();
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      resizeTextarea();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUpdated)(async () => {
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      updateIconOffset();
    });
    expose({
      input,
      textarea,
      ref: _ref,
      textareaStyle,
      autosize: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "autosize"),
      focus,
      blur,
      select,
      clear,
      resizeTextarea
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.type === "textarea" ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsTextarea).b() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).b(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).m((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputSize)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).is("disabled", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputDisabled)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).is("exceed", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputExceed)), {
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).b("group")]: _ctx.$slots.prepend || _ctx.$slots.append,
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).bm("group", "append")]: _ctx.$slots.append,
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend,
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).m("prefix")]: _ctx.$slots.prefix || _ctx.prefixIcon,
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).m("suffix")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).bm("suffix", "password-clear")]: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showClear) && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showPwdVisible)
        }, _ctx.$attrs.class]),
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(containerStyle)),
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" input "), _ctx.type !== "textarea" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" prepend slot "), _ctx.$slots.prepend ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).be("group", "prepend"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "prepend")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("wrapper"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).is("focus", focused.value)])
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" prefix slot "), _ctx.$slots.prefix || _ctx.prefixIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("prefix"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("prefix-inner"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "prefix"), _ctx.prefixIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("icon"))
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.prefixIcon)))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2)], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("input", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
        id: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputId),
        ref_key: "input",
        ref: input,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("inner")
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(attrs), {
        type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
        disabled: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputDisabled),
        formatter: _ctx.formatter,
        parser: _ctx.parser,
        readonly: _ctx.readonly,
        autocomplete: _ctx.autocomplete,
        tabindex: _ctx.tabindex,
        "aria-label": _ctx.label,
        placeholder: _ctx.placeholder,
        style: _ctx.inputStyle,
        onCompositionstart: handleCompositionStart,
        onCompositionupdate: handleCompositionUpdate,
        onCompositionend: handleCompositionEnd,
        onInput: handleInput,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onChange: handleChange,
        onKeydown: handleKeydown
      }), null, 16, input4_hoisted_1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" suffix slot "), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(suffixVisible) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("suffix"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("suffix-inner"))
      }, [!(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showClear) || !(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showPwdVisible) || !(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(isWordLimitVisible) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "suffix"), _ctx.suffixIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("icon"))
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.suffixIcon)))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 64)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showClear) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("icon"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("clear")]),
        onMousedown: _cache[0] || (_cache[0] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)(() => {}, ["prevent"])),
        onClick: clear
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(circleClose))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(showPwdVisible) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 2,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("icon"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("password")]),
        onClick: handlePasswordVisible
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(passwordIcon))))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(isWordLimitVisible) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 3,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("count"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("count-inner"))
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(textLength)) + " / " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(attrs).maxlength), 3)], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(validateState) && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(validateIcon) && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(needStatusIcon) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 4,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("icon"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("validateIcon"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).is("loading", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(validateState) === "validating")])
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(validateIcon))))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2)], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" append slot "), _ctx.$slots.append ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).be("group", "append"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "append")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 64)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 1
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" textarea "), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("textarea", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
        id: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputId),
        ref_key: "textarea",
        ref: textarea,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsTextarea).e("inner")
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(attrs), {
        tabindex: _ctx.tabindex,
        disabled: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputDisabled),
        readonly: _ctx.readonly,
        autocomplete: _ctx.autocomplete,
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(textareaStyle),
        "aria-label": _ctx.label,
        placeholder: _ctx.placeholder,
        onCompositionstart: handleCompositionStart,
        onCompositionupdate: handleCompositionUpdate,
        onCompositionend: handleCompositionEnd,
        onInput: handleInput,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onChange: handleChange,
        onKeydown: handleKeydown
      }), null, 16, input4_hoisted_2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(isWordLimitVisible) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 0,
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(countStyle.value),
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(nsInput).e("count"))
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(textLength)) + " / " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(attrs).maxlength), 7)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 64))], 38)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.type !== "hidden"]]);
    };
  }

});

var Input = /* @__PURE__ */_export_sfc(input4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/input/index2.mjs




const ElInput = withInstall(Input);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-input.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/input/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/input/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/util2.mjs
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};

const renderThumbStyle = ({
  move,
  size,
  bar
}) => ({
  [bar.size]: size,
  transform: `translate${bar.axis}(${move}%)`
});


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/thumb3.mjs


const thumbProps = buildProps({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/scrollbar2.mjs
const scrollbarContextKey = Symbol("scrollbarContextKey");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/thumb4.mjs











const thumb4_COMPONENT_NAME = "Thumb";

const thumb4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: thumb4_COMPONENT_NAME,
  props: thumbProps,

  setup(props) {
    const scrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(scrollbarContextKey);
    const ns = useNamespace("scrollbar");
    if (!scrollbar) throwError(thumb4_COMPONENT_NAME, "can not inject scrollbar context");
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const thumb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const thumbState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
    const visible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    let cursorDown = false;
    let cursorLeave = false;
    let originalOnSelectStart = shared_isClient ? document.onselectstart : null;
    const bar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
    const thumbStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => renderThumbStyle({
      size: props.size,
      move: props.move,
      bar: bar.value
    }));
    const offsetRatio = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);

    const clickThumbHandler = e => {
      var _a;

      e.stopPropagation();
      if (e.ctrlKey || [1, 2].includes(e.button)) return;
      (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
      startDrag(e);
      const el = e.currentTarget;
      if (!el) return;
      thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
    };

    const clickTrackHandler = e => {
      if (!thumb.value || !instance.value || !scrollbar.wrapElement) return;
      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };

    const startDrag = e => {
      e.stopImmediatePropagation();
      cursorDown = true;
      document.addEventListener("mousemove", mouseMoveDocumentHandler);
      document.addEventListener("mouseup", mouseUpDocumentHandler);
      originalOnSelectStart = document.onselectstart;

      document.onselectstart = () => false;
    };

    const mouseMoveDocumentHandler = e => {
      if (!instance.value || !thumb.value) return;
      if (cursorDown === false) return;
      const prevPage = thumbState.value[bar.value.axis];
      if (!prevPage) return;
      const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };

    const mouseUpDocumentHandler = () => {
      cursorDown = false;
      thumbState.value[bar.value.axis] = 0;
      document.removeEventListener("mousemove", mouseMoveDocumentHandler);
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
      restoreOnselectstart();
      if (cursorLeave) visible.value = false;
    };

    const mouseMoveScrollbarHandler = () => {
      cursorLeave = false;
      visible.value = !!props.size;
    };

    const mouseLeaveScrollbarHandler = () => {
      cursorLeave = true;
      visible.value = cursorDown;
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      restoreOnselectstart();
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
    });

    const restoreOnselectstart = () => {
      if (document.onselectstart !== originalOnSelectStart) document.onselectstart = originalOnSelectStart;
    };

    useEventListener((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
    useEventListener((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
    return {
      ns,
      instance,
      thumb,
      bar,
      thumbStyle,
      visible,
      clickTrackHandler,
      clickThumbHandler
    };
  }

});

function thumb4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
    name: _ctx.ns.b("fade")
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      ref: "instance",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("bar"), _ctx.ns.is(_ctx.bar.key)]),
      onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.clickTrackHandler && _ctx.clickTrackHandler(...args))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      ref: "thumb",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("thumb")),
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.thumbStyle),
      onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.clickThumbHandler && _ctx.clickThumbHandler(...args))
    }, null, 38)], 34), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.always || _ctx.visible]])]),
    _: 1
  }, 8, ["name"]);
}

var Thumb = /* @__PURE__ */_export_sfc(thumb4_sfc_main, [["render", thumb4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/bar3.mjs


const barProps = buildProps({
  always: {
    type: Boolean,
    default: true
  },
  width: {
    type: String,
    default: ""
  },
  height: {
    type: String,
    default: ""
  },
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/bar4.mjs





const bar4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  components: {
    Thumb: Thumb
  },
  props: barProps,

  setup(props) {
    const moveX = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    const moveY = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    const GAP = 4;

    const handleScroll = wrap => {
      if (wrap) {
        const offsetHeight = wrap.offsetHeight - GAP;
        const offsetWidth = wrap.offsetWidth - GAP;
        moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
        moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
      }
    };

    return {
      handleScroll,
      moveX,
      moveY
    };
  }

});

function bar4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_thumb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("thumb");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_thumb, {
    move: _ctx.moveX,
    ratio: _ctx.ratioX,
    size: _ctx.width,
    always: _ctx.always
  }, null, 8, ["move", "ratio", "size", "always"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_thumb, {
    move: _ctx.moveY,
    ratio: _ctx.ratioY,
    size: _ctx.height,
    vertical: "",
    always: _ctx.always
  }, null, 8, ["move", "ratio", "size", "always"])], 64);
}

var Bar = /* @__PURE__ */_export_sfc(bar4_sfc_main, [["render", bar4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/scrollbar3.mjs



const scrollbarProps = buildProps({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: false
  },
  wrapStyle: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: {
    type: Boolean,
    default: false
  },
  minSize: {
    type: Number,
    default: 20
  }
});
const scrollbarEmits = {
  scroll: ({
    scrollTop,
    scrollLeft
  }) => shared_isNumber(scrollTop) && shared_isNumber(scrollLeft)
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/src/scrollbar4.mjs














const scrollbar4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElScrollbar",
  components: {
    Bar: Bar
  },
  props: scrollbarProps,
  emits: scrollbarEmits,

  setup(props, {
    emit
  }) {
    const ns = useNamespace("scrollbar");
    let stopResizeObserver = void 0;
    let stopResizeListener = void 0;
    const scrollbar$ = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const wrap$ = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const resize$ = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const sizeWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("0");
    const sizeHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("0");
    const barRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const moveX = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    const moveY = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    const ratioY = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(1);
    const ratioX = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(1);
    const SCOPE = "ElScrollbar";
    const GAP = 4;
    const style = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const style2 = {};
      if (props.height) style2.height = addUnit(props.height);
      if (props.maxHeight) style2.maxHeight = addUnit(props.maxHeight);
      return [props.wrapStyle, style2];
    });

    const handleScroll = () => {
      var _a;

      if (wrap$.value) {
        (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrap$.value);
        emit("scroll", {
          scrollTop: wrap$.value.scrollTop,
          scrollLeft: wrap$.value.scrollLeft
        });
      }
    };

    function scrollTo(arg1, arg2) {
      if (shared_esm_bundler_isObject(arg1)) {
        wrap$.value.scrollTo(arg1);
      } else if (shared_isNumber(arg1) && shared_isNumber(arg2)) {
        wrap$.value.scrollTo(arg1, arg2);
      }
    }

    const setScrollTop = value => {
      if (!shared_isNumber(value)) {
        error2_debugWarn(SCOPE, "value must be a number");
        return;
      }

      wrap$.value.scrollTop = value;
    };

    const setScrollLeft = value => {
      if (!shared_isNumber(value)) {
        error2_debugWarn(SCOPE, "value must be a number");
        return;
      }

      wrap$.value.scrollLeft = value;
    };

    const update = () => {
      if (!wrap$.value) return;
      const offsetHeight = wrap$.value.offsetHeight - GAP;
      const offsetWidth = wrap$.value.offsetWidth - GAP;
      const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
      const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
      const height = Math.max(originalHeight, props.minSize);
      const width = Math.max(originalWidth, props.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
      sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
      sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.noresize, noresize => {
      if (noresize) {
        stopResizeObserver == null ? void 0 : stopResizeObserver();
        stopResizeListener == null ? void 0 : stopResizeListener();
      } else {
        ;
        ({
          stop: stopResizeObserver
        } = useResizeObserver(resize$, update));
        stopResizeListener = useEventListener("resize", update);
      }
    }, {
      immediate: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => [props.maxHeight, props.height], () => {
      if (!props.native) (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        var _a;

        update();

        if (wrap$.value) {
          (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrap$.value);
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(scrollbarContextKey, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      scrollbarElement: scrollbar$,
      wrapElement: wrap$
    }));
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (!props.native) (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => update());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUpdated)(() => update());
    return {
      ns,
      scrollbar$,
      wrap$,
      resize$,
      barRef,
      moveX,
      moveY,
      ratioX,
      ratioY,
      sizeWidth,
      sizeHeight,
      style,
      update,
      handleScroll,
      scrollTo,
      setScrollTop,
      setScrollLeft
    };
  }

});

function scrollbar4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("bar");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    ref: "scrollbar$",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.b())
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    ref: "wrap$",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.wrapClass, _ctx.ns.e("wrap"), {
      [_ctx.ns.em("wrap", "hidden-default")]: !_ctx.native
    }]),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.style),
    onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
  }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.tag), {
    ref: "resize$",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("view"), _ctx.viewClass]),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.viewStyle)
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")]),
    _: 3
  }, 8, ["class", "style"]))], 38), !_ctx.native ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_bar, {
    key: 0,
    ref: "barRef",
    height: _ctx.sizeHeight,
    width: _ctx.sizeWidth,
    always: _ctx.always,
    "ratio-x": _ctx.ratioX,
    "ratio-y": _ctx.ratioY
  }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2);
}

var Scrollbar = /* @__PURE__ */_export_sfc(scrollbar4_sfc_main, [["render", scrollbar4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/index2.mjs






const ElScrollbar = withInstall(Scrollbar);

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tag/src/tag3.mjs




const tagProps = buildProps({
  closable: Boolean,
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  hit: Boolean,
  disableTransitions: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: componentSizes,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
});
const tagEmits = {
  close: evt => evt instanceof MouseEvent,
  click: evt => evt instanceof MouseEvent
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tag/src/tag4.mjs








const tag4_default_ = {
  name: "ElTag"
};

const tag4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...tag4_default_,
  props: tagProps,
  emits: tagEmits,

  setup(__props, {
    emit
  }) {
    const props = __props;
    const tagSize = useSize();
    const ns = useNamespace("tag");
    const classes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        hit,
        effect,
        closable,
        round
      } = props;
      return [ns.b(), ns.is("closable", closable), ns.m(type), ns.m(tagSize.value), ns.m(effect), ns.is("hit", hit), ns.is("round", round)];
    });

    const handleClose = event => {
      event.stopPropagation();
      emit("close", event);
    };

    const handleClick = event => {
      emit("click", event);
    };

    return (_ctx, _cache) => {
      return !_ctx.disableTransitions ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(classes)),
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
          backgroundColor: _ctx.color
        }),
        onClick: handleClick
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("content"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2), _ctx.closable ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("close")),
        onClick: handleClose
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(close_close))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 6)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
        key: 1,
        name: `${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).namespace.value}-zoom-in-center`
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(classes)),
          style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
            backgroundColor: _ctx.color
          }),
          onClick: handleClick
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("content"))
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2), _ctx.closable ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
          key: 0,
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("close")),
          onClick: handleClose
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(close_close))]),
          _: 1
        }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 6)]),
        _: 3
      }, 8, ["name"]));
    };
  }

});

var Tag = /* @__PURE__ */_export_sfc(tag4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tag/index2.mjs




const ElTag = withInstall(Tag);

;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/arrow-up.mjs



const arrow_up_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ArrowUp"
});

const arrow_up_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const arrow_up_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
}, null, -1);

const arrow_up_hoisted_3 = [arrow_up_hoisted_2];

function arrow_up_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", arrow_up_hoisted_1, arrow_up_hoisted_3);
}

var arrowUp = /* @__PURE__ */plugin_vue_export_helper_export_sfc(arrow_up_sfc_main, [["render", arrow_up_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/token2.mjs
const selectGroupKey = "ElSelectGroup";
const selectKey = "ElSelect";

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/strings2.mjs


const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/useOption2.mjs






function useOption(props, states) {
  const select = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(selectKey);
  const selectGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(selectGroupKey, {
    disabled: false
  });
  const isObject = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
  });
  const itemSelected = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (!select.props.multiple) {
      return isEqual(props.value, select.props.modelValue);
    } else {
      return contains(select.props.modelValue, props.value);
    }
  });
  const limitReached = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (select.props.multiple) {
      const modelValue = select.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  const currentLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.label || (isObject.value ? "" : props.value);
  });
  const currentValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.value || props.label || "";
  });
  const isDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.disabled || states.groupDisabled || limitReached.value;
  });
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();

  const contains = (arr = [], target) => {
    if (!isObject.value) {
      return arr && arr.includes(target);
    } else {
      const valueKey = select.props.valueKey;
      return arr && arr.some(item => {
        return lodash_es_get(item, valueKey) === lodash_es_get(target, valueKey);
      });
    }
  };

  const isEqual = (a, b) => {
    if (!isObject.value) {
      return a === b;
    } else {
      const {
        valueKey
      } = select.props;
      return lodash_es_get(a, valueKey) === lodash_es_get(b, valueKey);
    }
  };

  const hoverItem = () => {
    if (!props.disabled && !selectGroup.disabled) {
      select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
    }
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => currentLabel.value, () => {
    if (!props.created && !select.props.remote) select.setSelected();
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.value, (val, oldVal) => {
    const {
      remote,
      valueKey
    } = select.props;

    if (!props.created && !remote) {
      if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
        return;
      }

      select.setSelected();
    }
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => selectGroup.disabled, () => {
    states.groupDisabled = selectGroup.disabled;
  }, {
    immediate: true
  });
  const {
    queryChange
  } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(select);
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(queryChange, changes => {
    const {
      query
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(changes);
    const regexp = new RegExp(escapeStringRegexp(query), "i");
    states.visible = regexp.test(currentLabel.value) || props.created;

    if (!states.visible) {
      select.filteredOptionsCount--;
    }
  });
  return {
    select,
    currentLabel,
    currentValue,
    itemSelected,
    isDisabled,
    hoverItem
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/option2.mjs






const option2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: true,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const ns = useNamespace("select");
    const states = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });
    const {
      currentLabel,
      itemSelected,
      isDisabled,
      select,
      hoverItem
    } = useOption(props, states);
    const {
      visible,
      hover
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(states);
    const vm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)().proxy;
    const key = vm.value;
    select.onOptionCreate(vm);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        selected
      } = select;
      const selectedOptions = select.props.multiple ? selected : [selected];
      const doesSelected = selectedOptions.some(item => {
        return item.value === vm.value;
      });

      if (select.cachedOptions.get(key) === vm && !doesSelected) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          select.cachedOptions.delete(key);
        });
      }

      select.onOptionDestroy(key, vm);
    });

    function selectOptionClick() {
      if (props.disabled !== true && states.groupDisabled !== true) {
        select.handleOptionSelect(vm, true);
      }
    }

    return {
      ns,
      currentLabel,
      itemSelected,
      isDisabled,
      select,
      hoverItem,
      visible,
      hover,
      selectOptionClick,
      states
    };
  }

});

function option2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("dropdown", "item"), _ctx.ns.is("disabled", _ctx.isDisabled), {
      selected: _ctx.itemSelected,
      hover: _ctx.hover
    }]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.currentLabel), 1)])], 34)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.visible]]);
}

var Option = /* @__PURE__ */_export_sfc(option2_sfc_main, [["render", option2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/dom/resize-event2.mjs


const resizeHandler = function (entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];

    if (listeners.length) {
      listeners.forEach(fn => {
        fn();
      });
    }
  }
};

const addResizeListener = function (element, fn) {
  if (!shared_isClient || !element) return;

  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new ResizeObserver(resizeHandler);

    element.__ro__.observe(element);
  }

  element.__resizeListeners__.push(fn);
};

const removeResizeListener = function (element, fn) {
  var _a;

  if (!element || !element.__resizeListeners__) return;

  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

  if (!element.__resizeListeners__.length) {
    (_a = element.__ro__) == null ? void 0 : _a.disconnect();
  }
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/select-dropdown2.mjs








const select_dropdown2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",

  setup() {
    const select = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(selectKey);
    const ns = useNamespace("select");
    const popperClass = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => select.props.popperClass);
    const isMultiple = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => select.props.multiple);
    const isFitInputWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => select.props.fitInputWidth);
    const minWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");

    function updateMinWidth() {
      var _a;

      minWidth.value = `${(_a = select.selectWrapper) == null ? void 0 : _a.getBoundingClientRect().width}px`;
    }

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateMinWidth();
      addResizeListener(select.selectWrapper, updateMinWidth);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      removeResizeListener(select.selectWrapper, updateMinWidth);
    });
    return {
      ns,
      minWidth,
      popperClass,
      isMultiple,
      isFitInputWidth
    };
  }

});

function select_dropdown2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
      [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth
    })
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 6);
}

var ElSelectMenu = /* @__PURE__ */_export_sfc(select_dropdown2_sfc_main, [["render", select_dropdown2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);


;// CONCATENATED MODULE: ./node_modules/lodash-es/_stackClear.js

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new _ListCache();
  this.size = 0;
}

/* harmony default export */ var _stackClear = (stackClear);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_stackDelete.js
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/* harmony default export */ var _stackDelete = (stackDelete);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_stackGet.js
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ var _stackGet = (stackGet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_stackHas.js
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ var _stackHas = (stackHas);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_stackSet.js



/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof _ListCache) {
    var pairs = data.__data__;

    if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new _MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ var _stackSet = (stackSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Stack.js






/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;
/* harmony default export */ var _Stack = (Stack);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheAdd.js
/** Used to stand-in for `undefined` hash values. */
var _setCacheAdd_HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, _setCacheAdd_HASH_UNDEFINED);

  return this;
}

/* harmony default export */ var _setCacheAdd = (setCacheAdd);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheHas.js
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ var _setCacheHas = (setCacheHas);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_SetCache.js



/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new _MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;
/* harmony default export */ var _SetCache = (SetCache);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_arraySome.js
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/* harmony default export */ var _arraySome = (arraySome);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cacheHas.js
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ var _cacheHas = (cacheHas);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_equalArrays.js



/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!_arraySome(other, function (othValue, othIndex) {
        if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ var _equalArrays = (equalArrays);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Uint8Array.js

/** Built-in value references. */

var _Uint8Array_Uint8Array = _root.Uint8Array;
/* harmony default export */ var _Uint8Array = (_Uint8Array_Uint8Array);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_mapToArray.js
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ var _mapToArray = (mapToArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_setToArray.js
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ var _setToArray = (setToArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_equalByTag.js






/** Used to compose bitmasks for value comparisons. */

var _equalByTag_COMPARE_PARTIAL_FLAG = 1,
    _equalByTag_COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    _equalByTag_symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var _equalByTag_symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = _equalByTag_symbolProto ? _equalByTag_symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return lodash_es_eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = _mapToArray;

    case setTag:
      var isPartial = bitmask & _equalByTag_COMPARE_PARTIAL_FLAG;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= _equalByTag_COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case _equalByTag_symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/* harmony default export */ var _equalByTag = (equalByTag);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayPush.js
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/* harmony default export */ var _arrayPush = (arrayPush);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetAllKeys.js


/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return lodash_es_isArray(object) ? result : _arrayPush(result, symbolsFunc(object));
}

/* harmony default export */ var _baseGetAllKeys = (baseGetAllKeys);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayFilter.js
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/* harmony default export */ var _arrayFilter = (arrayFilter);
;// CONCATENATED MODULE: ./node_modules/lodash-es/stubArray.js
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ var lodash_es_stubArray = (stubArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbols.js


/** Used for built-in method references. */

var _getSymbols_objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = _getSymbols_objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? lodash_es_stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
/* harmony default export */ var _getSymbols = (getSymbols);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTimes.js
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/* harmony default export */ var _baseTimes = (baseTimes);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsArguments.js


/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
}

/* harmony default export */ var _baseIsArguments = (baseIsArguments);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isArguments.js


/** Used for built-in method references. */

var isArguments_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;
/** Built-in value references. */

var isArguments_propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = _baseIsArguments(function () {
  return arguments;
}()) ? _baseIsArguments : function (value) {
  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') && !isArguments_propertyIsEnumerable.call(value, 'callee');
};
/* harmony default export */ var lodash_es_isArguments = (isArguments);
;// CONCATENATED MODULE: ./node_modules/lodash-es/stubFalse.js
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ var lodash_es_stubFalse = (stubFalse);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isBuffer.js


/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? _root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || lodash_es_stubFalse;
/* harmony default export */ var lodash_es_isBuffer = (isBuffer);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var isLength_MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= isLength_MAX_SAFE_INTEGER;
}

/* harmony default export */ var lodash_es_isLength = (isLength);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsTypedArray.js



/** `Object#toString` result references. */

var _baseIsTypedArray_argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    _baseIsTypedArray_boolTag = '[object Boolean]',
    _baseIsTypedArray_dateTag = '[object Date]',
    _baseIsTypedArray_errorTag = '[object Error]',
    _baseIsTypedArray_funcTag = '[object Function]',
    _baseIsTypedArray_mapTag = '[object Map]',
    _baseIsTypedArray_numberTag = '[object Number]',
    objectTag = '[object Object]',
    _baseIsTypedArray_regexpTag = '[object RegExp]',
    _baseIsTypedArray_setTag = '[object Set]',
    _baseIsTypedArray_stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var _baseIsTypedArray_arrayBufferTag = '[object ArrayBuffer]',
    _baseIsTypedArray_dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] = typedArrayTags[_baseIsTypedArray_arrayBufferTag] = typedArrayTags[_baseIsTypedArray_boolTag] = typedArrayTags[_baseIsTypedArray_dataViewTag] = typedArrayTags[_baseIsTypedArray_dateTag] = typedArrayTags[_baseIsTypedArray_errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] = typedArrayTags[_baseIsTypedArray_mapTag] = typedArrayTags[_baseIsTypedArray_numberTag] = typedArrayTags[objectTag] = typedArrayTags[_baseIsTypedArray_regexpTag] = typedArrayTags[_baseIsTypedArray_setTag] = typedArrayTags[_baseIsTypedArray_stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return lodash_es_isObjectLike(value) && lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

/* harmony default export */ var _baseIsTypedArray = (baseIsTypedArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUnary.js
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/* harmony default export */ var _baseUnary = (baseUnary);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_nodeUtil.js

/** Detect free variable `exports`. */

var _nodeUtil_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var _nodeUtil_freeModule = _nodeUtil_freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var _nodeUtil_moduleExports = _nodeUtil_freeModule && _nodeUtil_freeModule.exports === _nodeUtil_freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = _nodeUtil_moduleExports && _freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = _nodeUtil_freeModule && _nodeUtil_freeModule.require && _nodeUtil_freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* harmony default export */ var _nodeUtil = (nodeUtil);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isTypedArray.js



/* Node.js helper references. */

var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
/* harmony default export */ var lodash_es_isTypedArray = (isTypedArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayLikeKeys.js






/** Used for built-in method references. */

var _arrayLikeKeys_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = lodash_es_isArray(value),
      isArg = !isArr && lodash_es_isArguments(value),
      isBuff = !isArr && !isArg && lodash_es_isBuffer(value),
      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    _isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _arrayLikeKeys = (arrayLikeKeys);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var _isPrototype_objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || _isPrototype_objectProto;
  return value === proto;
}

/* harmony default export */ var _isPrototype = (isPrototype);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_overArg.js
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ var _overArg = (overArg);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeys.js

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = _overArg(Object.keys, Object);
/* harmony default export */ var _nativeKeys = (nativeKeys);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeys.js


/** Used for built-in method references. */

var _baseKeys_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _baseKeys_hasOwnProperty = _baseKeys_objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (_baseKeys_hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _baseKeys = (baseKeys);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLike.js


/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
}

/* harmony default export */ var lodash_es_isArrayLike = (isArrayLike);
;// CONCATENATED MODULE: ./node_modules/lodash-es/keys.js



/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys_keys(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

/* harmony default export */ var lodash_es_keys = (keys_keys);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeys.js



/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return _baseGetAllKeys(object, lodash_es_keys, _getSymbols);
}

/* harmony default export */ var _getAllKeys = (getAllKeys);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_equalObjects.js

/** Used to compose bitmasks for value comparisons. */

var _equalObjects_COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var _equalObjects_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _equalObjects_hasOwnProperty = _equalObjects_objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & _equalObjects_COMPARE_PARTIAL_FLAG,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : _equalObjects_hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ var _equalObjects = (equalObjects);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_DataView.js


/* Built-in method references that are verified to be native. */

var DataView = _getNative(_root, 'DataView');
/* harmony default export */ var _DataView = (DataView);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Promise.js


/* Built-in method references that are verified to be native. */

var _Promise_Promise = _getNative(_root, 'Promise');
/* harmony default export */ var _Promise = (_Promise_Promise);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_Set.js


/* Built-in method references that are verified to be native. */

var _Set_Set = _getNative(_root, 'Set');
/* harmony default export */ var _Set = (_Set_Set);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_WeakMap.js


/* Built-in method references that are verified to be native. */

var WeakMap = _getNative(_root, 'WeakMap');
/* harmony default export */ var _WeakMap = (WeakMap);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getTag.js







/** `Object#toString` result references. */

var _getTag_mapTag = '[object Map]',
    _getTag_objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    _getTag_setTag = '[object Set]',
    _getTag_weakMapTag = '[object WeakMap]';
var _getTag_dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != _getTag_dataViewTag || _Map && getTag(new _Map()) != _getTag_mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != _getTag_setTag || _WeakMap && getTag(new _WeakMap()) != _getTag_weakMapTag) {
  getTag = function (value) {
    var result = _baseGetTag(value),
        Ctor = result == _getTag_objectTag ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return _getTag_dataViewTag;

        case mapCtorString:
          return _getTag_mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return _getTag_setTag;

        case weakMapCtorString:
          return _getTag_weakMapTag;
      }
    }

    return result;
  };
}

/* harmony default export */ var _getTag = (getTag);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqualDeep.js








/** Used to compose bitmasks for value comparisons. */

var _baseIsEqualDeep_COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var _baseIsEqualDeep_argsTag = '[object Arguments]',
    _baseIsEqualDeep_arrayTag = '[object Array]',
    _baseIsEqualDeep_objectTag = '[object Object]';
/** Used for built-in method references. */

var _baseIsEqualDeep_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _baseIsEqualDeep_hasOwnProperty = _baseIsEqualDeep_objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = lodash_es_isArray(object),
      othIsArr = lodash_es_isArray(other),
      objTag = objIsArr ? _baseIsEqualDeep_arrayTag : _getTag(object),
      othTag = othIsArr ? _baseIsEqualDeep_arrayTag : _getTag(other);
  objTag = objTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : objTag;
  othTag = othTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : othTag;
  var objIsObj = objTag == _baseIsEqualDeep_objectTag,
      othIsObj = othTag == _baseIsEqualDeep_objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && lodash_es_isBuffer(object)) {
    if (!lodash_es_isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack());
    return objIsArr || lodash_es_isTypedArray(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & _baseIsEqualDeep_COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && _baseIsEqualDeep_hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && _baseIsEqualDeep_hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new _Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new _Stack());
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ var _baseIsEqualDeep = (baseIsEqualDeep);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqual.js


/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !lodash_es_isObjectLike(value) && !lodash_es_isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ var _baseIsEqual = (baseIsEqual);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isEqual.js

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */

function isEqual(value, other) {
  return _baseIsEqual(value, other);
}

/* harmony default export */ var lodash_es_isEqual = (isEqual);
;// CONCATENATED MODULE: ./node_modules/lodash-es/now.js

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now_now = function () {
  return _root.Date.now();
};

/* harmony default export */ var lodash_es_now = (now_now);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_trimmedEndIndex.js
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

/* harmony default export */ var _trimmedEndIndex = (trimmedEndIndex);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTrim.js

/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

/* harmony default export */ var _baseTrim = (baseTrim);
;// CONCATENATED MODULE: ./node_modules/lodash-es/toNumber.js



/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber_toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (lodash_es_isSymbol(value)) {
    return NAN;
  }

  if (lodash_es_isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = lodash_es_isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

/* harmony default export */ var lodash_es_toNumber = (toNumber_toNumber);
;// CONCATENATED MODULE: ./node_modules/lodash-es/debounce.js




/** Error message constants. */

var debounce_FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */

function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(debounce_FUNC_ERROR_TEXT);
  }

  wait = lodash_es_toNumber(wait) || 0;

  if (lodash_es_isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(lodash_es_toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = lodash_es_now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(lodash_es_now());
  }

  function debounced() {
    var time = lodash_es_now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ var lodash_es_debounce = (debounce);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/locale/lang/en2.mjs
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-locale/index2.mjs





const buildTranslator = locale => (path, option) => translate(path, option, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(locale));

const translate = (path, option, locale) => lodash_es_get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
  var _a;

  return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
});

const buildLocaleContext = locale => {
  const lang = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(locale).name);
  const localeRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isRef)(locale) ? locale : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale)
  };
};

const useLocale = () => {
  const locale = useGlobalConfig("locale");
  return buildLocaleContext((0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => locale.value || English));
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/vue/size2.mjs



const getComponentSize = size => {
  return componentSizeMap[size || "default"];
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/dom/scroll2.mjs



const isScroll = (el, isVertical) => {
  if (!isClient) return false;
  const key = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(isVertical)];
  const overflow = getStyle(el, key);
  return ["scroll", "auto", "overlay"].some(s => overflow.includes(s));
};

const getScrollContainer = (el, isVertical) => {
  if (!isClient) return;
  let parent = el;

  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) return window;
    if (isScroll(parent, isVertical)) return parent;
    parent = parent.parentNode;
  }

  return parent;
};

let scrollBarWidth;

const getScrollBarWidth = () => {
  var _a;

  if (!shared_isClient) return 0;
  if (scrollBarWidth !== void 0) return scrollBarWidth;
  const outer = document.createElement("div");
  outer.className = "el-scrollbar__wrap";
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style.position = "absolute";
  outer.style.top = "-9999px";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner = document.createElement("div");
  inner.style.width = "100%";
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
};

function scrollIntoView(container, selected) {
  if (!shared_isClient) return;

  if (!selected) {
    container.scrollTop = 0;
    return;
  }

  const offsetParents = [];
  let pointer = selected.offsetParent;

  while (pointer !== null && container !== pointer && container.contains(pointer)) {
    offsetParents.push(pointer);
    pointer = pointer.offsetParent;
  }

  const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
  const bottom = top + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;

  if (top < viewRectTop) {
    container.scrollTop = top;
  } else if (bottom > viewRectBottom) {
    container.scrollTop = bottom - container.clientHeight;
  }
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/useSelect2.mjs



















function useSelectStates(props) {
  const {
    t
  } = useLocale();
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
    options: /* @__PURE__ */new Map(),
    cachedOptions: /* @__PURE__ */new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    initialInputHeight: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    prefixWidth: 11,
    tagInMultiLine: false
  });
}

const useSelect = (props, states, ctx) => {
  const {
    t
  } = useLocale();
  const ns = useNamespace("select");
  const reference = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const tooltipRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const tags = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const selectWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const scrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const hoverOption = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(-1);
  const queryChange = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.shallowRef)({
    query: ""
  });
  const groupQueryChange = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.shallowRef)("");
  const elForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, {});
  const elFormItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, {});
  const readonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !props.filterable || props.multiple || !states.visible);
  const selectDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.disabled || elForm.disabled);
  const showClose = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
    const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
    return criteria;
  });
  const iconComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.remote && props.filterable ? "" : props.suffixIcon);
  const iconReverse = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ns.is("reverse", iconComponent.value && states.visible));
  const debounce$1 = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.remote ? 300 : 0);
  const emptyText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (props.loading) {
      return props.loadingText || t("el.select.loading");
    } else {
      if (props.remote && states.query === "" && states.options.size === 0) return false;

      if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props.noMatchText || t("el.select.noMatch");
      }

      if (states.options.size === 0) {
        return props.noDataText || t("el.select.noData");
      }
    }

    return null;
  });
  const optionsArray = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => Array.from(states.options.values()));
  const cachedOptionsArray = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => Array.from(states.cachedOptions.values()));
  const showNewOption = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const hasExistingOption = optionsArray.value.filter(option => {
      return !option.created;
    }).some(option => {
      return option.currentLabel === states.query;
    });
    return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
  });
  const selectSize = useSize();
  const collapseTagSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ["small"].includes(selectSize.value) ? "small" : "default");
  const dropMenuVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get() {
      return states.visible && emptyText.value !== false;
    },

    set(val) {
      states.visible = val;
    }

  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)([() => selectDisabled.value, () => selectSize.value, () => elForm.size], () => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      resetInputHeight();
    });
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.placeholder, val => {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, (val, oldVal) => {
    var _a;

    if (props.multiple) {
      resetInputHeight();

      if (val && val.length > 0 || input.value && states.query !== "") {
        states.currentPlaceholder = "";
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }

      if (props.filterable && !props.reserveKeyword) {
        states.query = "";
        handleQueryChange(states.query);
      }
    }

    setSelected();

    if (props.filterable && !props.multiple) {
      states.inputLength = 20;
    }

    if (!lodash_es_isEqual(val, oldVal)) {
      (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch(err => error2_debugWarn(err));
    }
  }, {
    flush: "post",
    deep: true
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => states.visible, val => {
    var _a, _b, _c;

    if (!val) {
      input.value && input.value.blur();
      states.query = "";
      states.previousQuery = null;
      states.selectedLabel = "";
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (input.value && input.value.value === "" && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });

      if (!props.multiple) {
        if (states.selected) {
          if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }

          if (props.filterable) states.query = states.selectedLabel;
        }

        if (props.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);

      if (props.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props.remote ? "" : states.selectedLabel;

        if (props.multiple) {
          (_c = input.value) == null ? void 0 : _c.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = `${states.selectedLabel}`;
            states.selectedLabel = "";
          }
        }

        handleQueryChange(states.query);

        if (!props.multiple && !props.remote) {
          queryChange.value.query = "";
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.triggerRef)(queryChange);
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.triggerRef)(groupQueryChange);
        }
      }
    }

    ctx.emit("visible-change", val);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => states.options.entries(), () => {
    var _a, _b, _c;

    if (!shared_isClient) return;
    (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);

    if (props.multiple) {
      resetInputHeight();
    }

    const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];

    if (!Array.from(inputs).includes(document.activeElement)) {
      setSelected();
    }

    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: "post"
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => states.hoverIndex, val => {
    if (typeof val === "number" && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    }

    optionsArray.value.forEach(option => {
      option.hover = hoverOption.value === option;
    });
  });

  const resetInputHeight = () => {
    if (props.collapseTags && !props.filterable) return;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      var _a, _b;

      if (!reference.value) return;
      const input2 = reference.value.$el.querySelector("input");
      const _tags = tags.value;
      const sizeInMap = states.initialInputHeight || getComponentSize(selectSize.value || elForm.size);
      input2.style.height = states.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
      states.tagInMultiLine = Number.parseFloat(input2.style.height) >= sizeInMap;

      if (states.visible && emptyText.value !== false) {
        (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
      }
    });
  };

  const handleQueryChange = val => {
    if (states.previousQuery === val || states.isOnComposition) return;

    if (states.previousQuery === null && (typeof props.filterMethod === "function" || typeof props.remoteMethod === "function")) {
      states.previousQuery = val;
      return;
    }

    states.previousQuery = val;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      var _a, _b;

      if (states.visible) (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
    });
    states.hoverIndex = -1;

    if (props.multiple && props.filterable) {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const length = input.value.value.length * 15 + 20;
        states.inputLength = props.collapseTags ? Math.min(50, length) : length;
        managePlaceholder();
        resetInputHeight();
      });
    }

    if (props.remote && typeof props.remoteMethod === "function") {
      states.hoverIndex = -1;
      props.remoteMethod(val);
    } else if (typeof props.filterMethod === "function") {
      props.filterMethod(val);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.triggerRef)(groupQueryChange);
    } else {
      states.filteredOptionsCount = states.optionsCount;
      queryChange.value.query = val;
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.triggerRef)(queryChange);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.triggerRef)(groupQueryChange);
    }

    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  };

  const managePlaceholder = () => {
    if (states.currentPlaceholder !== "") {
      states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
    }
  };

  const checkDefaultFirstOption = () => {
    const optionsInDropdown = optionsArray.value.filter(n => n.visible && !n.disabled && !n.states.groupDisabled);
    const userCreatedOption = optionsInDropdown.find(n => n.created);
    const firstOriginOption = optionsInDropdown[0];
    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
  };

  const setSelected = () => {
    var _a;

    if (!props.multiple) {
      const option = getOption(props.modelValue);

      if ((_a = option.props) == null ? void 0 : _a.created) {
        states.createdLabel = option.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }

      states.selectedLabel = option.currentLabel;
      states.selected = option;
      if (props.filterable) states.query = states.selectedLabel;
      return;
    } else {
      states.selectedLabel = "";
    }

    const result = [];

    if (Array.isArray(props.modelValue)) {
      props.modelValue.forEach(value => {
        result.push(getOption(value));
      });
    }

    states.selected = result;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      resetInputHeight();
    });
  };

  const getOption = value => {
    let option;
    const isObjectValue = toRawType(value).toLowerCase() === "object";
    const isNull = toRawType(value).toLowerCase() === "null";
    const isUndefined = toRawType(value).toLowerCase() === "undefined";

    for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
      const cachedOption = cachedOptionsArray.value[i];
      const isEqualValue = isObjectValue ? lodash_es_get(cachedOption.value, props.valueKey) === lodash_es_get(value, props.valueKey) : cachedOption.value === value;

      if (isEqualValue) {
        option = {
          value,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }

    if (option) return option;
    const label = isObjectValue ? value.label : !isNull && !isUndefined ? value : "";
    const newOption = {
      value,
      currentLabel: label
    };

    if (props.multiple) {
      ;
      newOption.hitState = false;
    }

    return newOption;
  };

  const resetHoverIndex = () => {
    setTimeout(() => {
      const valueKey = props.valueKey;

      if (!props.multiple) {
        states.hoverIndex = optionsArray.value.findIndex(item => {
          return getValueKey(item) === getValueKey(states.selected);
        });
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map(selected => {
            return optionsArray.value.findIndex(item => {
              return lodash_es_get(item, valueKey) === lodash_es_get(selected, valueKey);
            });
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };

  const handleResize = () => {
    var _a, _b;

    resetInputWidth();
    (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
    if (props.multiple && !props.filterable) resetInputHeight();
  };

  const resetInputWidth = () => {
    var _a;

    states.inputWidth = (_a = reference.value) == null ? void 0 : _a.$el.getBoundingClientRect().width;
  };

  const onInputChange = () => {
    if (props.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };

  const debouncedOnInputChange = lodash_es_debounce(() => {
    onInputChange();
  }, debounce$1.value);
  const debouncedQueryChange = lodash_es_debounce(e => {
    handleQueryChange(e.target.value);
  }, debounce$1.value);

  const emitChange = val => {
    if (!lodash_es_isEqual(props.modelValue, val)) {
      ctx.emit(CHANGE_EVENT, val);
    }
  };

  const deletePrevTag = e => {
    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
      const value = props.modelValue.slice();
      value.pop();
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
    }

    if (e.target.value.length === 1 && props.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };

  const deleteTag = (event, tag) => {
    const index = states.selected.indexOf(tag);

    if (index > -1 && !selectDisabled.value) {
      const value = props.modelValue.slice();
      value.splice(index, 1);
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      ctx.emit("remove-tag", tag.value);
    }

    event.stopPropagation();
  };

  const deleteSelected = event => {
    event.stopPropagation();
    const value = props.multiple ? [] : "";

    if (typeof value !== "string") {
      for (const item of states.selected) {
        if (item.isDisabled) value.push(item.value);
      }
    }

    ctx.emit(UPDATE_MODEL_EVENT, value);
    emitChange(value);
    states.visible = false;
    ctx.emit("clear");
  };

  const handleOptionSelect = (option, byClick) => {
    var _a;

    if (props.multiple) {
      const value = (props.modelValue || []).slice();
      const optionIndex = getValueIndex(value, option.value);

      if (optionIndex > -1) {
        value.splice(optionIndex, 1);
      } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
        value.push(option.value);
      }

      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);

      if (option.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }

      if (props.filterable) (_a = input.value) == null ? void 0 : _a.focus();
    } else {
      ctx.emit(UPDATE_MODEL_EVENT, option.value);
      emitChange(option.value);
      states.visible = false;
    }

    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible) return;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      scrollToOption(option);
    });
  };

  const getValueIndex = (arr = [], value) => {
    if (!shared_esm_bundler_isObject(value)) return arr.indexOf(value);
    const valueKey = props.valueKey;
    let index = -1;
    arr.some((item, i) => {
      if (lodash_es_get(item, valueKey) === lodash_es_get(value, valueKey)) {
        index = i;
        return true;
      }

      return false;
    });
    return index;
  };

  const setSoftFocus = () => {
    states.softFocus = true;

    const _input = input.value || reference.value;

    if (_input) {
      _input == null ? void 0 : _input.focus();
    }
  };

  const scrollToOption = option => {
    var _a, _b, _c, _d, _e;

    const targetOption = Array.isArray(option) ? option[0] : option;
    let target = null;

    if (targetOption == null ? void 0 : targetOption.value) {
      const options = optionsArray.value.filter(item => item.value === targetOption.value);

      if (options.length > 0) {
        target = options[0].$el;
      }
    }

    if (tooltipRef.value && target) {
      const menu = (_d = (_c = (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns.be("dropdown", "wrap")}`);

      if (menu) {
        scrollIntoView(menu, target);
      }
    }

    (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
  };

  const onOptionCreate = vm => {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };

  const onOptionDestroy = (key, vm) => {
    if (states.options.get(key) === vm) {
      states.optionsCount--;
      states.filteredOptionsCount--;
      states.options.delete(key);
    }
  };

  const resetInputState = e => {
    if (e.code !== EVENT_CODE.backspace) toggleLastOptionHitState(false);
    states.inputLength = input.value.value.length * 15 + 20;
    resetInputHeight();
  };

  const toggleLastOptionHitState = hit => {
    if (!Array.isArray(states.selected)) return;
    const option = states.selected[states.selected.length - 1];
    if (!option) return;

    if (hit === true || hit === false) {
      option.hitState = hit;
      return hit;
    }

    option.hitState = !option.hitState;
    return option.hitState;
  };

  const handleComposition = event => {
    const text = event.target.value;

    if (event.type === "compositionend") {
      states.isOnComposition = false;
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => handleQueryChange(text));
    } else {
      const lastCharacter = text[text.length - 1] || "";
      states.isOnComposition = !isKorean(lastCharacter);
    }
  };

  const handleMenuEnter = () => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => scrollToOption(states.selected));
  };

  const handleFocus = event => {
    if (!states.softFocus) {
      if (props.automaticDropdown || props.filterable) {
        if (props.filterable && !states.visible) {
          states.menuVisibleOnFocus = true;
        }

        states.visible = true;
      }

      ctx.emit("focus", event);
    } else {
      states.softFocus = false;
    }
  };

  const blur = () => {
    var _a;

    states.visible = false;
    (_a = reference.value) == null ? void 0 : _a.blur();
  };

  const handleBlur = event => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx.emit("blur", event);
      }
    });
    states.softFocus = false;
  };

  const handleClearClick = event => {
    deleteSelected(event);
  };

  const handleClose = () => {
    states.visible = false;
  };

  const toggleMenu = () => {
    var _a;

    if (props.automaticDropdown) return;

    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        states.visible = !states.visible;
      }

      if (states.visible) {
        ;
        (_a = input.value || reference.value) == null ? void 0 : _a.focus();
      }
    }
  };

  const selectOption = () => {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
      }
    }
  };

  const getValueKey = item => {
    return shared_esm_bundler_isObject(item.value) ? lodash_es_get(item.value, props.valueKey) : item.value;
  };

  const optionsAllDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => optionsArray.value.filter(option => option.visible).every(option => option.disabled));

  const navigateOptions = direction => {
    if (!states.visible) {
      states.visible = true;
      return;
    }

    if (states.options.size === 0 || states.filteredOptionsCount === 0) return;
    if (states.isOnComposition) return;

    if (!optionsAllDisabled.value) {
      if (direction === "next") {
        states.hoverIndex++;

        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction === "prev") {
        states.hoverIndex--;

        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }

      const option = optionsArray.value[states.hoverIndex];

      if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
        navigateOptions(direction);
      }

      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => scrollToOption(hoverOption.value));
    }
  };

  return {
    optionsArray,
    selectSize,
    handleResize,
    debouncedOnInputChange,
    debouncedQueryChange,
    deletePrevTag,
    deleteTag,
    deleteSelected,
    handleOptionSelect,
    scrollToOption,
    readonly,
    resetInputHeight,
    showClose,
    iconComponent,
    iconReverse,
    showNewOption,
    collapseTagSize,
    setSelected,
    managePlaceholder,
    selectDisabled,
    emptyText,
    toggleLastOptionHitState,
    resetInputState,
    handleComposition,
    onOptionCreate,
    onOptionDestroy,
    handleMenuEnter,
    handleFocus,
    blur,
    handleBlur,
    handleClearClick,
    handleClose,
    toggleMenu,
    selectOption,
    getValueKey,
    navigateOptions,
    dropMenuVisible,
    queryChange,
    groupQueryChange,
    reference,
    input,
    tooltipRef,
    tags,
    selectWrapper,
    scrollbar
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/directives/click-outside/index2.mjs



const nodeList = /* @__PURE__ */new Map();
let startClick;

if (shared_isClient) {
  document.addEventListener("mousedown", e => startClick = e);
  document.addEventListener("mouseup", e => {
    for (const handlers of nodeList.values()) {
      for (const {
        documentHandler
      } of handlers) {
        documentHandler(e, startClick);
      }
    }
  });
}

function createDocumentHandler(el, binding) {
  let excludes = [];

  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (isElement(binding.arg)) {
    excludes.push(binding.arg);
  }

  return function (mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some(item => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));

    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }

    binding.value(mouseup, mousedown);
  };
}

const ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }

    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },

  updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }

    const handlers = nodeList.get(el);
    const oldHandlerIndex = handlers.findIndex(item => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };

    if (oldHandlerIndex >= 0) {
      handlers.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers.push(newHandler);
    }
  },

  unmounted(el) {
    nodeList.delete(el);
  }

};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/constants/date2.mjs
const datePickTypes = ["year", "month", "date", "dates", "week", "datetime", "datetimerange", "daterange", "monthrange"];
const WEEK_DAYS = (/* unused pure expression or super */ null && (["sun", "mon", "tue", "wed", "thu", "fri", "sat"]));

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/vue/validator2.mjs




const isValidComponentSize = val => ["", ...componentSizes].includes(val);

const isValidDatePickType = val => [...datePickTypes].includes(val);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-focus/index2.mjs
const index2_useFocus = el => {
  return {
    focus: () => {
      var _a, _b;

      (_b = (_a = el.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    }
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/select2.mjs

























const select2_COMPONENT_NAME = "ElSelect";

const select2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: select2_COMPONENT_NAME,
  componentName: select2_COMPONENT_NAME,
  components: {
    ElInput: ElInput,
    ElSelectMenu: ElSelectMenu,
    ElOption: Option,
    ElTag: ElTag,
    ElScrollbar: ElScrollbar,
    ElTooltip: ElTooltip,
    ElIcon: ElIcon
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: true
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: {
      type: Boolean,
      default: false
    },
    teleported: useTooltipContentProps.teleported,
    persistent: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: [String, Object],
      default: circleClose
    },
    fitInputWidth: {
      type: Boolean,
      default: false
    },
    suffixIcon: {
      type: [String, Object],
      default: arrowUp
    },
    tagType: { ...tagProps.type,
      default: "info"
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "remove-tag", "clear", "visible-change", "focus", "blur"],

  setup(props, ctx) {
    const nsSelect = useNamespace("select");
    const nsInput = useNamespace("input");
    const {
      t
    } = useLocale();
    const states = useSelectStates(props);
    const {
      optionsArray,
      selectSize,
      readonly,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      setSelected,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconComponent,
      iconReverse,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      reference,
      input,
      tooltipRef,
      tags,
      selectWrapper,
      scrollbar,
      queryChange,
      groupQueryChange
    } = useSelect(props, states, ctx);
    const {
      focus
    } = index2_useFocus(reference);
    const {
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options,
      cachedOptions,
      optionsCount,
      prefixWidth,
      tagInMultiLine
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(states);
    const wrapperKls = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const classList = [nsSelect.b()];

      const _selectSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(selectSize);

      if (_selectSize) {
        classList.push(nsSelect.m(_selectSize));
      }

      if (props.disabled) {
        classList.push(nsSelect.m("disabled"));
      }

      return classList;
    });
    const selectTagsStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ({
      maxWidth: `${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputWidth) - 32}px`,
      width: "100%"
    }));
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(selectKey, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      props,
      options,
      optionsArray,
      cachedOptions,
      optionsCount,
      filteredOptionsCount,
      hoverIndex,
      handleOptionSelect,
      onOptionCreate,
      onOptionDestroy,
      selectWrapper,
      selected,
      setSelected,
      queryChange,
      groupQueryChange
    }));
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || t("el.select.placeholder");

      if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
        currentPlaceholder.value = "";
      }

      addResizeListener(selectWrapper.value, handleResize);

      if (reference.value && reference.value.$el) {
        const input2 = reference.value.input;
        states.initialInputHeight = input2.getBoundingClientRect().height;
      }

      if (props.remote && props.multiple) {
        resetInputHeight();
      }

      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const refEl = reference.value && reference.value.$el;
        if (!refEl) return;
        inputWidth.value = refEl.getBoundingClientRect().width;

        if (ctx.slots.prefix) {
          const prefix = refEl.querySelector(`.${nsInput.e("prefix")}`);
          prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
        }
      });
      setSelected();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      removeResizeListener(selectWrapper.value, handleResize);
    });

    if (props.multiple && !Array.isArray(props.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, []);
    }

    if (!props.multiple && Array.isArray(props.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, "");
    }

    const popperPaneRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b;

      return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
    });
    return {
      tagInMultiLine,
      prefixWidth,
      selectSize,
      readonly,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconComponent,
      iconReverse,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      focus,
      reference,
      input,
      tooltipRef,
      popperPaneRef,
      tags,
      selectWrapper,
      scrollbar,
      wrapperKls,
      selectTagsStyle,
      nsSelect
    };
  }

});

const select2_hoisted_1 = {
  class: "select-trigger"
};
const select2_hoisted_2 = ["disabled", "autocomplete"];
const select2_hoisted_3 = {
  style: {
    "height": "100%",
    "display": "flex",
    "justify-content": "center",
    "align-items": "center"
  }
};

function select2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tag");

  const _component_el_tooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tooltip");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_el_input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-input");

  const _component_el_option = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-option");

  const _component_el_scrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-scrollbar");

  const _component_el_select_menu = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-select-menu");

  const _directive_click_outside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDirective)("click-outside");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    ref: "selectWrapper",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.wrapperKls),
    onClick: _cache[24] || (_cache[24] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_tooltip, {
    ref: "tooltipRef",
    visible: _ctx.dropMenuVisible,
    "onUpdate:visible": _cache[23] || (_cache[23] = $event => _ctx.dropMenuVisible = $event),
    placement: "bottom-start",
    teleported: _ctx.teleported,
    "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
    "fallback-placements": ["bottom-start", "top-start", "right", "left"],
    effect: _ctx.effect,
    pure: "",
    trigger: "click",
    transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false,
    persistent: _ctx.persistent,
    onShow: _ctx.handleMenuEnter
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", select2_hoisted_1, [_ctx.multiple ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 0,
      ref: "tags",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("tags")),
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.selectTagsStyle)
    }, [_ctx.collapseTags && _ctx.selected.length ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
      key: 0,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.b("tags-wrapper"), {
        "has-prefix": _ctx.prefixWidth && _ctx.selected.length
      }])
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_tag, {
      closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
      size: _ctx.collapseTagSize,
      hit: _ctx.selected[0].hitState,
      type: _ctx.tagType,
      "disable-transitions": "",
      onClose: _cache[0] || (_cache[0] = $event => _ctx.deleteTag($event, _ctx.selected[0]))
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("tags-text")),
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
          maxWidth: _ctx.inputWidth - 123 + "px"
        })
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.selected[0].currentLabel), 7)]),
      _: 1
    }, 8, ["closable", "size", "hit", "type"]), _ctx.selected.length > 1 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tag, {
      key: 0,
      closable: false,
      size: _ctx.collapseTagSize,
      type: _ctx.tagType,
      "disable-transitions": ""
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.collapseTagsTooltip ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tooltip, {
        key: 0,
        disabled: _ctx.dropMenuVisible,
        "fallback-placements": ["bottom", "top", "right", "left"],
        effect: _ctx.effect,
        placement: "bottom",
        teleported: false
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("tags-text"))
        }, "+ " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.selected.length - 1), 3)]),
        content: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("collapse-tags"))
        }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.selected, (item, idx) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
            key: idx,
            class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("collapse-tag"))
          }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tag, {
            key: _ctx.getValueKey(item),
            class: "in-tooltip",
            closable: !_ctx.selectDisabled && !item.isDisabled,
            size: _ctx.collapseTagSize,
            hit: item.hitState,
            type: _ctx.tagType,
            "disable-transitions": "",
            style: {
              margin: "2px"
            },
            onClose: $event => _ctx.deleteTag($event, item)
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
              class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("tags-text")),
              style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
                maxWidth: _ctx.inputWidth - 75 + "px"
              })
            }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.currentLabel), 7)]),
            _: 2
          }, 1032, ["closable", "size", "hit", "type", "onClose"]))], 2);
        }), 128))], 2)]),
        _: 1
      }, 8, ["disabled", "effect"])) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("tags-text"))
      }, "+ " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.selected.length - 1), 3))]),
      _: 1
    }, 8, ["size", "type"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" <div> "), !_ctx.collapseTags ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
      key: 1,
      onAfterLeave: _ctx.resetInputHeight
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.b("tags-wrapper"), {
          "has-prefix": _ctx.prefixWidth && _ctx.selected.length
        }])
      }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.selected, item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tag, {
          key: _ctx.getValueKey(item),
          closable: !_ctx.selectDisabled && !item.isDisabled,
          size: _ctx.collapseTagSize,
          hit: item.hitState,
          type: _ctx.tagType,
          "disable-transitions": "",
          onClose: $event => _ctx.deleteTag($event, item)
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.e("tags-text")),
            style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
              maxWidth: _ctx.inputWidth - 75 + "px"
            })
          }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.currentLabel), 7)]),
          _: 2
        }, 1032, ["closable", "size", "hit", "type", "onClose"]);
      }), 128))], 2)]),
      _: 1
    }, 8, ["onAfterLeave"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" </div> "), _ctx.filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("input", {
      key: 2,
      ref: "input",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.query = $event),
      type: "text",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
      disabled: _ctx.selectDisabled,
      autocomplete: _ctx.autocomplete,
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
        marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : "",
        flexGrow: 1,
        width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
        maxWidth: `${_ctx.inputWidth - 42}px`
      }),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
      onKeydown: [_cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)), _cache[6] || (_cache[6] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)($event => _ctx.navigateOptions("next"), ["prevent"]), ["down"])), _cache[7] || (_cache[7] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)($event => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])), _cache[8] || (_cache[8] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)($event => _ctx.visible = false, ["stop", "prevent"]), ["esc"])), _cache[9] || (_cache[9] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])), _cache[10] || (_cache[10] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])), _cache[11] || (_cache[11] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)($event => _ctx.visible = false, ["tab"]))],
      onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
      onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
      onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
      onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
    }, null, 46, select2_hoisted_2)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vModelText, _ctx.query]]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 6)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
      id: _ctx.id,
      ref: "reference",
      modelValue: _ctx.selectedLabel,
      "onUpdate:modelValue": _cache[16] || (_cache[16] = $event => _ctx.selectedLabel = $event),
      type: "text",
      placeholder: _ctx.currentPlaceholder,
      name: _ctx.name,
      autocomplete: _ctx.autocomplete,
      size: _ctx.selectSize,
      disabled: _ctx.selectDisabled,
      readonly: _ctx.readonly,
      "validate-event": false,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.is("focus", _ctx.visible)]),
      tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
      onFocus: _ctx.handleFocus,
      onBlur: _ctx.handleBlur,
      onInput: _ctx.debouncedOnInputChange,
      onPaste: _ctx.debouncedOnInputChange,
      onCompositionstart: _ctx.handleComposition,
      onCompositionupdate: _ctx.handleComposition,
      onCompositionend: _ctx.handleComposition,
      onKeydown: [_cache[17] || (_cache[17] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)($event => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])), _cache[18] || (_cache[18] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)($event => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)(_ctx.selectOption, ["stop", "prevent"]), ["enter"]), _cache[19] || (_cache[19] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)($event => _ctx.visible = false, ["stop", "prevent"]), ["esc"])), _cache[20] || (_cache[20] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)($event => _ctx.visible = false, ["tab"]))],
      onMouseenter: _cache[21] || (_cache[21] = $event => _ctx.inputHovering = true),
      onMouseleave: _cache[22] || (_cache[22] = $event => _ctx.inputHovering = false)
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createSlots)({
      suffix: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.iconComponent && !_ctx.showClose ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.iconComponent)))]),
        _: 1
      }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.showClose && _ctx.clearIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
        onClick: _ctx.handleClearClick
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.clearIcon)))]),
        _: 1
      }, 8, ["class", "onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      _: 2
    }, [_ctx.$slots.prefix ? {
      name: "prefix",
      fn: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", select2_hoisted_3, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "prefix")])])
    } : void 0]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])])]),
    content: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_select_menu, null, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_scrollbar, {
        ref: "scrollbar",
        tag: "ul",
        "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
        "view-class": _ctx.nsSelect.be("dropdown", "list"),
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsSelect.is("empty", !_ctx.allowCreate && Boolean(_ctx.query) && _ctx.filteredOptionsCount === 0)])
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.showNewOption ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_option, {
          key: 0,
          value: _ctx.query,
          created: true
        }, null, 8, ["value"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["wrap-class", "view-class", "class"]), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.options.size > 0 && !_ctx.loading]]), _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [_ctx.$slots.empty ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "empty", {
        key: 0
      }) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("p", {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsSelect.be("dropdown", "empty"))
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.emptyText), 3))], 2112)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      _: 3
    })]),
    _: 3
  }, 8, ["visible", "teleported", "popper-class", "effect", "transition", "persistent", "onShow"])], 2)), [[_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]]);
}

var Select = /* @__PURE__ */_export_sfc(select2_sfc_main, [["render", select2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/src/option-group2.mjs






const option_group2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const ns = useNamespace("select");
    const visible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(true);
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const children = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(selectGroupKey, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({ ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(props)
    }));
    const select = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(selectKey);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      children.value = flattedChildren(instance.subTree);
    });

    const flattedChildren = node => {
      const children2 = [];

      if (Array.isArray(node.children)) {
        node.children.forEach(child => {
          var _a;

          if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
            children2.push(child.component.proxy);
          } else if ((_a = child.children) == null ? void 0 : _a.length) {
            children2.push(...flattedChildren(child));
          }
        });
      }

      return children2;
    };

    const {
      groupQueryChange
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(select);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(groupQueryChange, () => {
      visible.value = children.value.some(option => option.visible === true);
    });
    return {
      visible,
      ns
    };
  }

});

function option_group2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("ul", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("group", "wrap"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("li", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("group", "title"))
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.label), 3), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("li", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("ul", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.b("group"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2)])], 2)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.visible]]);
}

var OptionGroup = /* @__PURE__ */_export_sfc(option_group2_sfc_main, [["render", option_group2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/index2.mjs






const ElSelect = withInstall(Select, {
  Option: Option,
  OptionGroup: OptionGroup
});
const ElOption = withNoopInstall(Option);
const ElOptionGroup = withNoopInstall(OptionGroup);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-tag.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tag/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-option.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/option/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-option-group.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/option-group/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-scrollbar.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-select.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/style/css2.mjs








;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/select/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/option/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-dial/index.vue?vue&type=template&id=a9601268
/* unplugin-vue-components disabled */






const nx_dialvue_type_template_id_a9601268_hoisted_1 = {
  key: 0,
  class: "external-option"
};
const nx_dialvue_type_template_id_a9601268_hoisted_2 = {
  class: "external-option-title"
};
const nx_dialvue_type_template_id_a9601268_hoisted_3 = ["onClick"];
const nx_dialvue_type_template_id_a9601268_hoisted_4 = {
  class: "number-content"
};

const _hoisted_5 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/call_out.svg",
  alt: ""
}, null, -1);

const _hoisted_6 = [_hoisted_5];
const _hoisted_7 = {
  class: "nx-delete-button"
};

const _hoisted_8 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/dial.svg",
  alt: ""
}, null, -1);

const _hoisted_9 = {
  class: "span-white"
};

const _hoisted_10 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("audio", {
  style: {
    "display": "none"
  },
  id: "remoteAudio",
  controls: ""
}, null, -1);

const _hoisted_11 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("audio", {
  style: {
    "display": "none"
  },
  id: "playAudio",
  controls: ""
}, null, -1);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;

  const _component_el_select = ElSelect;

  const _component_el_input = ElInput;

  const _component_el_col = ElCol;

  const _component_el_row = ElRow;

  const _component_el_popover = ElPopover;

  const _component_nx_status = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("nx-status");

  const _component_nx_body = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("nx-body");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_popover, {
    ref: "setRemovePop",
    placement: "bottom",
    width: 304,
    onBeforeEnter: _ctx.showElPopover,
    visible: _ctx.popVisible,
    "popper-class": "dialStyle"
  }, {
    reference: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: "dial-link",
      onClick: _cache[4] || (_cache[4] = $event => _ctx.popVisible = !_ctx.popVisible)
    }, [_hoisted_8, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", _hoisted_9, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("sip.dailPad")), 1)])]),
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.callStatus != 2 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", nx_dialvue_type_template_id_a9601268_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", nx_dialvue_type_template_id_a9601268_hoisted_2, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("sip.displayNumber")) + ":", 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_select, {
      modelValue: _ctx.external.number,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.external.number = $event),
      filterable: "",
      placeholder: _ctx.i18n.global.t('sip.selectDisplayNumber'),
      teleported: false,
      onChange: _ctx.changeExternal
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.externalList, item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_option, {
          key: item.id,
          label: `${item.number}${item.remark != null && item.remark != '' ? '-' + item.remark : ''}`,
          value: item.id
        }, null, 8, ["label", "value"]);
      }), 128))]),
      _: 1
    }, 8, ["modelValue", "placeholder", "onChange"])])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
      ref: "numberRef",
      modelValue: _ctx.numberText,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.numberText = $event),
      onInput: _ctx.phoneInputChange,
      class: "number-input",
      disabled: _ctx.callStatus != 2 ? false : true
    }, null, 8, ["modelValue", "onInput", "disabled"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_row, {
      gutter: 15
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.numberJson, (item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_col, {
          span: 8,
          key: index
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            class: "number-circle",
            onClick: $event => _ctx.clickKeyBoardNumberKey(item.number)
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_dialvue_type_template_id_a9601268_hoisted_4, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("h3", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.number), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("p", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.label), 1)])], 8, nx_dialvue_type_template_id_a9601268_hoisted_3)]),
          _: 2
        }, 1024);
      }), 128)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        span: 8
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        span: 8
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
          class: "nx-call-button",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.callPhone && _ctx.callPhone(...args))
        }, _hoisted_6)]),
        _: 1
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        span: 8
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_7, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
          src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/delete.svg",
          alt: "",
          class: "delete-number",
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.deleteNumber && _ctx.deleteNumber(...args))
        })])]),
        _: 1
      })]),
      _: 1
    })]),
    _: 1
  }, 8, ["onBeforeEnter", "visible"]), _hoisted_10, _hoisted_11, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_nx_status), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_nx_body)]);
}
;// CONCATENATED MODULE: ./src/package/nx-dial/index.vue?vue&type=template&id=a9601268
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/config-provider/src/config-provider2.mjs







const messageConfig = {};
const configProviderProps = buildProps({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: definePropType(Object)
  },
  size: {
    type: String,
    values: componentSizes,
    default: ""
  },
  button: {
    type: definePropType(Object)
  },
  experimentalFeatures: {
    type: definePropType(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: definePropType(Object)
  },
  zIndex: {
    type: Number
  },
  namespace: {
    type: String,
    default: "el"
  }
});
var ConfigProvider = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElConfigProvider",
  props: configProviderProps,

  setup(props, {
    slots
  }) {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.message, val => {
      Object.assign(messageConfig, val != null ? val : {});
    }, {
      immediate: true,
      deep: true
    });
    const config = provideGlobalConfig(props);
    return () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(slots, "default", {
      config: config == null ? void 0 : config.value
    });
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/badge/src/badge3.mjs


const badgeProps = buildProps({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/badge/src/badge4.mjs







const badge4_hoisted_1 = ["textContent"];
const badge4_default_ = {
  name: "ElBadge"
};

const badge4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...badge4_default_,
  props: badgeProps,

  setup(__props, {
    expose
  }) {
    const props = __props;
    const ns = useNamespace("badge");
    const content = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (props.isDot) return "";

      if (shared_isNumber(props.value) && shared_isNumber(props.max)) {
        return props.max < props.value ? `${props.max}+` : `${props.value}`;
      }

      return `${props.value}`;
    });
    expose({
      content
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).b())
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
        name: `${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).namespace.value}-zoom-in-center`
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("sup", {
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("content"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).em("content", _ctx.type), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("fixed", !!_ctx.$slots.default), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("dot", _ctx.isDot)]),
          textContent: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(content))
        }, null, 10, badge4_hoisted_1), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, !_ctx.hidden && ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(content) || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(content) === "0" || _ctx.isDot)]])]),
        _: 1
      }, 8, ["name"])], 2);
    };
  }

});

var Badge = /* @__PURE__ */_export_sfc(badge4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/badge/index2.mjs




const ElBadge = withInstall(Badge);

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/message/src/message3.mjs



const messageTypes = ["success", "info", "warning", "error"];
const messageProps = buildProps({
  customClass: {
    type: String,
    default: ""
  },
  center: {
    type: Boolean,
    default: false
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3e3
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: definePropType([String, Object, Function]),
    default: ""
  },
  onClose: {
    type: definePropType(Function),
    required: false
  },
  showClose: {
    type: Boolean,
    default: false
  },
  type: {
    type: String,
    values: messageTypes,
    default: "info"
  },
  offset: {
    type: Number,
    default: 20
  },
  zIndex: {
    type: Number,
    default: 0
  },
  grouping: {
    type: Boolean,
    default: false
  },
  repeatNum: {
    type: Number,
    default: 1
  }
});
const messageEmits = {
  destroy: () => true
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/message/src/message4.mjs













const message4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElMessage",
  components: {
    ElBadge: ElBadge,
    ElIcon: ElIcon,
    ...TypeComponents
  },
  props: messageProps,
  emits: messageEmits,

  setup(props) {
    const ns = useNamespace("message");
    const visible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const badgeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(props.type ? props.type === "error" ? "danger" : props.type : "info");
    let stopTimer = void 0;
    const typeClass = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const type = props.type;
      return {
        [ns.bm("icon", type)]: type && TypeComponentsMap[type]
      };
    });
    const iconComponent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.icon || TypeComponentsMap[props.type] || "";
    });
    const customStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ({
      top: `${props.offset}px`,
      zIndex: props.zIndex
    }));

    function startTimer() {
      if (props.duration > 0) {
        ;
        ({
          stop: stopTimer
        } = shared_useTimeoutFn(() => {
          if (visible.value) close();
        }, props.duration));
      }
    }

    function clearTimer() {
      stopTimer == null ? void 0 : stopTimer();
    }

    function close() {
      visible.value = false;
    }

    function keydown({
      code
    }) {
      if (code === EVENT_CODE.esc) {
        if (visible.value) {
          close();
        }
      } else {
        startTimer();
      }
    }

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      startTimer();
      visible.value = true;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.repeatNum, () => {
      clearTimer();
      startTimer();
    });
    useEventListener(document, "keydown", keydown);
    return {
      ns,
      typeClass,
      iconComponent,
      customStyle,
      visible,
      badgeType,
      close,
      clearTimer,
      startTimer
    };
  }

});

const message4_hoisted_1 = ["id"];
const message4_hoisted_2 = ["innerHTML"];

function message4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_badge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-badge");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_close = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("close");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
    name: _ctx.ns.b("fade"),
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[2] || (_cache[2] = $event => _ctx.$emit("destroy"))
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      id: _ctx.id,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.b(), {
        [_ctx.ns.m(_ctx.type)]: _ctx.type && !_ctx.icon
      }, _ctx.ns.is("center", _ctx.center), _ctx.ns.is("closable", _ctx.showClose), _ctx.customClass]),
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.customStyle),
      role: "alert",
      onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
      onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args))
    }, [_ctx.repeatNum > 1 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_badge, {
      key: 0,
      value: _ctx.repeatNum,
      type: _ctx.badgeType,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("badge"))
    }, null, 8, ["value", "type", "class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.iconComponent ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
      key: 1,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("icon"), _ctx.typeClass])
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.iconComponent)))]),
      _: 1
    }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {}, () => [!_ctx.dangerouslyUseHTMLString ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("p", {
      key: 0,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("content"))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.message), 3)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
      key: 1
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(" Caution here, message could've been compromised, never use user's input as message "), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("p", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("content")),
      innerHTML: _ctx.message
    }, null, 10, message4_hoisted_2)], 2112))]), _ctx.showClose ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
      key: 2,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("closeBtn")),
      onClick: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)(_ctx.close, ["stop"])
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_close)]),
      _: 1
    }, 8, ["class", "onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 46, message4_hoisted_1), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.visible]])]),
    _: 3
  }, 8, ["name", "onBeforeLeave"]);
}

var MessageConstructor = /* @__PURE__ */_export_sfc(message4_sfc_main, [["render", message4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/message/src/message-method2.mjs











const instances = [];
let seed = 1;

const message = function (options = {}, context) {
  if (!shared_isClient) return {
    close: () => void 0
  };

  if (shared_isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
    return {
      close: () => void 0
    };
  }

  if (!(0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(options) && shared_esm_bundler_isObject(options) && options.grouping && !(0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(options.message) && instances.length) {
    const tempVm = instances.find(item => {
      var _a, _b, _c;

      return `${(_b = (_a = item.vm.props) == null ? void 0 : _a.message) != null ? _b : ""}` === `${(_c = options.message) != null ? _c : ""}`;
    });

    if (tempVm) {
      tempVm.vm.component.props.repeatNum += 1;
      tempVm.vm.component.props.type = (options == null ? void 0 : options.type) || "info";
      return {
        close: () => vm.component.proxy.visible = false
      };
    }
  }

  if (shared_esm_bundler_isString(options) || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(options)) {
    options = {
      message: options
    };
  }

  let verticalOffset = options.offset || 20;
  instances.forEach(({
    vm: vm2
  }) => {
    var _a;

    verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + 16;
  });
  verticalOffset += 16;
  const {
    nextZIndex
  } = useZIndex();
  const id = `message_${seed++}`;
  const userOnClose = options.onClose;
  const props = {
    zIndex: nextZIndex(),
    ...options,
    offset: verticalOffset,
    id,
    onClose: () => {
      message_method2_close(id, userOnClose);
    }
  };
  let appendTo = document.body;

  if (isElement(options.appendTo)) {
    appendTo = options.appendTo;
  } else if (shared_esm_bundler_isString(options.appendTo)) {
    appendTo = document.querySelector(options.appendTo);
  }

  if (!isElement(appendTo)) {
    error2_debugWarn("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body.");
    appendTo = document.body;
  }

  const container = document.createElement("div");
  container.className = `container_${id}`;
  const messageContent = props.message;
  const vm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(MessageConstructor, props, shared_esm_bundler_isFunction(messageContent) ? {
    default: messageContent
  } : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(messageContent) ? {
    default: () => messageContent
  } : null);
  vm.appContext = context || message._context;

  vm.props.onDestroy = () => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.render)(null, container);
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.render)(vm, container);
  instances.push({
    vm
  });
  appendTo.appendChild(container.firstElementChild);
  return {
    close: () => vm.component.proxy.visible = false
  };
};

messageTypes.forEach(type => {
  message[type] = (options = {}, appContext) => {
    if (shared_esm_bundler_isString(options) || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(options)) {
      options = {
        message: options
      };
    }

    return message({ ...options,
      type
    }, appContext);
  };
});

function message_method2_close(id, userOnClose) {
  const idx = instances.findIndex(({
    vm: vm2
  }) => id === vm2.component.props.id);
  if (idx === -1) return;
  const {
    vm
  } = instances[idx];
  if (!vm) return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = vm.el.offsetHeight;
  instances.splice(idx, 1);
  const len = instances.length;
  if (len < 1) return;

  for (let i = idx; i < len; i++) {
    const pos = Number.parseInt(instances[i].vm.el.style["top"], 10) - removedHeight - 16;
    instances[i].vm.component.props.offset = pos;
  }
}

function closeAll() {
  var _a;

  for (let i = instances.length - 1; i >= 0; i--) {
    const instance = instances[i].vm.component;
    (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.close();
  }
}

message.closeAll = closeAll;
message._context = null;

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/message/index2.mjs




const index2_ElMessage = withInstallFunction(message, "$message");

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-message.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/message/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/message/style/css.mjs

// EXTERNAL MODULE: ./node_modules/dayjs/dayjs.min.js
var dayjs_min = __webpack_require__(7013);
var dayjs_min_default = /*#__PURE__*/__webpack_require__.n(dayjs_min);
;// CONCATENATED MODULE: ./node_modules/@intlify/shared/dist/shared.esm-bundler.js
/*!
  * shared v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */

/**
 * Original Utilities
 * written by kazuya kawaguchi
 */
const inBrowser = typeof window !== 'undefined';
let mark;
let measure;

if (false) {}

const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
/* eslint-disable */

function shared_esm_bundler_format(message, ...args) {
  if (args.length === 1 && dist_shared_esm_bundler_isObject(args[0])) {
    args = args[0];
  }

  if (!args || !args.hasOwnProperty) {
    args = {};
  }

  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : '';
  });
}

const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

const shared_esm_bundler_makeSymbol = name => hasSymbol ? Symbol(name) : name;

const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({
  l: locale,
  k: key,
  s: source
});

const friendlyJSONstringify = json => JSON.stringify(json).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029').replace(/\u0027/g, '\\u0027');

const shared_esm_bundler_isNumber = val => typeof val === 'number' && isFinite(val);

const shared_esm_bundler_isDate = val => shared_esm_bundler_toTypeString(val) === '[object Date]';

const isRegExp = val => shared_esm_bundler_toTypeString(val) === '[object RegExp]';

const isEmptyObject = val => shared_esm_bundler_isPlainObject(val) && Object.keys(val).length === 0;

function shared_esm_bundler_warn(msg, err) {
  if (typeof console !== 'undefined') {
    console.warn(`[intlify] ` + msg);
    /* istanbul ignore if */

    if (err) {
      console.warn(err.stack);
    }
  }
}

const shared_esm_bundler_assign = Object.assign;

let shared_esm_bundler_globalThis;

const shared_esm_bundler_getGlobalThis = () => {
  // prettier-ignore
  return shared_esm_bundler_globalThis || (shared_esm_bundler_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});
};

function shared_esm_bundler_escapeHtml(rawText) {
  return rawText.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
}

const dist_shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;

function dist_shared_esm_bundler_hasOwn(obj, key) {
  return dist_shared_esm_bundler_hasOwnProperty.call(obj, key);
}
/* eslint-enable */

/**
 * Useful Utilities By Evan you
 * Modified by kazuya kawaguchi
 * MIT License
 * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts
 * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/codeframe.ts
 */


const dist_shared_esm_bundler_isArray = Array.isArray;

const dist_shared_esm_bundler_isFunction = val => typeof val === 'function';

const dist_shared_esm_bundler_isString = val => typeof val === 'string';

const shared_esm_bundler_isBoolean = val => typeof val === 'boolean';

const shared_esm_bundler_isSymbol = val => typeof val === 'symbol';

const dist_shared_esm_bundler_isObject = val => // eslint-disable-line
val !== null && typeof val === 'object';

const shared_esm_bundler_isPromise = val => {
  return dist_shared_esm_bundler_isObject(val) && dist_shared_esm_bundler_isFunction(val.then) && dist_shared_esm_bundler_isFunction(val.catch);
};

const shared_esm_bundler_objectToString = Object.prototype.toString;

const shared_esm_bundler_toTypeString = value => shared_esm_bundler_objectToString.call(value);

const shared_esm_bundler_isPlainObject = val => shared_esm_bundler_toTypeString(val) === '[object Object]'; // for converting list and named values to displayed strings.


const shared_esm_bundler_toDisplayString = val => {
  return val == null ? '' : dist_shared_esm_bundler_isArray(val) || shared_esm_bundler_isPlainObject(val) && val.toString === shared_esm_bundler_objectToString ? JSON.stringify(val, null, 2) : String(val);
};

const RANGE = 2;

function shared_esm_bundler_generateCodeFrame(source, start = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];

  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;

        if (j === i) {
          // push underline
          const pad = start - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + '^'.repeat(length));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * Event emitter, forked from the below:
 * - original repository url: https://github.com/developit/mitt
 * - code url: https://github.com/developit/mitt/blob/master/src/index.ts
 * - author: Jason Miller (https://github.com/developit)
 * - license: MIT
 */

/**
 * Create a event emitter
 *
 * @returns An event emitter
 */


function createEmitter() {
  const events = new Map();
  const emitter = {
    events,

    on(event, handler) {
      const handlers = events.get(event);
      const added = handlers && handlers.push(handler);

      if (!added) {
        events.set(event, [handler]);
      }
    },

    off(event, handler) {
      const handlers = events.get(event);

      if (handlers) {
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
    },

    emit(event, payload) {
      (events.get(event) || []).slice().map(handler => handler(payload));
      (events.get('*') || []).slice().map(handler => handler(event, payload));
    }

  };
  return emitter;
}


;// CONCATENATED MODULE: ./node_modules/@intlify/message-compiler/dist/message-compiler.esm-bundler.js


/*!
  * message-compiler v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */

const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 15
};
/** @internal */

const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`
};

function createCompileError(code, loc, options = {}) {
  const {
    domain,
    messages,
    args
  } = options;
  const msg =  false ? 0 : code;
  const error = new SyntaxError(String(msg));
  error.code = code;

  if (loc) {
    error.location = loc;
  }

  error.domain = domain;
  return error;
}
/** @internal */


function defaultOnError(error) {
  throw error;
}

const LocationStub = {
  start: {
    line: 1,
    column: 1,
    offset: 0
  },
  end: {
    line: 1,
    column: 1,
    offset: 0
  }
};

function createPosition(line, column, offset) {
  return {
    line,
    column,
    offset
  };
}

function createLocation(start, end, source) {
  const loc = {
    start,
    end
  };

  if (source != null) {
    loc.source = source;
  }

  return loc;
}

const CHAR_SP = ' ';
const CHAR_CR = '\r';
const CHAR_LF = '\n';
const CHAR_LS = String.fromCharCode(0x2028);
const CHAR_PS = String.fromCharCode(0x2029);

function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;

  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;

  const isLF = index => _buf[index] === CHAR_LF;

  const isPS = index => _buf[index] === CHAR_PS;

  const isLS = index => _buf[index] === CHAR_LS;

  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);

  const index = () => _index;

  const line = () => _line;

  const column = () => _column;

  const peekOffset = () => _peekOffset;

  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];

  const currentChar = () => charAt(_index);

  const currentPeek = () => charAt(_index + _peekOffset);

  function next() {
    _peekOffset = 0;

    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }

    if (isCRLF(_index)) {
      _index++;
    }

    _index++;
    _column++;
    return _buf[_index];
  }

  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }

    _peekOffset++;
    return _buf[_index + _peekOffset];
  }

  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }

  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }

  function skipToPeek() {
    const target = _index + _peekOffset; // eslint-disable-next-line no-unmodified-loop-condition

    while (target !== _index) {
      next();
    }

    _peekOffset = 0;
  }

  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}

const EOF = undefined;
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$1 = 'tokenizer';

function createTokenizer(source, options = {}) {
  const location = options.location !== false;

  const _scnr = createScanner(source);

  const currentOffset = () => _scnr.index();

  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());

  const _initLoc = currentPosition();

  const _initOffset = currentOffset();

  const _context = {
    currentType: 14
    /* EOF */
    ,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14
    /* EOF */
    ,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ''
  };

  const context = () => _context;

  const {
    onError
  } = options;

  function emitError(code, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;

    if (onError) {
      const loc = createLocation(ctx.startLoc, pos);
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN$1,
        args
      });
      onError(err);
    }
  }

  function getToken(context, type, value) {
    context.endLoc = currentPosition();
    context.currentType = type;
    const token = {
      type
    };

    if (location) {
      token.loc = createLocation(context.startLoc, context.endLoc);
    }

    if (value != null) {
      token.value = value;
    }

    return token;
  }

  const getEndToken = context => getToken(context, 14
  /* EOF */
  );

  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return '';
    }
  }

  function peekSpaces(scnr) {
    let buf = '';

    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }

    return buf;
  }

  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }

  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }

    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95 // _
    ;
  }

  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }

    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57; // 0-9
  }

  function isNamedIdentifierStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 2
    /* BraceLeft */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }

  function isListIdentifierStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 2
    /* BraceLeft */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }

  function isLiteralStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 2
    /* BraceLeft */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }

  function isLinkedDotStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 8
    /* LinkedAlias */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "."
    /* LinkedDot */
    ;
    scnr.resetPeek();
    return ret;
  }

  function isLinkedModifierStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 9
    /* LinkedDot */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }

  function isLinkedDelimiterStart(scnr, context) {
    const {
      currentType
    } = context;

    if (!(currentType === 8
    /* LinkedAlias */
    || currentType === 12
    /* LinkedModifier */
    )) {
      return false;
    }

    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":"
    /* LinkedDelimiter */
    ;
    scnr.resetPeek();
    return ret;
  }

  function isLinkedReferStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 10
    /* LinkedDelimiter */
    ) {
      return false;
    }

    const fn = () => {
      const ch = scnr.currentPeek();

      if (ch === "{"
      /* BraceLeft */
      ) {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@"
      /* LinkedAlias */
      || ch === "%"
      /* Modulo */
      || ch === "|"
      /* Pipe */
      || ch === ":"
      /* LinkedDelimiter */
      || ch === "."
      /* LinkedDot */
      || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        // other characters
        return isIdentifierStart(ch);
      }
    };

    const ret = fn();
    scnr.resetPeek();
    return ret;
  }

  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|"
    /* Pipe */
    ;
    scnr.resetPeek();
    return ret;
  }

  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%"
    /* Modulo */
    && scnr.peek() === "{"
    /* BraceLeft */
    ;
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }

  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = '', detectModulo = false) => {
      const ch = scnr.currentPeek();

      if (ch === "{"
      /* BraceLeft */
      ) {
        return prev === "%"
        /* Modulo */
        ? false : hasSpace;
      } else if (ch === "@"
      /* LinkedAlias */
      || !ch) {
        return prev === "%"
        /* Modulo */
        ? true : hasSpace;
      } else if (ch === "%"
      /* Modulo */
      ) {
        scnr.peek();
        return fn(hasSpace, "%"
        /* Modulo */
        , true);
      } else if (ch === "|"
      /* Pipe */
      ) {
        return prev === "%"
        /* Modulo */
        || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };

    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }

  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();

    if (ch === EOF) {
      return EOF;
    }

    if (fn(ch)) {
      scnr.next();
      return ch;
    }

    return null;
  }

  function takeIdentifierChar(scnr) {
    const closure = ch => {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc >= 48 && cc <= 57 || // 0-9
      cc === 95 || // _
      cc === 36 // $
      ;
    };

    return takeChar(scnr, closure);
  }

  function takeDigit(scnr) {
    const closure = ch => {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57; // 0-9
    };

    return takeChar(scnr, closure);
  }

  function takeHexDigit(scnr) {
    const closure = ch => {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57 || // 0-9
      cc >= 65 && cc <= 70 || // A-F
      cc >= 97 && cc <= 102; // a-f
    };

    return takeChar(scnr, closure);
  }

  function getDigits(scnr) {
    let ch = '';
    let num = '';

    while (ch = takeDigit(scnr)) {
      num += ch;
    }

    return num;
  }

  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();

    if (ch !== "%"
    /* Modulo */
    ) {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }

    scnr.next();
    return "%"
    /* Modulo */
    ;
  }

  function readText(scnr) {
    let buf = '';

    while (true) {
      const ch = scnr.currentChar();

      if (ch === "{"
      /* BraceLeft */
      || ch === "}"
      /* BraceRight */
      || ch === "@"
      /* LinkedAlias */
      || ch === "|"
      /* Pipe */
      || !ch) {
        break;
      } else if (ch === "%"
      /* Modulo */
      ) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }

    return buf;
  }

  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = '';
    let name = '';

    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }

    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }

    return name;
  }

  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = '';

    if (scnr.currentChar() === '-') {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }

    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }

    return value;
  }

  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `\'`);
    let ch = '';
    let literal = '';

    const fn = x => x !== LITERAL_DELIMITER && x !== CHAR_LF;

    while (ch = takeChar(scnr, fn)) {
      if (ch === '\\') {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }

    const current = scnr.currentChar();

    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0); // TODO: Is it correct really?

      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `\'`);
      }

      return literal;
    }

    eat(scnr, `\'`);
    return literal;
  }

  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();

    switch (ch) {
      case '\\':
      case `\'`:
        scnr.next();
        return `\\${ch}`;

      case 'u':
        return readUnicodeEscapeSequence(scnr, ch, 4);

      case 'U':
        return readUnicodeEscapeSequence(scnr, ch, 6);

      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return '';
    }
  }

  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = '';

    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);

      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }

      sequence += ch;
    }

    return `\\${unicode}${sequence}`;
  }

  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = '';
    let identifiers = '';

    const closure = ch => ch !== "{"
    /* BraceLeft */
    && ch !== "}"
    /* BraceRight */
    && ch !== CHAR_SP && ch !== CHAR_LF;

    while (ch = takeChar(scnr, closure)) {
      identifiers += ch;
    }

    return identifiers;
  }

  function readLinkedModifier(scnr) {
    let ch = '';
    let name = '';

    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }

    return name;
  }

  function readLinkedRefer(scnr) {
    const fn = (detect = false, buf) => {
      const ch = scnr.currentChar();

      if (ch === "{"
      /* BraceLeft */
      || ch === "%"
      /* Modulo */
      || ch === "@"
      /* LinkedAlias */
      || ch === "|"
      /* Pipe */
      || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF) {
        buf += ch;
        scnr.next();
        return fn(detect, buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(true, buf);
      }
    };

    return fn(false, '');
  }

  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(scnr, "|"
    /* Pipe */
    );
    skipSpaces(scnr);
    return plural;
  } // TODO: We need refactoring of token parsing ...


  function readTokenInPlaceholder(scnr, context) {
    let token = null;
    const ch = scnr.currentChar();

    switch (ch) {
      case "{"
      /* BraceLeft */
      :
        if (context.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }

        scnr.next();
        token = getToken(context, 2
        /* BraceLeft */
        , "{"
        /* BraceLeft */
        );
        skipSpaces(scnr);
        context.braceNest++;
        return token;

      case "}"
      /* BraceRight */
      :
        if (context.braceNest > 0 && context.currentType === 2
        /* BraceLeft */
        ) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }

        scnr.next();
        token = getToken(context, 3
        /* BraceRight */
        , "}"
        /* BraceRight */
        );
        context.braceNest--;
        context.braceNest > 0 && skipSpaces(scnr);

        if (context.inLinked && context.braceNest === 0) {
          context.inLinked = false;
        }

        return token;

      case "@"
      /* LinkedAlias */
      :
        if (context.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }

        token = readTokenInLinked(scnr, context) || getEndToken(context);
        context.braceNest = 0;
        return token;

      default:
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;

        if (isPluralStart(scnr)) {
          if (context.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }

          token = getToken(context, 1
          /* Pipe */
          , readPlural(scnr)); // reset

          context.braceNest = 0;
          context.inLinked = false;
          return token;
        }

        if (context.braceNest > 0 && (context.currentType === 5
        /* Named */
        || context.currentType === 6
        /* List */
        || context.currentType === 7
        /* Literal */
        )) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context.braceNest = 0;
          return readToken(scnr, context);
        }

        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {
          token = getToken(context, 5
          /* Named */
          , readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }

        if (validListIdentifier = isListIdentifierStart(scnr, context)) {
          token = getToken(context, 6
          /* List */
          , readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }

        if (validLiteral = isLiteralStart(scnr, context)) {
          token = getToken(context, 7
          /* Literal */
          , readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }

        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...
          token = getToken(context, 13
          /* InvalidPlace */
          , readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }

        break;
    }

    return token;
  } // TODO: We need refactoring of token parsing ...


  function readTokenInLinked(scnr, context) {
    const {
      currentType
    } = context;
    let token = null;
    const ch = scnr.currentChar();

    if ((currentType === 8
    /* LinkedAlias */
    || currentType === 9
    /* LinkedDot */
    || currentType === 12
    /* LinkedModifier */
    || currentType === 10
    /* LinkedDelimiter */
    ) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }

    switch (ch) {
      case "@"
      /* LinkedAlias */
      :
        scnr.next();
        token = getToken(context, 8
        /* LinkedAlias */
        , "@"
        /* LinkedAlias */
        );
        context.inLinked = true;
        return token;

      case "."
      /* LinkedDot */
      :
        skipSpaces(scnr);
        scnr.next();
        return getToken(context, 9
        /* LinkedDot */
        , "."
        /* LinkedDot */
        );

      case ":"
      /* LinkedDelimiter */
      :
        skipSpaces(scnr);
        scnr.next();
        return getToken(context, 10
        /* LinkedDelimiter */
        , ":"
        /* LinkedDelimiter */
        );

      default:
        if (isPluralStart(scnr)) {
          token = getToken(context, 1
          /* Pipe */
          , readPlural(scnr)); // reset

          context.braceNest = 0;
          context.inLinked = false;
          return token;
        }

        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context);
        }

        if (isLinkedModifierStart(scnr, context)) {
          skipSpaces(scnr);
          return getToken(context, 12
          /* LinkedModifier */
          , readLinkedModifier(scnr));
        }

        if (isLinkedReferStart(scnr, context)) {
          skipSpaces(scnr);

          if (ch === "{"
          /* BraceLeft */
          ) {
            // scan the placeholder
            return readTokenInPlaceholder(scnr, context) || token;
          } else {
            return getToken(context, 11
            /* LinkedKey */
            , readLinkedRefer(scnr));
          }
        }

        if (currentType === 8
        /* LinkedAlias */
        ) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }

        context.braceNest = 0;
        context.inLinked = false;
        return readToken(scnr, context);
    }
  } // TODO: We need refactoring of token parsing ...


  function readToken(scnr, context) {
    let token = {
      type: 14
      /* EOF */

    };

    if (context.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context) || getEndToken(context);
    }

    if (context.inLinked) {
      return readTokenInLinked(scnr, context) || getEndToken(context);
    }

    const ch = scnr.currentChar();

    switch (ch) {
      case "{"
      /* BraceLeft */
      :
        return readTokenInPlaceholder(scnr, context) || getEndToken(context);

      case "}"
      /* BraceRight */
      :
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(context, 3
        /* BraceRight */
        , "}"
        /* BraceRight */
        );

      case "@"
      /* LinkedAlias */
      :
        return readTokenInLinked(scnr, context) || getEndToken(context);

      default:
        if (isPluralStart(scnr)) {
          token = getToken(context, 1
          /* Pipe */
          , readPlural(scnr)); // reset

          context.braceNest = 0;
          context.inLinked = false;
          return token;
        }

        const {
          isModulo,
          hasSpace
        } = detectModuloStart(scnr);

        if (isModulo) {
          return hasSpace ? getToken(context, 0
          /* Text */
          , readText(scnr)) : getToken(context, 4
          /* Modulo */
          , readModulo(scnr));
        }

        if (isTextStart(scnr)) {
          return getToken(context, 0
          /* Text */
          , readText(scnr));
        }

        break;
    }

    return token;
  }

  function nextToken() {
    const {
      currentType,
      offset,
      startLoc,
      endLoc
    } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();

    if (_scnr.currentChar() === EOF) {
      return getToken(_context, 14
      /* EOF */
      );
    }

    return readToken(_scnr, _context);
  }

  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}

const ERROR_DOMAIN = 'parser'; // Backslash backslash, backslash quote, uHHHH, UHHHHHH.

const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;

    case `\\\'`:
      return `\'`;

    default:
      {
        const codePoint = parseInt(codePoint4 || codePoint6, 16);

        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {
          return String.fromCodePoint(codePoint);
        } // invalid ...
        // Replace them with U+FFFD REPLACEMENT CHARACTER.


        return '';
      }
  }
}

function createParser(options = {}) {
  const location = options.location !== false;
  const {
    onError
  } = options;

  function emitError(tokenzer, code, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;

    if (onError) {
      const loc = createLocation(start, end);
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN,
        args
      });
      onError(err);
    }
  }

  function startNode(type, offset, loc) {
    const node = {
      type,
      start: offset,
      end: offset
    };

    if (location) {
      node.loc = {
        start: loc,
        end: loc
      };
    }

    return node;
  }

  function endNode(node, offset, pos, type) {
    node.end = offset;

    if (type) {
      node.type = type;
    }

    if (location && node.loc) {
      node.loc.end = pos;
    }
  }

  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3
    /* Text */
    , context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseList(tokenizer, index) {
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get brace left loc

    const node = startNode(5
    /* List */
    , offset, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken(); // skip brach right

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseNamed(tokenizer, key) {
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get brace left loc

    const node = startNode(4
    /* Named */
    , offset, loc);
    node.key = key;
    tokenizer.nextToken(); // skip brach right

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get brace left loc

    const node = startNode(9
    /* Literal */
    , offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken(); // skip brach right

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get linked dot loc

    const node = startNode(8
    /* LinkedModifier */
    , offset, loc);

    if (token.type !== 12
    /* LinkedModifier */
    ) {
      // empty modifier
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = '';
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    } // check token


    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }

    node.value = token.value || '';
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }

  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7
    /* LinkedKey */
    , context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6
    /* Linked */
    , context.offset, context.startLoc);
    let token = tokenizer.nextToken();

    if (token.type === 9
    /* LinkedDot */
    ) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    } // asset check token


    if (token.type !== 10
    /* LinkedDelimiter */
    ) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }

    token = tokenizer.nextToken(); // skip brace left

    if (token.type === 2
    /* BraceLeft */
    ) {
      token = tokenizer.nextToken();
    }

    switch (token.type) {
      case 11
      /* LinkedKey */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');
        break;

      case 5
      /* Named */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseNamed(tokenizer, token.value || '');
        break;

      case 6
      /* List */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseList(tokenizer, token.value || '');
        break;

      case 7
      /* Literal */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseLiteral(tokenizer, token.value || '');
        break;

      default:
        // empty key
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7
        /* LinkedKey */
        , nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = '';
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
    }

    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }

  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1
    /* Pipe */
    ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1
    /* Pipe */
    ? context.endLoc : context.startLoc;
    const node = startNode(2
    /* Message */
    , startOffset, startLoc);
    node.items = [];
    let nextToken = null;

    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;

      switch (token.type) {
        case 0
        /* Text */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseText(tokenizer, token.value || ''));
          break;

        case 6
        /* List */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseList(tokenizer, token.value || ''));
          break;

        case 5
        /* Named */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseNamed(tokenizer, token.value || ''));
          break;

        case 7
        /* Literal */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseLiteral(tokenizer, token.value || ''));
          break;

        case 8
        /* LinkedAlias */
        :
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
      }
    } while (context.currentType !== 14
    /* EOF */
    && context.currentType !== 1
    /* Pipe */
    ); // adjust message node loc


    const endOffset = context.currentType === 1
    /* Pipe */
    ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1
    /* Pipe */
    ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }

  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1
    /* Plural */
    , offset, loc);
    node.cases = [];
    node.cases.push(msgNode);

    do {
      const msg = parseMessage(tokenizer);

      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }

      node.cases.push(msg);
    } while (context.currentType !== 14
    /* EOF */
    );

    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const {
      offset,
      startLoc
    } = context;
    const msgNode = parseMessage(tokenizer);

    if (context.currentType === 14
    /* EOF */
    ) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }

  function parse(source) {
    const tokenizer = createTokenizer(source, shared_esm_bundler_assign({}, options));
    const context = tokenizer.context();
    const node = startNode(0
    /* Resource */
    , context.offset, context.startLoc);

    if (location && node.loc) {
      node.loc.source = source;
    }

    node.body = parseResource(tokenizer); // assert whether achieved to EOF

    if (context.currentType !== 14
    /* EOF */
    ) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');
    }

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  return {
    parse
  };
}

function getTokenCaption(token) {
  if (token.type === 14
  /* EOF */
  ) {
    return 'EOF';
  }

  const name = (token.value || '').replace(/\r?\n/gu, '\\n');
  return name.length > 10 ? name.slice(0, 9) + '' : name;
}

function createTransformer(ast, options = {} // eslint-disable-line
) {
  const _context = {
    ast,
    helpers: new Set()
  };

  const context = () => _context;

  const helper = name => {
    _context.helpers.add(name);

    return name;
  };

  return {
    context,
    helper
  };
}

function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}

function traverseNode(node, transformer) {
  // TODO: if we need pre-hook of transform, should be implemented to here
  switch (node.type) {
    case 1
    /* Plural */
    :
      traverseNodes(node.cases, transformer);
      transformer.helper("plural"
      /* PLURAL */
      );
      break;

    case 2
    /* Message */
    :
      traverseNodes(node.items, transformer);
      break;

    case 6
    /* Linked */
    :
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper("linked"
      /* LINKED */
      );
      transformer.helper("type"
      /* TYPE */
      );
      break;

    case 5
    /* List */
    :
      transformer.helper("interpolate"
      /* INTERPOLATE */
      );
      transformer.helper("list"
      /* LIST */
      );
      break;

    case 4
    /* Named */
    :
      transformer.helper("interpolate"
      /* INTERPOLATE */
      );
      transformer.helper("named"
      /* NAMED */
      );
      break;
  } // TODO: if we need post-hook of transform, should be implemented to here

} // transform AST


function transform(ast, options = {} // eslint-disable-line
) {
  const transformer = createTransformer(ast);
  transformer.helper("normalize"
  /* NORMALIZE */
  ); // traverse

  ast.body && traverseNode(ast.body, transformer); // set meta information

  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}

function createCodeGenerator(ast, options) {
  const {
    sourceMap,
    filename,
    breakLineCode,
    needIndent: _needIndent
  } = options;
  const _context = {
    source: ast.loc.source,
    filename,
    code: '',
    column: 1,
    line: 1,
    offset: 0,
    map: undefined,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };

  const context = () => _context;

  function push(code, node) {
    _context.code += code;
  }

  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : '';

    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }

  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }

  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }

  function newline() {
    _newline(_context.indentLevel);
  }

  const helper = key => `_${key}`;

  const needIndent = () => _context.needIndent;

  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}

function generateLinkedNode(generator, node) {
  const {
    helper
  } = generator;
  generator.push(`${helper("linked"
  /* LINKED */
  )}(`);
  generateNode(generator, node.key);

  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }

  generator.push(`)`);
}

function generateMessageNode(generator, node) {
  const {
    helper,
    needIndent
  } = generator;
  generator.push(`${helper("normalize"
  /* NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;

  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);

    if (i === length - 1) {
      break;
    }

    generator.push(', ');
  }

  generator.deindent(needIndent());
  generator.push('])');
}

function generatePluralNode(generator, node) {
  const {
    helper,
    needIndent
  } = generator;

  if (node.cases.length > 1) {
    generator.push(`${helper("plural"
    /* PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;

    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);

      if (i === length - 1) {
        break;
      }

      generator.push(', ');
    }

    generator.deindent(needIndent());
    generator.push(`])`);
  }
}

function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push('null');
  }
}

function generateNode(generator, node) {
  const {
    helper
  } = generator;

  switch (node.type) {
    case 0
    /* Resource */
    :
      generateResource(generator, node);
      break;

    case 1
    /* Plural */
    :
      generatePluralNode(generator, node);
      break;

    case 2
    /* Message */
    :
      generateMessageNode(generator, node);
      break;

    case 6
    /* Linked */
    :
      generateLinkedNode(generator, node);
      break;

    case 8
    /* LinkedModifier */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    case 7
    /* LinkedKey */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    case 5
    /* List */
    :
      generator.push(`${helper("interpolate"
      /* INTERPOLATE */
      )}(${helper("list"
      /* LIST */
      )}(${node.index}))`, node);
      break;

    case 4
    /* Named */
    :
      generator.push(`${helper("interpolate"
      /* INTERPOLATE */
      )}(${helper("named"
      /* NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;

    case 9
    /* Literal */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    case 3
    /* Text */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    default:
      if (false) {}

  }
} // generate code from AST


const generate = (ast, options = {} // eslint-disable-line
) => {
  const mode = dist_shared_esm_bundler_isString(options.mode) ? options.mode : 'normal';
  const filename = dist_shared_esm_bundler_isString(options.filename) ? options.filename : 'message.intl';
  const sourceMap = !!options.sourceMap; // prettier-ignore

  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\n';
  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);

  if (helpers.length > 0) {
    generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);
    generator.newline();
  }

  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  const {
    code,
    map
  } = generator.context();
  return {
    ast,
    code,
    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any

  };
};

function baseCompile(source, options = {}) {
  const assignedOptions = shared_esm_bundler_assign({}, options); // parse source codes

  const parser = createParser(assignedOptions);
  const ast = parser.parse(source); // transform ASTs

  transform(ast, assignedOptions); // generate javascript codes

  return generate(ast, assignedOptions);
}


;// CONCATENATED MODULE: ./node_modules/@intlify/devtools-if/dist/devtools-if.esm-bundler.js
/*!
  * devtools-if v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
const IntlifyDevToolsHooks = {
  I18nInit: 'i18n:init',
  FunctionTranslate: 'function:translate'
};

;// CONCATENATED MODULE: ./node_modules/@intlify/core-base/dist/core-base.esm-bundler.js
/*!
  * core-base v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */




const pathStateMachine = [];
pathStateMachine[0
/* BEFORE_PATH */
] = {
  ["w"
  /* WORKSPACE */
  ]: [0
  /* BEFORE_PATH */
  ],
  ["i"
  /* IDENT */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: [7
  /* AFTER_PATH */
  ]
};
pathStateMachine[1
/* IN_PATH */
] = {
  ["w"
  /* WORKSPACE */
  ]: [1
  /* IN_PATH */
  ],
  ["."
  /* DOT */
  ]: [2
  /* BEFORE_IDENT */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: [7
  /* AFTER_PATH */
  ]
};
pathStateMachine[2
/* BEFORE_IDENT */
] = {
  ["w"
  /* WORKSPACE */
  ]: [2
  /* BEFORE_IDENT */
  ],
  ["i"
  /* IDENT */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["0"
  /* ZERO */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ]
};
pathStateMachine[3
/* IN_IDENT */
] = {
  ["i"
  /* IDENT */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["0"
  /* ZERO */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["w"
  /* WORKSPACE */
  ]: [1
  /* IN_PATH */
  , 1
  /* PUSH */
  ],
  ["."
  /* DOT */
  ]: [2
  /* BEFORE_IDENT */
  , 1
  /* PUSH */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  , 1
  /* PUSH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: [7
  /* AFTER_PATH */
  , 1
  /* PUSH */
  ]
};
pathStateMachine[4
/* IN_SUB_PATH */
] = {
  ["'"
  /* SINGLE_QUOTE */
  ]: [5
  /* IN_SINGLE_QUOTE */
  , 0
  /* APPEND */
  ],
  ["\""
  /* DOUBLE_QUOTE */
  ]: [6
  /* IN_DOUBLE_QUOTE */
  , 0
  /* APPEND */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  , 2
  /* INC_SUB_PATH_DEPTH */
  ],
  ["]"
  /* RIGHT_BRACKET */
  ]: [1
  /* IN_PATH */
  , 3
  /* PUSH_SUB_PATH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: 8
  /* ERROR */
  ,
  ["l"
  /* ELSE */
  ]: [4
  /* IN_SUB_PATH */
  , 0
  /* APPEND */
  ]
};
pathStateMachine[5
/* IN_SINGLE_QUOTE */
] = {
  ["'"
  /* SINGLE_QUOTE */
  ]: [4
  /* IN_SUB_PATH */
  , 0
  /* APPEND */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: 8
  /* ERROR */
  ,
  ["l"
  /* ELSE */
  ]: [5
  /* IN_SINGLE_QUOTE */
  , 0
  /* APPEND */
  ]
};
pathStateMachine[6
/* IN_DOUBLE_QUOTE */
] = {
  ["\""
  /* DOUBLE_QUOTE */
  ]: [4
  /* IN_SUB_PATH */
  , 0
  /* APPEND */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: 8
  /* ERROR */
  ,
  ["l"
  /* ELSE */
  ]: [6
  /* IN_DOUBLE_QUOTE */
  , 0
  /* APPEND */
  ]
};
/**
 * Check if an expression is a literal value.
 */

const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function isLiteral(exp) {
  return literalValueRE.test(exp);
}
/**
 * Strip quotes from a string
 */


function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
}
/**
 * Determine the type of a character in a keypath.
 */


function getPathCharType(ch) {
  if (ch === undefined || ch === null) {
    return "o"
    /* END_OF_FAIL */
    ;
  }

  const code = ch.charCodeAt(0);

  switch (code) {
    case 0x5b: // [

    case 0x5d: // ]

    case 0x2e: // .

    case 0x22: // "

    case 0x27:
      // '
      return ch;

    case 0x5f: // _

    case 0x24: // $

    case 0x2d:
      // -
      return "i"
      /* IDENT */
      ;

    case 0x09: // Tab (HT)

    case 0x0a: // Newline (LF)

    case 0x0d: // Return (CR)

    case 0xa0: // No-break space (NBSP)

    case 0xfeff: // Byte Order Mark (BOM)

    case 0x2028: // Line Separator (LS)

    case 0x2029:
      // Paragraph Separator (PS)
      return "w"
      /* WORKSPACE */
      ;
  }

  return "i"
  /* IDENT */
  ;
}
/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */


function formatSubPath(path) {
  const trimmed = path.trim(); // invalid leading 0

  if (path.charAt(0) === '0' && isNaN(parseInt(path))) {
    return false;
  }

  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*"
  /* ASTARISK */
  + trimmed;
}
/**
 * Parse a string path into an array of segments
 */


function parse(path) {
  const keys = [];
  let index = -1;
  let mode = 0
  /* BEFORE_PATH */
  ;
  let subPathDepth = 0;
  let c;
  let key; // eslint-disable-line

  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];

  actions[0
  /* APPEND */
  ] = () => {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[1
  /* PUSH */
  ] = () => {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[2
  /* INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[0
    /* APPEND */
    ]();
    subPathDepth++;
  };

  actions[3
  /* PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4
      /* IN_SUB_PATH */
      ;
      actions[0
      /* APPEND */
      ]();
    } else {
      subPathDepth = 0;

      if (key === undefined) {
        return false;
      }

      key = formatSubPath(key);

      if (key === false) {
        return false;
      } else {
        actions[1
        /* PUSH */
        ]();
      }
    }
  };

  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];

    if (mode === 5
    /* IN_SINGLE_QUOTE */
    && nextChar === "'"
    /* SINGLE_QUOTE */
    || mode === 6
    /* IN_DOUBLE_QUOTE */
    && nextChar === "\""
    /* DOUBLE_QUOTE */
    ) {
      index++;
      newChar = '\\' + nextChar;
      actions[0
      /* APPEND */
      ]();
      return true;
    }
  }

  while (mode !== null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue;
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap["l"
    /* ELSE */
    ] || 8
    /* ERROR */
    ; // check parse error

    if (transition === 8
    /* ERROR */
    ) {
      return;
    }

    mode = transition[0];

    if (transition[1] !== undefined) {
      action = actions[transition[1]];

      if (action) {
        newChar = c;

        if (action() === false) {
          return;
        }
      }
    } // check parse finish


    if (mode === 7
    /* AFTER_PATH */
    ) {
      return keys;
    }
  }
} // path token cache


const cache = new Map();
/**
 * key-value message resolver
 *
 * @remarks
 * Resolves messages with the key-value structure. Note that messages with a hierarchical structure such as objects cannot be resolved
 *
 * @param obj - A target object to be resolved with path
 * @param path - A {@link Path | path} to resolve the value of message
 *
 * @returns A resolved {@link PathValue | path value}
 *
 * @VueI18nGeneral
 */

function resolveWithKeyValue(obj, path) {
  return dist_shared_esm_bundler_isObject(obj) ? obj[path] : null;
}
/**
 * message resolver
 *
 * @remarks
 * Resolves messages. messages with a hierarchical structure such as objects can be resolved. This resolver is used in VueI18n as default.
 *
 * @param obj - A target object to be resolved with path
 * @param path - A {@link Path | path} to resolve the value of message
 *
 * @returns A resolved {@link PathValue | path value}
 *
 * @VueI18nGeneral
 */


function resolveValue(obj, path) {
  // check object
  if (!dist_shared_esm_bundler_isObject(obj)) {
    return null;
  } // parse path


  let hit = cache.get(path);

  if (!hit) {
    hit = parse(path);

    if (hit) {
      cache.set(path, hit);
    }
  } // check hit


  if (!hit) {
    return null;
  } // resolve path value


  const len = hit.length;
  let last = obj;
  let i = 0;

  while (i < len) {
    const val = last[hit[i]];

    if (val === undefined) {
      return null;
    }

    last = val;
    i++;
  }

  return last;
}

const DEFAULT_MODIFIER = str => str;

const DEFAULT_MESSAGE = ctx => ''; // eslint-disable-line


const DEFAULT_MESSAGE_DATA_TYPE = 'text';

const DEFAULT_NORMALIZE = values => values.length === 0 ? '' : values.join('');

const DEFAULT_INTERPOLATE = shared_esm_bundler_toDisplayString;

function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);

  if (choicesLength === 2) {
    // prettier-ignore
    return choice ? choice > 1 ? 1 : 0 : 1;
  }

  return choice ? Math.min(choice, 2) : 0;
}

function getPluralIndex(options) {
  // prettier-ignore
  const index = shared_esm_bundler_isNumber(options.pluralIndex) ? options.pluralIndex : -1; // prettier-ignore

  return options.named && (shared_esm_bundler_isNumber(options.named.count) || shared_esm_bundler_isNumber(options.named.n)) ? shared_esm_bundler_isNumber(options.named.count) ? options.named.count : shared_esm_bundler_isNumber(options.named.n) ? options.named.n : index : index;
}

function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }

  if (!props.n) {
    props.n = pluralIndex;
  }
}

function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = dist_shared_esm_bundler_isObject(options.pluralRules) && dist_shared_esm_bundler_isString(locale) && dist_shared_esm_bundler_isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = dist_shared_esm_bundler_isObject(options.pluralRules) && dist_shared_esm_bundler_isString(locale) && dist_shared_esm_bundler_isFunction(options.pluralRules[locale]) ? pluralDefault : undefined;

  const plural = messages => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };

  const _list = options.list || [];

  const list = index => _list[index]; // eslint-disable-next-line @typescript-eslint/no-explicit-any


  const _named = options.named || {};

  shared_esm_bundler_isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);

  const named = key => _named[key];

  function message(key) {
    // prettier-ignore
    const msg = dist_shared_esm_bundler_isFunction(options.messages) ? options.messages(key) : dist_shared_esm_bundler_isObject(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) // resolve from parent messages
    : DEFAULT_MESSAGE : msg;
  }

  const _modifier = name => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;

  const normalize = shared_esm_bundler_isPlainObject(options.processor) && dist_shared_esm_bundler_isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = shared_esm_bundler_isPlainObject(options.processor) && dist_shared_esm_bundler_isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = shared_esm_bundler_isPlainObject(options.processor) && dist_shared_esm_bundler_isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;

  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type = 'text';
    let modifier = '';

    if (args.length === 1) {
      if (dist_shared_esm_bundler_isObject(arg1)) {
        modifier = arg1.modifier || modifier;
        type = arg1.type || type;
      } else if (dist_shared_esm_bundler_isString(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (dist_shared_esm_bundler_isString(arg1)) {
        modifier = arg1 || modifier;
      }

      if (dist_shared_esm_bundler_isString(arg2)) {
        type = arg2 || type;
      }
    }

    let msg = message(key)(ctx); // The message in vnode resolved with linked are returned as an array by processor.nomalize

    if (type === 'vnode' && dist_shared_esm_bundler_isArray(msg) && modifier) {
      msg = msg[0];
    }

    return modifier ? _modifier(modifier)(msg, type) : msg;
  };

  const ctx = {
    ["list"
    /* LIST */
    ]: list,
    ["named"
    /* NAMED */
    ]: named,
    ["plural"
    /* PLURAL */
    ]: plural,
    ["linked"
    /* LINKED */
    ]: linked,
    ["message"
    /* MESSAGE */
    ]: message,
    ["type"
    /* TYPE */
    ]: type,
    ["interpolate"
    /* INTERPOLATE */
    ]: interpolate,
    ["normalize"
    /* NORMALIZE */
    ]: normalize
  };
  return ctx;
}

let devtools = null;

function setDevToolsHook(hook) {
  devtools = hook;
}

function getDevToolsHook() {
  return devtools;
}

function initI18nDevTools(i18n, version, meta) {
  // TODO: queue if devtools is undefined
  devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
    timestamp: Date.now(),
    i18n,
    version,
    meta
  });
}

const translateDevTools = /* #__PURE__*/createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);

function createDevToolsHook(hook) {
  return payloads => devtools && devtools.emit(hook, payloads);
}

const CoreWarnCodes = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  __EXTEND_POINT__: 7
};
/** @internal */

const warnMessages = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`
};

function getWarnMessage(code, ...args) {
  return format(warnMessages[code], ...args);
}
/**
 * Fallback with simple implemenation
 *
 * @remarks
 * A fallback locale function implemented with a simple fallback algorithm.
 *
 * Basically, it returns the value as specified in the `fallbackLocale` props, and is processed with the fallback inside intlify.
 *
 * @param ctx - A {@link CoreContext | context}
 * @param fallback - A {@link FallbackLocale | fallback locale}
 * @param start - A starting {@link Locale | locale}
 *
 * @returns Fallback locales
 *
 * @VueI18nGeneral
 */


function fallbackWithSimple(ctx, fallback, start // eslint-disable-line @typescript-eslint/no-unused-vars
) {
  // prettier-ignore
  return [...new Set([start, ...(dist_shared_esm_bundler_isArray(fallback) ? fallback : dist_shared_esm_bundler_isObject(fallback) ? Object.keys(fallback) : dist_shared_esm_bundler_isString(fallback) ? [fallback] : [start])])];
}
/**
 * Fallback with locale chain
 *
 * @remarks
 * A fallback locale function implemented with a fallback chain algorithm. It's used in VueI18n as default.
 *
 * @param ctx - A {@link CoreContext | context}
 * @param fallback - A {@link FallbackLocale | fallback locale}
 * @param start - A starting {@link Locale | locale}
 *
 * @returns Fallback locales
 *
 * @VueI18nSee [Fallbacking](../guide/essentials/fallback)
 *
 * @VueI18nGeneral
 */


function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = dist_shared_esm_bundler_isString(start) ? start : DEFAULT_LOCALE;
  const context = ctx;

  if (!context.__localeChainCache) {
    context.__localeChainCache = new Map();
  }

  let chain = context.__localeChainCache.get(startLocale);

  if (!chain) {
    chain = []; // first block defined by start

    let block = [start]; // while any intervening block found

    while (dist_shared_esm_bundler_isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    } // prettier-ignore
    // last block defined by default


    const defaults = dist_shared_esm_bundler_isArray(fallback) || !shared_esm_bundler_isPlainObject(fallback) ? fallback : fallback['default'] ? fallback['default'] : null; // convert defaults to array

    block = dist_shared_esm_bundler_isString(defaults) ? [defaults] : defaults;

    if (dist_shared_esm_bundler_isArray(block)) {
      appendBlockToChain(chain, block, false);
    }

    context.__localeChainCache.set(startLocale, chain);
  }

  return chain;
}

function appendBlockToChain(chain, block, blocks) {
  let follow = true;

  for (let i = 0; i < block.length && shared_esm_bundler_isBoolean(follow); i++) {
    const locale = block[i];

    if (dist_shared_esm_bundler_isString(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }

  return follow;
}

function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split('-');

  do {
    const target = tokens.join('-');
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);

  return follow;
}

function appendItemToChain(chain, target, blocks) {
  let follow = false;

  if (!chain.includes(target)) {
    follow = true;

    if (target) {
      follow = target[target.length - 1] !== '!';
      const locale = target.replace(/!/g, '');
      chain.push(locale);

      if ((dist_shared_esm_bundler_isArray(blocks) || shared_esm_bundler_isPlainObject(blocks)) && blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any
      ) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        follow = blocks[locale];
      }
    }
  }

  return follow;
}
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Intlify core-base version
 * @internal
 */


const VERSION = '9.2.2';
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = 'en-US';
const MISSING_RESOLVE_VALUE = '';

const core_base_esm_bundler_capitalize = str => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;

function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      // prettier-ignore
      return type === 'text' && dist_shared_esm_bundler_isString(val) ? val.toUpperCase() : type === 'vnode' && dist_shared_esm_bundler_isObject(val) && '__v_isVNode' in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      // prettier-ignore
      return type === 'text' && dist_shared_esm_bundler_isString(val) ? val.toLowerCase() : type === 'vnode' && dist_shared_esm_bundler_isObject(val) && '__v_isVNode' in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      // prettier-ignore
      return type === 'text' && dist_shared_esm_bundler_isString(val) ? core_base_esm_bundler_capitalize(val) : type === 'vnode' && dist_shared_esm_bundler_isObject(val) && '__v_isVNode' in val ? core_base_esm_bundler_capitalize(val.children) : val;
    }
  };
}

let _compiler;

function registerMessageCompiler(compiler) {
  _compiler = compiler;
}

let _resolver;
/**
 * Register the message resolver
 *
 * @param resolver - A {@link MessageResolver} function
 *
 * @VueI18nGeneral
 */


function registerMessageResolver(resolver) {
  _resolver = resolver;
}

let _fallbacker;
/**
 * Register the locale fallbacker
 *
 * @param fallbacker - A {@link LocaleFallbacker} function
 *
 * @VueI18nGeneral
 */


function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
} // Additional Meta for Intlify DevTools


let _additionalMeta = null;

const setAdditionalMeta = meta => {
  _additionalMeta = meta;
};

const getAdditionalMeta = () => _additionalMeta;

let _fallbackContext = null;

const setFallbackContext = context => {
  _fallbackContext = context;
};

const getFallbackContext = () => _fallbackContext; // ID for CoreContext


let _cid = 0;

function createCoreContext(options = {}) {
  // setup options
  const version = dist_shared_esm_bundler_isString(options.version) ? options.version : VERSION;
  const locale = dist_shared_esm_bundler_isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = dist_shared_esm_bundler_isArray(options.fallbackLocale) || shared_esm_bundler_isPlainObject(options.fallbackLocale) || dist_shared_esm_bundler_isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const messages = shared_esm_bundler_isPlainObject(options.messages) ? options.messages : {
    [locale]: {}
  };
  const datetimeFormats = shared_esm_bundler_isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {
    [locale]: {}
  };
  const numberFormats = shared_esm_bundler_isPlainObject(options.numberFormats) ? options.numberFormats : {
    [locale]: {}
  };
  const modifiers = shared_esm_bundler_assign({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = dist_shared_esm_bundler_isFunction(options.missing) ? options.missing : null;
  const missingWarn = shared_esm_bundler_isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = shared_esm_bundler_isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = dist_shared_esm_bundler_isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = shared_esm_bundler_isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = shared_esm_bundler_isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = dist_shared_esm_bundler_isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = dist_shared_esm_bundler_isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = dist_shared_esm_bundler_isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = dist_shared_esm_bundler_isObject(options.fallbackContext) ? options.fallbackContext : undefined;
  const onWarn = dist_shared_esm_bundler_isFunction(options.onWarn) ? options.onWarn : shared_esm_bundler_warn; // setup internal options

  const internalOptions = options;

  const __datetimeFormatters = dist_shared_esm_bundler_isObject(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : new Map();

  const __numberFormatters = dist_shared_esm_bundler_isObject(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : new Map();

  const __meta = dist_shared_esm_bundler_isObject(internalOptions.__meta) ? internalOptions.__meta : {};

  _cid++;
  const context = {
    version,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  } // for vue-devtools timeline event

  if (false) {} // NOTE: experimental !!


  if ( false || __INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version, __meta);
  }

  return context;
}
/** @internal */


function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
/** @internal */


function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
/** @internal */


function handleMissing(context, key, locale, missingWarn, type) {
  const {
    missing,
    onWarn
  } = context; // for vue-devtools timeline event

  if (false) {}

  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return dist_shared_esm_bundler_isString(ret) ? ret : key;
  } else {
    if (false) {}

    return key;
  }
}
/** @internal */


function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
/* eslint-enable @typescript-eslint/no-explicit-any */


const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
const WARN_MESSAGE = (/* unused pure expression or super */ null && (`Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`));

function checkHtmlMessage(source, options) {
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;

  if (warnHtmlMessage && RE_HTML_TAG.test(source)) {
    warn(format(WARN_MESSAGE, {
      source
    }));
  }
}

const defaultOnCacheKey = source => source;

let compileCache = Object.create(null);

function clearCompileCache() {
  compileCache = Object.create(null);
}

function compileToFunction(source, options = {}) {
  {
    // check HTML message
     false && 0; // check caches

    const onCacheKey = options.onCacheKey || defaultOnCacheKey;
    const key = onCacheKey(source);
    const cached = compileCache[key];

    if (cached) {
      return cached;
    } // compile error detecting


    let occurred = false;
    const onError = options.onError || defaultOnError;

    options.onError = err => {
      occurred = true;
      onError(err);
    }; // compile


    const {
      code
    } = baseCompile(source, options); // evaluate function

    const msg = new Function(`return ${code}`)(); // if occurred compile error, don't cache

    return !occurred ? compileCache[key] = msg : msg;
  }
}

let code = CompileErrorCodes.__EXTEND_POINT__;

const inc = () => ++code;

const CoreErrorCodes = {
  INVALID_ARGUMENT: code,
  INVALID_DATE_ARGUMENT: inc(),
  INVALID_ISO_DATE_ARGUMENT: inc(),
  __EXTEND_POINT__: inc() // 18

};

function createCoreError(code) {
  return createCompileError(code, null,  false ? 0 : undefined);
}
/** @internal */


const core_base_esm_bundler_errorMessages = {
  [CoreErrorCodes.INVALID_ARGUMENT]: 'Invalid arguments',
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: 'The date provided is an invalid Date object.' + 'Make sure your Date represents a valid date.',
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: 'The argument provided is not a valid ISO date string'
};

const NOOP_MESSAGE_FUNCTION = () => '';

const isMessageFunction = val => dist_shared_esm_bundler_isFunction(val); // implementation of `translate` function


function core_base_esm_bundler_translate(context, ...args) {
  const {
    fallbackFormat,
    postTranslation,
    unresolving,
    messageCompiler,
    fallbackLocale,
    messages
  } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = shared_esm_bundler_isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = shared_esm_bundler_isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = shared_esm_bundler_isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage; // prettier-ignore

  const defaultMsgOrKey = dist_shared_esm_bundler_isString(options.default) || shared_esm_bundler_isBoolean(options.default) // default by function option
  ? !shared_esm_bundler_isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat // default by `fallbackFormat` option
  ? !messageCompiler ? () => key : key : '';
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== '';
  const locale = dist_shared_esm_bundler_isString(options.locale) ? options.locale : context.locale; // escape params

  escapeParameter && escapeParams(options); // resolve message format
  // eslint-disable-next-line prefer-const

  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [key, locale, messages[locale] || {}]; // NOTE:
  //  Fix to work around `ssrTransfrom` bug in Vite.
  //  https://github.com/vitejs/vite/issues/4306
  //  To get around this, use temporary variables.
  //  https://github.com/nuxt/framework/issues/1461#issuecomment-954606243

  let format = formatScope; // if you use default message, set it as message format!

  let cacheBaseKey = key;

  if (!resolvedMessage && !(dist_shared_esm_bundler_isString(format) || isMessageFunction(format))) {
    if (enableDefaultMsg) {
      format = defaultMsgOrKey;
      cacheBaseKey = format;
    }
  } // checking message format and target locale


  if (!resolvedMessage && (!(dist_shared_esm_bundler_isString(format) || isMessageFunction(format)) || !dist_shared_esm_bundler_isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }

  if (false) {} // setup compile error detecting


  let occurred = false;

  const errorDetector = () => {
    occurred = true;
  }; // compile message format


  const msg = !isMessageFunction(format) ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) : format; // if occurred compile error, return the message format

  if (occurred) {
    return format;
  } // evaluate message with context


  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext); // if use post translation option, proceed it with handler

  const ret = postTranslation ? postTranslation(messaged, key) : messaged; // NOTE: experimental !!

  if ( false || __INTLIFY_PROD_DEVTOOLS__) {
    // prettier-ignore
    const payloads = {
      timestamp: Date.now(),
      key: dist_shared_esm_bundler_isString(key) ? key : isMessageFunction(format) ? format.key : '',
      locale: targetLocale || (isMessageFunction(format) ? format.locale : ''),
      format: dist_shared_esm_bundler_isString(format) ? format : isMessageFunction(format) ? format.source : '',
      message: ret
    };
    payloads.meta = shared_esm_bundler_assign({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }

  return ret;
}

function escapeParams(options) {
  if (dist_shared_esm_bundler_isArray(options.list)) {
    options.list = options.list.map(item => dist_shared_esm_bundler_isString(item) ? shared_esm_bundler_escapeHtml(item) : item);
  } else if (dist_shared_esm_bundler_isObject(options.named)) {
    Object.keys(options.named).forEach(key => {
      if (dist_shared_esm_bundler_isString(options.named[key])) {
        options.named[key] = shared_esm_bundler_escapeHtml(options.named[key]);
      }
    });
  }
}

function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const {
    messages,
    onWarn,
    messageResolver: resolveValue,
    localeFallbacker
  } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale); // eslint-disable-line @typescript-eslint/no-explicit-any

  let message = {};
  let targetLocale;
  let format = null;
  let from = locale;
  let to = null;
  const type = 'translate';

  for (let i = 0; i < locales.length; i++) {
    targetLocale = to = locales[i];

    if (false) {} // for vue-devtools timeline event


    if (false) {}

    message = messages[targetLocale] || {}; // for vue-devtools timeline event

    let start = null;
    let startTag;
    let endTag;

    if (false) {}

    if ((format = resolveValue(message, key)) === null) {
      // if null, resolve with object key path
      format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any
    } // for vue-devtools timeline event


    if (false) {}

    if (dist_shared_esm_bundler_isString(format) || dist_shared_esm_bundler_isFunction(format)) break;
    const missingRet = handleMissing(context, // eslint-disable-line @typescript-eslint/no-explicit-any
    key, targetLocale, missingWarn, type);

    if (missingRet !== key) {
      format = missingRet;
    }

    from = to;
  }

  return [format, targetLocale, message];
}

function compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {
  const {
    messageCompiler,
    warnHtmlMessage
  } = context;

  if (isMessageFunction(format)) {
    const msg = format;
    msg.locale = msg.locale || targetLocale;
    msg.key = msg.key || key;
    return msg;
  }

  if (messageCompiler == null) {
    const msg = () => format;

    msg.locale = targetLocale;
    msg.key = key;
    return msg;
  } // for vue-devtools timeline event


  let start = null;
  let startTag;
  let endTag;

  if (false) {}

  const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector)); // for vue-devtools timeline event

  if (false) {}

  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format;
  return msg;
}

function evaluateMessage(context, msg, msgCtx) {
  // for vue-devtools timeline event
  let start = null;
  let startTag;
  let endTag;

  if (false) {}

  const messaged = msg(msgCtx); // for vue-devtools timeline event

  if (false) {}

  return messaged;
}
/** @internal */


function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};

  if (!dist_shared_esm_bundler_isString(arg1) && !shared_esm_bundler_isNumber(arg1) && !isMessageFunction(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  } // prettier-ignore


  const key = shared_esm_bundler_isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;

  if (shared_esm_bundler_isNumber(arg2)) {
    options.plural = arg2;
  } else if (dist_shared_esm_bundler_isString(arg2)) {
    options.default = arg2;
  } else if (shared_esm_bundler_isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (dist_shared_esm_bundler_isArray(arg2)) {
    options.list = arg2;
  }

  if (shared_esm_bundler_isNumber(arg3)) {
    options.plural = arg3;
  } else if (dist_shared_esm_bundler_isString(arg3)) {
    options.default = arg3;
  } else if (shared_esm_bundler_isPlainObject(arg3)) {
    shared_esm_bundler_assign(options, arg3);
  }

  return [key, options];
}

function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
  return {
    warnHtmlMessage,
    onError: err => {
      errorDetector && errorDetector(err);

      if (false) {} else {
        throw err;
      }
    },
    onCacheKey: source => generateFormatCacheKey(locale, key, source)
  };
}

function getMessageContextOptions(context, locale, message, options) {
  const {
    modifiers,
    pluralRules,
    messageResolver: resolveValue,
    fallbackLocale,
    fallbackWarn,
    missingWarn,
    fallbackContext
  } = context;

  const resolveMessage = key => {
    let val = resolveValue(message, key); // fallback to root context

    if (val == null && fallbackContext) {
      const [,, message] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue(message, key);
    }

    if (dist_shared_esm_bundler_isString(val)) {
      let occurred = false;

      const errorDetector = () => {
        occurred = true;
      };

      const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      // TODO: should be implemented warning message
      return NOOP_MESSAGE_FUNCTION;
    }
  };

  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };

  if (context.processor) {
    ctxOptions.processor = context.processor;
  }

  if (options.list) {
    ctxOptions.list = options.list;
  }

  if (options.named) {
    ctxOptions.named = options.named;
  }

  if (shared_esm_bundler_isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }

  return ctxOptions;
}

const intlDefined = typeof Intl !== 'undefined';
const Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
  numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
}; // implementation of `datetime` function

function datetime(context, ...args) {
  const {
    datetimeFormats,
    unresolving,
    fallbackLocale,
    onWarn,
    localeFallbacker
  } = context;
  const {
    __datetimeFormatters
  } = context;

  if (false) {}

  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = shared_esm_bundler_isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = shared_esm_bundler_isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = dist_shared_esm_bundler_isString(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
  fallbackLocale, locale);

  if (!dist_shared_esm_bundler_isString(key) || key === '') {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  } // resolve format


  let datetimeFormat = {};
  let targetLocale;
  let format = null;
  let from = locale;
  let to = null;
  const type = 'datetime format';

  for (let i = 0; i < locales.length; i++) {
    targetLocale = to = locales[i];

    if (false) {} // for vue-devtools timeline event


    if (false) {}

    datetimeFormat = datetimeFormats[targetLocale] || {};
    format = datetimeFormat[key];
    if (shared_esm_bundler_isPlainObject(format)) break;
    handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any

    from = to;
  } // checking format and target locale


  if (!shared_esm_bundler_isPlainObject(format) || !dist_shared_esm_bundler_isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }

  let id = `${targetLocale}__${key}`;

  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }

  let formatter = __datetimeFormatters.get(id);

  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, shared_esm_bundler_assign({}, format, overrides));

    __datetimeFormatters.set(id, formatter);
  }

  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
/** @internal */


const DATETIME_FORMAT_OPTIONS_KEYS = ['localeMatcher', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName', 'formatMatcher', 'hour12', 'timeZone', 'dateStyle', 'timeStyle', 'calendar', 'dayPeriod', 'numberingSystem', 'hourCycle', 'fractionalSecondDigits'];
/** @internal */

function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value;

  if (dist_shared_esm_bundler_isString(arg1)) {
    // Only allow ISO strings - other date formats are often supported,
    // but may cause different results in different browsers.
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);

    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    } // Some browsers can not parse the iso datetime separated by space,
    // this is a compromise solution by replace the 'T'/' ' with 'T'


    const dateTime = matches[3] ? matches[3].trim().startsWith('T') ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);

    try {
      // This will fail if the date is not valid
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (shared_esm_bundler_isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }

    value = arg1;
  } else if (shared_esm_bundler_isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }

  if (dist_shared_esm_bundler_isString(arg2)) {
    options.key = arg2;
  } else if (shared_esm_bundler_isPlainObject(arg2)) {
    Object.keys(arg2).forEach(key => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }

  if (dist_shared_esm_bundler_isString(arg3)) {
    options.locale = arg3;
  } else if (shared_esm_bundler_isPlainObject(arg3)) {
    overrides = arg3;
  }

  if (shared_esm_bundler_isPlainObject(arg4)) {
    overrides = arg4;
  }

  return [options.key || '', value, options, overrides];
}
/** @internal */


function clearDateTimeFormat(ctx, locale, format) {
  const context = ctx;

  for (const key in format) {
    const id = `${locale}__${key}`;

    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }

    context.__datetimeFormatters.delete(id);
  }
} // implementation of `number` function


function number(context, ...args) {
  const {
    numberFormats,
    unresolving,
    fallbackLocale,
    onWarn,
    localeFallbacker
  } = context;
  const {
    __numberFormatters
  } = context;

  if (false) {}

  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = shared_esm_bundler_isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = shared_esm_bundler_isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = dist_shared_esm_bundler_isString(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
  fallbackLocale, locale);

  if (!dist_shared_esm_bundler_isString(key) || key === '') {
    return new Intl.NumberFormat(locale, overrides).format(value);
  } // resolve format


  let numberFormat = {};
  let targetLocale;
  let format = null;
  let from = locale;
  let to = null;
  const type = 'number format';

  for (let i = 0; i < locales.length; i++) {
    targetLocale = to = locales[i];

    if (false) {} // for vue-devtools timeline event


    if (false) {}

    numberFormat = numberFormats[targetLocale] || {};
    format = numberFormat[key];
    if (shared_esm_bundler_isPlainObject(format)) break;
    handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any

    from = to;
  } // checking format and target locale


  if (!shared_esm_bundler_isPlainObject(format) || !dist_shared_esm_bundler_isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }

  let id = `${targetLocale}__${key}`;

  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }

  let formatter = __numberFormatters.get(id);

  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, shared_esm_bundler_assign({}, format, overrides));

    __numberFormatters.set(id, formatter);
  }

  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
/** @internal */


const NUMBER_FORMAT_OPTIONS_KEYS = ['localeMatcher', 'style', 'currency', 'currencyDisplay', 'currencySign', 'useGrouping', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'compactDisplay', 'notation', 'signDisplay', 'unit', 'unitDisplay', 'roundingMode', 'roundingPriority', 'roundingIncrement', 'trailingZeroDisplay'];
/** @internal */

function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};

  if (!shared_esm_bundler_isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }

  const value = arg1;

  if (dist_shared_esm_bundler_isString(arg2)) {
    options.key = arg2;
  } else if (shared_esm_bundler_isPlainObject(arg2)) {
    Object.keys(arg2).forEach(key => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }

  if (dist_shared_esm_bundler_isString(arg3)) {
    options.locale = arg3;
  } else if (shared_esm_bundler_isPlainObject(arg3)) {
    overrides = arg3;
  }

  if (shared_esm_bundler_isPlainObject(arg4)) {
    overrides = arg4;
  }

  return [options.key || '', value, options, overrides];
}
/** @internal */


function clearNumberFormat(ctx, locale, format) {
  const context = ctx;

  for (const key in format) {
    const id = `${locale}__${key}`;

    if (!context.__numberFormatters.has(id)) {
      continue;
    }

    context.__numberFormatters.delete(id);
  }
} // TODO: we could not exports for Node native ES Moudles yet...


{
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {
    shared_esm_bundler_getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}

;// CONCATENATED MODULE: ./node_modules/vue-i18n/dist/vue-i18n.esm-bundler.js
/*!
  * vue-i18n v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */





/**
 * Vue I18n Version
 *
 * @remarks
 * Semver format. Same format as the package.json `version` field.
 *
 * @VueI18nGeneral
 */

const vue_i18n_esm_bundler_VERSION = '9.2.2';
/**
 * This is only called in esm-bundler builds.
 * istanbul-ignore-next
 */

function initFeatureFlags() {
  let needWarn = false;

  if (typeof __VUE_I18N_FULL_INSTALL__ !== 'boolean') {
    needWarn = true;
    shared_esm_bundler_getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }

  if (typeof __VUE_I18N_LEGACY_API__ !== 'boolean') {
    needWarn = true;
    shared_esm_bundler_getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }

  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {
    shared_esm_bundler_getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }

  if (false) {}
}

let code$1 = CoreWarnCodes.__EXTEND_POINT__;

const inc$1 = () => ++code$1;

const I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$1,
  NOT_SUPPORTED_PRESERVE: inc$1(),
  NOT_SUPPORTED_FORMATTER: inc$1(),
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  NOT_FOUND_PARENT_SCOPE: inc$1() // 13

};
const vue_i18n_esm_bundler_warnMessages = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`
};

function vue_i18n_esm_bundler_getWarnMessage(code, ...args) {
  return format(vue_i18n_esm_bundler_warnMessages[code], ...args);
}

let vue_i18n_esm_bundler_code = CompileErrorCodes.__EXTEND_POINT__;

const vue_i18n_esm_bundler_inc = () => ++vue_i18n_esm_bundler_code;

const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: vue_i18n_esm_bundler_code,
  // legacy module errors
  INVALID_ARGUMENT: vue_i18n_esm_bundler_inc(),
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: vue_i18n_esm_bundler_inc(),
  NOT_INSLALLED: vue_i18n_esm_bundler_inc(),
  NOT_AVAILABLE_IN_LEGACY_MODE: vue_i18n_esm_bundler_inc(),
  // directive module errors
  REQUIRED_VALUE: vue_i18n_esm_bundler_inc(),
  INVALID_VALUE: vue_i18n_esm_bundler_inc(),
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: vue_i18n_esm_bundler_inc(),
  NOT_INSLALLED_WITH_PROVIDE: vue_i18n_esm_bundler_inc(),
  // unexpected error
  UNEXPECTED_ERROR: vue_i18n_esm_bundler_inc(),
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: vue_i18n_esm_bundler_inc(),
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: vue_i18n_esm_bundler_inc(),
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: vue_i18n_esm_bundler_inc(),
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: vue_i18n_esm_bundler_inc(),
  // for enhancement
  __EXTEND_POINT__: vue_i18n_esm_bundler_inc() // 29

};

function createI18nError(code, ...args) {
  return createCompileError(code, null,  false ? 0 : undefined);
}

const vue_i18n_esm_bundler_errorMessages = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: 'Unexpected return type in composer',
  [I18nErrorCodes.INVALID_ARGUMENT]: 'Invalid argument',
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: 'Must be called at the top of a `setup` function',
  [I18nErrorCodes.NOT_INSLALLED]: 'Need to install with `app.use` function',
  [I18nErrorCodes.UNEXPECTED_ERROR]: 'Unexpected error',
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: 'Not available in legacy mode',
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE]: 'Need to install with `provide` function',
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: 'Not compatible legacy VueI18n.',
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: 'vue-i18n-bridge support Vue 2.x only',
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: 'Must define i18n option or custom block in Composition API with using local scope in Legacy API mode',
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: 'Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly'
};
const TransrateVNodeSymbol = /* #__PURE__*/shared_esm_bundler_makeSymbol('__transrateVNode');
const DatetimePartsSymbol = /* #__PURE__*/shared_esm_bundler_makeSymbol('__datetimeParts');
const NumberPartsSymbol = /* #__PURE__*/shared_esm_bundler_makeSymbol('__numberParts');
const EnableEmitter = /* #__PURE__*/(/* unused pure expression or super */ null && (makeSymbol('__enableEmitter')));
const DisableEmitter = /* #__PURE__*/(/* unused pure expression or super */ null && (makeSymbol('__disableEmitter')));
const SetPluralRulesSymbol = shared_esm_bundler_makeSymbol('__setPluralRules');
shared_esm_bundler_makeSymbol('__intlifyMeta');
const InejctWithOption = /* #__PURE__*/shared_esm_bundler_makeSymbol('__injectWithOption');
const __VUE_I18N_BRIDGE__ = '__VUE_I18N_BRIDGE__';
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Transform flat json in obj to normal json in obj
 */

function handleFlatJson(obj) {
  // check obj
  if (!dist_shared_esm_bundler_isObject(obj)) {
    return obj;
  }

  for (const key in obj) {
    // check key
    if (!dist_shared_esm_bundler_hasOwn(obj, key)) {
      continue;
    } // handle for normal json


    if (!key.includes('.')) {
      // recursive process value if value is also a object
      if (dist_shared_esm_bundler_isObject(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } // handle for flat json, transform to normal json
    else {
      // go to the last object
      const subKeys = key.split('.');
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;

      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }

        currentObj = currentObj[subKeys[i]];
      } // update last object value, delete old property


      currentObj[subKeys[lastIndex]] = obj[key];
      delete obj[key]; // recursive process value if value is also a object

      if (dist_shared_esm_bundler_isObject(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }

  return obj;
}

function getLocaleMessages(locale, options) {
  const {
    messages,
    __i18n,
    messageResolver,
    flatJson
  } = options; // prettier-ignore

  const ret = shared_esm_bundler_isPlainObject(messages) ? messages : dist_shared_esm_bundler_isArray(__i18n) ? {} : {
    [locale]: {}
  }; // merge locale messages of i18n custom block

  if (dist_shared_esm_bundler_isArray(__i18n)) {
    __i18n.forEach(custom => {
      if ('locale' in custom && 'resource' in custom) {
        const {
          locale,
          resource
        } = custom;

        if (locale) {
          ret[locale] = ret[locale] || {};
          deepCopy(resource, ret[locale]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        dist_shared_esm_bundler_isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  } // handle messages for flat json


  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (dist_shared_esm_bundler_hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }

  return ret;
}

const isNotObjectOrIsArray = val => !dist_shared_esm_bundler_isObject(val) || dist_shared_esm_bundler_isArray(val); // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


function deepCopy(src, des) {
  // src and des should both be objects, and non of then can be a array
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }

  for (const key in src) {
    if (dist_shared_esm_bundler_hasOwn(src, key)) {
      if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
        // replace with src[key] when:
        // src[key] or des[key] is not a object, or
        // src[key] or des[key] is a array
        des[key] = src[key];
      } else {
        // src[key] and des[key] are both object, merge them
        deepCopy(src[key], des[key]);
      }
    }
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getComponentOptions(instance) {
  return instance.type;
}

function adjustI18nResources(global, options, componentOptions // eslint-disable-line @typescript-eslint/no-explicit-any
) {
  let messages = dist_shared_esm_bundler_isObject(options.messages) ? options.messages : {};

  if ('__i18nGlobal' in componentOptions) {
    messages = getLocaleMessages(global.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  } // merge locale messages


  const locales = Object.keys(messages);

  if (locales.length) {
    locales.forEach(locale => {
      global.mergeLocaleMessage(locale, messages[locale]);
    });
  }

  {
    // merge datetime formats
    if (dist_shared_esm_bundler_isObject(options.datetimeFormats)) {
      const locales = Object.keys(options.datetimeFormats);

      if (locales.length) {
        locales.forEach(locale => {
          global.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    } // merge number formats


    if (dist_shared_esm_bundler_isObject(options.numberFormats)) {
      const locales = Object.keys(options.numberFormats);

      if (locales.length) {
        locales.forEach(locale => {
          global.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}

function createTextNode(key) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_root_Vue_.Text, null, key, 0);
}
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-disable @typescript-eslint/no-explicit-any */
// extend VNode interface


const DEVTOOLS_META = '__INTLIFY_META__';
let composerID = 0;

function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)() || undefined, type);
  };
} // for Intlify DevTools


const getMetaInfo = () => {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  let meta = null; // eslint-disable-line @typescript-eslint/no-explicit-any

  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? {
    [DEVTOOLS_META]: meta
  } // eslint-disable-line @typescript-eslint/no-explicit-any
  : null;
};
/**
 * Create composer interface factory
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function createComposer(options = {}, VueI18nLegacy) {
  const {
    __root
  } = options;

  const _isGlobal = __root === undefined;

  let _inheritLocale = shared_esm_bundler_isBoolean(options.inheritLocale) ? options.inheritLocale : true;

  const _locale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)( // prettier-ignore
  __root && _inheritLocale ? __root.locale.value : dist_shared_esm_bundler_isString(options.locale) ? options.locale : DEFAULT_LOCALE);

  const _fallbackLocale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)( // prettier-ignore
  __root && _inheritLocale ? __root.fallbackLocale.value : dist_shared_esm_bundler_isString(options.fallbackLocale) || dist_shared_esm_bundler_isArray(options.fallbackLocale) || shared_esm_bundler_isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);

  const _messages = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getLocaleMessages(_locale.value, options)); // prettier-ignore


  const _datetimeFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(shared_esm_bundler_isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {
    [_locale.value]: {}
  }); // prettier-ignore


  const _numberFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(shared_esm_bundler_isPlainObject(options.numberFormats) ? options.numberFormats : {
    [_locale.value]: {}
  }); // warning suppress options
  // prettier-ignore


  let _missingWarn = __root ? __root.missingWarn : shared_esm_bundler_isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true; // prettier-ignore


  let _fallbackWarn = __root ? __root.fallbackWarn : shared_esm_bundler_isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true; // prettier-ignore


  let _fallbackRoot = __root ? __root.fallbackRoot : shared_esm_bundler_isBoolean(options.fallbackRoot) ? options.fallbackRoot : true; // configure fall back to root


  let _fallbackFormat = !!options.fallbackFormat; // runtime missing


  let _missing = dist_shared_esm_bundler_isFunction(options.missing) ? options.missing : null;

  let _runtimeMissing = dist_shared_esm_bundler_isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null; // postTranslation handler


  let _postTranslation = dist_shared_esm_bundler_isFunction(options.postTranslation) ? options.postTranslation : null; // prettier-ignore


  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : shared_esm_bundler_isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;

  let _escapeParameter = !!options.escapeParameter; // custom linked modifiers
  // prettier-ignore


  const _modifiers = __root ? __root.modifiers : shared_esm_bundler_isPlainObject(options.modifiers) ? options.modifiers : {}; // pluralRules


  let _pluralRules = options.pluralRules || __root && __root.pluralRules; // runtime context
  // eslint-disable-next-line prefer-const


  let _context;

  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: vue_i18n_esm_bundler_VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? undefined : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? undefined : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      __meta: {
        framework: 'vue'
      }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = shared_esm_bundler_isPlainObject(_context) ? _context.__datetimeFormatters : undefined;
      ctxOptions.__numberFormatters = shared_esm_bundler_isPlainObject(_context) ? _context.__numberFormatters : undefined;
    }

    if (false) {}

    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };

  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value); // track reactivity

  function trackReactivityValues() {
    return [_locale.value, _fallbackLocale.value, _messages.value, _datetimeFormats.value, _numberFormats.value];
  } // locale


  const locale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get: () => _locale.value,
    set: val => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  }); // fallbackLocale

  const fallbackLocale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get: () => _fallbackLocale.value,
    set: val => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  }); // messages

  const messages = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _messages.value); // datetimeFormats

  const datetimeFormats = /* #__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _datetimeFormats.value); // numberFormats

  const numberFormats = /* #__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _numberFormats.value); // getPostTranslationHandler

  function getPostTranslationHandler() {
    return dist_shared_esm_bundler_isFunction(_postTranslation) ? _postTranslation : null;
  } // setPostTranslationHandler


  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  } // getMissingHandler


  function getMissingHandler() {
    return _missing;
  } // setMissingHandler


  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }

    _missing = handler;
    _context.missing = _runtimeMissing;
  }

  function isResolvedTranslateMessage(type, arg // eslint-disable-line @typescript-eslint/no-explicit-any
  ) {
    return type !== 'translate' || !arg.resolvedMessage;
  }

  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues(); // track reactive dependency
    // NOTE: experimental !!

    let ret;

    if ( false || __INTLIFY_PROD_DEVTOOLS__) {
      try {
        setAdditionalMeta(getMetaInfo());

        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : undefined;
        }

        ret = fn(_context);
      } finally {
        setAdditionalMeta(null);

        if (!_isGlobal) {
          _context.fallbackContext = undefined;
        }
      }
    } else {
      ret = fn(_context);
    }

    if (shared_esm_bundler_isNumber(ret) && ret === NOT_REOSLVED) {
      const [key, arg2] = argumentParser();

      if (false) {}

      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      /* istanbul ignore next */
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  }; // t


  function t(...args) {
    return wrapWithDeps(context => Reflect.apply(core_base_esm_bundler_translate, null, [context, ...args]), () => parseTranslateArgs(...args), 'translate', root => Reflect.apply(root.t, root, [...args]), key => key, val => dist_shared_esm_bundler_isString(val));
  } // rt


  function rt(...args) {
    const [arg1, arg2, arg3] = args;

    if (arg3 && !dist_shared_esm_bundler_isObject(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }

    return t(...[arg1, arg2, shared_esm_bundler_assign({
      resolvedMessage: true
    }, arg3 || {})]);
  } // d


  function d(...args) {
    return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', root => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, val => dist_shared_esm_bundler_isString(val));
  } // n


  function n(...args) {
    return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', root => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, val => dist_shared_esm_bundler_isString(val));
  } // for custom processor


  function normalize(values) {
    return values.map(val => dist_shared_esm_bundler_isString(val) || shared_esm_bundler_isNumber(val) || shared_esm_bundler_isBoolean(val) ? createTextNode(String(val)) : val);
  }

  const interpolate = val => val;

  const processor = {
    normalize,
    interpolate,
    type: 'vnode'
  }; // transrateVNode, using for `i18n-t` component

  function transrateVNode(...args) {
    return wrapWithDeps(context => {
      let ret;
      const _context = context;

      try {
        _context.processor = processor;
        ret = Reflect.apply(core_base_esm_bundler_translate, null, [_context, ...args]);
      } finally {
        _context.processor = null;
      }

      return ret;
    }, () => parseTranslateArgs(...args), 'translate', // eslint-disable-next-line @typescript-eslint/no-explicit-any
    root => root[TransrateVNodeSymbol](...args), key => [createTextNode(key)], val => dist_shared_esm_bundler_isArray(val));
  } // numberParts, using for `i18n-n` component


  function numberParts(...args) {
    return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', // eslint-disable-next-line @typescript-eslint/no-explicit-any
    root => root[NumberPartsSymbol](...args), () => [], val => dist_shared_esm_bundler_isString(val) || dist_shared_esm_bundler_isArray(val));
  } // datetimeParts, using for `i18n-d` component


  function datetimeParts(...args) {
    return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', // eslint-disable-next-line @typescript-eslint/no-explicit-any
    root => root[DatetimePartsSymbol](...args), () => [], val => dist_shared_esm_bundler_isString(val) || dist_shared_esm_bundler_isArray(val));
  }

  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  } // te


  function te(key, locale) {
    const targetLocale = dist_shared_esm_bundler_isString(locale) ? locale : _locale.value;
    const message = getLocaleMessage(targetLocale);
    return _context.messageResolver(message, key) !== null;
  }

  function resolveMessages(key) {
    let messages = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);

    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};

      const messageValue = _context.messageResolver(targetLocaleMessages, key);

      if (messageValue != null) {
        messages = messageValue;
        break;
      }
    }

    return messages;
  } // tm


  function tm(key) {
    const messages = resolveMessages(key); // prettier-ignore

    return messages != null ? messages : __root ? __root.tm(key) || {} : {};
  } // getLocaleMessage


  function getLocaleMessage(locale) {
    return _messages.value[locale] || {};
  } // setLocaleMessage


  function setLocaleMessage(locale, message) {
    _messages.value[locale] = message;
    _context.messages = _messages.value;
  } // mergeLocaleMessage


  function mergeLocaleMessage(locale, message) {
    _messages.value[locale] = _messages.value[locale] || {};
    deepCopy(message, _messages.value[locale]);
    _context.messages = _messages.value;
  } // getDateTimeFormat


  function getDateTimeFormat(locale) {
    return _datetimeFormats.value[locale] || {};
  } // setDateTimeFormat


  function setDateTimeFormat(locale, format) {
    _datetimeFormats.value[locale] = format;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale, format);
  } // mergeDateTimeFormat


  function mergeDateTimeFormat(locale, format) {
    _datetimeFormats.value[locale] = shared_esm_bundler_assign(_datetimeFormats.value[locale] || {}, format);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale, format);
  } // getNumberFormat


  function getNumberFormat(locale) {
    return _numberFormats.value[locale] || {};
  } // setNumberFormat


  function setNumberFormat(locale, format) {
    _numberFormats.value[locale] = format;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale, format);
  } // mergeNumberFormat


  function mergeNumberFormat(locale, format) {
    _numberFormats.value[locale] = shared_esm_bundler_assign(_numberFormats.value[locale] || {}, format);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale, format);
  } // for debug


  composerID++; // watch root locale & fallbackLocale

  if (__root && inBrowser) {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(__root.locale, val => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(__root.fallbackLocale, val => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  } // define basic composition API!


  const composer = {
    id: composerID,
    locale,
    fallbackLocale,

    get inheritLocale() {
      return _inheritLocale;
    },

    set inheritLocale(val) {
      _inheritLocale = val;

      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },

    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },

    messages,

    get modifiers() {
      return _modifiers;
    },

    get pluralRules() {
      return _pluralRules || {};
    },

    get isGlobal() {
      return _isGlobal;
    },

    get missingWarn() {
      return _missingWarn;
    },

    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },

    get fallbackWarn() {
      return _fallbackWarn;
    },

    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },

    get fallbackRoot() {
      return _fallbackRoot;
    },

    set fallbackRoot(val) {
      _fallbackRoot = val;
    },

    get fallbackFormat() {
      return _fallbackFormat;
    },

    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },

    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },

    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },

    get escapeParameter() {
      return _escapeParameter;
    },

    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },

    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOption] = options.__injectWithOption;
    composer[TransrateVNodeSymbol] = transrateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  } // for vue-devtools timeline event

  if (false) {}

  return composer;
}
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Convert to I18n Composer Options from VueI18n Options
 *
 * @internal
 */


function convertComposerOptions(options) {
  const locale = dist_shared_esm_bundler_isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = dist_shared_esm_bundler_isString(options.fallbackLocale) || dist_shared_esm_bundler_isArray(options.fallbackLocale) || shared_esm_bundler_isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = dist_shared_esm_bundler_isFunction(options.missing) ? options.missing : undefined;
  const missingWarn = shared_esm_bundler_isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = shared_esm_bundler_isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = shared_esm_bundler_isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = shared_esm_bundler_isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = dist_shared_esm_bundler_isFunction(options.postTranslation) ? options.postTranslation : undefined;
  const warnHtmlMessage = dist_shared_esm_bundler_isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== 'off' : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = shared_esm_bundler_isBoolean(options.sync) ? options.sync : true;

  if (false) {}

  if (false) {}

  let messages = options.messages;

  if (shared_esm_bundler_isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages, locale) => {
      const message = messages[locale] || (messages[locale] = {});
      shared_esm_bundler_assign(message, sharedMessages[locale]);
      return messages;
    }, messages || {});
  }

  const {
    __i18n,
    __root,
    __injectWithOption
  } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    __i18n,
    __root,
    __injectWithOption
  };
}
/**
 * create VueI18n interface factory
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options)); // defines VueI18n

    const vueI18n = {
      // id
      id: composer.id,

      // locale
      get locale() {
        return composer.locale.value;
      },

      set locale(val) {
        composer.locale.value = val;
      },

      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },

      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },

      // messages
      get messages() {
        return composer.messages.value;
      },

      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },

      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },

      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },

      // formatter
      get formatter() {
         false && 0; // dummy

        return {
          interpolate() {
            return [];
          }

        };
      },

      set formatter(val) {
         false && 0;
      },

      // missing
      get missing() {
        return composer.getMissingHandler();
      },

      set missing(handler) {
        composer.setMissingHandler(handler);
      },

      // silentTranslationWarn
      get silentTranslationWarn() {
        return shared_esm_bundler_isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },

      set silentTranslationWarn(val) {
        composer.missingWarn = shared_esm_bundler_isBoolean(val) ? !val : val;
      },

      // silentFallbackWarn
      get silentFallbackWarn() {
        return shared_esm_bundler_isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },

      set silentFallbackWarn(val) {
        composer.fallbackWarn = shared_esm_bundler_isBoolean(val) ? !val : val;
      },

      // modifiers
      get modifiers() {
        return composer.modifiers;
      },

      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },

      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },

      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },

      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },

      // sync
      get sync() {
        return composer.inheritLocale;
      },

      set sync(val) {
        composer.inheritLocale = val;
      },

      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? 'warn' : 'off';
      },

      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== 'off';
      },

      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },

      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },

      // preserveDirectiveContent
      get preserveDirectiveContent() {
         false && 0;
        return true;
      },

      set preserveDirectiveContent(val) {
         false && 0;
      },

      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },

      // for internal
      __composer: composer,

      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options = {};
        let list = null;
        let named = null;

        if (!dist_shared_esm_bundler_isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }

        const key = arg1;

        if (dist_shared_esm_bundler_isString(arg2)) {
          options.locale = arg2;
        } else if (dist_shared_esm_bundler_isArray(arg2)) {
          list = arg2;
        } else if (shared_esm_bundler_isPlainObject(arg2)) {
          named = arg2;
        }

        if (dist_shared_esm_bundler_isArray(arg3)) {
          list = arg3;
        } else if (shared_esm_bundler_isPlainObject(arg3)) {
          named = arg3;
        } // return composer.t(key, (list || named || {}) as any, options)


        return Reflect.apply(composer.t, composer, [key, list || named || {}, options]);
      },

      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },

      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options = {
          plural: 1
        };
        let list = null;
        let named = null;

        if (!dist_shared_esm_bundler_isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }

        const key = arg1;

        if (dist_shared_esm_bundler_isString(arg2)) {
          options.locale = arg2;
        } else if (shared_esm_bundler_isNumber(arg2)) {
          options.plural = arg2;
        } else if (dist_shared_esm_bundler_isArray(arg2)) {
          list = arg2;
        } else if (shared_esm_bundler_isPlainObject(arg2)) {
          named = arg2;
        }

        if (dist_shared_esm_bundler_isString(arg3)) {
          options.locale = arg3;
        } else if (dist_shared_esm_bundler_isArray(arg3)) {
          list = arg3;
        } else if (shared_esm_bundler_isPlainObject(arg3)) {
          named = arg3;
        } // return composer.t(key, (list || named || {}) as any, options)


        return Reflect.apply(composer.t, composer, [key, list || named || {}, options]);
      },

      // te
      te(key, locale) {
        return composer.te(key, locale);
      },

      // tm
      tm(key) {
        return composer.tm(key);
      },

      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },

      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },

      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },

      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },

      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },

      // setDateTimeFormat
      setDateTimeFormat(locale, format) {
        composer.setDateTimeFormat(locale, format);
      },

      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format) {
        composer.mergeDateTimeFormat(locale, format);
      },

      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },

      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },

      // setNumberFormat
      setNumberFormat(locale, format) {
        composer.setNumberFormat(locale, format);
      },

      // mergeNumberFormat
      mergeNumberFormat(locale, format) {
        composer.mergeNumberFormat(locale, format);
      },

      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
         false && 0;
        return -1;
      },

      // for internal
      __onComponentInstanceCreated(target) {
        const {
          componentInstanceCreatedListener
        } = options;

        if (componentInstanceCreatedListener) {
          componentInstanceCreatedListener(target, vueI18n);
        }
      }

    }; // for vue-devtools timeline event

    if (false) {}

    return vueI18n;
  }
}
/* eslint-enable @typescript-eslint/no-explicit-any */


const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val
    /* ComponetI18nScope */
    ) => val === 'parent' || val === 'global',
    default: 'parent'
    /* ComponetI18nScope */

  },
  i18n: {
    type: Object
  }
};

function getInterpolateArg( // eslint-disable-next-line @typescript-eslint/no-explicit-any
{
  slots
}, // SetupContext,
keys) {
  if (keys.length === 1 && keys[0] === 'default') {
    // default slot with list
    const ret = slots.default ? slots.default() : []; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    return ret.reduce((slot, current) => {
      return slot = [...slot, ...(dist_shared_esm_bundler_isArray(current.children) ? current.children : [current])];
    }, []);
  } else {
    // named slots
    return keys.reduce((arg, key) => {
      const slot = slots[key];

      if (slot) {
        arg[key] = slot();
      }

      return arg;
    }, {});
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getFragmentableTag(tag) {
  return external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment;
}
/**
 * Translation Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [TranslationProps](component#translationprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Component Interpolation](../guide/advanced/component)
 *
 * @example
 * ```html
 * <div id="app">
 *   <!-- ... -->
 *   <i18n path="term" tag="label" for="tos">
 *     <a :href="url" target="_blank">{{ $t('tos') }}</a>
 *   </i18n>
 *   <!-- ... -->
 * </div>
 * ```
 * ```js
 * import { createApp } from 'vue'
 * import { createI18n } from 'vue-i18n'
 *
 * const messages = {
 *   en: {
 *     tos: 'Term of Service',
 *     term: 'I accept xxx {0}.'
 *   },
 *   ja: {
 *     tos: '',
 *     term: ' xxx {0}'
 *   }
 * }
 *
 * const i18n = createI18n({
 *   locale: 'en',
 *   messages
 * })
 *
 * const app = createApp({
 *   data: {
 *     url: '/term'
 *   }
 * }).use(i18n).mount('#app')
 * ```
 *
 * @VueI18nComponent
 */


const Translation =
/* defineComponent */
{
  /* eslint-disable */
  name: 'i18n-t',
  props: shared_esm_bundler_assign({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: val => shared_esm_bundler_isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),

  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const {
      slots,
      attrs
    } = context; // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050

    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter(key => key !== '_');
      const options = {};

      if (props.locale) {
        options.locale = props.locale;
      }

      if (props.plural !== undefined) {
        options.plural = dist_shared_esm_bundler_isString(props.plural) ? +props.plural : props.plural;
      }

      const arg = getInterpolateArg(context, keys); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      const children = i18n[TransrateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = shared_esm_bundler_assign({}, attrs);
      const tag = dist_shared_esm_bundler_isString(props.tag) || dist_shared_esm_bundler_isObject(props.tag) ? props.tag : getFragmentableTag();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tag, assignedAttrs, children);
    };
  }

};

function vue_i18n_esm_bundler_isVNode(target) {
  return dist_shared_esm_bundler_isArray(target) && !dist_shared_esm_bundler_isString(target[0]);
}

function renderFormatter(props, context, slotKeys, partFormatter) {
  const {
    slots,
    attrs
  } = context;
  return () => {
    const options = {
      part: true
    };
    let overrides = {};

    if (props.locale) {
      options.locale = props.locale;
    }

    if (dist_shared_esm_bundler_isString(props.format)) {
      options.key = props.format;
    } else if (dist_shared_esm_bundler_isObject(props.format)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (dist_shared_esm_bundler_isString(props.format.key)) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        options.key = props.format.key;
      } // Filter out number format options only


      overrides = Object.keys(props.format).reduce((options, prop) => {
        return slotKeys.includes(prop) ? shared_esm_bundler_assign({}, options, {
          [prop]: props.format[prop]
        }) // eslint-disable-line @typescript-eslint/no-explicit-any
        : options;
      }, {});
    }

    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];

    if (dist_shared_esm_bundler_isArray(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({
          [part.type]: part.value,
          index,
          parts
        }) : [part.value];

        if (vue_i18n_esm_bundler_isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }

        return node;
      });
    } else if (dist_shared_esm_bundler_isString(parts)) {
      children = [parts];
    }

    const assignedAttrs = shared_esm_bundler_assign({}, attrs);
    const tag = dist_shared_esm_bundler_isString(props.tag) || dist_shared_esm_bundler_isObject(props.tag) ? props.tag : getFragmentableTag();
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tag, assignedAttrs, children);
  };
}
/**
 * Number Format Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [FormattableProps](component#formattableprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Custom Formatting](../guide/essentials/number#custom-formatting)
 *
 * @VueI18nDanger
 * Not supported IE, due to no support `Intl.NumberFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatToParts)
 *
 * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-numberformat)
 *
 * @VueI18nComponent
 */


const NumberFormat =
/* defineComponent */
{
  /* eslint-disable */
  name: 'i18n-n',
  props: shared_esm_bundler_assign({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),

  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: 'parent',
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => // eslint-disable-next-line @typescript-eslint/no-explicit-any
    i18n[NumberPartsSymbol](...args));
  }

};
/**
 * Datetime Format Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [FormattableProps](component#formattableprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Custom Formatting](../guide/essentials/datetime#custom-formatting)
 *
 * @VueI18nDanger
 * Not supported IE, due to no support `Intl.DateTimeFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts)
 *
 * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-datetimeformat)
 *
 * @VueI18nComponent
 */

const DatetimeFormat =
/*defineComponent */
{
  /* eslint-disable */
  name: 'i18n-d',
  props: shared_esm_bundler_assign({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),

  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: 'parent',
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => // eslint-disable-next-line @typescript-eslint/no-explicit-any
    i18n[DatetimePartsSymbol](...args));
  }

};

function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;

  if (i18n.mode === 'composition') {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);

    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}

function vTDirective(i18n) {
  const _process = binding => {
    const {
      instance,
      modifiers,
      value
    } = binding;
    /* istanbul ignore if */

    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    const composer = getComposer$2(i18n, instance.$);

    if (false) {}

    const parsedValue = parseValue(value);
    return [Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]), composer];
  };

  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);

    if (inBrowser && i18n.global === composer) {
      // global scope only
      el.__i18nWatcher = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }

    el.__composer = composer;
    el.textContent = textContent;
  };

  const unregister = el => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();

      el.__i18nWatcher = undefined;
      delete el.__i18nWatcher;
    }

    if (el.__composer) {
      el.__composer = undefined;
      delete el.__composer;
    }
  };

  const update = (el, {
    value
  }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]);
    }
  };

  const getSSRProps = binding => {
    const [textContent] = _process(binding);

    return {
      textContent
    };
  };

  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}

function parseValue(value) {
  if (dist_shared_esm_bundler_isString(value)) {
    return {
      path: value
    };
  } else if (shared_esm_bundler_isPlainObject(value)) {
    if (!('path' in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, 'path');
    }

    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}

function makeParams(value) {
  const {
    path,
    locale,
    args,
    choice,
    plural
  } = value;
  const options = {};
  const named = args || {};

  if (dist_shared_esm_bundler_isString(locale)) {
    options.locale = locale;
  }

  if (shared_esm_bundler_isNumber(choice)) {
    options.plural = choice;
  }

  if (shared_esm_bundler_isNumber(plural)) {
    options.plural = plural;
  }

  return [path, named, options];
}

function apply(app, i18n, ...options) {
  const pluginOptions = shared_esm_bundler_isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = shared_esm_bundler_isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;

  if (false) {}

  if (globalInstall) {
    // install components
    app.component(!useI18nComponentName ? Translation.name : 'i18n', Translation);
    app.component(NumberFormat.name, NumberFormat);
    app.component(DatetimeFormat.name, DatetimeFormat);
  } // install directive


  {
    app.directive('t', vTDirective(i18n));
  }
}

const VUE_I18N_COMPONENT_TYPES = 'vue-i18n: composer properties';
let devtoolsApi;

async function enableDevTools(app, i18n) {
  return new Promise((resolve, reject) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n"
        /* PLUGIN */
        ,
        label: VueDevToolsLabels["vue-devtools-plugin-vue-i18n"
        /* PLUGIN */
        ],
        packageName: 'vue-i18n',
        homepage: 'https://vue-i18n.intlify.dev',
        logo: 'https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png',
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app: app // eslint-disable-line @typescript-eslint/no-explicit-any

      }, api => {
        devtoolsApi = api;
        api.on.visitComponentTree(({
          componentInstance,
          treeNode
        }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n);
        });
        api.on.inspectComponent(({
          componentInstance,
          instanceData
        }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n.mode === 'legacy') {
              // ignore global scope on legacy mode
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api.addInspector({
          id: "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ,
          label: VueDevToolsLabels["vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ],
          icon: 'language',
          treeFilterPlaceholder: VueDevToolsPlaceholders["vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ]
        });
        api.on.getInspectorTree(payload => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ) {
            registerScope(payload, i18n);
          }
        });
        const roots = new Map();
        api.on.getInspectorState(async payload => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ) {
            api.unhighlightElement();
            inspectScope(payload, i18n);

            if (payload.nodeId === 'global') {
              if (!roots.has(payload.app)) {
                const [root] = await api.getComponentInstances(payload.app);
                roots.set(payload.app, root);
              }

              api.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n);
              instance && api.highlightElement(instance);
            }
          }
        });
        api.on.editInspectorState(payload => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ) {
            editScope(payload, i18n);
          }
        });
        api.addTimelineLayer({
          id: "vue-i18n-timeline"
          /* TIMELINE */
          ,
          label: VueDevToolsLabels["vue-i18n-timeline"
          /* TIMELINE */
          ],
          color: VueDevToolsTimelineColors["vue-i18n-timeline"
          /* TIMELINE */
          ]
        });
        resolve(true);
      });
    } catch (e) {
      console.error(e);
      reject(false);
    }
  });
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || 'Anonymous';
}

function updateComponentTreeTags(instance, // eslint-disable-line @typescript-eslint/no-explicit-any
treeNode, i18n) {
  // prettier-ignore
  const global = i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;

  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    // add custom tags local scope only
    if (instance.vnode.el.__VUE_I18N__ !== global) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0x000000,
        backgroundColor: 0xffcd19
      };
      treeNode.tags.push(tag);
    }
  }
}

function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: 'locale',
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: 'availableLocales',
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: 'fallbackLocale',
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: 'inheritLocale',
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: 'messages',
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: 'datetimeFormats',
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: 'numberFormats',
      editable: false,
      value: composer.numberFormats.value
    });
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getLocaleMessageValue(messages) {
  const value = {};
  Object.keys(messages).forEach(key => {
    const v = messages[key];

    if (isFunction(v) && 'source' in v) {
      value[key] = getMessageFunctionDetails(v);
    } else if (isObject(v)) {
      value[key] = getLocaleMessageValue(v);
    } else {
      value[key] = v;
    }
  });
  return value;
}

const ESC = {
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '&': '&amp;'
};

function vue_i18n_esm_bundler_escape(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}

function escapeChar(a) {
  return ESC[a] || a;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${vue_i18n_esm_bundler_escape(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: 'function',
      display: `<span></span> ${argString}`
    }
  };
}

function registerScope(payload, i18n) {
  payload.rootNodes.push({
    id: 'global',
    label: 'Global Scope'
  }); // prettier-ignore

  const global = i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;

  for (const [keyInstance, instance] of i18n.__instances) {
    // prettier-ignore
    const composer = i18n.mode === 'composition' ? instance : instance.__composer;

    if (global === composer) {
      continue;
    }

    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}

function getComponentInstance(nodeId, i18n) {
  let instance = null;

  if (nodeId !== 'global') {
    for (const [component, composer] of i18n.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component;
        break;
      }
    }
  }

  return instance;
}

function getComposer$1(nodeId, i18n) {
  if (nodeId === 'global') {
    return i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;
  } else {
    const instance = Array.from(i18n.__instances.values()).find(item => item.id.toString() === nodeId);

    if (instance) {
      return i18n.mode === 'composition' ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}

function inspectScope(payload, i18n // eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  const composer = getComposer$1(payload.nodeId, i18n);

  if (composer) {
    // TODO:
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    payload.state = makeScopeInspectState(composer);
  }

  return null;
}

function makeScopeInspectState(composer) {
  const state = {};
  const localeType = 'Locale related info';
  const localeStates = [{
    type: localeType,
    key: 'locale',
    editable: true,
    value: composer.locale.value
  }, {
    type: localeType,
    key: 'fallbackLocale',
    editable: true,
    value: composer.fallbackLocale.value
  }, {
    type: localeType,
    key: 'availableLocales',
    editable: false,
    value: composer.availableLocales
  }, {
    type: localeType,
    key: 'inheritLocale',
    editable: true,
    value: composer.inheritLocale
  }];
  state[localeType] = localeStates;
  const localeMessagesType = 'Locale messages info';
  const localeMessagesStates = [{
    type: localeMessagesType,
    key: 'messages',
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  }];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = 'Datetime formats info';
    const datetimeFormatsStates = [{
      type: datetimeFormatsType,
      key: 'datetimeFormats',
      editable: false,
      value: composer.datetimeFormats.value
    }];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = 'Datetime formats info';
    const numberFormatsStates = [{
      type: numberFormatsType,
      key: 'numberFormats',
      editable: false,
      value: composer.numberFormats.value
    }];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}

function addTimelineEvent(event, payload) {
  if (devtoolsApi) {
    let groupId;

    if (payload && 'groupId' in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }

    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline"
      /* TIMELINE */
      ,
      event: {
        title: event,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event === "compile-error"
        /* COMPILE_ERROR */
        ? 'error' : event === "fallback"
        /* FALBACK */
        || event === "missing"
        /* MISSING */
        ? 'warning' : 'default'
      }
    });
  }
}

function editScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);

  if (composer) {
    const [field] = payload.path;

    if (field === 'locale' && isString(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === 'fallbackLocale' && (isString(payload.state.value) || isArray(payload.state.value) || isObject(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === 'inheritLocale' && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
/**
 * Supports compatibility for legacy vue-i18n APIs
 * This mixin is used when we use vue-i18n@v9.x or later
 */


function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
      /* istanbul ignore if */

      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }

      const options = this.$options;

      if (options.i18n) {
        const optionsI18n = options.i18n;

        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }

        optionsI18n.__root = composer;

        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          this.$i18n = createVueI18n(optionsI18n);
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __root: composer
          });
        }
      } else {
        // set global
        this.$i18n = vuei18n;
      }

      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }

      vuei18n.__onComponentInstanceCreated(this.$i18n);

      i18n.__setInstance(instance, this.$i18n); // defines vue-i18n legacy APIs


      this.$t = (...args) => this.$i18n.t(...args);

      this.$rt = (...args) => this.$i18n.rt(...args);

      this.$tc = (...args) => this.$i18n.tc(...args);

      this.$te = (key, locale) => this.$i18n.te(key, locale);

      this.$d = (...args) => this.$i18n.d(...args);

      this.$n = (...args) => this.$i18n.n(...args);

      this.$tm = key => this.$i18n.tm(key);
    },

    mounted() {
      /* istanbul ignore if */
      if (false) {}
    },

    unmounted() {
      const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
      /* istanbul ignore if */

      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      /* istanbul ignore if */


      if (false) {}

      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;

      i18n.__deleteInstance(instance);

      delete this.$i18n;
    }

  };
}

function mergeToRoot(root, options) {
  root.locale = options.locale || root.locale;
  root.fallbackLocale = options.fallbackLocale || root.fallbackLocale;
  root.missing = options.missing || root.missing;
  root.silentTranslationWarn = options.silentTranslationWarn || root.silentFallbackWarn;
  root.silentFallbackWarn = options.silentFallbackWarn || root.silentFallbackWarn;
  root.formatFallbackMessages = options.formatFallbackMessages || root.formatFallbackMessages;
  root.postTranslation = options.postTranslation || root.postTranslation;
  root.warnHtmlInMessage = options.warnHtmlInMessage || root.warnHtmlInMessage;
  root.escapeParameterHtml = options.escapeParameterHtml || root.escapeParameterHtml;
  root.sync = options.sync || root.sync;

  root.__composer[SetPluralRulesSymbol](options.pluralizationRules || root.pluralizationRules);

  const messages = getLocaleMessages(root.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach(locale => root.mergeLocaleMessage(locale, messages[locale]));

  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach(locale => root.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }

  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach(locale => root.mergeNumberFormat(locale, options.numberFormats[locale]));
  }

  return root;
}
/**
 * Injection key for {@link useI18n}
 *
 * @remarks
 * The global injection key for I18n instances with `useI18n`. this injection key is used in Web Components.
 * Specify the i18n instance created by {@link createI18n} together with `provide` function.
 *
 * @VueI18nGeneral
 */


const I18nInjectionKey = /* #__PURE__*/shared_esm_bundler_makeSymbol('global-vue-i18n'); // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types

function createI18n(options = {}, VueI18nLegacy) {
  // prettier-ignore
  const __legacyMode = __VUE_I18N_LEGACY_API__ && shared_esm_bundler_isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__; // prettier-ignore


  const __globalInjection = shared_esm_bundler_isBoolean(options.globalInjection) ? options.globalInjection : true; // prettier-ignore


  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;

  const __instances = new Map();

  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = shared_esm_bundler_makeSymbol( false ? 0 : '');

  function __getInstance(component) {
    return __instances.get(component) || null;
  }

  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }

  function __deleteInstance(component) {
    __instances.delete(component);
  }

  {
    const i18n = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? 'legacy' : 'composition';
      },

      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },

      // install plugin
      async install(app, ...options) {
        if (false) {} // setup global provider


        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n); // global method and properties injection for Composition API

        if (!__legacyMode && __globalInjection) {
          injectGlobalFields(app, i18n.global);
        } // install built-in components and directive


        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options);
        } // setup mixin for Legacy API


        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        } // release global scope


        const unmountApp = app.unmount;

        app.unmount = () => {
          i18n.dispose();
          unmountApp();
        }; // setup vue-devtools plugin


        if (false) {}
      },

      // global accessor
      get global() {
        return __global;
      },

      dispose() {
        globalScope.stop();
      },

      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function useI18n(options = {}) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();

  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }

  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
  }

  const i18n = getI18nInstance(instance);
  const global = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);

  if (__VUE_I18N_LEGACY_API__) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (i18n.mode === 'legacy' && !options.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }

      return useI18nForLegacy(instance, scope, global, options);
    }
  }

  if (scope === 'global') {
    adjustI18nResources(global, options, componentOptions);
    return global;
  }

  if (scope === 'parent') {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let composer = getComposer(i18n, instance, options.__useComponent);

    if (composer == null) {
      if (false) {}

      composer = global;
    }

    return composer;
  }

  const i18nInternal = i18n;

  let composer = i18nInternal.__getInstance(instance);

  if (composer == null) {
    const composerOptions = shared_esm_bundler_assign({}, options);

    if ('__i18n' in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }

    if (global) {
      composerOptions.__root = global;
    }

    composer = createComposer(composerOptions);
    setupLifeCycle(i18nInternal, instance, composer);

    i18nInternal.__setInstance(instance, composer);
  }

  return composer;
}
/**
 * Cast to VueI18n legacy compatible type
 *
 * @remarks
 * This API is provided only with [vue-i18n-bridge](https://vue-i18n.intlify.dev/guide/migration/ways.html#what-is-vue-i18n-bridge).
 *
 * The purpose of this function is to convert an {@link I18n} instance created with {@link createI18n | createI18n(legacy: true)} into a `vue-i18n@v8.x` compatible instance of `new VueI18n` in a TypeScript environment.
 *
 * @param i18n - An instance of {@link I18n}
 * @returns A i18n instance which is casted to {@link VueI18n} type
 *
 * @VueI18nTip
 * :new: provided by **vue-i18n-bridge only**
 *
 * @VueI18nGeneral
 */


const castToVueI18n = (i18n // eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
  if (!(__VUE_I18N_BRIDGE__ in i18n)) {
    throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
  }

  return i18n;
};

function createGlobal(options, legacyMode, VueI18nLegacy // eslint-disable-line @typescript-eslint/no-explicit-any
) {
  const scope = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.effectScope)();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));

    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    return [scope, obj];
  }
}

function getI18nInstance(instance) {
  {
    const i18n = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    /* istanbul ignore if */

    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE);
    }

    return i18n;
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getScope(options, componentOptions) {
  // prettier-ignore
  return isEmptyObject(options) ? '__i18n' in componentOptions ? 'local' : 'global' : !options.useScope ? 'local' : options.useScope;
}

function getGlobalComposer(i18n) {
  // prettier-ignore
  return i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;
}

function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = target.parent;

  while (current != null) {
    const i18nInternal = i18n;

    if (i18n.mode === 'composition') {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);

        if (vueI18n != null) {
          composer = vueI18n.__composer;

          if (useComponent && composer && !composer[InejctWithOption] // eslint-disable-line @typescript-eslint/no-explicit-any
          ) {
            composer = null;
          }
        }
      }
    }

    if (composer != null) {
      break;
    }

    if (root === current) {
      break;
    }

    current = current.parent;
  }

  return composer;
}

function setupLifeCycle(i18n, target, composer) {
  let emitter = null;
  {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      // inject composer instance to DOM for intlify-devtools
      if (false) {}
    }, target);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      // remove composer instance from DOM for intlify-devtools
      if (false) {}

      i18n.__deleteInstance(target);
    }, target);
  }
}

function useI18nForLegacy(instance, scope, root, options = {} // eslint-disable-line @typescript-eslint/no-explicit-any
) {
  const isLocale = scope === 'local';

  const _composer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.shallowRef)(null);

  if (isLocale && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }

  const _inheritLocale = shared_esm_bundler_isBoolean(options.inheritLocale) ? options.inheritLocale : true;

  const _locale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)( // prettier-ignore
  isLocale && _inheritLocale ? root.locale.value : dist_shared_esm_bundler_isString(options.locale) ? options.locale : DEFAULT_LOCALE);

  const _fallbackLocale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)( // prettier-ignore
  isLocale && _inheritLocale ? root.fallbackLocale.value : dist_shared_esm_bundler_isString(options.fallbackLocale) || dist_shared_esm_bundler_isArray(options.fallbackLocale) || shared_esm_bundler_isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);

  const _messages = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(getLocaleMessages(_locale.value, options)); // prettier-ignore


  const _datetimeFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(shared_esm_bundler_isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {
    [_locale.value]: {}
  }); // prettier-ignore


  const _numberFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(shared_esm_bundler_isPlainObject(options.numberFormats) ? options.numberFormats : {
    [_locale.value]: {}
  }); // prettier-ignore


  const _missingWarn = isLocale ? root.missingWarn : shared_esm_bundler_isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true; // prettier-ignore


  const _fallbackWarn = isLocale ? root.fallbackWarn : shared_esm_bundler_isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true; // prettier-ignore


  const _fallbackRoot = isLocale ? root.fallbackRoot : shared_esm_bundler_isBoolean(options.fallbackRoot) ? options.fallbackRoot : true; // configure fall back to root


  const _fallbackFormat = !!options.fallbackFormat; // runtime missing


  const _missing = dist_shared_esm_bundler_isFunction(options.missing) ? options.missing : null; // postTranslation handler


  const _postTranslation = dist_shared_esm_bundler_isFunction(options.postTranslation) ? options.postTranslation : null; // prettier-ignore


  const _warnHtmlMessage = isLocale ? root.warnHtmlMessage : shared_esm_bundler_isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;

  const _escapeParameter = !!options.escapeParameter; // prettier-ignore


  const _modifiers = isLocale ? root.modifiers : shared_esm_bundler_isPlainObject(options.modifiers) ? options.modifiers : {}; // pluralRules


  const _pluralRules = options.pluralRules || isLocale && root.pluralRules; // track reactivity


  function trackReactivityValues() {
    return [_locale.value, _fallbackLocale.value, _messages.value, _datetimeFormats.value, _numberFormats.value];
  } // locale


  const locale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: val => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }

      _locale.value = val;
    }
  }); // fallbackLocale

  const fallbackLocale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: val => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }

      _fallbackLocale.value = val;
    }
  }); // messages

  const messages = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (_composer.value) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return _composer.value.messages.value;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return _messages.value;
    }
  });
  const datetimeFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _datetimeFormats.value);
  const numberFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _numberFormats.value);

  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }

  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }

  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }

  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }

  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }

  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => '');
  }

  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : '';
  }

  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => '');
  }

  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => '');
  }

  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }

  function te(key, locale) {
    return _composer.value ? _composer.value.te(key, locale) : false;
  }

  function getLocaleMessage(locale) {
    return _composer.value ? _composer.value.getLocaleMessage(locale) : {};
  }

  function setLocaleMessage(locale, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale, message);

      _messages.value[locale] = message;
    }
  }

  function mergeLocaleMessage(locale, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale, message);
    }
  }

  function getDateTimeFormat(locale) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale) : {};
  }

  function setDateTimeFormat(locale, format) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale, format);

      _datetimeFormats.value[locale] = format;
    }
  }

  function mergeDateTimeFormat(locale, format) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale, format);
    }
  }

  function getNumberFormat(locale) {
    return _composer.value ? _composer.value.getNumberFormat(locale) : {};
  }

  function setNumberFormat(locale, format) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale, format);

      _numberFormats.value[locale] = format;
    }
  }

  function mergeNumberFormat(locale, format) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale, format);
    }
  }

  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },

    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,

    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },

    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },

    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },

    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },

    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },

    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },

    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },

    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },

    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },

    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },

    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },

    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },

    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },

    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },

    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },

    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },

    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },

    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },

    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };

  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach(locale => {
      composer.mergeLocaleMessage(locale, _messages.value[locale]);
    });
    Object.keys(_datetimeFormats.value).forEach(locale => {
      composer.mergeDateTimeFormat(locale, _datetimeFormats.value[locale]);
    });
    Object.keys(_numberFormats.value).forEach(locale => {
      composer.mergeNumberFormat(locale, _numberFormats.value[locale]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeMount)(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any


    const composer = _composer.value = instance.proxy.$i18n.__composer;

    if (scope === 'global') {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocale) {
      sync(composer);
    }
  });
  return wrapper;
}

const globalExportProps = ['locale', 'fallbackLocale', 'availableLocales'];
const globalExportMethods = ['t', 'rt', 'd', 'n', 'tm'];

function injectGlobalFields(app, composer) {
  const i18n = Object.create(null);
  globalExportProps.forEach(prop => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);

    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    const wrap = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isRef)(desc.value) // check computed props
    ? {
      get() {
        return desc.value.value;
      },

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }

    } : {
      get() {
        return desc.get && desc.get();
      }

    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach(method => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);

    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
} // register message compiler at vue-i18n


registerMessageCompiler(compileToFunction); // register message resolver at vue-i18n

registerMessageResolver(resolveValue); // register fallback locale at vue-i18n

registerLocaleFallbacker(fallbackWithLocaleChain);
{
  initFeatureFlags();
} // NOTE: experimental !!

if ( false || __INTLIFY_PROD_DEVTOOLS__) {
  const target = shared_esm_bundler_getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}

if (false) {}

;// CONCATENATED MODULE: ./src/i18n/config/zh.js
/* harmony default export */ var zh = ({
  head: {
    nxcc: '',
    beginnersGuide: '',
    management: '',
    confirm: '',
    cancel: '',
    exitSuccessfully: '',
    successfullyModified: '',
    openAfterCall: '',
    closeAfterCall: '',
    openGuide: '',
    tokenExpired: ''
  },
  dashboard: {
    recentCalls: '',
    sInService: '',
    ended: '',
    hangUp: '',
    comment: '',
    save: '',
    edit: '',
    revisionHistory: '',
    viewCallLogs: '',
    nocalllogs: '',
    callLogs: '',
    noCrm: 'CRM',
    noNumber: '',
    enter: '',
    noBusiness: '',
    enterBusiness: '',
    notHavePermissionNumber: ''
  },
  sip: {
    noAgentInformation: '',
    noDialerInformation: '',
    noAgentAvailable: '',
    dialerInitialization: '',
    dialerFailedRegister: '',
    inCall: '',
    savedSuccessfully: '',
    free: '',
    busy: '',
    afterCall: '',
    equipmentDetection: '',
    logout: '',
    dailPad: '',
    dialing: '',
    dialerOverdue: '',
    notCountry: '',
    errNumber: '',
    networkError: '',
    registerSuccessfully: '',
    registrationFailed: '',
    errSymCode: `"#"`,
    enterNumber: '',
    rejected: '',
    newCall: '',
    dialer: '',
    minuteAgo: '',
    hourAgo: '',
    justNow: '',
    displayNumber: '',
    selectDisplayNumber: '',
    notSupportMic: '',
    isHaveMic: ',',
    newCalleeIn: '-',
    unknown: ''
  },
  record: {
    selectType: '',
    inboundCall: '',
    outboundCall: '',
    enterAgentGroupName: '',
    enteAgentAccount: '/',
    enterCalledId: '',
    enterCallerId: '',
    startingTime: '',
    endTime: '',
    selectCallTime: '',
    search: '',
    reset: '',
    download: '',
    time: '',
    callType: '',
    callerId: '',
    calledId: '',
    connectionStatus: '',
    queueStartTime: '',
    callStartTime: '',
    callEndTime: '',
    queueDuration: '(s)',
    callDuration: '(s)',
    audioFiles: '',
    audioGenerating: '',
    notSupportAudio: ' audio ',
    agentUsername: '',
    enterAgentNickname: '',
    agentAccount: '',
    agentGroup: '',
    selectAgentGroup: '',
    actions: '',
    callBack: '',
    redialBack: '',
    agentAccountEmial: '/',
    hangupReason: '',
    callStatus: ''
  },
  expenses: {
    agent: '',
    totalAmount: '(+)',
    totalDuration: '(s)',
    totalBillableDuration: '(s)',
    totalAmount: '',
    inboundCallAmount: '',
    inboundCallAnswering: '()',
    billableDuration: '(s)',
    amount: '',
    outboundCallAmount: '',
    OutboundCallAnswering: '()',
    transactionDetails: '',
    expenseDetails: ''
  },
  group: {
    add: '',
    agentGroupId: '',
    enterAgentGroupId: '',
    agentQuantity: '',
    description: '',
    enterDescription: '',
    created: '',
    edittingMembers: '',
    modify: '',
    delete: '',
    noAgentMembers: '',
    createdSuccessfully: '',
    updateSuccessfully: '',
    agentGroupMembers: '',
    deleteAgentGroup: '?',
    priorityAgentGroup: '',
    ringingStrategy: '',
    order: '',
    atTheSameTime: '',
    selectStrategy: ''
  },
  agent: {
    maximumAgents: `100`,
    agentEmail: '',
    bulkCreation: '',
    enterAgentEmail: '/',
    defaultCountry: '',
    availableCountries: '',
    agentAccessPoint: '',
    record: '',
    agentStatus: '',
    open: '',
    close: '',
    accountRole: '',
    password: '',
    resetPassword: '',
    customerServiceSpecialist: '',
    supervisor: '',
    administrator: '',
    selectDefaultCountry: '',
    afterSelectingTip: '',
    selectAvailableCountries: '',
    availableRangeAgent: '',
    selectAgentAccessPoint: '',
    makingCallAreaLine: '',
    recording: '',
    retentionPeriod: '',
    sevenDays: '7()',
    bulkImport: '',
    click: '',
    downlodTemplate: '',
    fillInFormat: '',
    uploadFiles: '',
    followFormatImport: '',
    onlyAvailable: 'xlxs',
    onlySingle: '',
    importUpTime: '100',
    upperBoundAgent: '',
    preview: '',
    confirmRecording: '',
    confirmOffRecording: '',
    hint: '',
    confirmAgentStatus: '',
    confirmEnableAgentStatus: '',
    randomPasswordOne: '',
    randomPasswordTwo: '',
    confirmDeleteAgent: '',
    uploadFileation: '',
    establish: '',
    sendingSucceeded: '',
    // 
    batchOperation: '',
    resetPassword: '',
    openAgent: '',
    closureAgent: '',
    addBatches: '',
    bulkInvitation: '',
    invite: '',
    theAgentFreeAgent: '660',
    agentQuantity: '',
    enterAgentQuantity: '',
    operationResult: '',
    bulkCreation: '',
    checkAccountPassword1: '',
    checkAccountPassword2: '',
    batchOpenedSuccessfully: '',
    batchClosedSuccessfully: '',
    resetResultMailbox1: '',
    resetResultMailbox2: '',
    selectAgentFirst: ''
  },
  quote: {
    callPricing: '',
    callPricingTip: '',
    country: '',
    selectCountry: '',
    countryCode: '',
    price: '(CNY)',
    billingCycle: ''
  },
  seeting: {
    sortingAfterAitting: '',
    customizeProcessing: '',
    second: '',
    blacklistedNumberTip: '',
    callFailureLimit: '',
    cannotNumber: ''
  },
  guide: {
    helpGuidance: '',
    guide1: '',
    guide1_1: '1. ',
    guide1_2: '2. ',
    guide1_3: '3. ',
    guide1_4: '4. ',
    guide2: '',
    guide2_1: '1. ',
    guide2_2: '1. ',
    guide2_3: '1. ',
    guide2_4: '2. ',
    guide2_5: '1. ',
    guide2_6: '2. ',
    guide2_7: '3. ',
    guide2_8: '4. ',
    guide2_9: '5. ',
    guide2_10: '6. ',
    guide2_11: '7. ',
    guide3: '',
    guide3_1: '1. ',
    guide3_2: '2. ',
    guide3_3: '3. ',
    guide3_4: '1. ',
    guide3_5: '2. ',
    guide4: '',
    guide4_1: '1. ',
    guide4_2: '2. ',
    guide4_3: '*',
    guide4_4: '',
    guide4_5: '',
    guide5: '',
    guide5_1: '1. ',
    guide5_2: '2. ',
    guide5_3: '3. ',
    guide6: '',
    guide6_1: '1. ',
    guide6_2: '2. ',
    guide6_3: '3. ',
    guide7: '',
    guide7_1: '1. ',
    guide7_2: '2. icon',
    guide7_3: '3. icon'
  },
  equipment: {
    ccMicTestingTitle: '',
    startTest: '',
    lineTest: '',
    deviceTest: '',
    browserTest: '',
    networkMonitoring: '',
    microphoneOption: ':',
    trySaying: '""',
    ableToSeeLine: '',
    speakerOption: ':',
    turnUpVolume: '',
    hearSound: '',
    microphone: '',
    normal: '',
    abnormal: '',
    yes: '',
    no: '',
    seeYesMicLine: '',
    seeNoMicLine: '',
    listenYesMicLine: '',
    listenNoMicLine: '',
    speaker: '',
    browsers: '',
    networkStatus: '',
    reCheck: '',
    copy: '',
    lineTest: '',
    deviceStatus: '',
    testTypes: '',
    // 1
    localMicrophone: '',
    theAudioSound: '',
    browserSupport: '',
    basicInformation: '',
    // 1
    operatingSystem: '',
    browser: '',
    screenResolution: '',
    numberProcessors: '',
    apiSupport: 'API ',
    webrtcSupport: ' WebRTC',
    webAudioSupport: ' WebAudio',
    webSocketSupport: ' WebSocket',
    availableDevices: '',
    whetherAuthorizeMicrophone: '',
    microphoneDevice: '',
    speakerDevice: '',
    networkstatus: '',
    apiTesting: 'API ',
    networkNormal: '',
    networkError: '',
    webSocketConnectionTest: 'WebSocket ',
    connectionNormal: '',
    connectionError: '',
    currentMicrophoneDevice: '',
    notSupportMicrophone: '',
    checkWhetherMicrophone: ',',
    copiedSuccessfully: '',
    ccMicTesting: ''
  },
  statis: {
    productivityStatistics: '',
    statusStatistics: '',
    inboundCall: '',
    inboundCallMissed: '',
    inboundCallAnswered: '',
    inboundCallAnsweredRate: '',
    outboundCall: '',
    outboundCallMissed: '',
    outboundCallAnswered: '',
    outboundCallAnsweredRate: '',
    statusDuration: '',
    onlineDuration: '',
    idleDuration: '',
    busyDuration: '',
    dialedDuration: '',
    queueDuration: ':',
    callStrategy: '',
    inboundMissedCallsList: '',
    outboundCallAnsweredRateCallsList: '',
    ringstarttime: '',
    ringendtime: '',
    ringingduration: '(s)'
  }
});
;// CONCATENATED MODULE: ./src/i18n/config/en.js
/* harmony default export */ var config_en = ({
  head: {
    nxcc: 'NXCC',
    beginnersGuide: 'Beginners Guide',
    management: 'Management',
    confirm: 'Confirm',
    cancel: 'cancel',
    exitSuccessfully: 'exit successfully',
    successfullyModified: 'Successfully modified',
    openAfterCall: 'Enabling the After-call Work refers to the busy status will be opened by default when a dialer ends a calling and switch to the free status after the after-call work is finished.',
    closeAfterCall: 'Disable the After-call Work',
    openGuide: 'Click here to open the Beginners Guide',
    tokenExpired: 'Login has expired, please login again!'
  },
  dashboard: {
    recentCalls: 'Recent Calls',
    sInService: 'SIn Service',
    ended: 'Ended',
    hangUp: 'Hang up',
    comment: 'Comment',
    save: 'Save',
    edit: 'Edit',
    revisionHistory: 'Revision history',
    viewCallLogs: 'View Call Logs',
    nocalllogs: 'No call logs',
    callLogs: 'Call Logs',
    noCrm: 'Not connection with CRM',
    noNumber: 'The record has no number',
    enter: 'Enter',
    noBusiness: 'No business record',
    enterBusiness: 'Please enter comment',
    notHavePermissionNumber: 'You do not have permission to dial this number'
  },
  sip: {
    noAgentInformation: 'No agent information',
    noDialerInformation: 'No dialer information',
    noAgentAvailable: 'No agent available',
    dialerInitialization: 'The dialer is in the initialization.',
    dialerFailedRegister: 'The dialer failed to register.',
    inCall: 'In a call',
    savedSuccessfully: 'Saved successfully',
    free: 'Free',
    busy: 'Busy',
    afterCall: 'After-call',
    equipmentDetection: 'Equipment detection',
    logout: 'Log out',
    dailPad: 'Dail Pad',
    dialing: 'Dialing',
    dialerOverdue: 'The dialer is overdue',
    notCountry: 'The calling country is not available.',
    errNumber: 'Incorrect number',
    networkError: 'Network Error',
    registerSuccessfully: 'Register Successfully',
    registrationFailed: 'registration failed',
    errSymCode: 'The number contains an illegal symbol ("#")',
    enterNumber: 'please enter the number',
    rejected: 'Rejected',
    newCall: 'New call',
    dialer: 'Dialer',
    minuteAgo: ' minute ago',
    hourAgo: ' hour ago',
    justNow: ' just now',
    displayNumber: 'call display number',
    selectDisplayNumber: 'Select call display number',
    notSupportMic: 'The browser does not support microphones, please change the browser',
    isHaveMic: 'Check for the presence of a microphone and go to your browser settings to check if it is turned on or consult a technician',
    newCalleeIn: 'You have a new call - NXCLOUD Call Center',
    unknown: 'unknown'
  },
  record: {
    selectType: 'Please select a call type',
    inboundCall: 'InboundCall',
    outboundCall: 'OutboundCall',
    enterAgentGroupName: 'Enteranagentgroupname',
    enteAgentAccount: 'EnterAgent Email / Agent Account',
    enterCalledId: 'Enteran called ID',
    enterCallerId: 'Enteran caller ID',
    startingTime: 'Starting Time',
    endTime: 'End Time',
    selectCallTime: 'Please select a call time',
    search: 'Search',
    reset: 'Reset',
    download: 'Download',
    time: 'Time',
    callType: 'CallType',
    callerId: 'Caller ID',
    calledId: 'Called ID',
    connectionStatus: 'Connection Status',
    queueStartTime: 'Queue start time',
    callStartTime: 'Call start time',
    callEndTime: 'Call end time',
    queueDuration: 'Queue Duration (Sec.)',
    callDuration: 'Call Duration (Sec.)',
    audioFiles: 'Audio files',
    audioGenerating: 'The audio file is in generating.',
    notSupportAudio: 'Your browser does not support the audio file.',
    agentUsername: 'Agent Username',
    enterAgentNickname: 'Enter an Agent name',
    agentAccount: 'Agent account',
    agentGroup: 'Agentgroup',
    selectAgentGroup: 'Please select an agent group',
    actions: 'Actions',
    callBack: 'Call Back',
    redialBack: 'Redial',
    agentAccountEmial: 'Agent Email / Agent Account',
    hangupReason: 'Hang up reason',
    callStatus: 'Call Status'
  },
  expenses: {
    agent: 'Agent',
    totalAmount: 'Total Amount (both inbound and outbound calls)',
    totalDuration: 'Total Duration (Sec.)',
    totalBillableDuration: 'Total Billable Duration (Sec.)',
    totalAmount: 'TotalAmount(CNY)',
    inboundCallAmount: 'InboundCall amount',
    inboundCallAnswering: 'Inbound Call Answering Duration (Sec.)',
    billableDuration: 'BillableDuration(Sec.)',
    amount: 'Amount(CNY)',
    outboundCallAmount: 'OutboundCall amount',
    OutboundCallAnswering: 'OutboundCall answering timeSec.)',
    billableDuration: 'BillableDuration(Sec.)',
    transactionDetails: 'Transaction Details',
    expenseDetails: 'Expense Details'
  },
  group: {
    add: 'Add',
    agentGroupId: 'AgentGroupID',
    enterAgentGroupId: 'Enter an Agent Group ID',
    agentQuantity: 'Agent Quantity',
    description: 'Description',
    enterDescription: 'Enter comments',
    created: 'Created',
    edittingMembers: 'Editting Members',
    modify: 'Modify',
    delete: 'Delete',
    noAgentMembers: 'No agent members in this group',
    createdSuccessfully: 'Created successfully',
    updateSuccessfully: 'Updated Successfully',
    agentGroupMembers: 'Agent group members',
    deleteAgentGroup: 'Please confirm whether to delete the agent group?',
    deletedSuccessfully: 'Deleted Successfully',
    priorityAgentGroup: 'A served customer takes priority to the member of the Agent Group',
    ringingStrategy: 'Ringing strategy',
    order: 'order',
    atTheSameTime: 'at the same time',
    selectStrategy: 'Please select a ringing strategy'
  },
  agent: {
    maximumAgents: `Agent limit: 100 seats are free for a limited time.`,
    agentEmail: 'Agent Email',
    bulkCreation: 'Bulk Creation',
    enterAgentEmail: 'Please enter the Agent Email / Agent Account',
    defaultCountry: 'Default country',
    availableCountries: 'Available Countries',
    agentAccessPoint: 'Agent Access Point',
    record: 'Record',
    agentStatus: 'Agent status',
    open: 'open',
    close: 'close',
    accountRole: 'Account role',
    password: 'Password',
    resetPassword: 'Reset Password',
    customerServiceSpecialist: 'Customer Service Specialist',
    supervisor: 'Supervisor',
    administrator: 'Administrator',
    selectDefaultCountry: 'Please select a default country',
    afterSelectingTip: 'After selecting the default country, dialing this country number can be done without the country code',
    selectAvailableCountries: 'Please select available countries',
    availableRangeAgent: 'The available range of making calls countries for the Agent.',
    selectAgentAccessPoint: 'Please select an agent access point',
    makingCallAreaLine: 'Making a call by a designated area line',
    recording: 'recording',
    retentionPeriod: 'Retention Period',
    sevenDays: '7 days (free)',
    bulkImport: 'Bulk Import',
    click: 'Click',
    downlodTemplate: 'Downlod/Import Template',
    fillInFormat: 'Fill in the content by the template format',
    uploadFiles: 'upload files',
    followFormatImport: 'Please follow the template format to import',
    onlyAvailable: 'Only available for xlsx. file format',
    onlySingle: 'Only a single file at a time to import',
    importUpTime: 'The import of agent information is up to 100 at a time.',
    upperBoundAgent: 'The excess agents will be off by default when the imported quantity is out of the upper bound of the agent. ',
    preview: 'Preview',
    confirmRecording: 'Please confirm whether to ',
    confirmOffRecording: ' recording',
    hint: 'hint',
    confirmAgentStatus: 'Please confirm whether to ',
    confirmEnableAgentStatus: ' the agent status',
    randomPasswordOne: `The system will send an email with a random password to the Agent's email(`,
    randomPasswordTwo: `), while the old password will be invalid. Please confirm whether to reset the password.`,
    confirmDeleteAgent: 'Please confirm whether to delete the agent',
    uploadFileation: 'Please upload the file',
    establish: 'Establish',
    sendingSucceeded: 'Sending succeeded',
    // 
    batchOperation: 'Batch operation',
    resetPassword: 'Reset Password',
    openAgent: 'Open Agent',
    closureAgent: 'Closure Agent',
    addBatches: 'Add in batches',
    bulkInvitation: 'Bulk invitation',
    invite: 'Invite',
    theAgentFreeAgent: 'The Agent is free for 6 months within a limited time, which has saved you 60 CNY per Agent',
    agentQuantity: 'Agent Quantity',
    enterAgentQuantity: 'Enter an agent Quantity',
    operationResult: 'Operation result',
    bulkCreation: 'Bulk Creation',
    checkAccountPassword1: 'The batch creation is successful, please check the account password in the mailbox of (',
    checkAccountPassword2: ')',
    batchOpenedSuccessfully: 'Batch opened successfully',
    batchClosedSuccessfully: 'Batch closed successfully',
    resetResultMailbox1: 'The reset is successful, please check the result in the mailbox of (',
    resetResultMailbox2: ')',
    selectAgentFirst: 'Please select a  agent first',
    agentLimitTime: 'Agent limit: 100 seats are free for a limited time.'
  },
  quote: {
    callPricing: 'Call Pricing',
    callPricingTip: 'The call pricing is real-time updating and adjusting in the actual situation.',
    country: 'Country',
    selectCountry: 'Please select a country',
    countryCode: 'Country code',
    price: 'Price(CNY)',
    billingCycle: 'Bill Type'
  },
  seeting: {
    sortingAfterAitting: 'After-call ',
    customizeProcessing: 'Time-gap Setting',
    second: 'Second'
  },
  guide: {
    helpGuidance: 'Help and guidance',
    guide1: 'Open the call-center service',
    guide1_1: '1. After login the Middle-Office, please select the User from the left hand side menu.',
    guide1_2: '2. Click the edit button on the right side and select the user you need to edit permission.',
    guide1_3: '3. Check the box, then help the user to open the call-center permission.',
    guide1_4: '4. Select a role for the user in the call-center, then click the confirm button to complete the operation',
    guide2: 'Creating Agents',
    guide2_1: '1. Click the top right button and then select NXCC.',
    guide2_2: '1. Select the Management-Side on the top bar menu.',
    guide2_3: '1. Select the AgentsManagement section.',
    guide2_4: '2. Then click the top right button, "Add"',
    guide2_5: '1. Enter an agent email you need to invite',
    guide2_6: `2. You can assign it to the Agent Group, which has already been created previously. If you don't select an Agent Group, the Agent won't be assigned when calling.`,
    guide2_7: '3. Select the default country for this Agent, which refers to dialing this country number, can be done without the country code.',
    guide2_8: '4. Select the available countries for the Agent, which refers to the range of countries for available dialing.',
    guide2_9: '5. Select the agent access point, which refers to the system access point by default but supports modifying manually.',
    guide2_10: '6. You can enable the Recording, which refers to all calls generated the audio files and can view the Call Logs.',
    guide2_11: '7. If the invite email exists as in the Team, it will generate an Agent. Otherwise, it needs to join the invite link first.',
    guide3: 'Creating Agent Groups',
    guide3_1: '1. Select the Agent GroupManagement section.',
    guide3_2: '2. Then click the top right button, "Add" pop up.',
    guide3_3: '3. Enter an agent group name, type in the description then click the Create button to finish the creation.',
    guide3_4: '1. Click the button Edit Members from the right side.',
    guide3_5: '2. Add a member to this Agent Group and complete to add.',
    guide4: 'Switch the Status',
    guide4_1: '1. Click the top right button to switch the status.',
    guide4_2: '2. Select the Free status',
    guide4_3: '*Only in the Free status can be in a polling call.',
    guide4_4: `It won't receive the call in the Busy status.`,
    guide4_5: `But outbound calls won't be impacted by the status.`,
    guide5: 'Call testing',
    guide5_1: '1. Click the top right button to open the Setting List.',
    guide5_2: '2. Select a device to test, which means the system will automatically call the test phone number.',
    guide5_3: '3. The audio will play when the call is picked up, and you can speak on the phone after listening to the beep, and if you can hear your voice, which refers to the dialer line is normal.',
    guide6: 'Making the outbound call',
    guide6_1: '1. Click the dial pad section on the top bar menu.',
    guide6_2: '2. Enter the phone number on the dial pad.',
    guide6_3: '3. Click the Dial icon to an outbound call.',
    guide7: 'Receive incoming calls',
    guide7_1: '1. A call hint will pop up on the right side if a new incoming call comes out.',
    guide7_2: '2. Click the green phone icon to pick up the call.',
    guide7_3: '3. Click the red phone icon to reject the call.'
  },
  equipment: {
    ccMicTestingTitle: 'NXCC Mic Testing',
    startTest: 'Start Test',
    lineTest: 'Line Test',
    deviceTest: 'Device Test',
    browserTest: 'Browser Test',
    networkMonitoring: 'Network monitoring',
    microphoneOption: 'Microphone Option',
    trySaying: 'Try saying "hello" into the microphone~',
    ableToSeeLine: 'Would be able to see a line moving up & down in the test box area?',
    speakerOption: 'Speaker Option',
    turnUpVolume: 'Please click to play the audio to turn up the volume',
    hearSound: 'Can you hear the sound',
    microphone: 'Microphone',
    normal: 'Normal',
    abnormal: 'Abnormal',
    yes: 'yes',
    no: 'no',
    seeYesMicLine: 'yes',
    seeNoMicLine: 'no',
    listenYesMicLine: 'yes',
    listenNoMicLine: 'no',
    speaker: 'Speaker',
    browsers: 'Browsers',
    networkStatus: 'Network status',
    reCheck: 'Re-check',
    copy: 'Copy',
    lineTest: 'Line Test',
    deviceStatus: 'Device status',
    testTypes: 'Test types',
    localMicrophone: 'Local microphone',
    theAudioSound: 'The audio sound',
    browserSupport: 'Browser support',
    basicInformation: 'Basic Information',
    operatingSystem: 'Operating system',
    browser: 'Browser',
    screenResolution: 'Screen Resolution',
    numberProcessors: 'Number of logical processors',
    apiSupport: 'API support',
    webrtcSupport: 'WebRTC Support',
    webAudioSupport: 'WebAudio Support',
    webSocketSupport: 'WebSocket Support',
    availableDevices: 'Available devices',
    whetherAuthorizeMicrophone: 'Whether to authorize the use of the microphone',
    microphoneDevice: 'Microphone Device',
    speakerDevice: 'Speaker Device',
    networkstatus: 'Network status',
    apiTesting: 'API testing',
    networkNormal: 'The network is normal, the delay is ',
    networkError: 'Network Error',
    webSocketConnectionTest: 'WebSocket connection test',
    connectionNormal: 'Normal',
    connectionError: 'Connection Error',
    currentMicrophoneDevice: 'Current Microphone Device',
    notSupportMicrophone: 'The browser does not support the microphone, please change the browser',
    checkWhetherMicrophone: 'Please check whether there is a microphone, and go to the browser settings to check whether it is turned on or consult a technical staff',
    copiedSuccessfully: 'Copied successfully',
    ccMicTesting: 'ccMicTesting'
  },
  statis: {
    productivityStatistics: 'ProductivityStatistics',
    statusStatistics: 'StatusStatistics',
    inboundCall: 'InboundCall',
    inboundCallMissed: 'InboundCall Missed',
    inboundCallAnswered: 'InboundCallAnswered',
    inboundCallAnsweredRate: 'InboundCallAnsweredRate',
    outboundCall: 'OutboundCall',
    outboundCallMissed: 'OutboundCall Missed',
    outboundCallAnswered: 'OutboundCallAnswered',
    outboundCallAnsweredRate: 'OutboundCallAnsweredRate',
    statusDuration: 'StatusDuration',
    onlineDuration: 'OnlineDuration',
    idleDuration: 'IdleDuration',
    busyDuration: 'BusyDuration',
    dialedDuration: 'DialedDuration',
    queueDuration: 'queue Duration:',
    callStrategy: 'Call Strategy',
    inboundMissedCallsList: 'Inbound Missed Calls List',
    outboundCallAnsweredRateCallsList: 'Outbound Missed Calls List',
    ringstarttime: 'Ring start time',
    ringendtime: 'Ring end time',
    ringingduration: 'Ringing durationSec.)'
  }
});
;// CONCATENATED MODULE: ./node_modules/js-cookie/dist/js.cookie.mjs
/*! js-cookie v3.0.1 | MIT */

/* eslint-disable no-var */
function js_cookie_assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      target[key] = source[key];
    }
  }

  return target;
}
/* eslint-enable no-var */

/* eslint-disable no-var */


var defaultConverter = {
  read: function (value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }

    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function (value) {
    return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
  }
};
/* eslint-enable no-var */

/* eslint-disable no-var */

function init(converter, defaultAttributes) {
  function set(key, value, attributes) {
    if (typeof document === 'undefined') {
      return;
    }

    attributes = js_cookie_assign({}, defaultAttributes, attributes);

    if (typeof attributes.expires === 'number') {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }

    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }

    key = encodeURIComponent(key).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = '';

    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }

      stringifiedAttributes += '; ' + attributeName;

      if (attributes[attributeName] === true) {
        continue;
      } // Considers RFC 6265 section 5.2:
      // ...
      // 3.  If the remaining unparsed-attributes contains a %x3B (";")
      //     character:
      // Consume the characters of the unparsed-attributes up to,
      // not including, the first %x3B (";") character.
      // ...


      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    }

    return document.cookie = key + '=' + converter.write(value, key) + stringifiedAttributes;
  }

  function get(key) {
    if (typeof document === 'undefined' || arguments.length && !key) {
      return;
    } // To prevent the for loop in the first place assign an empty array
    // in case there are no cookies at all.


    var cookies = document.cookie ? document.cookie.split('; ') : [];
    var jar = {};

    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split('=');
      var value = parts.slice(1).join('=');

      try {
        var foundKey = decodeURIComponent(parts[0]);
        jar[foundKey] = converter.read(value, foundKey);

        if (key === foundKey) {
          break;
        }
      } catch (e) {}
    }

    return key ? jar[key] : jar;
  }

  return Object.create({
    set: set,
    get: get,
    remove: function (key, attributes) {
      set(key, '', js_cookie_assign({}, attributes, {
        expires: -1
      }));
    },
    withAttributes: function (attributes) {
      return init(this.converter, js_cookie_assign({}, this.attributes, attributes));
    },
    withConverter: function (converter) {
      return init(js_cookie_assign({}, this.converter, converter), this.attributes);
    }
  }, {
    attributes: {
      value: Object.freeze(defaultAttributes)
    },
    converter: {
      value: Object.freeze(converter)
    }
  });
}

var api = init(defaultConverter, {
  path: '/'
});
/* eslint-enable no-var */

/* harmony default export */ var js_cookie = (api);
;// CONCATENATED MODULE: ./src/i18n/index.js




const messages = {
  zh: zh,
  en: config_en
};
const language = (navigator.language || 'zh').toLocaleLowerCase(); // 

const i18n_i18n = createI18n({
  locale: js_cookie.get("locale") == "en-US" ? 'en' : 'zh' || 0 || 0,
  // 
  fallbackLocale: 'en',
  // 
  globalInjection: true,
  legacy: false,
  messages
});
/* harmony default export */ var src_i18n = (i18n_i18n);
;// CONCATENATED MODULE: ./src/package/state.js





const state = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  // 
  numberText: '',
  numberJson: [{
    number: 1,
    label: ''
  }, {
    number: 2,
    label: 'ABC'
  }, {
    number: 3,
    label: 'DEF'
  }, {
    number: 4,
    label: 'GHI'
  }, {
    number: 5,
    label: 'JKL'
  }, {
    number: 6,
    label: 'MNO'
  }, {
    number: 7,
    label: 'PQRS'
  }, {
    number: 8,
    label: 'TUV'
  }, {
    number: 9,
    label: 'WXYZ'
  }, {
    number: '*',
    label: ''
  }, {
    number: 0,
    label: '+'
  }, {
    number: '#',
    label: ''
  }],
  isMenuAct: 1,
  // 
  callNumber: '',
  callStatus: null,
  numberVisible: false,
  statusTxt: ['', '', '', '', ''],
  statusTxtEn: ['Dialing', 'New call', 'In a call', 'Rejected', 'Hang up'],
  activeNames: ['1', '2'],
  dialogTableVisible: false,
  talkCallTime: '00:00:00',
  nxwcall: null,
  currentUser: null,
  narrowVisible: false,
  // 
  bodyVisible: false,
  statusOptions: [{
    value: 'Available',
    label: src_i18n.global.t("sip.free")
  }, {
    value: 'On break',
    label: src_i18n.global.t("sip.busy")
  }],
  statusValue: 'Available',
  isMenu: 1,
  overList: [],
  isActiveOver: 0,
  isCallingList: {
    number: '',
    status: '',
    time: ''
  },
  recetCallDetail: {
    number: '',
    status: '',
    time: ''
  },
  isMainCode: null,
  isMainShow: null,
  // 
  recordSearch: {
    direction: null,
    group: null,
    name: '',
    number: null,
    startDate: dayjs_min_default()().startOf('day').format('YYYY-MM-DD HH:mm:ss'),
    endDate: dayjs_min_default()().endOf('day').format('YYYY-MM-DD HH:mm:ss'),
    current: 1,
    size: 10
  },
  recordCallTime: [dayjs_min_default()().startOf('day'), dayjs_min_default()().endOf('day')],
  recordList: [],
  recordTotal: 0,
  tableLoading: false,
  dialogWidth: 914,
  userEmail: '',
  setToken: '',
  isSuccess: false,
  // webrtc--
  isReject: null,
  //  1 2
  isCalling: 1,
  //  0 1
  isTimer: null,
  // 
  isLoginSuccess: null,
  //  1null
  isOpenSpeech: null,
  // 
  external: {
    number: null
  },
  // 
  externalList: [],
  // 
  externalInfo: {},
  recordCallId: null,
  sipNumber: null,
  timers: null,
  stopTimeval: null,
  callDidNumber: null,
  popVisible: false,
  // 
  busRecord: {
    businessRecord: ''
  },
  // 
  modeifyRecordVisible: false,
  // 
  modeifyhistoryVisible: false,
  businessRecordHistory: "",
  // 
  allRecordList: []
});
const exportFile = response => {
  let data = response.data;
  let fileReader = new FileReader();

  fileReader.onload = function () {
    try {
      let jsonData = JSON.parse(data);

      if (jsonData.code) {
        // 
        index2_ElMessage.error(jsonData.msg);
      }
    } catch (err) {
      let url = window.URL.createObjectURL(new Blob([response.data], {
        type: response.headers["content-type"]
      })); // 

      let link = document.createElement("a");
      let xx = response.headers["content-disposition"].split("filename=");
      let z = "";

      if ([...xx].pop()) {
        z = [...xx].pop().split(";").shift();
      }

      link.download = decodeURI(z);
      link.style.display = "none";
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  fileReader.readAsText(data);
};
// EXTERNAL MODULE: ./src/package/public/nxwebrtc.js
var nxwebrtc = __webpack_require__(491);
var nxwebrtc_default = /*#__PURE__*/__webpack_require__.n(nxwebrtc);
// EXTERNAL MODULE: ./node_modules/aegis-web-sdk/lib/aegis.min.js
var aegis_min = __webpack_require__(8927);
var aegis_min_default = /*#__PURE__*/__webpack_require__.n(aegis_min);
;// CONCATENATED MODULE: ./src/utils/common.js


/**
 * @description 
 * @param { any } response 
 */


const saasUrl = (/* unused pure expression or super */ null && ("https://nxlink.nxcloud.com"));
const common_exportFile = response => {
  let data = response.data;
  let fileReader = new FileReader();

  fileReader.onload = function () {
    try {
      let jsonData = JSON.parse(data);

      if (jsonData.code) {
        // 
        ElMessage.error(jsonData.msg);
      }
    } catch (err) {
      let url = window.URL.createObjectURL(new Blob([response.data], {
        type: response.headers["content-type"]
      })); // 

      let link = document.createElement("a");
      let xx = response.headers["content-disposition"].split("filename=");
      let z = "";

      if ([...xx].pop()) {
        z = [...xx].pop().split(";").shift();
      }

      link.download = decodeURI(z);
      link.style.display = "none";
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  fileReader.readAsText(data);
};
const common_format = function (seconds) {
  const hour = Math.floor(seconds / 3600) >= 10 ? Math.floor(seconds / 3600) : '0' + Math.floor(seconds / 3600);
  seconds -= 3600 * hour;
  const min = Math.floor(seconds / 60) >= 10 ? Math.floor(seconds / 60) : '0' + Math.floor(seconds / 60);
  seconds -= 60 * min;
  const sec = seconds >= 10 ? seconds : '0' + seconds;
  return hour + ':' + min + ':' + sec;
};
const aegis = new (aegis_min_default())({
  id: 'aZbwJFDQ7X4yxdr6Xr',
  //  id
  uin: 'xxx',
  //  ID
  reportApiSpeed: true,
  // 
  reportAssetSpeed: true,
  // 
  spa: true // spa  pv 
  // hostUrl: 'https://cc.nxcloud.com/'

});
const getBrowse = function () {
  var browser = {};
  var userAgent = navigator.userAgent.toLowerCase();
  var s;
  (s = userAgent.match(/msie ([\d.]+)/)) ? browser.ie = s[1] : (s = userAgent.match(/firefox\/([\d.]+)/)) ? browser.firefox = s[1] : (s = userAgent.match(/chrome\/([\d.]+)/)) ? browser.chrome = s[1] : (s = userAgent.match(/opera.([\d.]+)/)) ? browser.opera = s[1] : (s = userAgent.match(/version\/([\d.]+).*safari/)) ? browser.safari = s[1] : 0;
  var version = "";

  if (browser.ie) {
    version = "IE " + browser.ie;
  } else {
    if (browser.firefox) {
      version = "firefox " + browser.firefox;
    } else {
      if (browser.chrome) {
        version = "chrome " + browser.chrome;
      } else {
        if (browser.opera) {
          version = "opera " + browser.opera;
        } else {
          if (browser.safari) {
            version = "safari " + browser.safari;
          } else {
            version = "";
          }
        }
      }
    }
  }

  return version;
};
const browserRedirect = function () {
  var sUserAgent = navigator.userAgent;
  var isWin = navigator.platform == "Win32" || navigator.platform == "Windows";
  var isMac = navigator.platform == "Mac68K" || navigator.platform == "MacPPC" || navigator.platform == "Macintosh" || navigator.platform == "MacIntel";
  if (isMac) return "Mac";
  var isUnix = navigator.platform == "X11" && !isWin && !isMac;
  if (isUnix) return "Unix";
  var isLinux = String(navigator.platform).indexOf("Linux") > -1;
  if (isLinux) return "Linux";

  if (isWin) {
    var isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
    if (isWin2K) return "Window2000";
    var isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
    if (isWinXP) return "WindowXP";
    var isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
    if (isWin2003) return "Window2003";
    var isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
    if (isWinVista) return "WinVista";
    var isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
    if (isWin7) return "Window7";
    var isWin10 = sUserAgent.indexOf("Windows NT 10") > -1 || sUserAgent.indexOf("Windows 10") > -1;
    if (isWin10) return "Window";
  }

  return "other";
};
const timeago = function (dateTimeStamp) {
  var minute = 1000 * 60; //

  var hour = minute * 60;
  var now = new Date().getTime(); //

  var diffValue = now - dateTimeStamp; //

  let result = '';

  if (diffValue < 0) {
    return;
  }

  var minC = diffValue / minute; //

  var hourC = diffValue / hour;

  if (hourC >= 1 && hourC <= 23) {
    result = " " + parseInt(hourC) + i18n.global.t('sip.hourAgo');
  } else if (minC >= 1 && minC <= 59) {
    result = " " + parseInt(minC) + i18n.global.t('sip.minuteAgo');
  } else if (diffValue >= 0 && diffValue <= minute) {
    result = i18n.global.t('sip.justNow');
  } else {
    var datetime = new Date();
    datetime.setTime(dateTimeStamp);
    var Nyear = datetime.getFullYear();
    var Nmonth = datetime.getMonth() + 1 < 10 ? "0" + (datetime.getMonth() + 1) : datetime.getMonth() + 1;
    var Ndate = datetime.getDate() < 10 ? "0" + datetime.getDate() : datetime.getDate();
    result = Nyear + "-" + Nmonth + "-" + Ndate;
  }

  return result;
};
;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-same-target/index2.mjs


const useSameTarget = handleClick => {
  if (!handleClick) {
    return {
      onClick: NOOP,
      onMousedown: NOOP,
      onMouseup: NOOP
    };
  }

  let mousedownTarget = false;
  let mouseupTarget = false;

  const onClick = e => {
    if (mousedownTarget && mouseupTarget) {
      handleClick(e);
    }

    mousedownTarget = mouseupTarget = false;
  };

  const onMousedown = e => {
    mousedownTarget = e.target === e.currentTarget;
  };

  const onMouseup = e => {
    mouseupTarget = e.target === e.currentTarget;
  };

  return {
    onClick,
    onMousedown,
    onMouseup
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/vue/vnode2.mjs





const vnode2_SCOPE = "utils/vue/vnode";

var PatchFlags = /* @__PURE__ */(PatchFlags2 => {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
  return PatchFlags2;
})(PatchFlags || {});

function isFragment(node) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(node) && node.type === external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment;
}

function isText(node) {
  return isVNode(node) && node.type === Text;
}

function isComment(node) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(node) && node.type === external_commonjs_vue_commonjs2_vue_root_Vue_.Comment;
}

const TEMPLATE = "template";

function isTemplate(node) {
  return isVNode(node) && node.type === TEMPLATE;
}

function isValidElementNode(node) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(node) && !isFragment(node) && !isComment(node);
}

function getChildren(node, depth) {
  if (isComment(node)) return;

  if (isFragment(node) || isTemplate(node)) {
    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : void 0;
  }

  return node;
}

const getFirstValidNode = (nodes, maxDepth = 3) => {
  if (Array.isArray(nodes)) {
    return getChildren(nodes[0], maxDepth);
  } else {
    return getChildren(nodes, maxDepth);
  }
};

function renderIf(condition, ...args) {
  return condition ? renderBlock(...args) : createCommentVNode("v-if", true);
}

function renderBlock(...args) {
  return openBlock(), createBlock(...args);
}

const getNormalizedProps = node => {
  if (!isVNode(node)) {
    debugWarn(vnode2_SCOPE, "[getNormalizedProps] must be a VNode");
    return {};
  }

  const raw = node.props || {};
  const type = (isVNode(node.type) ? node.type.props : void 0) || {};
  const props = {};
  Object.keys(type).forEach(key => {
    if (hasOwn(type[key], "default")) {
      props[key] = type[key].default;
    }
  });
  Object.keys(raw).forEach(key => {
    props[camelize(key)] = raw[key];
  });
  return props;
};

const ensureOnlyChild = children => {
  if (!isArray(children) || children.length > 1) {
    throw new Error("expect to receive a single Vue element child");
  }

  return children[0];
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/overlay/src/overlay2.mjs







const overlayProps = buildProps({
  mask: {
    type: Boolean,
    default: true
  },
  customMaskEvent: {
    type: Boolean,
    default: false
  },
  overlayClass: {
    type: definePropType([String, Array, Object])
  },
  zIndex: {
    type: definePropType([String, Number])
  }
});
const overlayEmits = {
  click: evt => evt instanceof MouseEvent
};
var Overlay = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElOverlay",
  props: overlayProps,
  emits: overlayEmits,

  setup(props, {
    slots,
    emit
  }) {
    const ns = useNamespace("overlay");

    const onMaskClick = e => {
      emit("click", e);
    };

    const {
      onClick,
      onMousedown,
      onMouseup
    } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
    return () => {
      return props.mask ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)("div", {
        class: [ns.b(), props.overlayClass],
        style: {
          zIndex: props.zIndex
        },
        onClick,
        onMousedown,
        onMouseup
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        class: props.overlayClass,
        style: {
          zIndex: props.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(slots, "default")]);
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/overlay/index2.mjs


const ElOverlay = Overlay;

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/src/dialog-content3.mjs



const dialogContentProps = buildProps({
  center: {
    type: Boolean,
    default: false
  },
  closeIcon: {
    type: iconPropType,
    default: ""
  },
  customClass: {
    type: String,
    default: ""
  },
  draggable: {
    type: Boolean,
    default: false
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  }
});
const dialogContentEmits = {
  close: () => true
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/dialog2.mjs
const dialogInjectionKey = Symbol("dialogInjectionKey");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/src/dialog-content4.mjs








const dialog_content4_hoisted_1 = ["aria-label"];
const dialog_content4_default_ = {
  name: "ElDialogContent"
};

const dialog_content4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...dialog_content4_default_,
  props: dialogContentProps,
  emits: dialogContentEmits,

  setup(__props) {
    const {
      Close
    } = CloseComponents;
    const {
      dialogRef,
      headerRef,
      ns,
      style
    } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(dialogInjectionKey);
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        ref_key: "dialogRef",
        ref: dialogRef,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).b(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("fullscreen", _ctx.fullscreen), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("draggable", _ctx.draggable), {
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).m("center")]: _ctx.center
        }, _ctx.customClass]),
        "aria-modal": "true",
        role: "dialog",
        "aria-label": _ctx.title || "dialog",
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(style)),
        onClick: _cache[1] || (_cache[1] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)(() => {}, ["stop"]))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
        ref_key: "headerRef",
        ref: headerRef,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("header"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "title", {}, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("title"))
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.title), 3)])], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("body"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2), _ctx.$slots.footer ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("footer"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "footer")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.showClose ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
        key: 1,
        "aria-label": "close",
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("headerbtn")),
        type: "button",
        onClick: _cache[0] || (_cache[0] = $event => _ctx.$emit("close"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("close"))
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.closeIcon || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(Close))))]),
        _: 1
      }, 8, ["class"])], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 14, dialog_content4_hoisted_1);
    };
  }

});

var ElDialogContent = /* @__PURE__ */_export_sfc(dialog_content4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/src/dialog3.mjs






const dialogProps = buildProps({ ...dialogContentProps,
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: {
    type: definePropType(Function)
  },
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: {
    type: Boolean,
    required: true
  },
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: false
  }
});
const dialogEmits = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [UPDATE_MODEL_EVENT]: value => shared_isBoolean(value),
  openAutoFocus: () => true,
  closeAutoFocus: () => true
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-lockscreen/index2.mjs







const useLockscreen = trigger => {
  if (!(0,external_commonjs_vue_commonjs2_vue_root_Vue_.isRef)(trigger)) {
    throwError("[useLockscreen]", "You need to pass a ref param to this function");
  }

  if (!shared_isClient || hasClass(document.body, "el-popup-parent--hidden")) {
    return;
  }

  let scrollBarWidth = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = "0";
  let computedBodyPaddingRight = 0;

  const cleanup = () => {
    removeClass(document.body, "el-popup-parent--hidden");

    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(trigger, val => {
    if (!val) {
      cleanup();
      return;
    }

    withoutHiddenClass = !hasClass(document.body, "el-popup-parent--hidden");

    if (withoutHiddenClass) {
      bodyPaddingRight = document.body.style.paddingRight;
      computedBodyPaddingRight = Number.parseInt(style2_getStyle(document.body, "paddingRight"), 10);
    }

    scrollBarWidth = getScrollBarWidth();
    const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
    const bodyOverflowY = style2_getStyle(document.body, "overflowY");

    if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth}px`;
    }

    addClass(document.body, "el-popup-parent--hidden");
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onScopeDispose)(() => cleanup());
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-modal/index2.mjs




const modalStack = [];

const closeModal = e => {
  if (modalStack.length === 0) return;

  if (e.code === EVENT_CODE.esc) {
    e.stopPropagation();
    const topModal = modalStack[modalStack.length - 1];
    topModal.handleClose();
  }
};

const useModal = (instance, visibleRef) => {
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(visibleRef, val => {
    if (val) {
      modalStack.push(instance);
    } else {
      modalStack.splice(modalStack.indexOf(instance), 1);
    }
  });
};

if (shared_isClient) useEventListener(document, "keydown", closeModal);

;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-restore-active/index2.mjs


const useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => toggle.value, val => {
    var _a, _b;

    if (val) {
      previousActive = document.activeElement;

      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.isRef)(initialFocus)) {
        (_b = (_a = initialFocus.value).focus) == null ? void 0 : _b.call(_a);
      }
    } else {
      if (false) {} else {
        previousActive.focus();
      }
    }
  });
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/src/use-dialog2.mjs













const useDialog = (props, targetRef) => {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const emit = instance.emit;
  const {
    nextZIndex
  } = useZIndex();
  let lastPosition = "";
  const visible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const closed = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const rendered = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const zIndex = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(props.zIndex || nextZIndex());
  let openTimer = void 0;
  let closeTimer = void 0;
  const normalizeWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => shared_isNumber(props.width) ? `${props.width}px` : props.width);
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const style = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const style2 = {};
    const varPrefix = `--${namespace.value}-dialog`;

    if (!props.fullscreen) {
      if (props.top) {
        style2[`${varPrefix}-margin-top`] = props.top;
      }

      if (props.width) {
        style2[`${varPrefix}-width`] = normalizeWidth.value;
      }
    }

    return style2;
  });

  function afterEnter() {
    emit("opened");
  }

  function afterLeave() {
    emit("closed");
    emit(UPDATE_MODEL_EVENT, false);

    if (props.destroyOnClose) {
      rendered.value = false;
    }
  }

  function beforeLeave() {
    emit("close");
  }

  function open() {
    closeTimer == null ? void 0 : closeTimer();
    openTimer == null ? void 0 : openTimer();

    if (props.openDelay && props.openDelay > 0) {
      ;
      ({
        stop: openTimer
      } = shared_useTimeoutFn(() => doOpen(), props.openDelay));
    } else {
      doOpen();
    }
  }

  function close() {
    openTimer == null ? void 0 : openTimer();
    closeTimer == null ? void 0 : closeTimer();

    if (props.closeDelay && props.closeDelay > 0) {
      ;
      ({
        stop: closeTimer
      } = shared_useTimeoutFn(() => doClose(), props.closeDelay));
    } else {
      doClose();
    }
  }

  function handleClose() {
    function hide(shouldCancel) {
      if (shouldCancel) return;
      closed.value = true;
      visible.value = false;
    }

    if (props.beforeClose) {
      props.beforeClose(hide);
    } else {
      close();
    }
  }

  function onModalClick() {
    if (props.closeOnClickModal) {
      handleClose();
    }
  }

  function doOpen() {
    if (!shared_isClient) return;
    visible.value = true;
  }

  function doClose() {
    visible.value = false;
  }

  if (props.lockScroll) {
    useLockscreen(visible);
  }

  if (props.closeOnPressEscape) {
    useModal({
      handleClose
    }, visible);
  }

  useRestoreActive(visible);
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
    if (val) {
      closed.value = false;
      open();
      rendered.value = true;
      emit("open");
      zIndex.value = props.zIndex ? zIndex.value++ : nextZIndex();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible.value) {
        close();
      }
    }
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.fullscreen, val => {
    if (!targetRef.value) return;

    if (val) {
      lastPosition = targetRef.value.style.transform;
      targetRef.value.style.transform = "";
    } else {
      targetRef.value.style.transform = lastPosition;
    }
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
    if (props.modelValue) {
      visible.value = true;
      rendered.value = true;
      open();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick,
    close,
    doClose,
    closed,
    style,
    rendered,
    visible,
    zIndex
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/hooks/use-draggable/index2.mjs




const index2_useDraggable = (targetRef, dragRef, draggable) => {
  let transform = {
    offsetX: 0,
    offsetY: 0
  };

  const onMousedown = e => {
    const downX = e.clientX;
    const downY = e.clientY;
    const {
      offsetX,
      offsetY
    } = transform;
    const targetRect = targetRef.value.getBoundingClientRect();
    const targetLeft = targetRect.left;
    const targetTop = targetRect.top;
    const targetWidth = targetRect.width;
    const targetHeight = targetRect.height;
    const clientWidth = document.documentElement.clientWidth;
    const clientHeight = document.documentElement.clientHeight;
    const minLeft = -targetLeft + offsetX;
    const minTop = -targetTop + offsetY;
    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
    const maxTop = clientHeight - targetTop - targetHeight + offsetY;

    const onMousemove = e2 => {
      const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
      const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
      transform = {
        offsetX: moveX,
        offsetY: moveY
      };
      targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
    };

    const onMouseup = () => {
      document.removeEventListener("mousemove", onMousemove);
      document.removeEventListener("mouseup", onMouseup);
    };

    document.addEventListener("mousemove", onMousemove);
    document.addEventListener("mouseup", onMouseup);
  };

  const onDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.addEventListener("mousedown", onMousedown);
    }
  };

  const offDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.removeEventListener("mousedown", onMousedown);
    }
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
      if (draggable.value) {
        onDraggable();
      } else {
        offDraggable();
      }
    });
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
    offDraggable();
  });
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/src/dialog4.mjs












const dialog4_default_ = {
  name: "ElDialog"
};

const dialog4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...dialog4_default_,
  props: dialogProps,
  emits: dialogEmits,

  setup(__props, {
    expose
  }) {
    const props = __props;
    const ns = useNamespace("dialog");
    const dialogRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const headerRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      visible,
      style,
      rendered,
      zIndex,
      afterEnter,
      afterLeave,
      beforeLeave,
      handleClose,
      onModalClick
    } = useDialog(props, dialogRef);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(dialogInjectionKey, {
      dialogRef,
      headerRef,
      ns,
      rendered,
      style
    });
    const overlayEvent = useSameTarget(onModalClick);
    const draggable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.draggable && !props.fullscreen);
    index2_useDraggable(dialogRef, headerRef, draggable);
    expose({
      visible
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
        name: "dialog-fade",
        onAfterEnter: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(afterEnter),
        onAfterLeave: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(afterLeave),
        onBeforeLeave: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(beforeLeave)
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElOverlay), {
          "custom-mask-event": "",
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(zIndex)
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(`${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).namespace.value}-overlay-dialog`),
            onClick: _cache[0] || (_cache[0] = (...args) => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(overlayEvent).onClick && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(overlayEvent).onClick(...args)),
            onMousedown: _cache[1] || (_cache[1] = (...args) => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(overlayEvent).onMousedown && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(overlayEvent).onMousedown(...args)),
            onMouseup: _cache[2] || (_cache[2] = (...args) => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(overlayEvent).onMouseup && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(overlayEvent).onMouseup(...args))
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(rendered) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(ElDialogContent, {
            key: 0,
            "custom-class": _ctx.customClass,
            center: _ctx.center,
            "close-icon": _ctx.closeIcon,
            draggable: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(draggable),
            fullscreen: _ctx.fullscreen,
            "show-close": _ctx.showClose,
            style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(style)),
            title: _ctx.title,
            onClose: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(handleClose)
          }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createSlots)({
            title: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "title")]),
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")]),
            _: 2
          }, [_ctx.$slots.footer ? {
            name: "footer",
            fn: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "footer")])
          } : void 0]), 1032, ["custom-class", "center", "close-icon", "draggable", "fullscreen", "show-close", "style", "title", "onClose"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 34)]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index"]), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(visible)]])]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])], 8, ["disabled"]);
    };
  }

});

var Dialog = /* @__PURE__ */_export_sfc(dialog4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/index2.mjs





const ElDialog = withInstall(Dialog);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-dialog.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-overlay.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/overlay/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/style/css2.mjs



;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/dialog/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/src/button3.mjs






const buttonTypes = ["default", "primary", "success", "warning", "info", "danger", ""];
const buttonNativeTypes = ["button", "submit", "reset"];
const buttonProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  type: {
    type: String,
    values: buttonTypes,
    default: ""
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  nativeType: {
    type: String,
    values: buttonNativeTypes,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: iconPropType,
    default: () => loading
  },
  plain: Boolean,
  text: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  }
});
const buttonEmits = {
  click: evt => evt instanceof MouseEvent
};

;// CONCATENATED MODULE: ./node_modules/@ctrl/tinycolor/dist/module/util.js
/**
 * Take input from [0, n] and return it as [0, 1]
 * @hidden
 */
function bound01(n, max) {
  if (isOnePointZero(n)) {
    n = '100%';
  }

  var isPercent = isPercentage(n);
  n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n))); // Automatically convert percentage into number

  if (isPercent) {
    n = parseInt(String(n * max), 10) / 100;
  } // Handle floating point rounding errors


  if (Math.abs(n - max) < 0.000001) {
    return 1;
  } // Convert into [0, 1] range if it isn't already


  if (max === 360) {
    // If n is a hue given in degrees,
    // wrap around out-of-range values into [0, 360] range
    // then convert into [0, 1].
    n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
  } else {
    // If n not a hue given in degrees
    // Convert into [0, 1] range if it isn't already.
    n = n % max / parseFloat(String(max));
  }

  return n;
}
/**
 * Force a number between 0 and 1
 * @hidden
 */

function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
/**
 * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
 * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
 * @hidden
 */

function isOnePointZero(n) {
  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
}
/**
 * Check to see if string passed in is a percentage
 * @hidden
 */

function isPercentage(n) {
  return typeof n === 'string' && n.indexOf('%') !== -1;
}
/**
 * Return a valid alpha value [0,1] with all invalid values being set to 1
 * @hidden
 */

function boundAlpha(a) {
  a = parseFloat(a);

  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }

  return a;
}
/**
 * Replace a decimal with it's percentage value
 * @hidden
 */

function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }

  return n;
}
/**
 * Force a hex value to have 2 characters
 * @hidden
 */

function util_pad2(c) {
  return c.length === 1 ? '0' + c : String(c);
}
;// CONCATENATED MODULE: ./node_modules/@ctrl/tinycolor/dist/module/conversion.js
 // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

/**
 * Handle bounds / percentage checking to conform to CSS color spec
 * <http://www.w3.org/TR/css3-color/>
 * *Assumes:* r, g, b in [0, 255] or [0, 1]
 * *Returns:* { r, g, b } in [0, 255]
 */

function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
/**
 * Converts an RGB color value to HSL.
 * *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
 * *Returns:* { h, s, l } in [0,1]
 */

function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h = 0;
  var s = 0;
  var l = (max + min) / 2;

  if (max === min) {
    s = 0;
    h = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;

      default:
        break;
    }

    h /= 6;
  }

  return {
    h: h,
    s: s,
    l: l
  };
}

function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }

  if (t > 1) {
    t -= 1;
  }

  if (t < 1 / 6) {
    return p + (q - p) * (6 * t);
  }

  if (t < 1 / 2) {
    return q;
  }

  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }

  return p;
}
/**
 * Converts an HSL color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */


function hslToRgb(h, s, l) {
  var r;
  var g;
  var b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);

  if (s === 0) {
    // achromatic
    g = l;
    b = l;
    r = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
/**
 * Converts an RGB color value to HSV
 *
 * *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
 * *Returns:* { h, s, v } in [0,1]
 */

function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h = 0;
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;

      default:
        break;
    }

    h /= 6;
  }

  return {
    h: h,
    s: s,
    v: v
  };
}
/**
 * Converts an HSV color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */

function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
/**
 * Converts an RGB color to hex
 *
 * Assumes r, g, and b are contained in the set [0, 255]
 * Returns a 3 or 6 character hex
 */

function rgbToHex(r, g, b, allow3Char) {
  var hex = [util_pad2(Math.round(r).toString(16)), util_pad2(Math.round(g).toString(16)), util_pad2(Math.round(b).toString(16))]; // Return a 3 character hex if possible

  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }

  return hex.join('');
}
/**
 * Converts an RGBA color plus alpha transparency to hex
 *
 * Assumes r, g, b are contained in the set [0, 255] and
 * a in [0, 1]. Returns a 4 or 8 character rgba hex
 */
// eslint-disable-next-line max-params

function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [util_pad2(Math.round(r).toString(16)), util_pad2(Math.round(g).toString(16)), util_pad2(Math.round(b).toString(16)), util_pad2(convertDecimalToHex(a))]; // Return a 4 character hex if possible

  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }

  return hex.join('');
}
/**
 * Converts an RGBA color to an ARGB Hex8 string
 * Rarely used, but required for "toFilter()"
 */

function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join('');
}
/** Converts a decimal to a hex value */

function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
/** Converts a hex value to a decimal */

function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
/** Parse a base-16 hex value into a base-10 integer */

function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 0xff00) >> 8,
    b: color & 0xff
  };
}
;// CONCATENATED MODULE: ./node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
// https://github.com/bahamas10/css-color-names/blob/master/css-color-names.json

/**
 * @hidden
 */
var names = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  goldenrod: '#daa520',
  gold: '#ffd700',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavenderblush: '#fff0f5',
  lavender: '#e6e6fa',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};
;// CONCATENATED MODULE: ./node_modules/@ctrl/tinycolor/dist/module/format-input.js



/**
 * Given a string or object, convert that input to RGB
 *
 * Possible string inputs:
 * ```
 * "red"
 * "#f00" or "f00"
 * "#ff0000" or "ff0000"
 * "#ff000000" or "ff000000"
 * "rgb 255 0 0" or "rgb (255, 0, 0)"
 * "rgb 1.0 0 0" or "rgb (1, 0, 0)"
 * "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
 * "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
 * "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
 * "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
 * "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
 * ```
 */

function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;

  if (typeof color === 'string') {
    color = stringInputToObject(color);
  }

  if (typeof color === 'object') {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = 'hsv';
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = 'hsl';
    }

    if (Object.prototype.hasOwnProperty.call(color, 'a')) {
      a = color.a;
    }
  }

  a = boundAlpha(a);
  return {
    ok: ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a
  };
} // <http://www.w3.org/TR/css3-values/#integers>

var CSS_INTEGER = '[-\\+]?\\d+%?'; // <http://www.w3.org/TR/css3-values/#number-value>

var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?'; // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.

var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")"); // Actual matching.
// Parentheses and commas are optional, but not required.
// Whitespace can take the place of commas or opening paren

var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
  rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
  hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
  hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
  hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
  hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
/**
 * Permissive string parsing.  Take in a number of formats, and output an object
 * based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
 */

function stringInputToObject(color) {
  color = color.trim().toLowerCase();

  if (color.length === 0) {
    return false;
  }

  var named = false;

  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === 'transparent') {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: 'name'
    };
  } // Try to match string input using regular expressions.
  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
  // Just return an object and let the conversion functions handle that.
  // This way the result will be the same whether the tinycolor is initialized with string or object.


  var match = matchers.rgb.exec(color);

  if (match) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }

  match = matchers.rgba.exec(color);

  if (match) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }

  match = matchers.hsl.exec(color);

  if (match) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }

  match = matchers.hsla.exec(color);

  if (match) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }

  match = matchers.hsv.exec(color);

  if (match) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }

  match = matchers.hsva.exec(color);

  if (match) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }

  match = matchers.hex8.exec(color);

  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? 'name' : 'hex8'
    };
  }

  match = matchers.hex6.exec(color);

  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? 'name' : 'hex'
    };
  }

  match = matchers.hex4.exec(color);

  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? 'name' : 'hex8'
    };
  }

  match = matchers.hex3.exec(color);

  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? 'name' : 'hex'
    };
  }

  return false;
}
/**
 * Check to see if it looks like a CSS unit
 * (see `matchers` above for definition).
 */

function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
;// CONCATENATED MODULE: ./node_modules/@ctrl/tinycolor/dist/module/index.js





var TinyColor =
/** @class */
function () {
  function TinyColor(color, opts) {
    if (color === void 0) {
      color = '';
    }

    if (opts === void 0) {
      opts = {};
    }

    var _a; // If input is already a tinycolor, return itself


    if (color instanceof TinyColor) {
      // eslint-disable-next-line no-constructor-return
      return color;
    }

    if (typeof color === 'number') {
      color = numberInputToObject(color);
    }

    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
    this.gradientType = opts.gradientType; // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`

    if (this.r < 1) {
      this.r = Math.round(this.r);
    }

    if (this.g < 1) {
      this.g = Math.round(this.g);
    }

    if (this.b < 1) {
      this.b = Math.round(this.b);
    }

    this.isValid = rgb.ok;
  }

  TinyColor.prototype.isDark = function () {
    return this.getBrightness() < 128;
  };

  TinyColor.prototype.isLight = function () {
    return !this.isDark();
  };
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */


  TinyColor.prototype.getBrightness = function () {
    // http://www.w3.org/TR/AERT#color-contrast
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  };
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */


  TinyColor.prototype.getLuminance = function () {
    // http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    var rgb = this.toRgb();
    var R;
    var G;
    var B;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;

    if (RsRGB <= 0.03928) {
      R = RsRGB / 12.92;
    } else {
      // eslint-disable-next-line prefer-exponentiation-operator
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }

    if (GsRGB <= 0.03928) {
      G = GsRGB / 12.92;
    } else {
      // eslint-disable-next-line prefer-exponentiation-operator
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }

    if (BsRGB <= 0.03928) {
      B = BsRGB / 12.92;
    } else {
      // eslint-disable-next-line prefer-exponentiation-operator
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }

    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  };
  /**
   * Returns the alpha value of a color, from 0-1.
   */


  TinyColor.prototype.getAlpha = function () {
    return this.a;
  };
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */


  TinyColor.prototype.setAlpha = function (alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  /**
   * Returns the object as a HSVA object.
   */


  TinyColor.prototype.toHsv = function () {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this.a
    };
  };
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */


  TinyColor.prototype.toHsvString = function () {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h = Math.round(hsv.h * 360);
    var s = Math.round(hsv.s * 100);
    var v = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
  };
  /**
   * Returns the object as a HSLA object.
   */


  TinyColor.prototype.toHsl = function () {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this.a
    };
  };
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */


  TinyColor.prototype.toHslString = function () {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h = Math.round(hsl.h * 360);
    var s = Math.round(hsl.s * 100);
    var l = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
  };
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */


  TinyColor.prototype.toHex = function (allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }

    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  /**
   * Returns the hex value of the color -with a # appened.
   * @param allow3Char will shorten hex value to 3 char if possible
   */


  TinyColor.prototype.toHexString = function (allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }

    return '#' + this.toHex(allow3Char);
  };
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */


  TinyColor.prototype.toHex8 = function (allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }

    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  /**
   * Returns the hex 8 value of the color -with a # appened.
   * @param allow4Char will shorten hex value to 4 char if possible
   */


  TinyColor.prototype.toHex8String = function (allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }

    return '#' + this.toHex8(allow4Char);
  };
  /**
   * Returns the object as a RGBA object.
   */


  TinyColor.prototype.toRgb = function () {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */


  TinyColor.prototype.toRgbString = function () {
    var r = Math.round(this.r);
    var g = Math.round(this.g);
    var b = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
  };
  /**
   * Returns the object as a RGBA object.
   */


  TinyColor.prototype.toPercentageRgb = function () {
    var fmt = function (x) {
      return "".concat(Math.round(bound01(x, 255) * 100), "%");
    };

    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  /**
   * Returns the RGBA relative values interpolated into a string
   */


  TinyColor.prototype.toPercentageRgbString = function () {
    var rnd = function (x) {
      return Math.round(bound01(x, 255) * 100);
    };

    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  /**
   * The 'real' name of the color -if there is one.
   */


  TinyColor.prototype.toName = function () {
    if (this.a === 0) {
      return 'transparent';
    }

    if (this.a < 1) {
      return false;
    }

    var hex = '#' + rgbToHex(this.r, this.g, this.b, false);

    for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
      var _b = _a[_i],
          key = _b[0],
          value = _b[1];

      if (hex === value) {
        return key;
      }
    }

    return false;
  };

  TinyColor.prototype.toString = function (format) {
    var formatSet = Boolean(format);
    format = format !== null && format !== void 0 ? format : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith('hex') || format === 'name');

    if (needsAlphaFormat) {
      // Special case for "transparent", all other non-alpha formats
      // will return rgba when there is transparency.
      if (format === 'name' && this.a === 0) {
        return this.toName();
      }

      return this.toRgbString();
    }

    if (format === 'rgb') {
      formattedString = this.toRgbString();
    }

    if (format === 'prgb') {
      formattedString = this.toPercentageRgbString();
    }

    if (format === 'hex' || format === 'hex6') {
      formattedString = this.toHexString();
    }

    if (format === 'hex3') {
      formattedString = this.toHexString(true);
    }

    if (format === 'hex4') {
      formattedString = this.toHex8String(true);
    }

    if (format === 'hex8') {
      formattedString = this.toHex8String();
    }

    if (format === 'name') {
      formattedString = this.toName();
    }

    if (format === 'hsl') {
      formattedString = this.toHslString();
    }

    if (format === 'hsv') {
      formattedString = this.toHsvString();
    }

    return formattedString || this.toHexString();
  };

  TinyColor.prototype.toNumber = function () {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };

  TinyColor.prototype.clone = function () {
    return new TinyColor(this.toString());
  };
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.lighten = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor(hsl);
  };
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.brighten = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor(rgb);
  };
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.darken = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor(hsl);
  };
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.tint = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    return this.mix('white', amount);
  };
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.shade = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    return this.mix('black', amount);
  };
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.desaturate = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor(hsl);
  };
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */


  TinyColor.prototype.saturate = function (amount) {
    if (amount === void 0) {
      amount = 10;
    }

    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor(hsl);
  };
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */


  TinyColor.prototype.greyscale = function () {
    return this.desaturate(100);
  };
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */


  TinyColor.prototype.spin = function (amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor(hsl);
  };
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */


  TinyColor.prototype.mix = function (color, amount) {
    if (amount === void 0) {
      amount = 50;
    }

    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor(color).toRgb();
    var p = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return new TinyColor(rgba);
  };

  TinyColor.prototype.analogous = function (results, slices) {
    if (results === void 0) {
      results = 6;
    }

    if (slices === void 0) {
      slices = 30;
    }

    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];

    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor(hsl));
    }

    return ret;
  };
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */


  TinyColor.prototype.complement = function () {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor(hsl);
  };

  TinyColor.prototype.monochromatic = function (results) {
    if (results === void 0) {
      results = 6;
    }

    var hsv = this.toHsv();
    var h = hsv.h;
    var s = hsv.s;
    var v = hsv.v;
    var res = [];
    var modification = 1 / results;

    while (results--) {
      res.push(new TinyColor({
        h: h,
        s: s,
        v: v
      }));
      v = (v + modification) % 1;
    }

    return res;
  };

  TinyColor.prototype.splitcomplement = function () {
    var hsl = this.toHsl();
    var h = hsl.h;
    return [this, new TinyColor({
      h: (h + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), new TinyColor({
      h: (h + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  };
  /**
   * Compute how the color would appear on a background
   */


  TinyColor.prototype.onBackground = function (background) {
    var fg = this.toRgb();
    var bg = new TinyColor(background).toRgb();
    return new TinyColor({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  /**
   * Alias for `polyad(3)`
   */


  TinyColor.prototype.triad = function () {
    return this.polyad(3);
  };
  /**
   * Alias for `polyad(4)`
   */


  TinyColor.prototype.tetrad = function () {
    return this.polyad(4);
  };
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */


  TinyColor.prototype.polyad = function (n) {
    var hsl = this.toHsl();
    var h = hsl.h;
    var result = [this];
    var increment = 360 / n;

    for (var i = 1; i < n; i++) {
      result.push(new TinyColor({
        h: (h + i * increment) % 360,
        s: hsl.s,
        l: hsl.l
      }));
    }

    return result;
  };
  /**
   * compare color vs current color
   */


  TinyColor.prototype.equals = function (color) {
    return this.toRgbString() === new TinyColor(color).toRgbString();
  };

  return TinyColor;
}();

 // kept for backwards compatability with v1

function tinycolor(color, opts) {
  if (color === void 0) {
    color = '';
  }

  if (opts === void 0) {
    opts = {};
  }

  return new TinyColor(color, opts);
}
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/src/button-custom2.mjs






function darken(color, amount = 20) {
  return color.mix("#141414", amount).toString();
}

function useButtonCustomStyle(props) {
  const _disabled = useDisabled();

  const ns = useNamespace("button");
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    let styles = {};
    const buttonColor = props.color;

    if (buttonColor) {
      const color = new TinyColor(buttonColor);
      const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);

      if (props.plain) {
        styles = ns.cssVarBlock({
          "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
          "text-color": buttonColor,
          "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
          "hover-text-color": `var(${ns.cssVarName("color-white")})`,
          "hover-bg-color": buttonColor,
          "hover-border-color": buttonColor,
          "active-bg-color": activeBgColor,
          "active-text-color": `var(${ns.cssVarName("color-white")})`,
          "active-border-color": activeBgColor
        });

        if (_disabled.value) {
          styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
          styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
        }
      } else {
        const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
        const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
        styles = ns.cssVarBlock({
          "bg-color": buttonColor,
          "text-color": textColor,
          "border-color": buttonColor,
          "hover-bg-color": hoverBgColor,
          "hover-text-color": textColor,
          "hover-border-color": hoverBgColor,
          "active-bg-color": activeBgColor,
          "active-border-color": activeBgColor
        });

        if (_disabled.value) {
          const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
          styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
          styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
        }
      }
    }

    return styles;
  });
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/button2.mjs
const buttonGroupContextKey = Symbol("buttonGroupContextKey");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/src/button4.mjs












const button4_hoisted_1 = ["aria-disabled", "disabled", "autofocus", "type"];
const button4_default_ = {
  name: "ElButton"
};

const button4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...button4_default_,
  props: buttonProps,
  emits: buttonEmits,

  setup(__props, {
    expose,
    emit
  }) {
    const props = __props;
    const slots = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.useSlots)();
    const buttonGroupContext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(buttonGroupContextKey, void 0);
    const globalConfig = useGlobalConfig("button");
    const ns = useNamespace("button");
    const {
      form
    } = useFormItem();

    const _size = useSize((0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));

    const _disabled = useDisabled();

    const _ref = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();

    const _type = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");

    const autoInsertSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b, _c;

      return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a = globalConfig.value) == null ? void 0 : _a.autoInsertSpace) != null ? _c : false;
    });
    const shouldAddSpace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      const defaultSlot = (_a = slots.default) == null ? void 0 : _a.call(slots);

      if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
        const slot = defaultSlot[0];

        if ((slot == null ? void 0 : slot.type) === external_commonjs_vue_commonjs2_vue_root_Vue_.Text) {
          const text = slot.children;
          return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
        }
      }

      return false;
    });
    const buttonStyle = useButtonCustomStyle(props);

    const handleClick = evt => {
      if (props.nativeType === "reset") {
        form == null ? void 0 : form.resetFields();
      }

      emit("click", evt);
    };

    expose({
      ref: _ref,
      size: _size,
      type: _type,
      disabled: _disabled,
      shouldAddSpace
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
        ref_key: "_ref",
        ref: _ref,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).b(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).m((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(_type)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).m((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(_size)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("disabled", (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(_disabled)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("loading", _ctx.loading), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("plain", _ctx.plain), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("round", _ctx.round), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("circle", _ctx.circle), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("text", _ctx.text), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("has-bg", _ctx.bg)]),
        "aria-disabled": (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(_disabled) || _ctx.loading,
        disabled: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(_disabled) || _ctx.loading,
        autofocus: _ctx.autofocus,
        type: _ctx.nativeType,
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(buttonStyle)),
        onClick: handleClick
      }, [_ctx.loading ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [_ctx.$slots.loading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "loading", {
        key: 0
      }) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("loading"))
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.loadingIcon)))]),
        _: 1
      }, 8, ["class"]))], 2112)) : _ctx.icon || _ctx.$slots.icon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 1
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.icon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.icon), {
          key: 0
        })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "icon", {
          key: 1
        })]),
        _: 3
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.$slots.default ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 2,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)({
          [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).em("text", "expand")]: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(shouldAddSpace)
        })
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 14, button4_hoisted_1);
    };
  }

});

var Button = /* @__PURE__ */_export_sfc(button4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/src/button-group3.mjs

const buttonGroupProps = {
  size: buttonProps.size,
  type: buttonProps.type
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/src/button-group4.mjs







const button_group4_default_ = {
  name: "ElButtonGroup"
};

const button_group4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...button_group4_default_,
  props: buttonGroupProps,

  setup(__props) {
    const props = __props;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(buttonGroupContextKey, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      size: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "size"),
      type: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(props, "type")
    }));
    const ns = useNamespace("button");
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(`${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).b("group")}`)
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2);
    };
  }

});

var ButtonGroup = /* @__PURE__ */_export_sfc(button_group4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/index2.mjs





const ElButton = withInstall(Button, {
  ButtonGroup: ButtonGroup
});
const ElButtonGroup = withNoopInstall(ButtonGroup);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-button.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/button/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-status/index.vue?vue&type=template&id=097235a3
/* unplugin-vue-components disabled */


const nx_statusvue_type_template_id_097235a3_hoisted_1 = {
  class: "dialog-contaner"
};

const nx_statusvue_type_template_id_097235a3_hoisted_2 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
  class: "nx-status-narrow"
}, null, -1);

const nx_statusvue_type_template_id_097235a3_hoisted_3 = {
  class: "nx-staus-title"
};
const nx_statusvue_type_template_id_097235a3_hoisted_4 = {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/phone.svg",
  alt: "",
  class: "nx-staus-icon"
};
const nx_statusvue_type_template_id_097235a3_hoisted_5 = {
  class: "nx-status-number"
};
const nx_statusvue_type_template_id_097235a3_hoisted_6 = {
  class: "nx-status-remark"
};
const nx_statusvue_type_template_id_097235a3_hoisted_7 = {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/ripple.gif",
  alt: "",
  class: "nx-ripple-gif"
};
const nx_statusvue_type_template_id_097235a3_hoisted_8 = {
  class: "dialog-footer"
};

const nx_statusvue_type_template_id_097235a3_hoisted_9 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/hanupbtn.svg",
  alt: "",
  style: {
    "margin-right": "6px"
  }
}, null, -1);

function nx_statusvue_type_template_id_097235a3_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = ElButton;

  const _component_el_dialog = ElDialog;

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", nx_statusvue_type_template_id_097235a3_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.numberVisible,
    "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.numberVisible = $event),
    width: 274,
    "show-close": false,
    center: "",
    "custom-class": "nx-dialog",
    draggable: true,
    modal: false,
    "close-on-click-modal": false
  }, {
    footer: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", nx_statusvue_type_template_id_097235a3_hoisted_8, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
      src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/call_hang.svg",
      alt: "",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.hangupCall && _ctx.hangupCall(...args)),
      class: "nx-call-status-btn"
    }, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus != 2]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
      src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/call_out.svg",
      alt: "",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.answerCall && _ctx.answerCall(...args)),
      class: "nx-call-status-btn"
    }, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 1]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
      type: "primary",
      color: "#E53F48",
      round: "",
      onClick: _ctx.hangupCall,
      class: "nx-call-status-up"
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [nx_statusvue_type_template_id_097235a3_hoisted_9, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.hangUp")), 1)]),
      _: 1
    }, 8, ["onClick"]), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2]])])]),
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
      src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/to_small.svg",
      alt: "",
      class: "nx-status-bog",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openNarrow && _ctx.openNarrow(...args))
    }, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2]]), nx_statusvue_type_template_id_097235a3_hoisted_2, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_statusvue_type_template_id_097235a3_hoisted_3, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", nx_statusvue_type_template_id_097235a3_hoisted_4, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus != 2]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", nx_statusvue_type_template_id_097235a3_hoisted_5, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.callNumber), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_statusvue_type_template_id_097235a3_hoisted_6, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(Object.keys(_ctx.externalInfo).length != 0 ? _ctx.externalInfo.remark : ""), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-status-name", `callIng${_ctx.callStatus}`])
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.recordStatelang == "zh" ? _ctx.statusTxt[_ctx.callStatus] : _ctx.statusTxtEn[_ctx.callStatus]) + " ", 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
      class: "nx-status-time"
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.talkCallTime), 513), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", nx_statusvue_type_template_id_097235a3_hoisted_7, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2]])], 2)]),
    _: 1
  }, 8, ["modelValue"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.narrowVisible,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.narrowVisible = $event),
    width: 80,
    "show-close": false,
    center: "",
    "custom-class": "nx-narrow-dialog",
    draggable: true,
    modal: false,
    "close-on-click-modal": false,
    "close-delay": _ctx.callStatus == 4 ? 1000 : 0,
    "destroy-on-close": true
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
      src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/to_big.svg",
      alt: "",
      class: "nx-status-bog",
      onClick: _cache[4] || (_cache[4] = (...args) => _ctx.openExpand && _ctx.openExpand(...args))
    }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-status-name", `callIng${_ctx.callStatus}`])
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.statusTxt[_ctx.callStatus]), 3), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: "nx-status-time"
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.talkCallTime), 513), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2]])]),
    _: 1
  }, 8, ["modelValue", "close-delay"])]);
}
;// CONCATENATED MODULE: ./src/package/nx-status/index.vue?vue&type=template&id=097235a3
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-status/index.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */



/* harmony default export */ var nx_statusvue_type_script_lang_js = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "nx-status",

  setup() {
    const recordStatelang = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      recordStatelang.value = js_cookie.get("locale") == "zh-CN" ? "zh" : "en";
    });

    const hangupCall = () => {
      state.numberVisible = false;

      if (state.nxwcall != null) {
        const nxwcallPlace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
        nxwcallPlace.hangupCall();
        state.isReject = 2;
      }
    };

    const answerCall = () => {
      const nxwcallanwser = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
      nxwcallanwser.answerCall();
      state.callStatus = 2;
    };

    const openNarrow = () => {
      state.narrowVisible = true;
      state.numberVisible = false;
    };

    const openExpand = () => {
      state.narrowVisible = false;
      state.numberVisible = true;
    };

    return { ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(state),
      recordStatelang,
      hangupCall,
      answerCall,
      openNarrow,
      openExpand,
      i18n: src_i18n
    };
  }

}));
;// CONCATENATED MODULE: ./src/package/nx-status/index.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */ 
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-status/index.vue?vue&type=style&index=0&id=097235a3&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/package/nx-status/index.vue?vue&type=style&index=0&id=097235a3&lang=scss
/* unplugin-vue-components disabled */
// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js
var exportHelper = __webpack_require__(1620);
;// CONCATENATED MODULE: ./src/package/nx-status/index.vue
/* unplugin-vue-components disabled */



;


const __exports__ = /*#__PURE__*/(0,exportHelper/* default */.Z)(nx_statusvue_type_script_lang_js, [['render',nx_statusvue_type_template_id_097235a3_render]])

/* harmony default export */ var nx_status = (__exports__);
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-body/index.vue?vue&type=template&id=1a6351a2
/* unplugin-vue-components disabled */




const nx_bodyvue_type_template_id_1a6351a2_hoisted_1 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/leftArrow.svg",
  alt: ""
}, null, -1);

const nx_bodyvue_type_template_id_1a6351a2_hoisted_2 = {
  class: "dialog-contaner"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_3 = {
  class: "nx-body-contaner"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_4 = {
  class: "nx-body-menu"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_5 = {
  class: "nx-body-head"
};

const nx_bodyvue_type_template_id_1a6351a2_hoisted_6 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/head_img.png",
  alt: ""
}, null, -1);

const nx_bodyvue_type_template_id_1a6351a2_hoisted_7 = {
  class: "nx-body-list"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_8 = {
  key: 0,
  class: "nx-list-recent"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_9 = {
  key: 1,
  class: "nx-list-record-head"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_10 = {
  class: "nx-record-head"
};
const nx_bodyvue_type_template_id_1a6351a2_hoisted_11 = {
  class: "nx-list-record"
};
function nx_bodyvue_type_template_id_1a6351a2_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;

  const _component_el_select = ElSelect;

  const _component_nx_recent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("nx-recent");

  const _component_nx_record = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("nx-record");

  const _component_el_dialog = ElDialog;

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-call-log", _ctx.recordStatelang == 'zh' ? '' : 'nx-call-log-en']),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openBodyDialog && _ctx.openBodyDialog(...args))
  }, [nx_bodyvue_type_template_id_1a6351a2_hoisted_1, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("p", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.recentCalls")), 1)], 2), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, !_ctx.bodyVisible]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_2, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.bodyVisible,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.bodyVisible = $event),
    width: _ctx.dialogWidth,
    "show-close": false,
    "custom-class": "nx-body-dialog",
    modal: false,
    "close-on-click-modal": false
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_3, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
      src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/to_small.svg",
      alt: "",
      class: "nx-detail-bog",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.closeNarrow && _ctx.closeNarrow(...args))
    }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_4, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_5, [nx_bodyvue_type_template_id_1a6351a2_hoisted_6, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-body-slot", _ctx.statusValue == 'On break' ? 'nx-body-slot-busy' : 'nx-body-slot-idle'])
    }, null, 2)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_select, {
      modelValue: _ctx.statusValue,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.statusValue = $event),
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-body-select", _ctx.statusValue == 'On break' ? 'nx-body-select-act' : '']),
      placeholder: "Select",
      size: "small",
      onChange: _ctx.changeBodyStatus
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.statusOptions, item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_option, {
          key: item.value,
          label: item.label,
          value: item.value
        }, null, 8, ["label", "value"]);
      }), 128))]),
      _: 1
    }, 8, ["modelValue", "class", "onChange"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_7, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-body-zjth", _ctx.isMenu == 1 ? 'nx-body-zjth-bg2' : 'nx-body-zjth-bg1']),
      onClick: _cache[3] || (_cache[3] = $event => _ctx.isSelect(1))
    }, null, 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["nx-body-zjth", _ctx.isMenu == 2 ? 'nx-body-thjl-bg2' : 'nx-body-thjl-bg1']),
      onClick: _cache[4] || (_cache[4] = $event => _ctx.isSelect(2))
    }, null, 2)])]), _ctx.isMenu == 1 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_8, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_nx_recent)])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), _ctx.isMenu == 2 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_9, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_10, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.callLogs")), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_bodyvue_type_template_id_1a6351a2_hoisted_11, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_nx_record, {
      isHeight: true
    })])])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true)])]),
    _: 1
  }, 8, ["modelValue", "width"])])]);
}
;// CONCATENATED MODULE: ./src/package/nx-body/index.vue?vue&type=template&id=1a6351a2
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline/src/timeline2.mjs



const Timeline = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTimeline",

  setup(_, {
    slots
  }) {
    const ns = useNamespace("timeline");
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)("timeline", slots);
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("ul", {
        class: [ns.b()]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(slots, "default")]);
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline/src/timeline-item3.mjs



const timelineItemProps = buildProps({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: {
    type: Boolean,
    default: false
  },
  center: {
    type: Boolean,
    default: false
  },
  placement: {
    type: String,
    default: "bottom"
  },
  type: {
    type: String,
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    default: "normal"
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  hollow: {
    type: Boolean,
    default: false
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline/src/timeline-item4.mjs







const timeline_item4_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTimelineItem",
  components: {
    ElIcon: ElIcon
  },
  props: timelineItemProps,

  setup() {
    const ns = useNamespace("timeline-item");
    return {
      ns
    };
  }

});

function timeline_item4_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.b(), {
      [_ctx.ns.e("center")]: _ctx.center
    }])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("tail"))
  }, null, 2), !_ctx.$slots.dot ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 0,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("node"), _ctx.ns.em("node", _ctx.size || ""), _ctx.ns.em("node", _ctx.type || ""), _ctx.ns.is("hollow", _ctx.hollow)]),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
      backgroundColor: _ctx.color
    })
  }, [_ctx.icon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
    key: 0,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("icon"))
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.icon)))]),
    _: 1
  }, 8, ["class"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 6)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.$slots.dot ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 1,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("dot"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "dot")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("wrapper"))
  }, [!_ctx.hideTimestamp && _ctx.placement === "top" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 0,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("timestamp"), _ctx.ns.is("top")])
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.timestamp), 3)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("content"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2), !_ctx.hideTimestamp && _ctx.placement === "bottom" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 1,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("timestamp"), _ctx.ns.is("bottom")])
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.timestamp), 3)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2)], 2);
}

var TimelineItem = /* @__PURE__ */_export_sfc(timeline_item4_sfc_main, [["render", timeline_item4_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline/index2.mjs





const ElTimeline = withInstall(Timeline, {
  TimelineItem: TimelineItem
});
const ElTimelineItem = withNoopInstall(TimelineItem);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-timeline.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-timeline-item.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline-item/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/timeline-item/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/space/src/item2.mjs






const spaceItem = buildProps({
  prefixCls: {
    type: String,
    default: ""
  }
});

const item2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: spaceItem,

  setup(props) {
    const ns = useNamespace("space");
    const classes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => `${props.prefixCls || ns.b()}__item`);
    return {
      classes
    };
  }

});

function item2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.classes)
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2);
}

var Item = /* @__PURE__ */_export_sfc(item2_sfc_main, [["render", item2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/space/src/item.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/space/src/use-space2.mjs





const SIZE_MAP = {
  small: 8,
  default: 12,
  large: 16
};

function useSpace(props) {
  const ns = useNamespace("space");
  const classes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [ns.b(), ns.m(props.direction), props.class]);
  const horizontalSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
  const verticalSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
  const containerStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const wrapKls = props.wrap || props.fill ? {
      flexWrap: "wrap",
      marginBottom: `-${verticalSize.value}px`
    } : {};
    const alignment = {
      alignItems: props.alignment
    };
    return [wrapKls, alignment, props.style];
  });
  const itemStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const itemBaseStyle = {
      paddingBottom: `${verticalSize.value}px`,
      marginRight: `${horizontalSize.value}px`
    };
    const fillStyle = props.fill ? {
      flexGrow: 1,
      minWidth: `${props.fillRatio}%`
    } : {};
    return [itemBaseStyle, fillStyle];
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
    const {
      size = "small",
      wrap,
      direction: dir,
      fill
    } = props;

    if (Array.isArray(size)) {
      const [h = 0, v = 0] = size;
      horizontalSize.value = h;
      verticalSize.value = v;
    } else {
      let val;

      if (shared_isNumber(size)) {
        val = size;
      } else {
        val = SIZE_MAP[size] || SIZE_MAP.small;
      }

      if ((wrap || fill) && dir === "horizontal") {
        horizontalSize.value = verticalSize.value = val;
      } else {
        if (dir === "horizontal") {
          horizontalSize.value = val;
          verticalSize.value = 0;
        } else {
          verticalSize.value = val;
          horizontalSize.value = 0;
        }
      }
    }
  });
  return {
    classes,
    containerStyle,
    itemStyle
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/space/src/space2.mjs










const spaceProps = buildProps({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  style: {
    type: definePropType([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: definePropType(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: definePropType([Object, String, Number, Array]),
    default: null,
    validator: val => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(val) || shared_isNumber(val) || shared_esm_bundler_isString(val)
  },
  wrap: {
    type: Boolean,
    default: false
  },
  fill: {
    type: Boolean,
    default: false
  },
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: componentSizes,
    validator: val => {
      return shared_isNumber(val) || shared_esm_bundler_isArray(val) && val.length === 2 && val.every(i => shared_isNumber(i));
    }
  }
});
var Space = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElSpace",
  props: spaceProps,

  setup(props, {
    slots
  }) {
    const {
      classes,
      containerStyle,
      itemStyle
    } = useSpace(props);
    return () => {
      var _a;

      const {
        spacer,
        prefixCls,
        direction
      } = props;
      const children = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(slots, "default", {
        key: 0
      }, () => []);
      if (((_a = children.children) != null ? _a : []).length === 0) return null;

      if (shared_esm_bundler_isArray(children.children)) {
        let extractedChildren = [];
        children.children.forEach((child, loopKey) => {
          if (isFragment(child)) {
            if (shared_esm_bundler_isArray(child.children)) {
              child.children.forEach((nested, key) => {
                extractedChildren.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(Item, {
                  style: itemStyle.value,
                  prefixCls,
                  key: `nested-${key}`
                }, {
                  default: () => [nested]
                }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
              });
            }
          } else if (isValidElementNode(child)) {
            extractedChildren.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(Item, {
              style: itemStyle.value,
              prefixCls,
              key: `LoopKey${loopKey}`
            }, {
              default: () => [child]
            }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
          }
        });

        if (spacer) {
          const len = extractedChildren.length - 1;
          extractedChildren = extractedChildren.reduce((acc, child, idx) => {
            const children2 = [...acc, child];

            if (idx !== len) {
              children2.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)("span", {
                style: [itemStyle.value, direction === "vertical" ? "width: 100%" : null],
                key: idx
              }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.isVNode)(spacer) ? spacer : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)(spacer, PatchFlags.TEXT)], PatchFlags.STYLE));
            }

            return children2;
          }, []);
        }

        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)("div", {
          class: classes.value,
          style: containerStyle.value
        }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
      }

      return children.children;
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/space/index2.mjs





const ElSpace = withInstall(Space);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-space.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/space/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/space/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/scrollbar/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-recent/index.vue?vue&type=template&id=2c4e9cac
/* unplugin-vue-components disabled */







const nx_recentvue_type_template_id_2c4e9cac_hoisted_1 = {
  style: {
    "width": "100%",
    "display": "flex"
  }
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_2 = {
  class: "nx-recent nx-sdk-recent"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_3 = {
  class: "nx-record-title"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_4 = {
  class: "nx-record-tip"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_5 = {
  class: "nx-record-over-ul"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_6 = {
  class: "nx-record-ing-title"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_7 = {
  class: "nx-record-ing-content"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_8 = {
  style: {
    "margin-bottom": "4px"
  }
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_9 = {
  key: 0,
  class: "nx-record-tip"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_10 = {
  class: "nx-record-over-ul"
};
const nx_recentvue_type_template_id_2c4e9cac_hoisted_11 = ["onClick"];
const _hoisted_12 = {
  class: "nx-record-ing-title"
};
const _hoisted_13 = {
  class: "nx-record-ing-content"
};
const _hoisted_14 = {
  style: {
    "margin-bottom": "4px"
  }
};
const _hoisted_15 = ["onClick"];
const _hoisted_16 = {
  key: 0,
  class: "nx-detail nx-sdk-detail"
};
const _hoisted_17 = {
  class: "nx-detail-head"
};
const _hoisted_18 = {
  key: 0,
  class: "nx-detail-head-time"
};
const _hoisted_19 = {
  key: 1,
  class: "nx-detail-head-time"
};
const _hoisted_20 = {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/ripple.gif",
  alt: "",
  class: "nx-ripple-gif"
};
const _hoisted_21 = {
  class: "nx-detail-content"
};
const _hoisted_22 = {
  class: "nx-detail-content-nei"
};
const _hoisted_23 = {
  class: "nx-detail-content-number"
};
const _hoisted_24 = {
  class: "nx-detail-foot"
};
const _hoisted_25 = {
  class: "nx-detail-foot-nei"
};

const _hoisted_26 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/hanupbtn.svg",
  alt: "",
  style: {
    "margin-right": "6px"
  }
}, null, -1);

const _hoisted_27 = {
  class: "recordAct-content"
};
const _hoisted_28 = {
  class: "recordAct-time"
};
const _hoisted_29 = {
  class: "recordAct-time-txt"
};
const _hoisted_30 = {
  class: "recordAct-time-btn"
};
function nx_recentvue_type_template_id_2c4e9cac_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = ElScrollbar;

  const _component_el_button = ElButton;

  const _component_el_space = ElSpace;

  const _component_el_timeline_item = ElTimelineItem;

  const _component_el_timeline = ElTimeline;

  const _component_el_dialog = ElDialog;

  const _component_el_input = ElInput;

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recentvue_type_template_id_2c4e9cac_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recentvue_type_template_id_2c4e9cac_hoisted_2, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("h3", nx_recentvue_type_template_id_2c4e9cac_hoisted_3, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.recentCalls")), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recentvue_type_template_id_2c4e9cac_hoisted_4, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.sInService")), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("ul", nx_recentvue_type_template_id_2c4e9cac_hoisted_5, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("li", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.isActiveOver == -1 ? 'nx-act-over' : ''),
    onClick: _cache[0] || (_cache[0] = $event => _ctx.overSelect(_ctx.isCallingList, -1))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("h3", nx_recentvue_type_template_id_2c4e9cac_hoisted_6, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.isCallingList.number), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.isCallingList.remark ? _ctx.isCallingList.remark : ""), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recentvue_type_template_id_2c4e9cac_hoisted_7, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", nx_recentvue_type_template_id_2c4e9cac_hoisted_8, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.isCallingList.status), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.callStatus == 5 ? _ctx.isCallingList.duration : _ctx.talkCallTime), 1)])], 2)])], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2 || _ctx.callStatus == 5]]), _ctx.overList.length > 0 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", nx_recentvue_type_template_id_2c4e9cac_hoisted_9, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.ended")), 1)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_scrollbar, {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.callStatus == 2 || _ctx.callStatus == 5 ? 'scrollList1' : 'scrollList2')
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("ul", nx_recentvue_type_template_id_2c4e9cac_hoisted_10, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.overList, (item, index) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)({
          'nx-act-over': index == _ctx.isActiveOver
        }),
        key: index,
        onClick: $event => _ctx.overSelect(item, index)
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("h3", _hoisted_12, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.direction == 0 ? item.caller : item.callee), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.remark ? item.remark : ""), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_13, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", _hoisted_14, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(item.accessStatus), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.format(item.callDuration)), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
        src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/call_ing.svg",
        alt: "",
        class: "nx-record-ing-call",
        onClick: $event => _ctx.backCalling(item.direction == 0 ? item.caller : item.callee, item)
      }, null, 8, _hoisted_15)], 10, nx_recentvue_type_template_id_2c4e9cac_hoisted_11);
    }), 128))])]),
    _: 1
  }, 8, ["class"])]), _ctx.isMainCode == null ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_16, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_17, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("h3", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((_ctx.callStatus == 5 || _ctx.callStatus == 2) && _ctx.isActiveOver === -1 ? _ctx.isCallingList.status : _ctx.recetCallDetail.status), 1), _ctx.callStatus != 5 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", _hoisted_18, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.isActiveOver === -1 ? _ctx.talkCallTime : _ctx.recetCallDetail.time), 1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", _hoisted_19, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.isCallingList.duration), 1)), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", _hoisted_20, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.isActiveOver === -1 && _ctx.callStatus == 2]])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_21, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_22, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_23, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.recetCallDetail.number), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.isActiveOver === -1 ? _ctx.isCallingList.remark : _ctx.recetCallDetail.remark), 1)])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_24, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_25, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
    type: "primary",
    color: "#E53F48",
    round: "",
    onClick: _ctx.hangUpPhone
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_hoisted_26, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.hangUp")), 1)]),
    _: 1
  }, 8, ["onClick"])])], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.callStatus == 2 && _ctx.isActiveOver === -1]])])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.modeifyRecordVisible,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.modeifyRecordVisible = $event),
    title: _ctx.i18n.global.t('dashboard.comment'),
    width: "356px",
    onClose: _ctx.handleCloseModeify,
    "custom-class": "nx-el-dialog"
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_timeline, null, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.allRecordList, (activity, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_timeline_item, {
          key: index
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_27, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            class: "recordAct-name"
          }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(activity.agentNickName), 513), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, activity.agentNickName != '' && activity.agentNickName != null]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(activity.agentName), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_28, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_29, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_space, {
            size: 4
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(activity.gmtCreate), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.edit")), 1)]),
            _: 2
          }, 1024)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_30, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
            type: "primary",
            text: "",
            onClick: $event => _ctx.handleOpenHistory(activity.content),
            style: {
              "color": "#00a062"
            }
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.viewCallLogs")), 1)]),
            _: 2
          }, 1032, ["onClick"])])])]),
          _: 2
        }, 1024);
      }), 128))]),
      _: 1
    })]),
    _: 1
  }, 8, ["modelValue", "title", "onClose"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.modeifyhistoryVisible,
    "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.modeifyhistoryVisible = $event),
    title: _ctx.i18n.global.t('dashboard.comment'),
    width: "540px",
    "custom-class": "nx-el-dialog",
    onClose: _ctx.handleCloseHistory
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
      modelValue: _ctx.businessRecordHistory,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.businessRecordHistory = $event),
      "show-word-limit": true,
      maxlength: "200",
      rows: 4,
      type: "textarea",
      placeholder: _ctx.i18n.global.t('dashboard.enter'),
      disabled: ""
    }, null, 8, ["modelValue", "placeholder"])]),
    _: 1
  }, 8, ["modelValue", "title", "onClose"])], 64);
}
;// CONCATENATED MODULE: ./src/package/nx-recent/index.vue?vue&type=template&id=2c4e9cac
/* unplugin-vue-components disabled */
// EXTERNAL MODULE: ./node_modules/axios/index.js
var node_modules_axios = __webpack_require__(2084);
var axios_default = /*#__PURE__*/__webpack_require__.n(node_modules_axios);
;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  // @ts-ignore
  return typeof navigator !== 'undefined' && typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {};
}
const isProxyAvailable = typeof Proxy === 'function';
;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/const.js
const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';
;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/time.js
let supported;
let perf;
function isPerformanceSupported() {
  var _a;

  if (supported !== undefined) {
    return supported;
  }

  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof __webpack_require__.g !== 'undefined' && ((_a = __webpack_require__.g.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = __webpack_require__.g.perf_hooks.performance;
  } else {
    supported = false;
  }

  return supported;
}
function time_now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/proxy.js


class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};

    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }

    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);

    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e) {// noop
    }

    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },

      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {// noop
        }

        currentSettings = value;
      },

      now() {
        return time_now();
      }

    };

    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }

    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === 'on') {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {}
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise(resolve => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }

  async setRealTarget(target) {
    this.target = target;

    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }

    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }

}
;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/index.js






function esm_setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;

  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) setupFn(proxy.proxiedTarget);
  }
}
;// CONCATENATED MODULE: ./node_modules/vuex/dist/vuex.esm-bundler.js


/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */


var storeKey = 'store';

function useStore(key) {
  if (key === void 0) key = null;
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(key !== null ? key : storeKey);
}
/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */


function find(list, f) {
  return list.filter(f)[0];
}
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


function vuex_esm_bundler_deepCopy(obj, cache) {
  if (cache === void 0) cache = []; // just return if obj is immutable value

  if (obj === null || typeof obj !== 'object') {
    return obj;
  } // if obj is hit, it is in circular structure


  var hit = find(cache, function (c) {
    return c.original === obj;
  });

  if (hit) {
    return hit.copy;
  }

  var copy = Array.isArray(obj) ? [] : {}; // put the copy into cache at first
  // because we want to refer it in recursive deepCopy

  cache.push({
    original: obj,
    copy: copy
  });
  Object.keys(obj).forEach(function (key) {
    copy[key] = vuex_esm_bundler_deepCopy(obj[key], cache);
  });
  return copy;
}
/**
 * forEach for object
 */


function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function vuex_esm_bundler_isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function vuex_esm_bundler_isPromise(val) {
  return val && typeof val.then === 'function';
}

function vuex_esm_bundler_assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

function partial(fn, arg) {
  return function () {
    return fn(arg);
  };
}

function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }

  return function () {
    var i = subs.indexOf(fn);

    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state; // init all modules

  installModule(store, state, [], store._modules.root, true); // reset state

  resetStoreState(store, state, hot);
}

function resetStoreState(store, state, hot) {
  var oldState = store._state; // bind store public getters

  store.getters = {}; // reset local getters cache

  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldState.
    // using partial to return function with only arguments preserved in closure environment.
    computedObj[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      // TODO: use `computed` when it's possible. at the moment we can't due to
      // https://github.com/vuejs/vuex/pull/1883
      get: function () {
        return computedObj[key]();
      },
      enumerable: true // for local getters

    });
  });
  store._state = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
    data: state
  }); // enable strict mode for new state

  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldState) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldState.data = null;
      });
    }
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;

  var namespace = store._modules.getNamespace(path); // register in namespace map


  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && "production" !== 'production') {}

    store._modulesNamespaceMap[namespace] = module;
  } // set state


  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];

    store._withCommit(function () {
      if (false) {}

      parentState[moduleName] = module.state;
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);
  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */


function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';
  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if (false) {}
      }

      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if (false) {}
      }

      store.commit(type, payload, options);
    }
  }; // getters and state object must be gotten lazily
  // because they will be changed by state update

  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function () {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}

function makeLocalGetters(store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) {
        return;
      } // extract local getter type


      var localType = type.slice(splitPos); // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.

      Object.defineProperty(gettersProxy, localType, {
        get: function () {
          return store.getters[type];
        },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace];
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);

    if (!vuex_esm_bundler_isPromise(res)) {
      res = Promise.resolve(res);
    }

    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);

        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (false) {}

    return;
  }

  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(function () {
    return store._state.data;
  }, function () {
    if (false) {}
  }, {
    deep: true,
    flush: 'sync'
  });
}

function getNestedState(state, path) {
  return path.reduce(function (state, key) {
    return state[key];
  }, state);
}

function unifyObjectStyle(type, payload, options) {
  if (vuex_esm_bundler_isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (false) {}

  return {
    type: type,
    payload: payload,
    options: options
  };
}

var LABEL_VUEX_BINDINGS = 'vuex bindings';
var MUTATIONS_LAYER_ID = 'vuex:mutations';
var ACTIONS_LAYER_ID = 'vuex:actions';
var INSPECTOR_ID = 'vuex';
var actionId = 0;

function addDevtools(app, store) {
  esm_setupDevtoolsPlugin({
    id: 'org.vuejs.vuex',
    app: app,
    label: 'Vuex',
    homepage: 'https://next.vuex.vuejs.org/',
    logo: 'https://vuejs.org/images/icons/favicon-96x96.png',
    packageName: 'vuex',
    componentStateTypes: [LABEL_VUEX_BINDINGS]
  }, function (api) {
    api.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: 'Vuex Mutations',
      color: COLOR_LIME_500
    });
    api.addTimelineLayer({
      id: ACTIONS_LAYER_ID,
      label: 'Vuex Actions',
      color: COLOR_LIME_500
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: 'Vuex',
      icon: 'storage',
      treeFilterPlaceholder: 'Filter stores...'
    });
    api.on.getInspectorTree(function (payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        if (payload.filter) {
          var nodes = [];
          flattenStoreForInspectorTree(nodes, store._modules.root, payload.filter, '');
          payload.rootNodes = nodes;
        } else {
          payload.rootNodes = [formatStoreForInspectorTree(store._modules.root, '')];
        }
      }
    });
    api.on.getInspectorState(function (payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        makeLocalGetters(store, modulePath);
        payload.state = formatStoreForInspectorState(getStoreModule(store._modules, modulePath), modulePath === 'root' ? store.getters : store._makeLocalGettersCache, modulePath);
      }
    });
    api.on.editInspectorState(function (payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        var path = payload.path;

        if (modulePath !== 'root') {
          path = modulePath.split('/').filter(Boolean).concat(path);
        }

        store._withCommit(function () {
          payload.set(store._state.data, path, payload.state.value);
        });
      }
    });
    store.subscribe(function (mutation, state) {
      var data = {};

      if (mutation.payload) {
        data.payload = mutation.payload;
      }

      data.state = state;
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: Date.now(),
          title: mutation.type,
          data: data
        }
      });
    });
    store.subscribeAction({
      before: function (action, state) {
        var data = {};

        if (action.payload) {
          data.payload = action.payload;
        }

        action._id = actionId++;
        action._time = Date.now();
        data.state = state;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: action._time,
            title: action.type,
            groupId: action._id,
            subtitle: 'start',
            data: data
          }
        });
      },
      after: function (action, state) {
        var data = {};

        var duration = Date.now() - action._time;

        data.duration = {
          _custom: {
            type: 'duration',
            display: duration + "ms",
            tooltip: 'Action duration',
            value: duration
          }
        };

        if (action.payload) {
          data.payload = action.payload;
        }

        data.state = state;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: action.type,
            groupId: action._id,
            subtitle: 'end',
            data: data
          }
        });
      }
    });
  });
} // extracted from tailwind palette


var COLOR_LIME_500 = 0x84cc16;
var COLOR_DARK = 0x666666;
var COLOR_WHITE = 0xffffff;
var TAG_NAMESPACED = {
  label: 'namespaced',
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
/**
 * @param {string} path
 */

function extractNameFromPath(path) {
  return path && path !== 'root' ? path.split('/').slice(-2, -1)[0] : 'Root';
}
/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorNode}
 */


function formatStoreForInspectorTree(module, path) {
  return {
    id: path || 'root',
    // all modules end with a `/`, we want the last segment only
    // cart/ -> cart
    // nested/cart/ -> cart
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function (moduleName) {
      return formatStoreForInspectorTree(module._children[moduleName], path + moduleName + '/');
    })
  };
}
/**
 * @param {import('@vue/devtools-api').CustomInspectorNode[]} result
 * @param {*} module
 * @param {string} filter
 * @param {string} path
 */


function flattenStoreForInspectorTree(result, module, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || 'root',
      label: path.endsWith('/') ? path.slice(0, path.length - 1) : path || 'Root',
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }

  Object.keys(module._children).forEach(function (moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter, path + moduleName + '/');
  });
}
/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorState}
 */


function formatStoreForInspectorState(module, getters, path) {
  getters = path === 'root' ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function (key) {
      return {
        key: key,
        editable: true,
        value: module.state[key]
      };
    })
  };

  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function (key) {
      return {
        key: key.endsWith('/') ? extractNameFromPath(key) : key,
        editable: false,
        value: canThrow(function () {
          return tree[key];
        })
      };
    });
  }

  return storeState;
}

function transformPathsToObjectTree(getters) {
  var result = {};
  Object.keys(getters).forEach(function (key) {
    var path = key.split('/');

    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function (p) {
        if (!target[p]) {
          target[p] = {
            _custom: {
              value: {},
              display: p,
              tooltip: 'Module',
              abstract: true
            }
          };
        }

        target = target[p]._custom.value;
      });
      target[leafKey] = canThrow(function () {
        return getters[key];
      });
    } else {
      result[key] = canThrow(function () {
        return getters[key];
      });
    }
  });
  return result;
}

function getStoreModule(moduleMap, path) {
  var names = path.split('/').filter(function (n) {
    return n;
  });
  return names.reduce(function (module, moduleName, i) {
    var child = module[moduleName];

    if (!child) {
      throw new Error("Missing module \"" + moduleName + "\" for path \"" + path + "\".");
    }

    return i === names.length - 1 ? child : child._children;
  }, path === 'root' ? moduleMap : moduleMap.root._children);
}

function canThrow(cb) {
  try {
    return cb();
  } catch (e) {
    return e;
  }
} // Base data struct for store's module, package with some attribute and method


var Module = function Module(rawModule, runtime) {
  this.runtime = runtime; // Store some children item

  this._children = Object.create(null); // Store the origin module object which passed by programmer

  this._rawModule = rawModule;
  var rawState = rawModule.state; // Store the origin module's state

  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = {
  namespaced: {
    configurable: true
  }
};

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;

  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }

  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }

  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0) runtime = true;

  if (false) {}

  var newModule = new Module(rawModule, runtime);

  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  } // register nested modules


  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if (false) {}

    return;
  }

  if (!child.runtime) {
    return;
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key);
  }

  return false;
};

function update(path, targetModule, newModule) {
  if (false) {} // update target module


  targetModule.update(newModule); // update nested modules

  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (false) {}

        return;
      }

      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var functionAssert = {
  assert: function (value) {
    return typeof value === 'function';
  },
  expected: 'function'
};
var objectAssert = {
  assert: function (value) {
    return typeof value === 'function' || typeof value === 'object' && typeof value.handler === 'function';
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function (value, type) {
      vuex_esm_bundler_assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}

function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";

  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }

  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}

function createStore(options) {
  return new Store(options);
}

var Store = function Store(options) {
  var this$1$1 = this;
  if (options === void 0) options = {};

  if (false) {}

  var plugins = options.plugins;
  if (plugins === void 0) plugins = [];
  var strict = options.strict;
  if (strict === void 0) strict = false;
  var devtools = options.devtools; // store internal state

  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = Object.create(null);
  this._devtools = devtools; // bind commit and dispatch to self

  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;

  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };

  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  }; // strict mode


  this.strict = strict;
  var state = this._modules.root.state; // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters

  installModule(this, state, [], this._modules.root); // initialize the store state, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)

  resetStoreState(this, state); // apply plugins

  plugins.forEach(function (plugin) {
    return plugin(this$1$1);
  });
};

var prototypeAccessors = {
  state: {
    configurable: true
  }
};

Store.prototype.install = function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== undefined ? this._devtools :  false || false;

  if (useDevtools) {
    addDevtools(app, this);
  }
};

prototypeAccessors.state.get = function () {
  return this._state.data;
};

prototypeAccessors.state.set = function (v) {
  if (false) {}
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this; // check object-style commit

  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;
  var mutation = {
    type: type,
    payload: payload
  };
  var entry = this._mutations[type];

  if (!entry) {
    if (false) {}

    return;
  }

  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });

  this._subscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
  .forEach(function (sub) {
    return sub(mutation, this$1$1.state);
  });

  if (false) {}
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this; // check object-style dispatch

  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;
  var action = {
    type: type,
    payload: payload
  };
  var entry = this._actions[type];

  if (!entry) {
    if (false) {}

    return;
  }

  try {
    this._actionSubscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .filter(function (sub) {
      return sub.before;
    }).forEach(function (sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e) {
    if (false) {}
  }

  var result = entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1$1._actionSubscribers.filter(function (sub) {
          return sub.after;
        }).forEach(function (sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e) {
        if (false) {}
      }

      resolve(res);
    }, function (error) {
      try {
        this$1$1._actionSubscribers.filter(function (sub) {
          return sub.error;
        }).forEach(function (sub) {
          return sub.error(action, this$1$1.state, error);
        });
      } catch (e) {
        if (false) {}
      }

      reject(error);
    });
  });
};

Store.prototype.subscribe = function subscribe(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
};

Store.prototype.subscribeAction = function subscribeAction(fn, options) {
  var subs = typeof fn === 'function' ? {
    before: fn
  } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
};

Store.prototype.watch = function watch$1(getter, cb, options) {
  var this$1$1 = this;

  if (false) {}

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(function () {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1$1 = this;

  this._withCommit(function () {
    this$1$1._state.data = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0) options = {};

  if (typeof path === 'string') {
    path = [path];
  }

  if (false) {}

  this._modules.register(path, rawModule);

  installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

  resetStoreState(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if (false) {}

  this._modules.unregister(path);

  this._withCommit(function () {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });

  resetStore(this);
};

Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === 'string') {
    path = [path];
  }

  if (false) {}

  return this._modules.isRegistered(path);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);

  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);
/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};

  if (false) {}

  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

        if (!module) {
          return;
        }

        state = module.context.state;
        getters = module.context.getters;
      }

      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};

  if (false) {}

  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // Get the commit method from store


      var commit = this.$store.commit;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

        if (!module) {
          return;
        }

        commit = module.context.commit;
      }

      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};

  if (false) {}

  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val; // The namespace has been mutated by normalizeNamespace

    val = namespace + val;

    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }

      if (false) {}

      return this.$store.getters[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};

  if (false) {}

  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // get dispatch function from store


      var dispatch = this.$store.dispatch;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

        if (!module) {
          return;
        }

        dispatch = module.context.dispatch;
      }

      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */

var createNamespacedHelpers = function (namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};
/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */


function normalizeMap(map) {
  if (!isValidMap(map)) {
    return [];
  }

  return Array.isArray(map) ? map.map(function (key) {
    return {
      key: key,
      val: key
    };
  }) : Object.keys(map).map(function (key) {
    return {
      key: key,
      val: map[key]
    };
  });
}
/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */


function isValidMap(map) {
  return Array.isArray(map) || vuex_esm_bundler_isObject(map);
}
/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */


function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }

    return fn(namespace, map);
  };
}
/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */


function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];

  if (false) {}

  return module;
} // Credits: borrowed code from fcomb/redux-logger


function createLogger(ref) {
  if (ref === void 0) ref = {};
  var collapsed = ref.collapsed;
  if (collapsed === void 0) collapsed = true;
  var filter = ref.filter;
  if (filter === void 0) filter = function (mutation, stateBefore, stateAfter) {
    return true;
  };
  var transformer = ref.transformer;
  if (transformer === void 0) transformer = function (state) {
    return state;
  };
  var mutationTransformer = ref.mutationTransformer;
  if (mutationTransformer === void 0) mutationTransformer = function (mut) {
    return mut;
  };
  var actionFilter = ref.actionFilter;
  if (actionFilter === void 0) actionFilter = function (action, state) {
    return true;
  };
  var actionTransformer = ref.actionTransformer;
  if (actionTransformer === void 0) actionTransformer = function (act) {
    return act;
  };
  var logMutations = ref.logMutations;
  if (logMutations === void 0) logMutations = true;
  var logActions = ref.logActions;
  if (logActions === void 0) logActions = true;
  var logger = ref.logger;
  if (logger === void 0) logger = console;
  return function (store) {
    var prevState = vuex_esm_bundler_deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return;
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = vuex_esm_bundler_deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + mutation.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + action.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  };
}

function startMessage(logger, message, collapsed) {
  var startMessage = collapsed ? logger.groupCollapsed : logger.group; // render

  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage(logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log(' log end ');
  }
}

function getFormattedTime() {
  var time = new Date();
  return " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
}

function repeat(str, times) {
  return new Array(times + 1).join(str);
}

function pad(num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num;
}

var index = {
  version: '4.0.2',
  Store: Store,
  storeKey: storeKey,
  createStore: createStore,
  useStore: useStore,
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};
/* harmony default export */ var vuex_esm_bundler = ((/* unused pure expression or super */ null && (index)));

;// CONCATENATED MODULE: ./src/utils/requet-sdk.js




const store = useStore(); // 

function apiurl() {
  let apiUrl = '';
  apiUrl = "https://cc.nxcloud.com"; // if (window.location.host.indexOf('localhost') !== -1 || window.location.host.indexOf('10.75') !== -1) {
  // } else {
  //   apiUrl = window.location.protocol + '//' + window.location.host
  // }

  return apiUrl;
}

(axios_default()).defaults.baseURL = apiurl(); // axios.defaults.baseURL = process.env.VUE_APP_BASE_API

(axios_default()).defaults.timeout = 30000;
(axios_default()).defaults.headers["Content-Type"] = 'application/json'; // axios.defaults.headers['Content-Type'] = 'application/x-www-form-urlencoded charset=UTF-8'
// axios.defaults.transformRequhest = [function (data) {
//   var ret = ''
//   for (const it in data) {
//     ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&'
//   }
//   return ret
// }]

axios_default().interceptors.request.use(config => {
  // token 
  const token = localStorage.getItem('ccToken');
  const lang = js_cookie.get("locale") == 'en-US' ? 'en_US' : 'zh_CN';

  if (token) {
    if (config.url.indexOf('/admin/saas_plat/user/logout') != -1) {
      config.headers.Authorization = token;
    } else if (config.url.indexOf('/api') != -1 || config.url.indexOf('/fs') != -1) {
      config.headers.lang = lang;
      config.headers.usertoken = token;
    }
  }

  return config;
}, error => {
  return Promise.reject(error);
});
axios_default().interceptors.response.use(response => {
  if (parseInt(response.status) === 200) {
    const res = response.data;

    if (res.ret_code && res.ret_code === 1) {
      return Promise.resolve(response);
    } else {
      // ElMessage.error(res.ret_msg || res.msg || '')
      if (res.code === 403 || res.code === 406 || res.code === 12001) {
        localStorage.removeItem("ccToken");
        localStorage.removeItem("ccUser"); // ElMessage.error('')
      }

      return Promise.resolve(response);
    }
  }
}, error => {
  if (error.response) {
    if (error.response.status === 403) {
      index2_ElMessage.error('');
      localStorage.removeItem("ccToken");
      localStorage.removeItem("ccUser");
    } else {
      if (error.message.indexOf('Network Error') !== -1) {
        index2_ElMessage.error('');
      } else {
        index2_ElMessage.error(error.message);
      }

      return Promise.reject(error.response);
    }
  } else {
    if (error.message.indexOf('Network Error') !== -1) {
      index2_ElMessage.error('');
    } else {
      index2_ElMessage.error(error.message);
    }

    return Promise.reject(error);
  }
});
async function requet_sdk_get(url, params) {
  return new Promise((resolve, reject) => {
    axios_default().get(url, {
      params: params
    }).then(res => {
      resolve(res.data);
    }).catch(err => {
      if (parseInt(err.status) === 403) {
        reject(err);
      } else {
        reject(err.data);
      }
    });
  });
}
function post(url, params, config) {
  return new Promise((resolve, reject) => {
    axios_default().post(url, params, config).then(res => {
      resolve(res);
    }).catch(err => {
      reject(err.data);
    });
  });
}
function patch(url, params) {
  return new Promise((resolve, reject) => {
    axios.patch(url, params).then(res => {
      resolve(res.data);
    }).catch(err => {
      reject(err.data);
    });
  });
}
function put(url, params) {
  return new Promise((resolve, reject) => {
    axios_default().put(url, params).then(res => {
      resolve(res.data);
    }).catch(err => {
      reject(err.data);
    });
  });
}
function DELETE(url, params) {
  return new Promise((resolve, reject) => {
    axios.delete(url, {
      params: params
    }).then(res => {
      resolve(res);
    }).catch(err => {
      reject(err.data);
    });
  });
}
;// CONCATENATED MODULE: ./src/package/api.js
/* api post, patch, put, DELETE */

const sdkUrl = 'https://cc.nxcloud.com';
const api_saasUrl = 'https://nxlink.nxcloud.com'; // const sdkUrl = 'https://nxcc-test.nxcloud.com'
// const saasUrl = 'https://testapp.nxcloud.com'
// 

const getLogInfo = (data, token) => {
  return post(sdkUrl + '/fs/webCall/register', data);
}; // 


const callLogList = (data, token) => {
  return post(sdkUrl + '/api/ccCdr/v1/page', data);
}; // 


const downloadHistory = (data, token) => {
  return post(sdkUrl + '/api/ccCdr/v1/output', data, {
    responseType: 'blob',
    token: token
  });
}; // 


const getCdrbusRecord = data => {
  return post(sdkUrl + '/api/ccCdrRecord/v1/recent', data);
}; // 


const createCdrbusRecord = data => {
  return post(sdkUrl + '/api/ccCdrRecord/v1/append', data);
}; // 


const allAgentGroupList = (data, token) => {
  return post(sdkUrl + `/api/ccAgentGroup/v1/queryByName?name=${data.name}`, data);
}; // 


const changeSeatStatus = (data, token) => {
  return post(sdkUrl + '/fs/ccAgent/status/change', data);
}; // 


const workbenchRecord = (data, token) => {
  return post(sdkUrl + '/api/ccCdr/v1/recent', data);
}; // 


const saasLogin = (data, token) => {
  return put(api_saasUrl + '/admin/saas_plat/user/login', data);
}; // 


const getVerify = () => {
  return requet_sdk_get(api_saasUrl + '/admin/saas_plat/captcha/start_image_verify');
}; // 


const loginOut = data => {
  return put(api_saasUrl + '/admin/saas_plat/user/logout', data);
}; // 


const getDidExternal = data => {
  return post(sdkUrl + '/api/ccDidNumber/v/myUsefulNumber', data);
};


;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-recent/index.vue?vue&type=script&lang=js


/* unplugin-vue-components disabled */





/* harmony default export */ var nx_recentvue_type_script_lang_js = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "nx-recent",
  props: ["isMainCode"],

  setup(props, ctx) {
    const {
      t
    } = src_i18n.global;
    const busRecordRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const busRecoedAble = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(true);
    const recentState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      // 
      busRecordRules: {
        businessRecord: [{
          required: true,
          message: t("dashboard.enterBusiness"),
          trigger: "blur"
        }]
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      state.isMainCode = props.isMainCode;
      getHistoryList();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => [state.callStatus, state.bodyVisible], val => {
      if (val[0] === 2 || val[0] === 5) {
        state.isActiveOver = -1;
        busRecoedAble.value = false; // 

        if (val[0] === 2) {
          state.busRecord.businessRecord = "";
          state.allRecordList = [];
        }
      } else {
        state.recetCallDetail = state.overList[0];
        state.isActiveOver = 0;
      }

      if (val[1] == true) {
        getHistoryList();
      }
    });

    const getHistoryList = () => {
      workbenchRecord({}).then(response => {
        if (response.data.code === 0) {
          response.data.data.map(item => {
            switch (item.answered) {
              case true:
                item.callIcon = item.direction == 0 ? "in" : "out";
                break;

              case false:
                item.callIcon = item.direction == 0 ? "noAns" : "out";
                break;

              default:
                break;
            }
          });
          state.overList = response.data.data;

          if (state.overList.length > 0) {
            if (state.callStatus === 2 || state.callStatus === 5) {
              state.overList.map(item => {
                if (item.sipCallId == state.isCallingList.sipCallId && state.isCallingList.sipCallId) {
                  state.callStatus = 4;
                }
              });
              overSelect(state.isCallingList, -1);
            } else {
              overSelect(state.overList[0], 0);
            }
          }
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    };

    const overSelect = (item, index) => {
      busRecoedAble.value = index == -1 ? false : true;

      if (busRecordRef.value) {
        busRecordRef.value.clearValidate(["businessRecord"]);
      }

      state.recetCallDetail = {
        number: index == -1 ? item.number : item.direction == 0 ? item.caller : item.callee,
        status: item.accessStatus,
        time: common_format(item.callDuration),
        remark: item.remark ? item.remark : ""
      };
      state.isActiveOver = index;
      state.recordCallId = item.sipCallId;
      getCdrbusRecord({
        cdrCallId: item.sipCallId
      }).then(response => {
        if (response.data.code == 0) {
          state.allRecordList = response.data.data;

          if (state.allRecordList.length > 0) {
            state.busRecord.businessRecord = state.allRecordList[0].content;
          } else {
            state.busRecord.businessRecord = "";
          }
        } else {
          index2_ElMessage.error(response.data.msg);
          state.busRecord.businessRecord = "";
        }
      });
    };

    const backCalling = (number, item) => {
      if (number) {
        if (state.isSuccess == false) {
          index2_ElMessage.warning(t("sip.dialerInitialization"));
          return;
        }

        if (state.callStatus === 0 || state.callStatus === 1 || state.callStatus === 2) {
          index2_ElMessage.warning(t("sip.inCall"));
          return;
        }

        state.numberVisible = true;
        state.callNumber = number;
        state.callStatus = 0;

        if (state.nxwcall) {
          state.externalInfo = item;
          const backCall = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);

          if (item.didNumberId == null || item.didNumberId == 0) {
            backCall.placeCall(number);
          } else {
            let hdrs = new Array(`X-NXCC-Out-Caller-Number:  ${item.direction == 0 ? item.callee : item.clientSipFrom}`, `X-NXCC-Out-Callee-Route: <sip:${item.remoteIp}:${item.sipPort}>`, `X-NXCC-Out-Callee-Prefix: ${item.callOutPrefix}`, `X-NXCC-Out-Remark: ${item.remark}`);
            backCall.placeCall(number, hdrs);
          }
        }
      } else {
        index2_ElMessage.warning(t("dashboard.noNumber"));
      }
    };

    const hangUpPhone = () => {
      if (state.nxwcall) {
        const nxwcallhang = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
        nxwcallhang.hangupCall();
      }
    };

    const editBusiness = () => {
      busRecoedAble.value = false;
    };

    const trimRecord = str => {
      return str.replace(/(^\s*)|(\s*$)/g, "");
    };

    const saveBusiness = () => {
      busRecordRef.value.validate(valid => {
        if (valid) {
          let contents = trimRecord(state.busRecord.businessRecord);
          const postForm = {
            cdrCallId: state.recordCallId,
            content: contents
          };
          createCdrbusRecord(postForm).then(response => {
            if (response.data.code == 0) {
              index2_ElMessage.success(t("sip.savedSuccessfully"));
              getCdrbusRecord({
                cdrCallId: state.recordCallId
              }).then(response => {
                if (response.data.code == 0) {
                  state.allRecordList = response.data.data;

                  if (state.allRecordList.length > 0) {
                    state.busRecord.businessRecord = state.allRecordList[0].content;
                  } else {// state.busRecord.businessRecord = "";
                  }
                } else {
                  index2_ElMessage.error(response.data.msg);
                }
              });
            } else {
              index2_ElMessage.error(response.data.msg);
            }
          });
        }
      });
    };

    const handleOpenModeify = () => {
      state.modeifyRecordVisible = true;
    };

    const handleCloseModeify = () => {
      state.modeifyRecordVisible = false;
    };

    const handleOpenHistory = value => {
      state.modeifyhistoryVisible = true;
      state.businessRecordHistory = value;
    };

    const handleCloseHistory = () => {
      state.modeifyhistoryVisible = false;
    };

    const fobbidenCall = () => {
      index2_ElMessage.warning(t("dashboard.notHavePermissionNumber"));
    };

    return { ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(state),
      ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(recentState),
      busRecoedAble,
      busRecordRef,
      overSelect,
      backCalling,
      hangUpPhone,
      format: common_format,
      i18n: src_i18n,
      editBusiness,
      saveBusiness,
      handleCloseModeify,
      handleOpenModeify,
      handleCloseHistory,
      handleOpenHistory,
      fobbidenCall
    };
  }

}));
;// CONCATENATED MODULE: ./src/package/nx-recent/index.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */ 
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-recent/index.vue?vue&type=style&index=0&id=2c4e9cac&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/package/nx-recent/index.vue?vue&type=style&index=0&id=2c4e9cac&lang=scss
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./src/package/nx-recent/index.vue
/* unplugin-vue-components disabled */



;


const nx_recent_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(nx_recentvue_type_script_lang_js, [['render',nx_recentvue_type_template_id_2c4e9cac_render]])

/* harmony default export */ var nx_recent = (nx_recent_exports_);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/loading/src/loading2.mjs




function createLoadingComponent(options) {
  let afterLeaveTimer;
  const afterLeaveFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const data = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({ ...options,
    originalPosition: "",
    originalOverflow: "",
    visible: false
  });

  function setText(text) {
    data.text = text;
  }

  function destroySelf() {
    const target = data.parent;

    if (!target.vLoadingAddClassList) {
      let loadingNumber = target.getAttribute("loading-number");
      loadingNumber = Number.parseInt(loadingNumber) - 1;

      if (!loadingNumber) {
        removeClass(target, "el-loading-parent--relative");
        target.removeAttribute("loading-number");
      } else {
        target.setAttribute("loading-number", loadingNumber.toString());
      }

      removeClass(target, "el-loading-parent--hidden");
    }

    remvoeElLoadingChild();
    loadingInstance.unmount();
  }

  function remvoeElLoadingChild() {
    var _a, _b;

    (_b = (_a = vm.$el) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
  }

  function close() {
    var _a;

    if (options.beforeClose && !options.beforeClose()) return;
    const target = data.parent;
    target.vLoadingAddClassList = void 0;
    afterLeaveFlag.value = true;
    clearTimeout(afterLeaveTimer);
    afterLeaveTimer = window.setTimeout(() => {
      if (afterLeaveFlag.value) {
        afterLeaveFlag.value = false;
        destroySelf();
      }
    }, 400);
    data.visible = false;
    (_a = options.closed) == null ? void 0 : _a.call(options);
  }

  function handleAfterLeave() {
    if (!afterLeaveFlag.value) return;
    afterLeaveFlag.value = false;
    destroySelf();
  }

  const elLoadingComponent = {
    name: "ElLoading",

    setup() {
      return () => {
        const svg = data.spinner || data.svg;
        const spinner = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("svg", {
          class: "circular",
          viewBox: data.svgViewBox ? data.svgViewBox : "25 25 50 50",
          ...(svg ? {
            innerHTML: svg
          } : {})
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("circle", {
          class: "path",
          cx: "50",
          cy: "50",
          r: "20",
          fill: "none"
        })]);
        const spinnerText = data.text ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("p", {
          class: "el-loading-text"
        }, [data.text]) : void 0;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
          name: "el-loading-fade",
          onAfterLeave: handleAfterLeave
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)("div", {
            style: {
              backgroundColor: data.background || ""
            },
            class: ["el-loading-mask", data.customClass, data.fullscreen ? "is-fullscreen" : ""]
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
            class: "el-loading-spinner"
          }, [spinner, spinnerText])]), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, data.visible]])])
        });
      };
    }

  };
  const loadingInstance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createApp)(elLoadingComponent);
  const vm = loadingInstance.mount(document.createElement("div"));
  return { ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(data),
    setText,
    remvoeElLoadingChild,
    close,
    handleAfterLeave,
    vm,

    get $el() {
      return vm.$el;
    }

  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/loading/src/service2.mjs








let fullscreenInstance = void 0;

const Loading = function (options = {}) {
  if (!shared_isClient) return void 0;
  const resolved = resolveOptions(options);

  if (resolved.fullscreen && fullscreenInstance) {
    return fullscreenInstance;
  }

  const instance = createLoadingComponent({ ...resolved,
    closed: () => {
      var _a;

      (_a = resolved.closed) == null ? void 0 : _a.call(resolved);
      if (resolved.fullscreen) fullscreenInstance = void 0;
    }
  });
  addStyle(resolved, resolved.parent, instance);
  addClassList(resolved, resolved.parent, instance);

  resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);

  let loadingNumber = resolved.parent.getAttribute("loading-number");

  if (!loadingNumber) {
    loadingNumber = "1";
  } else {
    loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
  }

  resolved.parent.setAttribute("loading-number", loadingNumber);
  resolved.parent.appendChild(instance.$el);
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => instance.visible.value = resolved.visible);

  if (resolved.fullscreen) {
    fullscreenInstance = instance;
  }

  return instance;
};

const resolveOptions = options => {
  var _a, _b, _c, _d;

  let target;

  if (shared_esm_bundler_isString(options.target)) {
    target = (_a = document.querySelector(options.target)) != null ? _a : document.body;
  } else {
    target = options.target || document.body;
  }

  return {
    parent: target === document.body || options.body ? document.body : target,
    background: options.background || "",
    svg: options.svg || "",
    svgViewBox: options.svgViewBox || "",
    spinner: options.spinner || false,
    text: options.text || "",
    fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
    lock: (_c = options.lock) != null ? _c : false,
    customClass: options.customClass || "",
    visible: (_d = options.visible) != null ? _d : true,
    target
  };
};

const addStyle = async (options, parent, instance) => {
  const {
    nextZIndex
  } = useZIndex();
  const maskStyle = {};

  if (options.fullscreen) {
    instance.originalPosition.value = style2_getStyle(document.body, "position");
    instance.originalOverflow.value = style2_getStyle(document.body, "overflow");
    maskStyle.zIndex = nextZIndex();
  } else if (options.parent === document.body) {
    instance.originalPosition.value = style2_getStyle(document.body, "position");
    await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();

    for (const property of ["top", "left"]) {
      const scroll = property === "top" ? "scrollTop" : "scrollLeft";
      maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(style2_getStyle(document.body, `margin-${property}`), 10)}px`;
    }

    for (const property of ["height", "width"]) {
      maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
    }
  } else {
    instance.originalPosition.value = style2_getStyle(parent, "position");
  }

  for (const [key, value] of Object.entries(maskStyle)) {
    instance.$el.style[key] = value;
  }
};

const addClassList = (options, parent, instance) => {
  if (instance.originalPosition.value !== "absolute" && instance.originalPosition.value !== "fixed") {
    addClass(parent, "el-loading-parent--relative");
  } else {
    removeClass(parent, "el-loading-parent--relative");
  }

  if (options.fullscreen && options.lock) {
    addClass(parent, "el-loading-parent--hidden");
  } else {
    removeClass(parent, "el-loading-parent--hidden");
  }
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/loading/src/directive2.mjs



const INSTANCE_KEY = Symbol("ElLoading");

const createInstance = (el, binding) => {
  var _a, _b, _c, _d;

  const vm = binding.instance;

  const getBindingProp = key => shared_esm_bundler_isObject(binding.value) ? binding.value[key] : void 0;

  const resolveExpression = key => {
    const data = shared_esm_bundler_isString(key) && (vm == null ? void 0 : vm[key]) || key;
    if (data) return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(data);else return data;
  };

  const getProp = name => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));

  const fullscreen = (_a = getBindingProp("fullscreen")) != null ? _a : binding.modifiers.fullscreen;
  const options = {
    text: getProp("text"),
    svg: getProp("svg"),
    svgViewBox: getProp("svgViewBox"),
    spinner: getProp("spinner"),
    background: getProp("background"),
    customClass: getProp("customClass"),
    fullscreen,
    target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
    body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
    lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
  };
  el[INSTANCE_KEY] = {
    options,
    instance: Loading(options)
  };
};

const updateOptions = (newOptions, originalOptions) => {
  for (const key of Object.keys(originalOptions)) {
    if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.isRef)(originalOptions[key])) originalOptions[key].value = newOptions[key];
  }
};

const vLoading = {
  mounted(el, binding) {
    if (binding.value) {
      createInstance(el, binding);
    }
  },

  updated(el, binding) {
    const instance = el[INSTANCE_KEY];

    if (binding.oldValue !== binding.value) {
      if (binding.value && !binding.oldValue) {
        createInstance(el, binding);
      } else if (binding.value && binding.oldValue) {
        if (shared_esm_bundler_isObject(binding.value)) updateOptions(binding.value, instance.options);
      } else {
        instance == null ? void 0 : instance.instance.close();
      }
    }
  },

  unmounted(el) {
    var _a;

    (_a = el[INSTANCE_KEY]) == null ? void 0 : _a.instance.close();
  }

};

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-loading.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/loading/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/loading/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/config-provider/index2.mjs




const ElConfigProvider = withInstall(ConfigProvider);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-config-provider.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/config-provider/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/config-provider/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/arrow-left.mjs



const arrow_left_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ArrowLeft"
});

const arrow_left_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const arrow_left_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
}, null, -1);

const arrow_left_hoisted_3 = [arrow_left_hoisted_2];

function arrow_left_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", arrow_left_hoisted_1, arrow_left_hoisted_3);
}

var arrowLeft = /* @__PURE__ */plugin_vue_export_helper_export_sfc(arrow_left_sfc_main, [["render", arrow_left_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/components/prev2.mjs




const paginationPrevProps = {
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String,
    default: ""
  }
};

const prev2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElPaginationPrev",
  components: {
    ElIcon: ElIcon,
    ArrowLeft: arrowLeft
  },
  props: paginationPrevProps,
  emits: ["click"],

  setup(props) {
    const internalDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.disabled || props.currentPage <= 1);
    return {
      internalDisabled
    };
  }

});

const prev2_hoisted_1 = ["disabled", "aria-disabled"];
const prev2_hoisted_2 = {
  key: 0
};

function prev2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-left");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    type: "button",
    class: "btn-prev",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = $event => _ctx.$emit("click", $event))
  }, [_ctx.prevText ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", prev2_hoisted_2, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.prevText), 1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
    key: 1
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_left)]),
    _: 1
  }))], 8, prev2_hoisted_1);
}

var Prev = /* @__PURE__ */_export_sfc(prev2_sfc_main, [["render", prev2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/arrow-right.mjs



const arrow_right_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ArrowRight"
});

const arrow_right_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const arrow_right_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
}, null, -1);

const arrow_right_hoisted_3 = [arrow_right_hoisted_2];

function arrow_right_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", arrow_right_hoisted_1, arrow_right_hoisted_3);
}

var arrowRight = /* @__PURE__ */plugin_vue_export_helper_export_sfc(arrow_right_sfc_main, [["render", arrow_right_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/components/next2.mjs




const paginationNextProps = {
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String,
    default: ""
  }
};

const next2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElPaginationNext",
  components: {
    ElIcon: ElIcon,
    ArrowRight: arrowRight
  },
  props: paginationNextProps,
  emits: ["click"],

  setup(props) {
    const internalDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
    return {
      internalDisabled
    };
  }

});

const next2_hoisted_1 = ["disabled", "aria-disabled"];
const next2_hoisted_2 = {
  key: 0
};

function next2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-right");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    type: "button",
    class: "btn-next",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = $event => _ctx.$emit("click", $event))
  }, [_ctx.nextText ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", next2_hoisted_2, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.nextText), 1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
    key: 1
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_right)]),
    _: 1
  }))], 8, next2_hoisted_1);
}

var Next = /* @__PURE__ */_export_sfc(next2_sfc_main, [["render", next2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/tokens/pagination2.mjs
const elPaginationKey = Symbol("elPaginationKey");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/usePagination2.mjs




const usePagination = () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(elPaginationKey, {});


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/components/sizes2.mjs











const paginationSizesProps = buildProps({
  pageSize: {
    type: Number,
    required: true
  },
  pageSizes: {
    type: definePropType(Array),
    default: () => mutable([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: Boolean,
  size: {
    type: String,
    default: "default"
  }
});

const sizes2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElPaginationSizes",
  components: {
    ElSelect: ElSelect,
    ElOption: ElOption
  },
  props: paginationSizesProps,
  emits: ["page-size-change"],

  setup(props, {
    emit
  }) {
    const {
      t
    } = useLocale();
    const ns = useNamespace("pagination");
    const pagination = usePagination();
    const innerPageSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(props.pageSize);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.pageSizes, (newVal, oldVal) => {
      if (lodash_es_isEqual(newVal, oldVal)) return;

      if (Array.isArray(newVal)) {
        const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
        emit("page-size-change", pageSize);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.pageSize, newVal => {
      innerPageSize.value = newVal;
    });
    const innerPageSizes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.pageSizes);

    function handleChange(val) {
      var _a;

      if (val !== innerPageSize.value) {
        innerPageSize.value = val;
        (_a = pagination.handleSizeChange) == null ? void 0 : _a.call(pagination, Number(val));
      }
    }

    return {
      ns,
      innerPageSizes,
      innerPageSize,
      t,
      handleChange
    };
  }

});

function sizes2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-option");

  const _component_el_select = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-select");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("sizes"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_select, {
    "model-value": _ctx.innerPageSize,
    disabled: _ctx.disabled,
    "popper-class": _ctx.popperClass,
    size: _ctx.size,
    onChange: _ctx.handleChange
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.innerPageSizes, item => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_option, {
        key: item,
        value: item,
        label: item + _ctx.t("el.pagination.pagesize")
      }, null, 8, ["value", "label"]);
    }), 128))]),
    _: 1
  }, 8, ["model-value", "disabled", "popper-class", "size", "onChange"])], 2);
}

var Sizes = /* @__PURE__ */_export_sfc(sizes2_sfc_main, [["render", sizes2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/components/jumper2.mjs








const jumper2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElPaginationJumper",
  components: {
    ElInput: ElInput
  },

  setup() {
    const {
      t
    } = useLocale();
    const ns = useNamespace("pagination");
    const {
      pageCount,
      disabled,
      currentPage,
      changeEvent
    } = usePagination();
    const userInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const innerValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
    });

    function handleInput(val) {
      userInput.value = +val;
    }

    function handleChange(val) {
      val = Math.trunc(+val);
      changeEvent == null ? void 0 : changeEvent(+val);
      userInput.value = void 0;
    }

    return {
      ns,
      pageCount,
      disabled,
      innerValue,
      t,
      handleInput,
      handleChange
    };
  }

});

const jumper2_hoisted_1 = ["disabled"];

function jumper2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-input");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("jump")),
    disabled: _ctx.disabled
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.pagination.goto")) + " ", 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    size: "small",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("editor"), _ctx.ns.is("in-pagination")]),
    min: 1,
    max: _ctx.pageCount,
    disabled: _ctx.disabled,
    "model-value": _ctx.innerValue,
    type: "number",
    "onUpdate:modelValue": _ctx.handleInput,
    onChange: _ctx.handleChange
  }, null, 8, ["class", "max", "disabled", "model-value", "onUpdate:modelValue", "onChange"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)(" " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.pagination.pageClassifier")), 1)], 10, jumper2_hoisted_1);
}

var Jumper = /* @__PURE__ */_export_sfc(jumper2_sfc_main, [["render", jumper2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/components/total2.mjs






const paginationTotalProps = {
  total: {
    type: Number,
    default: 1e3
  }
};

const total2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElPaginationTotal",
  props: paginationTotalProps,

  setup() {
    const {
      t
    } = useLocale();
    const ns = useNamespace("pagination");
    const {
      disabled
    } = usePagination();
    return {
      t,
      ns,
      disabled
    };
  }

});

const total2_hoisted_1 = ["disabled"];

function total2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("total")),
    disabled: _ctx.disabled
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.pagination.total", {
    total: _ctx.total
  })), 11, total2_hoisted_1);
}

var Total = /* @__PURE__ */_export_sfc(total2_sfc_main, [["render", total2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/d-arrow-left.mjs



const d_arrow_left_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "DArrowLeft"
});

const d_arrow_left_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const d_arrow_left_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
}, null, -1);

const d_arrow_left_hoisted_3 = [d_arrow_left_hoisted_2];

function d_arrow_left_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", d_arrow_left_hoisted_1, d_arrow_left_hoisted_3);
}

var dArrowLeft = /* @__PURE__ */plugin_vue_export_helper_export_sfc(d_arrow_left_sfc_main, [["render", d_arrow_left_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/d-arrow-right.mjs



const d_arrow_right_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "DArrowRight"
});

const d_arrow_right_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const d_arrow_right_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
}, null, -1);

const d_arrow_right_hoisted_3 = [d_arrow_right_hoisted_2];

function d_arrow_right_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", d_arrow_right_hoisted_1, d_arrow_right_hoisted_3);
}

var dArrowRight = /* @__PURE__ */plugin_vue_export_helper_export_sfc(d_arrow_right_sfc_main, [["render", d_arrow_right_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/more-filled.mjs



const more_filled_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "MoreFilled"
});

const more_filled_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const more_filled_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"
}, null, -1);

const more_filled_hoisted_3 = [more_filled_hoisted_2];

function more_filled_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", more_filled_hoisted_1, more_filled_hoisted_3);
}

var moreFilled = /* @__PURE__ */plugin_vue_export_helper_export_sfc(more_filled_sfc_main, [["render", more_filled_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/components/pager2.mjs





const paginationPagerProps = {
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: true
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
};

const pager2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElPaginationPager",
  components: {
    DArrowLeft: dArrowLeft,
    DArrowRight: dArrowRight,
    MoreFilled: moreFilled
  },
  props: paginationPagerProps,
  emits: ["change"],

  setup(props, {
    emit
  }) {
    const nsPager = useNamespace("pager");
    const nsIcon = useNamespace("icon");
    const showPrevMore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const showNextMore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const quickPrevHover = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const quickNextHover = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const pagers = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const pagerCount = props.pagerCount;
      const halfPagerCount = (pagerCount - 1) / 2;
      const currentPage = Number(props.currentPage);
      const pageCount = Number(props.pageCount);
      let showPrevMore2 = false;
      let showNextMore2 = false;

      if (pageCount > pagerCount) {
        if (currentPage > pagerCount - halfPagerCount) {
          showPrevMore2 = true;
        }

        if (currentPage < pageCount - halfPagerCount) {
          showNextMore2 = true;
        }
      }

      const array = [];

      if (showPrevMore2 && !showNextMore2) {
        const startPage = pageCount - (pagerCount - 2);

        for (let i = startPage; i < pageCount; i++) {
          array.push(i);
        }
      } else if (!showPrevMore2 && showNextMore2) {
        for (let i = 2; i < pagerCount; i++) {
          array.push(i);
        }
      } else if (showPrevMore2 && showNextMore2) {
        const offset = Math.floor(pagerCount / 2) - 1;

        for (let i = currentPage - offset; i <= currentPage + offset; i++) {
          array.push(i);
        }
      } else {
        for (let i = 2; i < pageCount; i++) {
          array.push(i);
        }
      }

      return array;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
      const halfPagerCount = (props.pagerCount - 1) / 2;
      showPrevMore.value = false;
      showNextMore.value = false;

      if (props.pageCount > props.pagerCount) {
        if (props.currentPage > props.pagerCount - halfPagerCount) {
          showPrevMore.value = true;
        }

        if (props.currentPage < props.pageCount - halfPagerCount) {
          showNextMore.value = true;
        }
      }
    });

    function onMouseenter(direction) {
      if (props.disabled) return;

      if (direction === "left") {
        quickPrevHover.value = true;
      } else {
        quickNextHover.value = true;
      }
    }

    function onEnter(e) {
      const target = e.target;

      if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
        const newPage = Number(target.textContent);

        if (newPage !== props.currentPage) {
          emit("change", newPage);
        }
      }
    }

    function onPagerClick(event) {
      const target = event.target;

      if (target.tagName.toLowerCase() === "ul" || props.disabled) {
        return;
      }

      let newPage = Number(target.textContent);
      const pageCount = props.pageCount;
      const currentPage = props.currentPage;
      const pagerCountOffset = props.pagerCount - 2;

      if (target.className.includes("more")) {
        if (target.className.includes("quickprev")) {
          newPage = currentPage - pagerCountOffset;
        } else if (target.className.includes("quicknext")) {
          newPage = currentPage + pagerCountOffset;
        }
      }

      if (!Number.isNaN(+newPage)) {
        if (newPage < 1) {
          newPage = 1;
        }

        if (newPage > pageCount) {
          newPage = pageCount;
        }
      }

      if (newPage !== currentPage) {
        emit("change", newPage);
      }
    }

    return {
      showPrevMore,
      showNextMore,
      quickPrevHover,
      quickNextHover,
      pagers,
      nsPager,
      nsIcon,
      onMouseenter,
      onPagerClick,
      onEnter
    };
  }

});

const pager2_hoisted_1 = ["aria-current"];
const pager2_hoisted_2 = ["aria-current"];
const pager2_hoisted_3 = ["aria-current"];

function pager2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_d_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-left");

  const _component_more_filled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("more-filled");

  const _component_d_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-right");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("ul", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsPager.b()),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onPagerClick && _ctx.onPagerClick(...args)),
    onKeyup: _cache[5] || (_cache[5] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withKeys)((...args) => _ctx.onEnter && _ctx.onEnter(...args), ["enter"]))
  }, [_ctx.pageCount > 0 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
    key: 0,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([[_ctx.nsPager.is("active", _ctx.currentPage === 1), _ctx.nsPager.is("disabled", _ctx.disabled)], "number"]),
    "aria-current": _ctx.currentPage === 1,
    tabindex: "0"
  }, " 1 ", 10, pager2_hoisted_1)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.showPrevMore ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
    key: 1,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["more", "btn-quickprev", _ctx.nsIcon.b(), _ctx.nsPager.is("disabled", _ctx.disabled)]),
    onMouseenter: _cache[0] || (_cache[0] = $event => _ctx.onMouseenter("left")),
    onMouseleave: _cache[1] || (_cache[1] = $event => _ctx.quickPrevHover = false)
  }, [_ctx.quickPrevHover ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_d_arrow_left, {
    key: 0
  })) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_more_filled, {
    key: 1
  }))], 34)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.pagers, pager => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
      key: pager,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([[_ctx.nsPager.is("active", _ctx.currentPage === pager), _ctx.nsPager.is("disabled", _ctx.disabled)], "number"]),
      "aria-current": _ctx.currentPage === pager,
      tabindex: "0"
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(pager), 11, pager2_hoisted_2);
  }), 128)), _ctx.showNextMore ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
    key: 2,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["more", "btn-quicknext", _ctx.nsIcon.b(), _ctx.nsPager.is("disabled", _ctx.disabled)]),
    onMouseenter: _cache[2] || (_cache[2] = $event => _ctx.onMouseenter("right")),
    onMouseleave: _cache[3] || (_cache[3] = $event => _ctx.quickNextHover = false)
  }, [_ctx.quickNextHover ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_d_arrow_right, {
    key: 0
  })) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_more_filled, {
    key: 1
  }))], 34)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.pageCount > 1 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
    key: 3,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([[_ctx.nsPager.is("active", _ctx.currentPage === _ctx.pageCount), _ctx.nsPager.is("disabled", _ctx.disabled)], "number"]),
    "aria-current": _ctx.currentPage === _ctx.pageCount,
    tabindex: "0"
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.pageCount), 11, pager2_hoisted_3)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 34);
}

var Pager = /* @__PURE__ */_export_sfc(pager2_sfc_main, [["render", pager2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/src/pagination2.mjs

















const isAbsent = v => typeof v !== "number";

const paginationProps = buildProps({
  total: Number,
  pageSize: Number,
  defaultPageSize: Number,
  currentPage: Number,
  defaultCurrentPage: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: value => {
      return typeof value === "number" && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
    },
    default: 7
  },
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: definePropType(Array),
    default: () => mutable([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  nextText: {
    type: String,
    default: ""
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
});
const paginationEmits = {
  "update:current-page": val => typeof val === "number",
  "update:page-size": val => typeof val === "number",
  "size-change": val => typeof val === "number",
  "current-change": val => typeof val === "number",
  "prev-click": val => typeof val === "number",
  "next-click": val => typeof val === "number"
};
const componentName = "ElPagination";
var Pagination = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: componentName,
  props: paginationProps,
  emits: paginationEmits,

  setup(props, {
    emit,
    slots
  }) {
    const {
      t
    } = useLocale();
    const ns = useNamespace("pagination");
    const vnodeProps = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)().vnode.props || {};
    const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
    const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
    const assertValidUsage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (isAbsent(props.total) && isAbsent(props.pageCount)) return false;
      if (!isAbsent(props.currentPage) && !hasCurrentPageListener) return false;

      if (props.layout.includes("sizes")) {
        if (!isAbsent(props.pageCount)) {
          if (!hasPageSizeListener) return false;
        } else if (!isAbsent(props.total)) {
          if (!isAbsent(props.pageSize)) {
            if (!hasPageSizeListener) {
              return false;
            }
          } else {}
        }
      }

      return true;
    });
    const innerPageSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
    const innerCurrentPage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
    const pageSizeBridge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
      get() {
        return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
      },

      set(v) {
        if (isAbsent(props.pageSize)) {
          innerPageSize.value = v;
        }

        if (hasPageSizeListener) {
          emit("update:page-size", v);
          emit("size-change", v);
        }
      }

    });
    const pageCountBridge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let pageCount = 0;

      if (!isAbsent(props.pageCount)) {
        pageCount = props.pageCount;
      } else if (!isAbsent(props.total)) {
        pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
      }

      return pageCount;
    });
    const currentPageBridge = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
      get() {
        return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
      },

      set(v) {
        let newCurrentPage = v;

        if (v < 1) {
          newCurrentPage = 1;
        } else if (v > pageCountBridge.value) {
          newCurrentPage = pageCountBridge.value;
        }

        if (isAbsent(props.currentPage)) {
          innerCurrentPage.value = newCurrentPage;
        }

        if (hasCurrentPageListener) {
          emit("update:current-page", newCurrentPage);
          emit("current-change", newCurrentPage);
        }
      }

    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(pageCountBridge, val => {
      if (currentPageBridge.value > val) currentPageBridge.value = val;
    });

    function handleCurrentChange(val) {
      currentPageBridge.value = val;
    }

    function handleSizeChange(val) {
      pageSizeBridge.value = val;
      const newPageCount = pageCountBridge.value;

      if (currentPageBridge.value > newPageCount) {
        currentPageBridge.value = newPageCount;
      }
    }

    function prev() {
      if (props.disabled) return;
      currentPageBridge.value -= 1;
      emit("prev-click", currentPageBridge.value);
    }

    function next() {
      if (props.disabled) return;
      currentPageBridge.value += 1;
      emit("next-click", currentPageBridge.value);
    }

    function addClass(element, cls) {
      if (element) {
        if (!element.props) {
          element.props = {};
        }

        element.props.class = [element.props.class, cls].join(" ");
      }
    }

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(elPaginationKey, {
      pageCount: pageCountBridge,
      disabled: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.disabled),
      currentPage: currentPageBridge,
      changeEvent: handleCurrentChange,
      handleSizeChange
    });
    return () => {
      var _a, _b;

      if (!assertValidUsage.value) {
        error2_debugWarn(componentName, t("el.pagination.deprecationWarning"));
        return null;
      }

      if (!props.layout) return null;
      if (props.hideOnSinglePage && pageCountBridge.value <= 1) return null;
      const rootChildren = [];
      const rightWrapperChildren = [];
      const rightWrapperRoot = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        class: ns.e("rightwrapper")
      }, rightWrapperChildren);
      const TEMPLATE_MAP = {
        prev: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(Prev, {
          disabled: props.disabled,
          currentPage: currentPageBridge.value,
          prevText: props.prevText,
          onClick: prev
        }),
        jumper: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(Jumper),
        pager: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(Pager, {
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          pagerCount: props.pagerCount,
          onChange: handleCurrentChange,
          disabled: props.disabled
        }),
        next: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(Next, {
          disabled: props.disabled,
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          nextText: props.nextText,
          onClick: next
        }),
        sizes: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(Sizes, {
          pageSize: pageSizeBridge.value,
          pageSizes: props.pageSizes,
          popperClass: props.popperClass,
          disabled: props.disabled,
          size: props.small ? "small" : "default"
        }),
        slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
        total: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(Total, {
          total: isAbsent(props.total) ? 0 : props.total
        })
      };
      const components = props.layout.split(",").map(item => item.trim());
      let haveRightWrapper = false;
      components.forEach(c => {
        if (c === "->") {
          haveRightWrapper = true;
          return;
        }

        if (!haveRightWrapper) {
          rootChildren.push(TEMPLATE_MAP[c]);
        } else {
          rightWrapperChildren.push(TEMPLATE_MAP[c]);
        }
      });
      addClass(rootChildren[0], ns.is("first"));
      addClass(rootChildren[rootChildren.length - 1], ns.is("last"));

      if (haveRightWrapper && rightWrapperChildren.length > 0) {
        addClass(rightWrapperChildren[0], ns.is("first"));
        addClass(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
        rootChildren.push(rightWrapperRoot);
      }

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        role: "pagination",
        "aria-label": "pagination",
        class: [ns.b(), ns.is("background", props.background), {
          [ns.m("small")]: props.small
        }]
      }, rootChildren);
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/index2.mjs




const ElPagination = withInstall(Pagination);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-pagination.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/style/css2.mjs



;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/pagination/style/css.mjs

// EXTERNAL MODULE: ./node_modules/escape-html/index.js
var escape_html = __webpack_require__(5085);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/util2.mjs










const getCell = function (event) {
  let cell = event.target;

  while (cell && cell.tagName.toUpperCase() !== "HTML") {
    if (cell.tagName.toUpperCase() === "TD") {
      return cell;
    }

    cell = cell.parentNode;
  }

  return null;
};

const util2_isObject = function (obj) {
  return obj !== null && typeof obj === "object";
};

const orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array;
  }

  if (typeof reverse === "string") {
    reverse = reverse === "descending" ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }

  const getKey = sortMethod ? null : function (value, index) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }

      return sortBy.map(by => {
        if (typeof by === "string") {
          return lodash_es_get(value, by);
        } else {
          return by(value, index, array);
        }
      });
    }

    if (sortKey !== "$key") {
      if (util2_isObject(value) && "$value" in value) value = value.$value;
    }

    return [util2_isObject(value) ? lodash_es_get(value, sortKey) : value];
  };

  const compare = function (a, b) {
    if (sortMethod) {
      return sortMethod(a.value, b.value);
    }

    for (let i = 0, len = a.key.length; i < len; i++) {
      if (a.key[i] < b.key[i]) {
        return -1;
      }

      if (a.key[i] > b.key[i]) {
        return 1;
      }
    }

    return 0;
  };

  return array.map((value, index) => {
    return {
      value,
      index,
      key: getKey ? getKey(value, index) : null
    };
  }).sort((a, b) => {
    let order = compare(a, b);

    if (!order) {
      order = a.index - b.index;
    }

    return order * +reverse;
  }).map(item => item.value);
};

const getColumnById = function (table, columnId) {
  let column = null;
  table.columns.forEach(item => {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};

const getColumnByKey = function (table, columnKey) {
  let column = null;

  for (let i = 0; i < table.columns.length; i++) {
    const item = table.columns[i];

    if (item.columnKey === columnKey) {
      column = item;
      break;
    }
  }

  return column;
};

const getColumnByCell = function (table, cell, namespace) {
  const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));

  if (matches) {
    return getColumnById(table, matches[0]);
  }

  return null;
};

const getRowIdentity = (row, rowKey) => {
  if (!row) throw new Error("Row is required when get row identity");

  if (typeof rowKey === "string") {
    if (!rowKey.includes(".")) {
      return `${row[rowKey]}`;
    }

    const key = rowKey.split(".");
    let current = row;

    for (const element of key) {
      current = current[element];
    }

    return `${current}`;
  } else if (typeof rowKey === "function") {
    return rowKey.call(null, row);
  }
};

const getKeysMap = function (array, rowKey) {
  const arrayMap = {};
  (array || []).forEach((row, index) => {
    arrayMap[getRowIdentity(row, rowKey)] = {
      row,
      index
    };
  });
  return arrayMap;
};

function mergeOptions(defaults, config) {
  const options = {};
  let key;

  for (key in defaults) {
    options[key] = defaults[key];
  }

  for (key in config) {
    if (shared_esm_bundler_hasOwn(config, key)) {
      const value = config[key];

      if (typeof value !== "undefined") {
        options[key] = value;
      }
    }
  }

  return options;
}

function parseWidth(width) {
  if (width === "") return width;

  if (width !== void 0) {
    width = Number.parseInt(width, 10);

    if (Number.isNaN(width)) {
      width = "";
    }
  }

  return width;
}

function parseMinWidth(minWidth) {
  if (minWidth === "") return minWidth;

  if (minWidth !== void 0) {
    minWidth = parseWidth(minWidth);

    if (Number.isNaN(minWidth)) {
      minWidth = 80;
    }
  }

  return minWidth;
}

function parseHeight(height) {
  if (typeof height === "number") {
    return height;
  }

  if (typeof height === "string") {
    if (/^\d+(?:px)?$/.test(height)) {
      return Number.parseInt(height, 10);
    } else {
      return height;
    }
  }

  return null;
}

function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}

function toggleRowStatus(statusArr, row, newVal) {
  let changed = false;
  const index = statusArr.indexOf(row);
  const included = index !== -1;

  const addRow = () => {
    statusArr.push(row);
    changed = true;
  };

  const removeRow = () => {
    statusArr.splice(index, 1);
    changed = true;
  };

  if (typeof newVal === "boolean") {
    if (newVal && !included) {
      addRow();
    } else if (!newVal && included) {
      removeRow();
    }
  } else {
    if (included) {
      removeRow();
    } else {
      addRow();
    }
  }

  return changed;
}

function walkTreeNode(root, cb, childrenKey = "children", lazyKey = "hasChildren") {
  const isNil = array => !(Array.isArray(array) && array.length);

  function _walker(parent, children, level) {
    cb(parent, children, level);
    children.forEach(item => {
      if (item[lazyKey]) {
        cb(item, null, level + 1);
        return;
      }

      const children2 = item[childrenKey];

      if (!isNil(children2)) {
        _walker(item, children2, level + 1);
      }
    });
  }

  root.forEach(item => {
    if (item[lazyKey]) {
      cb(item, null, 0);
      return;
    }

    const children = item[childrenKey];

    if (!isNil(children)) {
      _walker(item, children, 0);
    }
  });
}

let removePopper;

function createTablePopper(trigger, popperContent, popperOptions, tooltipEffect) {
  const {
    nextZIndex
  } = useZIndex();

  function renderContent() {
    const isLight = tooltipEffect === "light";
    const content2 = document.createElement("div");
    content2.className = `el-popper ${isLight ? "is-light" : "is-dark"}`;
    popperContent = escape_html(popperContent);
    content2.innerHTML = popperContent;
    content2.style.zIndex = String(nextZIndex());
    document.body.appendChild(content2);
    return content2;
  }

  function renderArrow() {
    const arrow2 = document.createElement("div");
    arrow2.className = "el-popper__arrow";
    return arrow2;
  }

  function showPopper() {
    popperInstance && popperInstance.update();
  }

  removePopper = function removePopper2() {
    try {
      popperInstance && popperInstance.destroy();
      content && document.body.removeChild(content);
      off(trigger, "mouseenter", showPopper);
      off(trigger, "mouseleave", removePopper2);
    } catch (e) {}
  };

  let popperInstance = null;
  const content = renderContent();
  const arrow = renderArrow();
  content.appendChild(arrow);
  popperInstance = yn(trigger, content, {
    modifiers: [{
      name: "offset",
      options: {
        offset: [0, 8]
      }
    }, {
      name: "arrow",
      options: {
        element: arrow,
        padding: 10
      }
    }],
    ...popperOptions
  });
  event2_on(trigger, "mouseenter", showPopper);
  event2_on(trigger, "mouseleave", removePopper);
  return popperInstance;
}

const isFixedColumn = (index, fixed, store, realColumns) => {
  let start = 0;
  let after = index;

  if (realColumns) {
    if (realColumns[index].colSpan > 1) {
      return {};
    }

    for (let i = 0; i < index; i++) {
      start += realColumns[i].colSpan;
    }

    after = start + realColumns[index].colSpan - 1;
  } else {
    start = index;
  }

  let fixedLayout;
  const columns = store.states.columns;

  switch (fixed) {
    case "left":
      if (after < store.states.fixedLeafColumnsLength.value) {
        fixedLayout = "left";
      }

      break;

    case "right":
      if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
        fixedLayout = "right";
      }

      break;

    default:
      if (after < store.states.fixedLeafColumnsLength.value) {
        fixedLayout = "left";
      } else if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
        fixedLayout = "right";
      }

  }

  return fixedLayout ? {
    direction: fixedLayout,
    start,
    after
  } : {};
};

const getFixedColumnsClass = (namespace, index, fixed, store, realColumns) => {
  const classes = [];
  const {
    direction,
    start
  } = isFixedColumn(index, fixed, store, realColumns);

  if (direction) {
    const isLeft = direction === "left";
    classes.push(`${namespace}-fixed-column--${direction}`);

    if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {
      classes.push("is-last-column");
    } else if (!isLeft && start === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
      classes.push("is-first-column");
    }
  }

  return classes;
};

function getOffset(offset, column) {
  return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
}

const getFixedColumnOffset = (index, fixed, store, realColumns) => {
  const {
    direction,
    start = 0
  } = isFixedColumn(index, fixed, store, realColumns);

  if (!direction) {
    return;
  }

  const styles = {};
  const isLeft = direction === "left";
  const columns = store.states.columns.value;

  if (isLeft) {
    styles.left = columns.slice(0, index).reduce(getOffset, 0);
  } else {
    styles.right = columns.slice(start + 1).reverse().reduce(getOffset, 0);
  }

  return styles;
};

const ensurePosition = (style, key) => {
  if (!style) return;

  if (!Number.isNaN(style[key])) {
    style[key] = `${style[key]}px`;
  }
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/store/expand2.mjs



function useExpand(watcherData) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const defaultExpandAll = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const expandRows = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);

  const updateExpandRows = () => {
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;

    if (defaultExpandAll.value) {
      expandRows.value = data.slice();
    } else if (rowKey) {
      const expandRowsMap = getKeysMap(expandRows.value, rowKey);
      expandRows.value = data.reduce((prev, row) => {
        const rowId = getRowIdentity(row, rowKey);
        const rowInfo = expandRowsMap[rowId];

        if (rowInfo) {
          prev.push(row);
        }

        return prev;
      }, []);
    } else {
      expandRows.value = [];
    }
  };

  const toggleRowExpansion = (row, expanded) => {
    const changed = toggleRowStatus(expandRows.value, row, expanded);

    if (changed) {
      instance.emit("expand-change", row, expandRows.value.slice());
    }
  };

  const setExpandRowKeys = rowKeys => {
    instance.store.assertRowKey();
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    const keysMap = getKeysMap(data, rowKey);
    expandRows.value = rowKeys.reduce((prev, cur) => {
      const info = keysMap[cur];

      if (info) {
        prev.push(info.row);
      }

      return prev;
    }, []);
  };

  const isRowExpanded = row => {
    const rowKey = watcherData.rowKey.value;

    if (rowKey) {
      const expandMap = getKeysMap(expandRows.value, rowKey);
      return !!expandMap[getRowIdentity(row, rowKey)];
    }

    return expandRows.value.includes(row);
  };

  return {
    updateExpandRows,
    toggleRowExpansion,
    setExpandRowKeys,
    isRowExpanded,
    states: {
      expandRows,
      defaultExpandAll
    }
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/store/current2.mjs



function useCurrent(watcherData) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();

  const _currentRowKey = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

  const currentRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

  const setCurrentRowKey = key => {
    instance.store.assertRowKey();
    _currentRowKey.value = key;
    setCurrentRowByKey(key);
  };

  const restoreCurrentRowKey = () => {
    _currentRowKey.value = null;
  };

  const setCurrentRowByKey = key => {
    const {
      data,
      rowKey
    } = watcherData;
    let _currentRow = null;

    if (rowKey.value) {
      _currentRow = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(data) || []).find(item => getRowIdentity(item, rowKey.value) === key);
    }

    currentRow.value = _currentRow;
    instance.emit("current-change", currentRow.value, null);
  };

  const updateCurrentRow = _currentRow => {
    const oldCurrentRow = currentRow.value;

    if (_currentRow && _currentRow !== oldCurrentRow) {
      currentRow.value = _currentRow;
      instance.emit("current-change", currentRow.value, oldCurrentRow);
      return;
    }

    if (!_currentRow && oldCurrentRow) {
      currentRow.value = null;
      instance.emit("current-change", null, oldCurrentRow);
    }
  };

  const updateCurrentRowData = () => {
    const rowKey = watcherData.rowKey.value;
    const data = watcherData.data.value || [];
    const oldCurrentRow = currentRow.value;

    if (!data.includes(oldCurrentRow) && oldCurrentRow) {
      if (rowKey) {
        const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
        setCurrentRowByKey(currentRowKey);
      } else {
        currentRow.value = null;
      }

      if (currentRow.value === null) {
        instance.emit("current-change", null, oldCurrentRow);
      }
    } else if (_currentRowKey.value) {
      setCurrentRowByKey(_currentRowKey.value);
      restoreCurrentRowKey();
    }
  };

  return {
    setCurrentRowKey,
    restoreCurrentRowKey,
    setCurrentRowByKey,
    updateCurrentRow,
    updateCurrentRowData,
    states: {
      _currentRowKey,
      currentRow
    }
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/store/tree2.mjs




function useTree(watcherData) {
  const expandRowKeys = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const treeData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
  const indent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(16);
  const lazy = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const lazyTreeNodeMap = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
  const lazyColumnIdentifier = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("hasChildren");
  const childrenColumnName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("children");
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const normalizedData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (!watcherData.rowKey.value) return {};
    const data = watcherData.data.value || [];
    return normalize(data);
  });
  const normalizedLazyNode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const rowKey = watcherData.rowKey.value;
    const keys = Object.keys(lazyTreeNodeMap.value);
    const res = {};
    if (!keys.length) return res;
    keys.forEach(key => {
      if (lazyTreeNodeMap.value[key].length) {
        const item = {
          children: []
        };
        lazyTreeNodeMap.value[key].forEach(row => {
          const currentRowKey = getRowIdentity(row, rowKey);
          item.children.push(currentRowKey);

          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
            res[currentRowKey] = {
              children: []
            };
          }
        });
        res[key] = item;
      }
    });
    return res;
  });

  const normalize = data => {
    const rowKey = watcherData.rowKey.value;
    const res = {};
    walkTreeNode(data, (parent, children, level) => {
      const parentId = getRowIdentity(parent, rowKey);

      if (Array.isArray(children)) {
        res[parentId] = {
          children: children.map(row => getRowIdentity(row, rowKey)),
          level
        };
      } else if (lazy.value) {
        res[parentId] = {
          children: [],
          lazy: true,
          level
        };
      }
    }, childrenColumnName.value, lazyColumnIdentifier.value);
    return res;
  };

  const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = (_a => (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value)()) => {
    var _a2;

    const nested = normalizedData.value;
    const normalizedLazyNode_ = normalizedLazyNode.value;
    const keys = Object.keys(nested);
    const newTreeData = {};

    if (keys.length) {
      const oldTreeData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(treeData);
      const rootLazyRowKeys = [];

      const getExpanded = (oldValue, key) => {
        if (ifChangeExpandRowKeys) {
          if (expandRowKeys.value) {
            return ifExpandAll || expandRowKeys.value.includes(key);
          } else {
            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
          }
        } else {
          const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
        }
      };

      keys.forEach(key => {
        const oldValue = oldTreeData[key];
        const newValue = { ...nested[key]
        };
        newValue.expanded = getExpanded(oldValue, key);

        if (newValue.lazy) {
          const {
            loaded = false,
            loading = false
          } = oldValue || {};
          newValue.loaded = !!loaded;
          newValue.loading = !!loading;
          rootLazyRowKeys.push(key);
        }

        newTreeData[key] = newValue;
      });
      const lazyKeys = Object.keys(normalizedLazyNode_);

      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
        lazyKeys.forEach(key => {
          const oldValue = oldTreeData[key];
          const lazyNodeChildren = normalizedLazyNode_[key].children;

          if (rootLazyRowKeys.includes(key)) {
            if (newTreeData[key].children.length !== 0) {
              throw new Error("[ElTable]children must be an empty array.");
            }

            newTreeData[key].children = lazyNodeChildren;
          } else {
            const {
              loaded = false,
              loading = false
            } = oldValue || {};
            newTreeData[key] = {
              lazy: true,
              loaded: !!loaded,
              loading: !!loading,
              expanded: getExpanded(oldValue, key),
              children: lazyNodeChildren,
              level: ""
            };
          }
        });
      }
    }

    treeData.value = newTreeData;
    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => expandRowKeys.value, () => {
    updateTreeData(true);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => normalizedData.value, () => {
    updateTreeData();
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => normalizedLazyNode.value, () => {
    updateTreeData();
  });

  const updateTreeExpandKeys = value => {
    expandRowKeys.value = value;
    updateTreeData();
  };

  const toggleTreeExpansion = (row, expanded) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id = getRowIdentity(row, rowKey);
    const data = id && treeData.value[id];

    if (id && data && "expanded" in data) {
      const oldExpanded = data.expanded;
      expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
      treeData.value[id].expanded = expanded;

      if (oldExpanded !== expanded) {
        instance.emit("expand-change", row, expanded);
      }

      instance.store.updateTableScrollY();
    }
  };

  const loadOrToggle = row => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id = getRowIdentity(row, rowKey);
    const data = treeData.value[id];

    if (lazy.value && data && "loaded" in data && !data.loaded) {
      loadData(row, id, data);
    } else {
      toggleTreeExpansion(row, void 0);
    }
  };

  const loadData = (row, key, treeNode) => {
    const {
      load
    } = instance.props;

    if (load && !treeData.value[key].loaded) {
      treeData.value[key].loading = true;
      load(row, treeNode, data => {
        if (!Array.isArray(data)) {
          throw new TypeError("[ElTable] data must be an array");
        }

        treeData.value[key].loading = false;
        treeData.value[key].loaded = true;
        treeData.value[key].expanded = true;

        if (data.length) {
          lazyTreeNodeMap.value[key] = data;
        }

        instance.emit("expand-change", row, true);
      });
    }
  };

  return {
    loadData,
    loadOrToggle,
    toggleTreeExpansion,
    updateTreeExpandKeys,
    updateTreeData,
    normalize,
    states: {
      expandRowKeys,
      treeData,
      indent,
      lazy,
      lazyTreeNodeMap,
      lazyColumnIdentifier,
      childrenColumnName
    }
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/store/watcher2.mjs









const sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;

  if (!sortingColumn || typeof sortingColumn.sortable === "string") {
    return data;
  }

  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};

const doFlattenColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.children) {
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};

function useWatcher() {
  var _a;

  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const {
    size: tableSize
  } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)((_a = instance.proxy) == null ? void 0 : _a.$props);
  const rowKey = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const data = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);

  const _data = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);

  const isComplex = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);

  const _columns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);

  const originColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const columns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const fixedColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const rightFixedColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const leafColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const fixedLeafColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const rightFixedLeafColumns = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const leafColumnsLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
  const fixedLeafColumnsLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
  const rightFixedLeafColumnsLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
  const isAllSelected = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const selection = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const reserveSelection = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const selectOnIndeterminate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const selectable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const filters = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
  const filteredData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const sortingColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const sortProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const sortOrder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const hoverRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(data, () => instance.state && scheduleLayout(false), {
    deep: true
  });

  const assertRowKey = () => {
    if (!rowKey.value) throw new Error("[ElTable] prop row-key is required");
  };

  const updateColumns = () => {
    fixedColumns.value = _columns.value.filter(column => column.fixed === true || column.fixed === "left");
    rightFixedColumns.value = _columns.value.filter(column => column.fixed === "right");

    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
      _columns.value[0].fixed = true;
      fixedColumns.value.unshift(_columns.value[0]);
    }

    const notFixedColumns = _columns.value.filter(column => !column.fixed);

    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
    const leafColumns2 = doFlattenColumns(notFixedColumns);
    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
    leafColumnsLength.value = leafColumns2.length;
    fixedLeafColumnsLength.value = fixedLeafColumns2.length;
    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
    columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
  };

  const scheduleLayout = (needUpdateColumns, immediate = false) => {
    if (needUpdateColumns) {
      updateColumns();
    }

    if (immediate) {
      instance.state.doLayout();
    } else {
      instance.state.debouncedUpdateLayout();
    }
  };

  const isSelected = row => {
    return selection.value.includes(row);
  };

  const clearSelection = () => {
    isAllSelected.value = false;
    const oldSelection = selection.value;

    if (oldSelection.length) {
      selection.value = [];
      instance.emit("selection-change", []);
    }
  };

  const cleanSelection = () => {
    let deleted;

    if (rowKey.value) {
      deleted = [];
      const selectedMap = getKeysMap(selection.value, rowKey.value);
      const dataMap = getKeysMap(data.value, rowKey.value);

      for (const key in selectedMap) {
        if (shared_esm_bundler_hasOwn(selectedMap, key) && !dataMap[key]) {
          deleted.push(selectedMap[key].row);
        }
      }
    } else {
      deleted = selection.value.filter(item => !data.value.includes(item));
    }

    if (deleted.length) {
      const newSelection = selection.value.filter(item => !deleted.includes(item));
      selection.value = newSelection;
      instance.emit("selection-change", newSelection.slice());
    }
  };

  const getSelectionRows = () => {
    return (selection.value || []).slice();
  };

  const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
    const changed = toggleRowStatus(selection.value, row, selected);

    if (changed) {
      const newSelection = (selection.value || []).slice();

      if (emitChange) {
        instance.emit("select", newSelection, row);
      }

      instance.emit("selection-change", newSelection);
    }
  };

  const _toggleAllSelection = () => {
    var _a2, _b;

    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
    isAllSelected.value = value;
    let selectionChanged = false;
    let childrenCount = 0;
    const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;
    data.value.forEach((row, index) => {
      const rowIndex = index + childrenCount;

      if (selectable.value) {
        if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      }

      childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
    });

    if (selectionChanged) {
      instance.emit("selection-change", selection.value ? selection.value.slice() : []);
    }

    instance.emit("select-all", selection.value);
  };

  const updateSelectionByRowKey = () => {
    const selectedMap = getKeysMap(selection.value, rowKey.value);
    data.value.forEach(row => {
      const rowId = getRowIdentity(row, rowKey.value);
      const rowInfo = selectedMap[rowId];

      if (rowInfo) {
        selection.value[rowInfo.index] = row;
      }
    });
  };

  const updateAllSelected = () => {
    var _a2, _b, _c;

    if (((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {
      isAllSelected.value = false;
      return;
    }

    let selectedMap;

    if (rowKey.value) {
      selectedMap = getKeysMap(selection.value, rowKey.value);
    }

    const isSelected2 = function (row) {
      if (selectedMap) {
        return !!selectedMap[getRowIdentity(row, rowKey.value)];
      } else {
        return selection.value.includes(row);
      }
    };

    let isAllSelected_ = true;
    let selectedCount = 0;
    let childrenCount = 0;

    for (let i = 0, j = (data.value || []).length; i < j; i++) {
      const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
      const rowIndex = i + childrenCount;
      const item = data.value[i];
      const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);

      if (!isSelected2(item)) {
        if (!selectable.value || isRowSelectable) {
          isAllSelected_ = false;
          break;
        }
      } else {
        selectedCount++;
      }

      childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
    }

    if (selectedCount === 0) isAllSelected_ = false;
    isAllSelected.value = isAllSelected_;
  };

  const getChildrenCount = rowKey2 => {
    var _a2;

    if (!instance || !instance.store) return 0;
    const {
      treeData
    } = instance.store.states;
    let count = 0;
    const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;

    if (children) {
      count += children.length;
      children.forEach(childKey => {
        count += getChildrenCount(childKey);
      });
    }

    return count;
  };

  const updateFilters = (columns2, values) => {
    if (!Array.isArray(columns2)) {
      columns2 = [columns2];
    }

    const filters_ = {};
    columns2.forEach(col => {
      filters.value[col.id] = values;
      filters_[col.columnKey || col.id] = values;
    });
    return filters_;
  };

  const updateSort = (column, prop, order) => {
    if (sortingColumn.value && sortingColumn.value !== column) {
      sortingColumn.value.order = null;
    }

    sortingColumn.value = column;
    sortProp.value = prop;
    sortOrder.value = order;
  };

  const execFilter = () => {
    let sourceData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(_data);
    Object.keys(filters.value).forEach(columnId => {
      const values = filters.value[columnId];
      if (!values || values.length === 0) return;
      const column = getColumnById({
        columns: columns.value
      }, columnId);

      if (column && column.filterMethod) {
        sourceData = sourceData.filter(row => {
          return values.some(value => column.filterMethod.call(null, value, row, column));
        });
      }
    });
    filteredData.value = sourceData;
  };

  const execSort = () => {
    data.value = sortData(filteredData.value, {
      sortingColumn: sortingColumn.value,
      sortProp: sortProp.value,
      sortOrder: sortOrder.value
    });
  };

  const execQuery = (ignore = void 0) => {
    if (!(ignore && ignore.filter)) {
      execFilter();
    }

    execSort();
  };

  const clearFilter = columnKeys => {
    const {
      tableHeaderRef
    } = instance.refs;
    if (!tableHeaderRef) return;
    const panels = Object.assign({}, tableHeaderRef.filterPanels);
    const keys = Object.keys(panels);
    if (!keys.length) return;

    if (typeof columnKeys === "string") {
      columnKeys = [columnKeys];
    }

    if (Array.isArray(columnKeys)) {
      const columns_ = columnKeys.map(key => getColumnByKey({
        columns: columns.value
      }, key));
      keys.forEach(key => {
        const column = columns_.find(col => col.id === key);

        if (column) {
          column.filteredValue = [];
        }
      });
      instance.store.commit("filterChange", {
        column: columns_,
        values: [],
        silent: true,
        multi: true
      });
    } else {
      keys.forEach(key => {
        const column = columns.value.find(col => col.id === key);

        if (column) {
          column.filteredValue = [];
        }
      });
      filters.value = {};
      instance.store.commit("filterChange", {
        column: {},
        values: [],
        silent: true
      });
    }
  };

  const clearSort = () => {
    if (!sortingColumn.value) return;
    updateSort(null, null, null);
    instance.store.commit("changeSortCondition", {
      silent: true
    });
  };

  const {
    setExpandRowKeys,
    toggleRowExpansion,
    updateExpandRows,
    states: expandStates,
    isRowExpanded
  } = useExpand({
    data,
    rowKey
  });
  const {
    updateTreeExpandKeys,
    toggleTreeExpansion,
    updateTreeData,
    loadOrToggle,
    states: treeStates
  } = useTree({
    data,
    rowKey
  });
  const {
    updateCurrentRowData,
    updateCurrentRow,
    setCurrentRowKey,
    states: currentData
  } = useCurrent({
    data,
    rowKey
  });

  const setExpandRowKeysAdapter = val => {
    setExpandRowKeys(val);
    updateTreeExpandKeys(val);
  };

  const toggleRowExpansionAdapter = (row, expanded) => {
    const hasExpandColumn = columns.value.some(({
      type
    }) => type === "expand");

    if (hasExpandColumn) {
      toggleRowExpansion(row, expanded);
    } else {
      toggleTreeExpansion(row, expanded);
    }
  };

  return {
    assertRowKey,
    updateColumns,
    scheduleLayout,
    isSelected,
    clearSelection,
    cleanSelection,
    getSelectionRows,
    toggleRowSelection,
    _toggleAllSelection,
    toggleAllSelection: null,
    updateSelectionByRowKey,
    updateAllSelected,
    updateFilters,
    updateCurrentRow,
    updateSort,
    execFilter,
    execSort,
    execQuery,
    clearFilter,
    clearSort,
    toggleRowExpansion,
    setExpandRowKeysAdapter,
    setCurrentRowKey,
    toggleRowExpansionAdapter,
    isRowExpanded,
    updateExpandRows,
    updateCurrentRowData,
    loadOrToggle,
    updateTreeData,
    states: {
      tableSize,
      rowKey,
      data,
      _data,
      isComplex,
      _columns,
      originColumns,
      columns,
      fixedColumns,
      rightFixedColumns,
      leafColumns,
      fixedLeafColumns,
      rightFixedLeafColumns,
      leafColumnsLength,
      fixedLeafColumnsLength,
      rightFixedLeafColumnsLength,
      isAllSelected,
      selection,
      reserveSelection,
      selectOnIndeterminate,
      selectable,
      filters,
      filteredData,
      sortingColumn,
      sortProp,
      sortOrder,
      hoverRow,
      ...expandStates,
      ...treeStates,
      ...currentData
    }
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/store/index2.mjs






function replaceColumn(array, column) {
  return array.map(item => {
    var _a;

    if (item.id === column.id) {
      return column;
    } else if ((_a = item.children) == null ? void 0 : _a.length) {
      item.children = replaceColumn(item.children, column);
    }

    return item;
  });
}

function sortColumn(array) {
  array.forEach(item => {
    var _a, _b;

    item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);

    if ((_b = item.children) == null ? void 0 : _b.length) {
      sortColumn(item.children);
    }
  });
  array.sort((cur, pre) => cur.no - pre.no);
}

function index2_useStore() {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const watcher = useWatcher();
  const ns = useNamespace("table");
  const mutations = {
    setData(states, data) {
      const dataInstanceChanged = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(states._data) !== data;
      states.data.value = data;
      states._data.value = data;
      instance.store.execQuery();
      instance.store.updateCurrentRowData();
      instance.store.updateExpandRows();
      instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);

      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(states.reserveSelection)) {
        instance.store.assertRowKey();
        instance.store.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          instance.store.clearSelection();
        } else {
          instance.store.cleanSelection();
        }
      }

      instance.store.updateAllSelected();

      if (instance.$ready) {
        instance.store.scheduleLayout();
      }
    },

    insertColumn(states, column, parent) {
      const array = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(states._columns);
      let newColumns = [];

      if (!parent) {
        array.push(column);
        newColumns = array;
      } else {
        if (parent && !parent.children) {
          parent.children = [];
        }

        parent.children.push(column);
        newColumns = replaceColumn(array, parent);
      }

      sortColumn(newColumns);
      states._columns.value = newColumns;

      if (column.type === "selection") {
        states.selectable.value = column.selectable;
        states.reserveSelection.value = column.reserveSelection;
      }

      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },

    removeColumn(states, column, parent) {
      const array = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(states._columns) || [];

      if (parent) {
        parent.children.splice(parent.children.findIndex(item => item.id === column.id), 1);

        if (parent.children.length === 0) {
          delete parent.children;
        }

        states._columns.value = replaceColumn(array, parent);
      } else {
        const index = array.indexOf(column);

        if (index > -1) {
          array.splice(index, 1);
          states._columns.value = array;
        }
      }

      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },

    sort(states, options) {
      const {
        prop,
        order,
        init
      } = options;

      if (prop) {
        const column = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(states.columns).find(column2 => column2.property === prop);

        if (column) {
          column.order = order;
          instance.store.updateSort(column, prop, order);
          instance.store.commit("changeSortCondition", {
            init
          });
        }
      }
    },

    changeSortCondition(states, options) {
      const {
        sortingColumn: column,
        sortProp: prop,
        sortOrder: order
      } = states;

      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(order) === null) {
        states.sortingColumn.value = null;
        states.sortProp.value = null;
      }

      const ingore = {
        filter: true
      };
      instance.store.execQuery(ingore);

      if (!options || !(options.silent || options.init)) {
        instance.emit("sort-change", {
          column: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(column),
          prop: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(prop),
          order: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(order)
        });
      }

      instance.store.updateTableScrollY();
    },

    filterChange(_states, options) {
      const {
        column,
        values,
        silent
      } = options;
      const newFilters = instance.store.updateFilters(column, values);
      instance.store.execQuery();

      if (!silent) {
        instance.emit("filter-change", newFilters);
      }

      instance.store.updateTableScrollY();
    },

    toggleAllSelection() {
      instance.store.toggleAllSelection();
    },

    rowSelectedChanged(_states, row) {
      instance.store.toggleRowSelection(row);
      instance.store.updateAllSelected();
    },

    setHoverRow(states, row) {
      states.hoverRow.value = row;
    },

    setCurrentRow(_states, row) {
      instance.store.updateCurrentRow(row);
    }

  };

  const commit = function (name, ...args) {
    const mutations2 = instance.store.mutations;

    if (mutations2[name]) {
      mutations2[name].apply(instance, [instance.store.states].concat(args));
    } else {
      throw new Error(`Action not found: ${name}`);
    }
  };

  const updateTableScrollY = function () {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => instance.layout.updateScrollY.apply(instance.layout));
  };

  return {
    ns,
    ...watcher,
    mutations,
    commit,
    updateTableScrollY
  };
}

class HelperStore {
  constructor() {
    this.Return = index2_useStore();
  }

}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/store/helper2.mjs




const InitialStateMap = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};

function helper2_createStore(table, props) {
  if (!table) {
    throw new Error("Table is required.");
  }

  const store = index2_useStore();
  store.toggleAllSelection = lodash_es_debounce(store._toggleAllSelection, 10);
  Object.keys(InitialStateMap).forEach(key => {
    handleValue(getArrKeysValue(props, key), key, store);
  });
  proxyTableProps(store, props);
  return store;
}

function proxyTableProps(store, props) {
  Object.keys(InitialStateMap).forEach(key => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => getArrKeysValue(props, key), value => {
      handleValue(value, key, store);
    });
  });
}

function handleValue(value, propsKey, store) {
  let newVal = value;
  let storeKey = InitialStateMap[propsKey];

  if (typeof InitialStateMap[propsKey] === "object") {
    storeKey = storeKey.key;
    newVal = newVal || InitialStateMap[propsKey].default;
  }

  store.states[storeKey].value = newVal;
}

function getArrKeysValue(props, keys) {
  if (keys.includes(".")) {
    const keyList = keys.split(".");
    let value = props;
    keyList.forEach(key => {
      value = value[key];
    });
    return value;
  } else {
    return props[keys];
  }
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-layout2.mjs







class TableLayout {
  constructor(options) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = [];
    this.fit = true;
    this.showHeader = true;
    this.height = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.scrollX = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    this.scrollY = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    this.bodyWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.fixedWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.rightFixedWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.tableHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.headerHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(44);
    this.appendHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    this.footerHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(44);
    this.viewportHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.bodyHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.bodyScrollHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    this.fixedBodyHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    this.gutterWidth = 0;

    for (const name in options) {
      if (shared_esm_bundler_hasOwn(options, name)) {
        if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.isRef)(this[name])) {
          this[name].value = options[name];
        } else {
          this[name] = options[name];
        }
      }
    }

    if (!this.table) {
      throw new Error("Table is required for Table Layout");
    }

    if (!this.store) {
      throw new Error("Store is required for Table Layout");
    }
  }

  updateScrollY() {
    const height = this.height.value;
    if (height === null) return false;
    const bodyWrapper = this.table.refs.bodyWrapper;

    if (this.table.vnode.el && bodyWrapper) {
      let scrollY = true;
      const prevScrollY = this.scrollY.value;

      if (this.bodyHeight.value === null) {
        scrollY = false;
      } else {
        scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value;
      }

      this.scrollY.value = scrollY;
      return prevScrollY !== scrollY;
    }

    return false;
  }

  setHeight(value, prop = "height") {
    if (!shared_isClient) return;
    const el = this.table.vnode.el;
    value = parseHeight(value);
    this.height.value = Number(value);
    if (!el && (value || value === 0)) return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => this.setHeight(value, prop));

    if (typeof value === "number") {
      el.style[prop] = `${value}px`;
      this.updateElsHeight();
    } else if (typeof value === "string") {
      el.style[prop] = value;
      this.updateElsHeight();
    }
  }

  setMaxHeight(value) {
    this.setHeight(value, "max-height");
  }

  getFlattenColumns() {
    const flattenColumns = [];
    const columns = this.table.store.states.columns.value;
    columns.forEach(column => {
      if (column.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });
    return flattenColumns;
  }

  updateElsHeight() {
    var _a, _b;

    if (!this.table.$ready) return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => this.updateElsHeight());
    const {
      tableWrapper,
      headerWrapper,
      appendWrapper,
      footerWrapper,
      tableHeader,
      tableBody
    } = this.table.refs;

    if (tableWrapper && tableWrapper.style.display === "none") {
      return;
    }

    const {
      tableLayout
    } = this.table.props;
    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;

    if (this.showHeader && !headerWrapper && tableLayout === "fixed") {
      return;
    }

    const headerTrElm = tableHeader ? tableHeader : null;
    const noneHeader = this.headerDisplayNone(headerTrElm);
    const headerWrapperOffsetHeight = (headerWrapper == null ? void 0 : headerWrapper.offsetHeight) || 0;
    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapperOffsetHeight;

    if (this.showHeader && !noneHeader && headerWrapperOffsetHeight > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => this.updateElsHeight());
    }

    const tableHeight = this.tableHeight.value = (_b = (_a = this.table) == null ? void 0 : _a.vnode.el) == null ? void 0 : _b.clientHeight;
    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;

    if (this.height.value !== null) {
      if (this.bodyHeight.value === null) {
        requestAnimationFrame(() => this.updateElsHeight());
      }

      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
      this.bodyScrollHeight.value = tableBody == null ? void 0 : tableBody.scrollHeight;
    }

    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;
    this.updateScrollY();
    this.notifyObservers("scrollable");
  }

  headerDisplayNone(elm) {
    if (!elm) return true;
    let headerChild = elm;

    while (headerChild.tagName !== "DIV") {
      if (getComputedStyle(headerChild).display === "none") {
        return true;
      }

      headerChild = headerChild.parentElement;
    }

    return false;
  }

  updateColumnsWidth() {
    if (!shared_isClient) return;
    const fit = this.fit;
    const bodyWidth = this.table.vnode.el.clientWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    const flexColumns = flattenColumns.filter(column => typeof column.width !== "number");
    flattenColumns.forEach(column => {
      if (typeof column.width === "number" && column.realWidth) column.realWidth = null;
    });

    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach(column => {
        bodyMinWidth += Number(column.width || column.minWidth || 80);
      });

      if (bodyMinWidth <= bodyWidth) {
        this.scrollX.value = false;
        const totalFlexWidth = bodyWidth - bodyMinWidth;

        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
          let noneFirstWidth = 0;
          flexColumns.forEach((column, index) => {
            if (index === 0) return;
            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
            noneFirstWidth += flexWidth;
            column.realWidth = Number(column.minWidth || 80) + flexWidth;
          });
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
        }
      } else {
        this.scrollX.value = true;
        flexColumns.forEach(column => {
          column.realWidth = Number(column.minWidth);
        });
      }

      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
      this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else {
      flattenColumns.forEach(column => {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = Number(column.width || column.minWidth);
        }

        bodyMinWidth += column.realWidth;
      });
      this.scrollX.value = bodyMinWidth > bodyWidth;
      this.bodyWidth.value = bodyMinWidth;
    }

    const fixedColumns = this.store.states.fixedColumns.value;

    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach(column => {
        fixedWidth += Number(column.realWidth || column.width);
      });
      this.fixedWidth.value = fixedWidth;
    }

    const rightFixedColumns = this.store.states.rightFixedColumns.value;

    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach(column => {
        rightFixedWidth += Number(column.realWidth || column.width);
      });
      this.rightFixedWidth.value = rightFixedWidth;
    }

    this.notifyObservers("columns");
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    const index = this.observers.indexOf(observer);

    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }

  notifyObservers(event) {
    const observers = this.observers;
    observers.forEach(observer => {
      var _a, _b;

      switch (event) {
        case "columns":
          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
          break;

        case "scrollable":
          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
          break;

        default:
          throw new Error(`Table Layout don't have event ${event}.`);
      }
    });
  }

}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/checkbox/src/useCheckbox2.mjs












const useCheckboxGroupProps = {
  modelValue: {
    type: Array,
    default: () => []
  },
  disabled: Boolean,
  min: {
    type: Number,
    default: void 0
  },
  max: {
    type: Number,
    default: void 0
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  id: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  fill: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: void 0
  },
  tag: {
    type: String,
    default: "div"
  }
};
const useCheckboxProps = {
  modelValue: {
    type: [Number, String, Boolean],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: {
    type: String,
    validator: isValidComponentSize
  },
  tabindex: [String, Number]
};

const useCheckboxGroup = () => {
  const elForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, {});
  const elFormItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, {});
  const checkboxGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)("CheckboxGroup", {});
  const isGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
  const elFormItemSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return elFormItem.size;
  });
  return {
    isGroup,
    checkboxGroup,
    elForm,
    elFormItemSize,
    elFormItem
  };
};

const useCheckboxGroupId = (props, {
  elFormItem
}) => {
  const {
    inputId: groupId,
    isLabeledByFormItem
  } = useFormItemInputId(props, {
    formItemContext: elFormItem
  });
  return {
    isLabeledByFormItem,
    groupId
  };
};

const useModel = props => {
  const selfModel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const {
    emit
  } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const {
    isGroup,
    checkboxGroup,
    elFormItem
  } = useCheckboxGroup();
  const isLimitExceeded = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const model = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
    get() {
      var _a, _b;

      return isGroup.value ? (_a = checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;
    },

    set(val) {
      var _a;

      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;
        isLimitExceeded.value === false && ((_a = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a.call(checkboxGroup, val));
      } else {
        emit(UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }

  });
  return {
    model,
    isGroup,
    isLimitExceeded,
    elFormItem
  };
};

const useCheckboxStatus = (props, slots, {
  model
}) => {
  const {
    isGroup,
    checkboxGroup
  } = useCheckboxGroup();
  const focus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const size = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, {
    prop: true
  });
  const isChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const value = model.value;

    if (toTypeString(value) === "[object Boolean]") {
      return value;
    } else if (Array.isArray(value)) {
      return value.includes(props.label);
    } else if (value !== null && value !== void 0) {
      return value === props.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxSize = useSize((0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    var _a;

    return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value : void 0;
  }));
  const hasOwnLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return !!(slots.default || props.label);
  });
  return {
    isChecked,
    focus,
    size,
    checkboxSize,
    hasOwnLabel
  };
};

const useCheckbox2_useDisabled = (props, {
  model,
  isChecked
}) => {
  const {
    elForm,
    isGroup,
    checkboxGroup
  } = useCheckboxGroup();
  const isLimitDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    var _a, _b;

    const max = (_a = checkboxGroup.max) == null ? void 0 : _a.value;
    const min = (_b = checkboxGroup.min) == null ? void 0 : _b.value;
    return !!(max || min) && model.value.length >= max && !isChecked.value || model.value.length <= min && isChecked.value;
  });
  const isDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    var _a, _b;

    const disabled = props.disabled || (elForm == null ? void 0 : elForm.disabled);
    return (_b = isGroup.value ? ((_a = checkboxGroup.disabled) == null ? void 0 : _a.value) || disabled || isLimitDisabled.value : disabled) != null ? _b : false;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};

const setStoreValue = (props, {
  model
}) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props.label)) {
      model.value.push(props.label);
    } else {
      model.value = props.trueLabel || true;
    }
  }

  props.checked && addToStore();
};

const useEvent = (props, {
  model,
  isLimitExceeded,
  hasOwnLabel,
  isDisabled,
  isLabeledByFormItem
}) => {
  const {
    elFormItem
  } = useCheckboxGroup();
  const {
    emit
  } = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();

  function getLabeledValue(value) {
    var _a, _b;

    return value === props.trueLabel || value === true ? (_a = props.trueLabel) != null ? _a : true : (_b = props.falseLabel) != null ? _b : false;
  }

  function emitChangeEvent(checked, e) {
    emit("change", getLabeledValue(checked), e);
  }

  function handleChange(e) {
    if (isLimitExceeded.value) return;
    const target = e.target;
    emit("change", getLabeledValue(target.checked), e);
  }

  async function onClickRoot(e) {
    if (isLimitExceeded.value) return;

    if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
      model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      emitChangeEvent(model.value, e);
    }
  }

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
    var _a;

    (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch(err => error2_debugWarn(err));
  });
  return {
    handleChange,
    onClickRoot
  };
};

const useCheckbox = (props, slots) => {
  const {
    model,
    isGroup,
    isLimitExceeded,
    elFormItem
  } = useModel(props);
  const {
    focus,
    size,
    isChecked,
    checkboxSize,
    hasOwnLabel
  } = useCheckboxStatus(props, slots, {
    model
  });
  const {
    isDisabled
  } = useCheckbox2_useDisabled(props, {
    model,
    isChecked
  });
  const {
    inputId,
    isLabeledByFormItem
  } = useFormItemInputId(props, {
    formItemContext: elFormItem,
    disableIdGeneration: hasOwnLabel,
    disableIdManagement: isGroup
  });
  const {
    handleChange,
    onClickRoot
  } = useEvent(props, {
    model,
    isLimitExceeded,
    hasOwnLabel,
    isDisabled,
    isLabeledByFormItem
  });
  setStoreValue(props, {
    model
  });
  return {
    elFormItem,
    inputId,
    isLabeledByFormItem,
    isChecked,
    isDisabled,
    isGroup,
    checkboxSize,
    hasOwnLabel,
    model,
    handleChange,
    onClickRoot,
    focus,
    size
  };
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/checkbox/src/checkbox2.mjs








const checkbox2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElCheckbox",
  props: useCheckboxProps,
  emits: [UPDATE_MODEL_EVENT, "change"],

  setup(props, {
    slots
  }) {
    const ns = useNamespace("checkbox");
    return {
      ns,
      ...useCheckbox(props, slots)
    };
  }

});

const checkbox2_hoisted_1 = ["tabindex", "role", "aria-checked"];
const checkbox2_hoisted_2 = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
const checkbox2_hoisted_3 = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];

function checkbox2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(!_ctx.hasOwnLabel && _ctx.isLabeledByFormItem ? "span" : "label"), {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.b(), _ctx.ns.m(_ctx.checkboxSize), _ctx.ns.is("disabled", _ctx.isDisabled), _ctx.ns.is("bordered", _ctx.border), _ctx.ns.is("checked", _ctx.isChecked)]),
    "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
    onClick: _ctx.onClickRoot
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("input"), _ctx.ns.is("disabled", _ctx.isDisabled), _ctx.ns.is("checked", _ctx.isChecked), _ctx.ns.is("indeterminate", _ctx.indeterminate), _ctx.ns.is("focus", _ctx.focus)]),
      tabindex: _ctx.indeterminate ? 0 : void 0,
      role: _ctx.indeterminate ? "checkbox" : void 0,
      "aria-checked": _ctx.indeterminate ? "mixed" : void 0
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("inner"))
    }, null, 2), _ctx.trueLabel || _ctx.falseLabel ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("input", {
      key: 0,
      id: _ctx.inputId,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.model = $event),
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("original")),
      type: "checkbox",
      "aria-hidden": _ctx.indeterminate ? "true" : "false",
      name: _ctx.name,
      tabindex: _ctx.tabindex,
      disabled: _ctx.isDisabled,
      "true-value": _ctx.trueLabel,
      "false-value": _ctx.falseLabel,
      onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[2] || (_cache[2] = $event => _ctx.focus = true),
      onBlur: _cache[3] || (_cache[3] = $event => _ctx.focus = false)
    }, null, 42, checkbox2_hoisted_2)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vModelCheckbox, _ctx.model]]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("input", {
      key: 1,
      id: _ctx.inputId,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.model = $event),
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("original")),
      type: "checkbox",
      "aria-hidden": _ctx.indeterminate ? "true" : "false",
      disabled: _ctx.isDisabled,
      value: _ctx.label,
      name: _ctx.name,
      tabindex: _ctx.tabindex,
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[6] || (_cache[6] = $event => _ctx.focus = true),
      onBlur: _cache[7] || (_cache[7] = $event => _ctx.focus = false)
    }, null, 42, checkbox2_hoisted_3)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vModelCheckbox, _ctx.model]])], 10, checkbox2_hoisted_1), _ctx.hasOwnLabel ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
      key: 0,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("label"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default"), !_ctx.$slots.default ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
      key: 0
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.label), 1)], 2112)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
    _: 3
  }, 8, ["class", "aria-controls", "onClick"]);
}

var Checkbox = /* @__PURE__ */_export_sfc(checkbox2_sfc_main, [["render", checkbox2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/checkbox/src/checkbox-button2.mjs








const checkbox_button2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElCheckboxButton",
  props: useCheckboxProps,
  emits: [UPDATE_MODEL_EVENT, "change"],

  setup(props, {
    slots
  }) {
    const {
      focus,
      isChecked,
      isDisabled,
      size,
      model,
      handleChange
    } = useCheckbox(props, slots);
    const {
      checkboxGroup
    } = useCheckboxGroup();
    const ns = useNamespace("checkbox");
    const activeStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b, _c, _d;

      const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : null
      };
    });
    return {
      focus,
      isChecked,
      isDisabled,
      model,
      handleChange,
      activeStyle,
      size,
      ns
    };
  }

});

const checkbox_button2_hoisted_1 = ["name", "tabindex", "disabled", "true-value", "false-value"];
const checkbox_button2_hoisted_2 = ["name", "tabindex", "disabled", "value"];

function checkbox_button2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("label", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.b("button"), _ctx.ns.bm("button", _ctx.size), _ctx.ns.is("disabled", _ctx.isDisabled), _ctx.ns.is("checked", _ctx.isChecked), _ctx.ns.is("focus", _ctx.focus)])
  }, [_ctx.trueLabel || _ctx.falseLabel ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("input", {
    key: 0,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.model = $event),
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("button", "original")),
    type: "checkbox",
    name: _ctx.name,
    tabindex: _ctx.tabindex,
    disabled: _ctx.isDisabled,
    "true-value": _ctx.trueLabel,
    "false-value": _ctx.falseLabel,
    onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
    onFocus: _cache[2] || (_cache[2] = $event => _ctx.focus = true),
    onBlur: _cache[3] || (_cache[3] = $event => _ctx.focus = false)
  }, null, 42, checkbox_button2_hoisted_1)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vModelCheckbox, _ctx.model]]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("input", {
    key: 1,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.model = $event),
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("button", "original")),
    type: "checkbox",
    name: _ctx.name,
    tabindex: _ctx.tabindex,
    disabled: _ctx.isDisabled,
    value: _ctx.label,
    onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
    onFocus: _cache[6] || (_cache[6] = $event => _ctx.focus = true),
    onBlur: _cache[7] || (_cache[7] = $event => _ctx.focus = false)
  }, null, 42, checkbox_button2_hoisted_2)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vModelCheckbox, _ctx.model]]), _ctx.$slots.default || _ctx.label ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
    key: 2,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("button", "inner")),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.isChecked ? _ctx.activeStyle : null)
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.label), 1)])], 6)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2);
}

var CheckboxButton = /* @__PURE__ */_export_sfc(checkbox_button2_sfc_main, [["render", checkbox_button2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/checkbox/src/checkbox-group2.mjs











const checkbox_group2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElCheckboxGroup",
  props: useCheckboxGroupProps,
  emits: [UPDATE_MODEL_EVENT, "change"],

  setup(props, {
    emit,
    slots
  }) {
    const {
      elFormItem
    } = useCheckboxGroup();
    const {
      groupId,
      isLabeledByFormItem
    } = useCheckboxGroupId(props, {
      elFormItem
    });
    const checkboxGroupSize = useSize();
    const ns = useNamespace("checkbox");

    const changeEvent = value => {
      emit(UPDATE_MODEL_EVENT, value);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        emit("change", value);
      });
    };

    const modelValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
      get() {
        return props.modelValue;
      },

      set(val) {
        changeEvent(val);
      }

    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)("CheckboxGroup", {
      name: "ElCheckboxGroup",
      modelValue,
      ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(props),
      checkboxGroupSize,
      changeEvent
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      var _a;

      (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch(err => error2_debugWarn(err));
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(props.tag, {
        id: groupId.value,
        class: ns.b("group"),
        role: "group",
        "aria-label": !isLabeledByFormItem.value ? props.label || "checkbox-group" : void 0,
        "aria-labelledby": isLabeledByFormItem.value ? elFormItem.labelId : void 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(slots, "default")]);
    };
  }

});

var CheckboxGroup = /* @__PURE__ */_export_sfc(checkbox_group2_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/checkbox/index2.mjs





const ElCheckbox = withInstall(Checkbox, {
  CheckboxButton: CheckboxButton,
  CheckboxGroup: CheckboxGroup
});
const ElCheckboxButton = withNoopInstall(CheckboxButton);
const ElCheckboxGroup = withNoopInstall(CheckboxGroup);

;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/arrow-down.mjs



const arrow_down_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ArrowDown"
});

const arrow_down_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const arrow_down_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
}, null, -1);

const arrow_down_hoisted_3 = [arrow_down_hoisted_2];

function arrow_down_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", arrow_down_hoisted_1, arrow_down_hoisted_3);
}

var arrowDown = /* @__PURE__ */plugin_vue_export_helper_export_sfc(arrow_down_sfc_main, [["render", arrow_down_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/filter-panel2.mjs












const {
  CheckboxGroup: filter_panel2_ElCheckboxGroup
} = ElCheckbox;

const filter_panel2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: ElCheckbox,
    ElCheckboxGroup: filter_panel2_ElCheckboxGroup,
    ElScrollbar: ElScrollbar,
    ElTooltip: ElTooltip,
    ElIcon: ElIcon,
    ArrowDown: arrowDown,
    ArrowUp: arrowUp
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },

  setup(props) {
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const {
      t
    } = useLocale();
    const ns = useNamespace("table-filter");
    const parent = instance == null ? void 0 : instance.parent;

    if (!parent.filterPanels.value[props.column.id]) {
      parent.filterPanels.value[props.column.id] = instance;
    }

    const tooltipVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const tooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const filters = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.column && props.column.filters;
    });
    const filterValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
      get: () => {
        var _a;

        return (((_a = props.column) == null ? void 0 : _a.filteredValue) || [])[0];
      },
      set: value => {
        if (filteredValue.value) {
          if (typeof value !== "undefined" && value !== null) {
            filteredValue.value.splice(0, 1, value);
          } else {
            filteredValue.value.splice(0, 1);
          }
        }
      }
    });
    const filteredValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)({
      get() {
        if (props.column) {
          return props.column.filteredValue || [];
        }

        return [];
      },

      set(value) {
        if (props.column) {
          props.upDataColumn("filteredValue", value);
        }
      }

    });
    const multiple = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (props.column) {
        return props.column.filterMultiple;
      }

      return true;
    });

    const isActive = filter => {
      return filter.value === filterValue.value;
    };

    const hidden = () => {
      tooltipVisible.value = false;
    };

    const showFilterPanel = e => {
      e.stopPropagation();
      tooltipVisible.value = !tooltipVisible.value;
    };

    const hideFilterPanel = () => {
      tooltipVisible.value = false;
    };

    const handleConfirm = () => {
      confirmFilter(filteredValue.value);
      hidden();
    };

    const handleReset = () => {
      filteredValue.value = [];
      confirmFilter(filteredValue.value);
      hidden();
    };

    const handleSelect = _filterValue => {
      filterValue.value = _filterValue;

      if (typeof _filterValue !== "undefined" && _filterValue !== null) {
        confirmFilter(filteredValue.value);
      } else {
        confirmFilter([]);
      }

      hidden();
    };

    const confirmFilter = filteredValue2 => {
      props.store.commit("filterChange", {
        column: props.column,
        values: filteredValue2
      });
      props.store.updateAllSelected();
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(tooltipVisible, value => {
      if (props.column) {
        props.upDataColumn("filterOpened", value);
      }
    }, {
      immediate: true
    });
    const popperPaneRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b;

      return (_b = (_a = tooltip.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
    });
    return {
      tooltipVisible,
      multiple,
      filteredValue,
      filterValue,
      filters,
      handleConfirm,
      handleReset,
      handleSelect,
      isActive,
      t,
      ns,
      showFilterPanel,
      hideFilterPanel,
      popperPaneRef,
      tooltip
    };
  }

});

const filter_panel2_hoisted_1 = {
  key: 0
};
const filter_panel2_hoisted_2 = ["disabled"];
const filter_panel2_hoisted_3 = ["label", "onClick"];

function filter_panel2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-checkbox");

  const _component_el_checkbox_group = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-checkbox-group");

  const _component_el_scrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-scrollbar");

  const _component_arrow_up = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-up");

  const _component_arrow_down = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-down");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_el_tooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tooltip");

  const _directive_click_outside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDirective)("click-outside");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tooltip, {
    ref: "tooltip",
    visible: _ctx.tooltipVisible,
    "onUpdate:visible": _cache[5] || (_cache[5] = $event => _ctx.tooltipVisible = $event),
    offset: 0,
    placement: _ctx.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": _ctx.ns.b(),
    persistent: ""
  }, {
    content: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.multiple ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", filter_panel2_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("content"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_scrollbar, {
      "wrap-class": _ctx.ns.e("wrap")
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_checkbox_group, {
        modelValue: _ctx.filteredValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.filteredValue = $event),
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("checkbox-group"))
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.filters, filter => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_checkbox, {
            key: filter.value,
            label: filter.value
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(filter.text), 1)]),
            _: 2
          }, 1032, ["label"]);
        }), 128))]),
        _: 1
      }, 8, ["modelValue", "class"])]),
      _: 1
    }, 8, ["wrap-class"])], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("bottom"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)({
        [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0
      }),
      disabled: _ctx.filteredValue.length === 0,
      type: "button",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.table.confirmFilter")), 11, filter_panel2_hoisted_2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
      type: "button",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.table.resetFilter")), 1)], 2)])) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("ul", {
      key: 1,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("list"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("li", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("list-item"), {
        [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
      }]),
      onClick: _cache[3] || (_cache[3] = $event => _ctx.handleSelect(null))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.table.clearFilter")), 3), ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.filters, filter => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
        key: filter.value,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
        label: filter.value,
        onClick: $event => _ctx.handleSelect(filter.value)
      }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(filter.text), 11, filter_panel2_hoisted_3);
    }), 128))], 2))]),
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([`${_ctx.ns.namespace.value}-table__column-filter-trigger`, `${_ctx.ns.namespace.value}-none-outline`]),
      onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.column.filterOpened ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_arrow_up, {
        key: 0
      })) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_arrow_down, {
        key: 1
      }))]),
      _: 1
    })], 2)), [[_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]])]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}

var FilterPanel = /* @__PURE__ */_export_sfc(filter_panel2_sfc_main, [["render", filter_panel2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/layout-observer2.mjs



function useLayoutObserver(root) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeMount)(() => {
    tableLayout.value.addObserver(instance);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUpdated)(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
    tableLayout.value.removeObserver(instance);
  });
  const tableLayout = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const layout = root.layout;

    if (!layout) {
      throw new Error("Can not find table layout.");
    }

    return layout;
  });

  const onColumnsChange = layout => {
    var _a;

    const cols = ((_a = root.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
    if (!cols.length) return;
    const flattenColumns = layout.getFlattenColumns();
    const columnsMap = {};
    flattenColumns.forEach(column => {
      columnsMap[column.id] = column;
    });

    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      const name = col.getAttribute("name");
      const column = columnsMap[name];

      if (column) {
        col.setAttribute("width", column.realWidth || column.width);
      }
    }
  };

  const onScrollableChange = layout => {
    var _a, _b;

    const cols = ((_a = root.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col[name=gutter]")) || [];

    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
    }

    const ths = ((_b = root.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];

    for (let i = 0, j = ths.length; i < j; i++) {
      const th = ths[i];
      th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
      th.style.display = layout.scrollY.value ? "" : "none";
    }
  };

  return {
    tableLayout: tableLayout.value,
    onColumnsChange,
    onScrollableChange
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/tokens2.mjs
const TABLE_INJECTION_KEY = Symbol("ElTable");

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-header/event-helper2.mjs






function event_helper2_useEvent(props, emit) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);

  const handleFilterClick = event => {
    event.stopPropagation();
    return;
  };

  const handleHeaderClick = (event, column) => {
    if (!column.filters && column.sortable) {
      handleSortClick(event, column, false);
    } else if (column.filterable && !column.sortable) {
      handleFilterClick(event);
    }

    parent == null ? void 0 : parent.emit("header-click", column, event);
  };

  const handleHeaderContextMenu = (event, column) => {
    parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
  };

  const draggingColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const dragging = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const dragState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});

  const handleMouseDown = (event, column) => {
    if (!shared_isClient) return;
    if (column.children && column.children.length > 0) return;

    if (draggingColumn.value && props.border) {
      dragging.value = true;
      const table = parent;
      emit("set-drag-visible", true);
      const tableEl = table == null ? void 0 : table.vnode.el;
      const tableLeft = tableEl.getBoundingClientRect().left;
      const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
      const columnRect = columnEl.getBoundingClientRect();
      const minLeft = columnRect.left - tableLeft + 30;
      addClass(columnEl, "noclick");
      dragState.value = {
        startMouseLeft: event.clientX,
        startLeft: columnRect.right - tableLeft,
        startColumnLeft: columnRect.left - tableLeft,
        tableLeft
      };
      const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
      resizeProxy.style.left = `${dragState.value.startLeft}px`;

      document.onselectstart = function () {
        return false;
      };

      document.ondragstart = function () {
        return false;
      };

      const handleMouseMove2 = event2 => {
        const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
        const proxyLeft = dragState.value.startLeft + deltaLeft;
        resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
      };

      const handleMouseUp = () => {
        if (dragging.value) {
          const {
            startColumnLeft,
            startLeft
          } = dragState.value;
          const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
          const columnWidth = finalLeft - startColumnLeft;
          column.width = column.realWidth = columnWidth;
          table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
          requestAnimationFrame(() => {
            props.store.scheduleLayout(false, true);
          });
          document.body.style.cursor = "";
          dragging.value = false;
          draggingColumn.value = null;
          dragState.value = {};
          emit("set-drag-visible", false);
        }

        document.removeEventListener("mousemove", handleMouseMove2);
        document.removeEventListener("mouseup", handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        setTimeout(() => {
          removeClass(columnEl, "noclick");
        }, 0);
      };

      document.addEventListener("mousemove", handleMouseMove2);
      document.addEventListener("mouseup", handleMouseUp);
    }
  };

  const handleMouseMove = (event, column) => {
    if (column.children && column.children.length > 0) return;
    let target = event.target;

    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }

    if (!column || !column.resizable) return;

    if (!dragging.value && props.border) {
      const rect = target.getBoundingClientRect();
      const bodyStyle = document.body.style;

      if (rect.width > 12 && rect.right - event.pageX < 8) {
        bodyStyle.cursor = "col-resize";

        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "col-resize";
        }

        draggingColumn.value = column;
      } else if (!dragging.value) {
        bodyStyle.cursor = "";

        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "pointer";
        }

        draggingColumn.value = null;
      }
    }
  };

  const handleMouseOut = () => {
    if (!shared_isClient) return;
    document.body.style.cursor = "";
  };

  const toggleOrder = ({
    order,
    sortOrders
  }) => {
    if (order === "") return sortOrders[0];
    const index = sortOrders.indexOf(order || null);
    return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
  };

  const handleSortClick = (event, column, givenOrder) => {
    event.stopPropagation();
    const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
    let target = event.target;

    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }

    if (target && target.tagName === "TH") {
      if (hasClass(target, "noclick")) {
        removeClass(target, "noclick");
        return;
      }
    }

    if (!column.sortable) return;
    const states = props.store.states;
    let sortProp = states.sortProp.value;
    let sortOrder;
    const sortingColumn = states.sortingColumn.value;

    if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
      if (sortingColumn) {
        sortingColumn.order = null;
      }

      states.sortingColumn.value = column;
      sortProp = column.property;
    }

    if (!order) {
      sortOrder = column.order = null;
    } else {
      sortOrder = column.order = order;
    }

    states.sortProp.value = sortProp;
    states.sortOrder.value = sortOrder;
    parent == null ? void 0 : parent.store.commit("changeSortCondition");
  };

  return {
    handleHeaderClick,
    handleHeaderContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseOut,
    handleSortClick,
    handleFilterClick
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-header/style.helper2.mjs






function useStyle(props) {
  const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
  const ns = useNamespace("table");

  const getHeaderRowStyle = rowIndex => {
    const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;

    if (typeof headerRowStyle === "function") {
      return headerRowStyle.call(null, {
        rowIndex
      });
    }

    return headerRowStyle;
  };

  const getHeaderRowClass = rowIndex => {
    const classes = [];
    const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;

    if (typeof headerRowClassName === "string") {
      classes.push(headerRowClassName);
    } else if (typeof headerRowClassName === "function") {
      classes.push(headerRowClassName.call(null, {
        rowIndex
      }));
    }

    return classes.join(" ");
  };

  const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
    var _a;

    let headerCellStyles = (_a = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a : {};

    if (typeof headerCellStyles === "function") {
      headerCellStyles = headerCellStyles.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }

    const fixedStyle = column.isSubColumn ? null : getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return Object.assign({}, headerCellStyles, fixedStyle);
  };

  const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
    const fixedClasses = column.isSubColumn ? [] : getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
    const classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName, ...fixedClasses];

    if (!column.children) {
      classes.push("is-leaf");
    }

    if (column.sortable) {
      classes.push("is-sortable");
    }

    const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;

    if (typeof headerCellClassName === "string") {
      classes.push(headerCellClassName);
    } else if (typeof headerCellClassName === "function") {
      classes.push(headerCellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }

    classes.push(ns.e("cell"));
    return classes.filter(className => Boolean(className)).join(" ");
  };

  return {
    getHeaderRowStyle,
    getHeaderRowClass,
    getHeaderCellStyle,
    getHeaderCellClass
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-header/utils-helper2.mjs



const getAllColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.children) {
      result.push(column);
      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};

const convertToRows = originColumns => {
  let maxLevel = 1;

  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;

      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }

    if (column.children) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };

  originColumns.forEach(column => {
    column.level = 1;
    traverse(column, void 0);
  });
  const rows = [];

  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }

  const allColumns = getAllColumns(originColumns);
  allColumns.forEach(column => {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
      column.children.forEach(col => col.isSubColumn = true);
    }

    rows[column.level - 1].push(column);
  });
  return rows;
};

function useUtils(props) {
  const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
  const columnRows = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return convertToRows(props.store.states.originColumns.value);
  });
  const isGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const result = columnRows.value.length > 1;

    if (result && parent) {
      parent.state.isGroup.value = true;
    }

    return result;
  });

  const toggleAllSelection = event => {
    event.stopPropagation();
    parent == null ? void 0 : parent.store.commit("toggleAllSelection");
  };

  return {
    isGroup,
    toggleAllSelection,
    columnRows
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-header/index2.mjs










var TableHeader = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTableHeader",
  components: {
    ElCheckbox: ElCheckbox
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },

  setup(props, {
    emit
  }) {
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
    const ns = useNamespace("table");
    const filterPanels = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
    const {
      onColumnsChange,
      onScrollableChange
    } = useLayoutObserver(parent);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(async () => {
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      const {
        prop,
        order
      } = props.defaultSort;
      parent == null ? void 0 : parent.store.commit("sort", {
        prop,
        order,
        init: true
      });
    });
    const {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    } = event_helper2_useEvent(props, emit);
    const {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    } = useStyle(props);
    const {
      isGroup,
      toggleAllSelection,
      columnRows
    } = useUtils(props);
    instance.state = {
      onColumnsChange,
      onScrollableChange
    };
    instance.filterPanels = filterPanels;
    return {
      ns,
      filterPanels,
      onColumnsChange,
      onScrollableChange,
      columnRows,
      getHeaderRowClass,
      getHeaderRowStyle,
      getHeaderCellClass,
      getHeaderCellStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
      isGroup,
      toggleAllSelection
    };
  },

  render() {
    const {
      ns,
      isGroup,
      columnRows,
      getHeaderCellStyle,
      getHeaderCellClass,
      getHeaderRowClass,
      getHeaderRowStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleSortClick,
      handleMouseOut,
      store,
      $parent
    } = this;
    let rowSpan = 1;
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("thead", {
      class: {
        [ns.is("group")]: isGroup
      }
    }, columnRows.map((subColumns, rowIndex) => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("tr", {
      class: getHeaderRowClass(rowIndex),
      key: rowIndex,
      style: getHeaderRowStyle(rowIndex)
    }, subColumns.map((column, cellIndex) => {
      if (column.rowSpan > rowSpan) {
        rowSpan = column.rowSpan;
      }

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("th", {
        class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
        colspan: column.colSpan,
        key: `${column.id}-thead`,
        rowspan: column.rowSpan,
        style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
        onClick: $event => handleHeaderClick($event, column),
        onContextmenu: $event => handleHeaderContextMenu($event, column),
        onMousedown: $event => handleMouseDown($event, column),
        onMousemove: $event => handleMouseMove($event, column),
        onMouseout: handleMouseOut
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        class: ["cell", column.filteredValue && column.filteredValue.length > 0 ? "highlight" : "", column.labelClassName]
      }, [column.renderHeader ? column.renderHeader({
        column,
        $index: cellIndex,
        store,
        _self: $parent
      }) : column.label, column.sortable && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("span", {
        onClick: $event => handleSortClick($event, column),
        class: "caret-wrapper"
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("i", {
        onClick: $event => handleSortClick($event, column, "ascending"),
        class: "sort-caret ascending"
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("i", {
        onClick: $event => handleSortClick($event, column, "descending"),
        class: "sort-caret descending"
      })]), column.filterable && (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(FilterPanel, {
        store,
        placement: column.filterPlacement || "bottom-start",
        column,
        upDataColumn: (key, value) => {
          column[key] = value;
        }
      })])]);
    }))));
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-body/events-helper2.mjs







function useEvents(props) {
  const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
  const tooltipContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
  const tooltipTrigger = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div"));

  const handleEvent = (event, row, name) => {
    var _a;

    const table = parent;
    const cell = getCell(event);
    let column;
    const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;

    if (cell) {
      column = getColumnByCell({
        columns: props.store.states.columns.value
      }, cell, namespace);

      if (column) {
        table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
      }
    }

    table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
  };

  const handleDoubleClick = (event, row) => {
    handleEvent(event, row, "dblclick");
  };

  const handleClick = (event, row) => {
    props.store.commit("setCurrentRow", row);
    handleEvent(event, row, "click");
  };

  const handleContextMenu = (event, row) => {
    handleEvent(event, row, "contextmenu");
  };

  const handleMouseEnter = lodash_es_debounce(index => {
    props.store.commit("setHoverRow", index);
  }, 30);
  const handleMouseLeave = lodash_es_debounce(() => {
    props.store.commit("setHoverRow", null);
  }, 30);

  const handleCellMouseEnter = (event, row) => {
    var _a;

    const table = parent;
    const cell = getCell(event);
    const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;

    if (cell) {
      const column = getColumnByCell({
        columns: props.store.states.columns.value
      }, cell, namespace);
      const hoverState = table.hoverState = {
        cell,
        column,
        row
      };
      table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
    }

    const cellChild = event.target.querySelector(".cell");

    if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
      return;
    }

    const range = document.createRange();
    range.setStart(cellChild, 0);
    range.setEnd(cellChild, cellChild.childNodes.length);
    const rangeWidth = range.getBoundingClientRect().width;
    const padding = (Number.parseInt(style2_getStyle(cellChild, "paddingLeft"), 10) || 0) + (Number.parseInt(style2_getStyle(cellChild, "paddingRight"), 10) || 0);

    if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
      createTablePopper(cell, cell.innerText || cell.textContent, {
        placement: "top",
        strategy: "fixed"
      }, row.tooltipEffect);
    }
  };

  const handleCellMouseLeave = event => {
    const cell = getCell(event);
    if (!cell) return;
    const oldHoverState = parent == null ? void 0 : parent.hoverState;
    parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
  };

  return {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-body/styles-helper2.mjs






function useStyles(props) {
  const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
  const ns = useNamespace("table");

  const getRowStyle = (row, rowIndex) => {
    const rowStyle = parent == null ? void 0 : parent.props.rowStyle;

    if (typeof rowStyle === "function") {
      return rowStyle.call(null, {
        row,
        rowIndex
      });
    }

    return rowStyle || null;
  };

  const getRowClass = (row, rowIndex) => {
    const classes = [ns.e("row")];

    if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
      classes.push("current-row");
    }

    if (props.stripe && rowIndex % 2 === 1) {
      classes.push(ns.em("row", "striped"));
    }

    const rowClassName = parent == null ? void 0 : parent.props.rowClassName;

    if (typeof rowClassName === "string") {
      classes.push(rowClassName);
    } else if (typeof rowClassName === "function") {
      classes.push(rowClassName.call(null, {
        row,
        rowIndex
      }));
    }

    return classes;
  };

  const getCellStyle = (rowIndex, columnIndex, row, column) => {
    const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
    let cellStyles = cellStyle != null ? cellStyle : {};

    if (typeof cellStyle === "function") {
      cellStyles = cellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }

    const fixedStyle = column.isSubColumn ? null : getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return Object.assign({}, cellStyles, fixedStyle);
  };

  const getCellClass = (rowIndex, columnIndex, row, column) => {
    const fixedClasses = column.isSubColumn ? [] : getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store);
    const classes = [column.id, column.align, column.className, ...fixedClasses];
    const cellClassName = parent == null ? void 0 : parent.props.cellClassName;

    if (typeof cellClassName === "string") {
      classes.push(cellClassName);
    } else if (typeof cellClassName === "function") {
      classes.push(cellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }

    classes.push(ns.e("cell"));
    return classes.filter(className => Boolean(className)).join(" ");
  };

  const getSpan = (row, column, rowIndex, columnIndex) => {
    let rowspan = 1;
    let colspan = 1;
    const fn = parent == null ? void 0 : parent.props.spanMethod;

    if (typeof fn === "function") {
      const result = fn({
        row,
        column,
        rowIndex,
        columnIndex
      });

      if (Array.isArray(result)) {
        rowspan = result[0];
        colspan = result[1];
      } else if (typeof result === "object") {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }

    return {
      rowspan,
      colspan
    };
  };

  const getColspanRealWidth = (columns, colspan, index) => {
    if (colspan < 1) {
      return columns[index].realWidth;
    }

    const widthArr = columns.map(({
      realWidth,
      width
    }) => realWidth || width).slice(index, index + colspan);
    return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
  };

  return {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-body/render-helper2.mjs







function useRender(props) {
  const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
  const {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  } = useEvents(props);
  const {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  } = useStyles(props);
  const firstDefaultColumnIndex = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.store.states.columns.value.findIndex(({
      type
    }) => type === "default");
  });

  const getKeyOfRow = (row, index) => {
    const rowKey = parent.props.rowKey;

    if (rowKey) {
      return getRowIdentity(row, rowKey);
    }

    return index;
  };

  const rowRender = (row, $index, treeRowData, expanded = false) => {
    const {
      tooltipEffect,
      store
    } = props;
    const {
      indent,
      columns
    } = store.states;
    const rowClasses = getRowClass(row, $index);
    let display = true;

    if (treeRowData) {
      rowClasses.push(`el-table__row--level-${treeRowData.level}`);
      display = treeRowData.display;
    }

    const displayStyle = display ? null : {
      display: "none"
    };
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("tr", {
      style: [displayStyle, getRowStyle(row, $index)],
      class: rowClasses,
      key: getKeyOfRow(row, $index),
      onDblclick: $event => handleDoubleClick($event, row),
      onClick: $event => handleClick($event, row),
      onContextmenu: $event => handleContextMenu($event, row),
      onMouseenter: () => handleMouseEnter($index),
      onMouseleave: handleMouseLeave
    }, columns.value.map((column, cellIndex) => {
      const {
        rowspan,
        colspan
      } = getSpan(row, column, $index, cellIndex);

      if (!rowspan || !colspan) {
        return null;
      }

      const columnData = { ...column
      };
      columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
      const data = {
        store: props.store,
        _self: props.context || parent,
        column: columnData,
        row,
        $index,
        cellIndex,
        expanded
      };

      if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
        data.treeNode = {
          indent: treeRowData.level * indent.value,
          level: treeRowData.level
        };

        if (typeof treeRowData.expanded === "boolean") {
          data.treeNode.expanded = treeRowData.expanded;

          if ("loading" in treeRowData) {
            data.treeNode.loading = treeRowData.loading;
          }

          if ("noLazyChildren" in treeRowData) {
            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
          }
        }
      }

      const baseKey = `${$index},${cellIndex}`;
      const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
      const tdChildren = cellChildren(cellIndex, column, data);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("td", {
        style: getCellStyle($index, cellIndex, row, column),
        class: getCellClass($index, cellIndex, row, column),
        key: `${patchKey}${baseKey}`,
        rowspan,
        colspan,
        onMouseenter: $event => handleCellMouseEnter($event, { ...row,
          tooltipEffect
        }),
        onMouseleave: handleCellMouseLeave
      }, [tdChildren]);
    }));
  };

  const cellChildren = (cellIndex, column, data) => {
    return column.renderCell(data);
  };

  const wrappedRowRender = (row, $index) => {
    const store = props.store;
    const {
      isRowExpanded,
      assertRowKey
    } = store;
    const {
      treeData,
      lazyTreeNodeMap,
      childrenColumnName,
      rowKey
    } = store.states;
    const columns = store.states.columns.value;
    const hasExpandColumn = columns.some(({
      type
    }) => type === "expand");

    if (hasExpandColumn) {
      const expanded = isRowExpanded(row);
      const tr = rowRender(row, $index, void 0, expanded);
      const renderExpanded = parent.renderExpanded;

      if (expanded) {
        if (!renderExpanded) {
          console.error("[Element Error]renderExpanded is required.");
          return tr;
        }

        return [[tr, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("tr", {
          key: `expanded-row__${tr.key}`
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("td", {
          colspan: columns.length,
          class: "el-table__cell el-table__expanded-cell"
        }, [renderExpanded({
          row,
          $index,
          store,
          expanded
        })])])]];
      } else {
        return [[tr]];
      }
    } else if (Object.keys(treeData.value).length) {
      assertRowKey();
      const key = getRowIdentity(row, rowKey.value);
      let cur = treeData.value[key];
      let treeRowData = null;

      if (cur) {
        treeRowData = {
          expanded: cur.expanded,
          level: cur.level,
          display: true
        };

        if (typeof cur.lazy === "boolean") {
          if (typeof cur.loaded === "boolean" && cur.loaded) {
            treeRowData.noLazyChildren = !(cur.children && cur.children.length);
          }

          treeRowData.loading = cur.loading;
        }
      }

      const tmp = [rowRender(row, $index, treeRowData)];

      if (cur) {
        let i = 0;

        const traverse = (children, parent2) => {
          if (!(children && children.length && parent2)) return;
          children.forEach(node => {
            const innerTreeRowData = {
              display: parent2.display && parent2.expanded,
              level: parent2.level + 1,
              expanded: false,
              noLazyChildren: false,
              loading: false
            };
            const childKey = getRowIdentity(node, rowKey.value);

            if (childKey === void 0 || childKey === null) {
              throw new Error("For nested data item, row-key is required.");
            }

            cur = { ...treeData.value[childKey]
            };

            if (cur) {
              innerTreeRowData.expanded = cur.expanded;
              cur.level = cur.level || innerTreeRowData.level;
              cur.display = !!(cur.expanded && innerTreeRowData.display);

              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }

                innerTreeRowData.loading = cur.loading;
              }
            }

            i++;
            tmp.push(rowRender(node, $index + i, innerTreeRowData));

            if (cur) {
              const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
              traverse(nodes2, cur);
            }
          });
        };

        cur.display = true;
        const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
        traverse(nodes, cur);
      }

      return tmp;
    } else {
      return rowRender(row, $index, void 0);
    }
  };

  return {
    wrappedRowRender,
    tooltipContent,
    tooltipTrigger
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-body/defaults2.mjs
const defaultProps = {
  store: {
    required: true,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-body/index2.mjs











var TableBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTableBody",
  props: defaultProps,

  setup(props) {
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const parent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
    const ns = useNamespace("table");
    const {
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    } = useRender(props);
    const {
      onColumnsChange,
      onScrollableChange
    } = useLayoutObserver(parent);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(props.store.states.hoverRow, (newVal, oldVal) => {
      if (!props.store.states.isComplex.value || !shared_isClient) return;
      let raf = window.requestAnimationFrame;

      if (!raf) {
        raf = fn => window.setTimeout(fn, 16);
      }

      raf(() => {
        var _a;

        const rows = (_a = instance == null ? void 0 : instance.vnode.el) == null ? void 0 : _a.querySelectorAll(`.${ns.e("row")}`);
        const oldRow = rows[oldVal];
        const newRow = rows[newVal];

        if (oldRow) {
          removeClass(oldRow, "hover-row");
        }

        if (newRow) {
          addClass(newRow, "hover-row");
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      var _a;

      (_a = removePopper) == null ? void 0 : _a();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUpdated)(() => {
      var _a;

      (_a = removePopper) == null ? void 0 : _a();
    });
    return {
      ns,
      onColumnsChange,
      onScrollableChange,
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    };
  },

  render() {
    const {
      wrappedRowRender,
      store
    } = this;
    const data = store.states.data.value || [];
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("tbody", {}, [data.reduce((acc, row) => {
      return acc.concat(wrappedRowRender(row, acc.length));
    }, [])]);
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/h-helper2.mjs


function hColgroup(props) {
  const isAuto = props.tableLayout === "auto";
  let columns = props.columns || [];

  if (isAuto) {
    if (columns.every(column => column.width === void 0)) {
      columns = [];
    }
  }

  const getPropsData = column => {
    const propsData = {
      key: `${props.tableLayout}_${column.id}`,
      style: {},
      name: void 0
    };

    if (isAuto) {
      propsData.style = {
        width: `${column.width}px`
      };
    } else {
      propsData.name = column.id;
    }

    return propsData;
  };

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("colgroup", {}, columns.map(column => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("col", getPropsData(column))));
}

hColgroup.props = ["columns", "tableLayout"];

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-footer/mapState-helper2.mjs



function useMapState() {
  const table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TABLE_INJECTION_KEY);
  const store = table == null ? void 0 : table.store;
  const leftFixedLeafCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return store.states.fixedLeafColumnsLength.value;
  });
  const rightFixedLeafCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return store.states.rightFixedColumns.value.length;
  });
  const columnsCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return store.states.columns.value.length;
  });
  const leftFixedCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return store.states.fixedColumns.value.length;
  });
  const rightFixedCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return store.states.rightFixedColumns.value.length;
  });
  return {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns: store.states.columns
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-footer/style-helper2.mjs





function style_helper2_useStyle(props) {
  const {
    columns
  } = useMapState();
  const ns = useNamespace("table");

  const getCellClasses = (columns2, cellIndex) => {
    const column = columns2[cellIndex];
    const classes = [ns.e("cell"), column.id, column.align, column.labelClassName, ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)];

    if (column.className) {
      classes.push(column.className);
    }

    if (!column.children) {
      classes.push(ns.is("leaf"));
    }

    return classes;
  };

  const getCellStyles = (column, cellIndex) => {
    const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return fixedStyle;
  };

  return {
    getCellClasses,
    getCellStyles,
    columns
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-footer/index2.mjs





var TableFooter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },

  setup(props) {
    const {
      getCellClasses,
      getCellStyles,
      columns
    } = style_helper2_useStyle(props);
    const ns = useNamespace("table");
    return {
      ns,
      getCellClasses,
      getCellStyles,
      columns
    };
  },

  render() {
    const {
      columns,
      getCellStyles,
      getCellClasses,
      summaryMethod,
      sumText,
      ns
    } = this;
    const data = this.store.states.data.value;
    let sums = [];

    if (summaryMethod) {
      sums = summaryMethod({
        columns,
        data
      });
    } else {
      columns.forEach((column, index) => {
        if (index === 0) {
          sums[index] = sumText;
          return;
        }

        const values = data.map(item => Number(item[column.property]));
        const precisions = [];
        let notNumber = true;
        values.forEach(value => {
          if (!Number.isNaN(+value)) {
            notNumber = false;
            const decimal = `${value}`.split(".")[1];
            precisions.push(decimal ? decimal.length : 0);
          }
        });
        const precision = Math.max.apply(null, precisions);

        if (!notNumber) {
          sums[index] = values.reduce((prev, curr) => {
            const value = Number(curr);

            if (!Number.isNaN(+value)) {
              return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
            } else {
              return prev;
            }
          }, 0);
        } else {
          sums[index] = "";
        }
      });
    }

    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("table", {
      class: ns.e("footer"),
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [hColgroup({
      columns
    }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("tbody", [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("tr", {}, [...columns.map((column, cellIndex) => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("td", {
      key: cellIndex,
      colspan: column.colSpan,
      rowspan: column.rowSpan,
      class: getCellClasses(columns, cellIndex),
      style: getCellStyles(column, cellIndex)
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
      class: ["cell", column.labelClassName]
    }, [sums[cellIndex]])]))])])]);
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table/utils-helper2.mjs
function utils_helper2_useUtils(store) {
  const setCurrentRow = row => {
    store.commit("setCurrentRow", row);
  };

  const getSelectionRows = () => {
    return store.getSelectionRows();
  };

  const toggleRowSelection = (row, selected) => {
    store.toggleRowSelection(row, selected, false);
    store.updateAllSelected();
  };

  const clearSelection = () => {
    store.clearSelection();
  };

  const clearFilter = columnKeys => {
    store.clearFilter(columnKeys);
  };

  const toggleAllSelection = () => {
    store.commit("toggleAllSelection");
  };

  const toggleRowExpansion = (row, expanded) => {
    store.toggleRowExpansionAdapter(row, expanded);
  };

  const clearSort = () => {
    store.clearSort();
  };

  const sort = (prop, order) => {
    store.commit("sort", {
      prop,
      order
    });
  };

  return {
    setCurrentRow,
    getSelectionRows,
    toggleRowSelection,
    clearSelection,
    clearFilter,
    toggleAllSelection,
    toggleRowExpansion,
    clearSort,
    sort
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table/style-helper2.mjs










function table_style_helper2_useStyle(props, layout, store, table) {
  const isHidden = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const renderExpanded = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
  const resizeProxyVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);

  const setDragVisible = visible => {
    resizeProxyVisible.value = visible;
  };

  const resizeState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({
    width: null,
    height: null
  });
  const isGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const scrollbarViewStyle = {
    display: "inline-block",
    verticalAlign: "middle"
  };
  const tableWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
    layout.setHeight(props.height);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
    layout.setMaxHeight(props.maxHeight);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
    if (!(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(rowKey)) return;
    store.setCurrentRowKey(`${currentRowKey}`);
  }, {
    immediate: true
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, data => {
    table.store.commit("setData", data);
  }, {
    immediate: true,
    deep: true
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
    if (props.expandRowKeys) {
      store.setExpandRowKeysAdapter(props.expandRowKeys);
    }
  });

  const handleMouseLeave = () => {
    table.store.commit("setHoverRow", null);
    if (table.hoverState) table.hoverState = null;
  };

  const handleHeaderFooterMousewheel = (event, data) => {
    const {
      pixelX,
      pixelY
    } = data;

    if (Math.abs(pixelX) >= Math.abs(pixelY)) {
      table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    }
  };

  const shouldUpdateHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
  });
  const tableBodyStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return {
      width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
    };
  });

  const doLayout = () => {
    if (shouldUpdateHeight.value) {
      layout.updateElsHeight();
    }

    layout.updateColumnsWidth();
    requestAnimationFrame(syncPostion);
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(async () => {
    await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    store.updateColumns();
    bindEvents();
    requestAnimationFrame(doLayout);
    resizeState.value = {
      width: tableWidth.value = table.vnode.el.offsetWidth,
      height: table.vnode.el.offsetHeight
    };
    store.states.columns.value.forEach(column => {
      if (column.filteredValue && column.filteredValue.length) {
        table.store.commit("filterChange", {
          column,
          values: column.filteredValue,
          silent: true
        });
      }
    });
    table.$ready = true;
  });

  const setScrollClassByEl = (el, className) => {
    if (!el) return;
    const classList = Array.from(el.classList).filter(item => !item.startsWith("is-scrolling-"));
    classList.push(layout.scrollX.value ? className : "is-scrolling-none");
    el.className = classList.join(" ");
  };

  const setScrollClass = className => {
    const {
      tableWrapper
    } = table.refs;
    setScrollClassByEl(tableWrapper, className);
  };

  const hasScrollClass = className => {
    const {
      tableWrapper
    } = table.refs;
    return !!(tableWrapper && tableWrapper.classList.contains(className));
  };

  const syncPostion = function () {
    if (!table.refs.scrollBarRef) return;

    if (!layout.scrollX.value) {
      const scrollingNoneClass = "is-scrolling-none";

      if (!hasScrollClass(scrollingNoneClass)) {
        setScrollClass(scrollingNoneClass);
      }

      return;
    }

    const scrollContainer = table.refs.scrollBarRef.wrap$;
    if (!scrollContainer) return;
    const {
      scrollLeft,
      offsetWidth,
      scrollWidth
    } = scrollContainer;
    const {
      headerWrapper,
      footerWrapper
    } = table.refs;
    if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
    if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;

    if (scrollLeft >= maxScrollLeftPosition) {
      setScrollClass("is-scrolling-right");
    } else if (scrollLeft === 0) {
      setScrollClass("is-scrolling-left");
    } else {
      setScrollClass("is-scrolling-middle");
    }
  };

  const bindEvents = () => {
    var _a;

    if (!table.refs.scrollBarRef) return;
    (_a = table.refs.scrollBarRef.wrap$) == null ? void 0 : _a.addEventListener("scroll", syncPostion, {
      passive: true
    });

    if (props.fit) {
      addResizeListener(table.vnode.el, resizeListener);
    } else {
      event2_on(window, "resize", doLayout);
    }
  };

  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
    unbindEvents();
  });

  const unbindEvents = () => {
    var _a;

    (_a = table.refs.scrollBarRef.wrap$) == null ? void 0 : _a.removeEventListener("scroll", syncPostion, true);

    if (props.fit) {
      removeResizeListener(table.vnode.el, resizeListener);
    } else {
      off(window, "resize", doLayout);
    }
  };

  const resizeListener = () => {
    if (!table.$ready) return;
    let shouldUpdateLayout = false;
    const el = table.vnode.el;
    const {
      width: oldWidth,
      height: oldHeight
    } = resizeState.value;
    const width = tableWidth.value = el.offsetWidth;

    if (oldWidth !== width) {
      shouldUpdateLayout = true;
    }

    const height2 = el.offsetHeight;

    if ((props.height || shouldUpdateHeight.value) && oldHeight !== height2) {
      shouldUpdateLayout = true;
    }

    if (shouldUpdateLayout) {
      resizeState.value = {
        width,
        height: height2
      };
      doLayout();
    }
  };

  const tableSize = useSize();
  const bodyWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      bodyWidth: bodyWidth_,
      scrollY,
      gutterWidth
    } = layout;
    return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
  });
  const tableLayout = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (props.maxHeight) return "fixed";
    return props.tableLayout;
  });

  function calcMaxHeight(maxHeight, footerHeight, headerHeight) {
    const parsedMaxHeight = parseHeight(maxHeight);
    const tableHeaderHeight = props.showHeader ? headerHeight : 0;
    if (parsedMaxHeight === null) return;

    if (shared_esm_bundler_isString(parsedMaxHeight)) {
      return `calc(${parsedMaxHeight} - ${footerHeight}px - ${tableHeaderHeight}px)`;
    }

    return parsedMaxHeight - footerHeight - tableHeaderHeight;
  }

  const height = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const headerHeight = layout.headerHeight.value || 0;
    const bodyHeight2 = layout.bodyHeight.value;
    const footerHeight = layout.footerHeight.value || 0;

    if (props.height) {
      return bodyHeight2 ? bodyHeight2 : void 0;
    } else if (props.maxHeight) {
      return calcMaxHeight(props.maxHeight, footerHeight, headerHeight);
    }

    return void 0;
  });
  const bodyHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const headerHeight = layout.headerHeight.value || 0;
    const bodyHeight2 = layout.bodyHeight.value;
    const footerHeight = layout.footerHeight.value || 0;

    if (props.height) {
      return {
        height: bodyHeight2 ? `${bodyHeight2}px` : ""
      };
    } else if (props.maxHeight) {
      const maxHeight = calcMaxHeight(props.maxHeight, footerHeight, headerHeight);

      if (maxHeight !== null) {
        return {
          "max-height": `${maxHeight}${shared_isNumber(maxHeight) ? "px" : ""}`
        };
      }
    }

    return {};
  });
  const emptyBlockStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (props.data && props.data.length) return null;
    let height2 = "100%";

    if (layout.appendHeight.value) {
      height2 = `calc(100% - ${layout.appendHeight.value}px)`;
    }

    return {
      width: tableWidth.value ? `${tableWidth.value}px` : "",
      height: height2
    };
  });

  const handleFixedMousewheel = (event, data) => {
    const bodyWrapper = table.refs.bodyWrapper;

    if (Math.abs(data.spinY) > 0) {
      const currentScrollTop = bodyWrapper.scrollTop;

      if (data.pixelY < 0 && currentScrollTop !== 0) {
        event.preventDefault();
      }

      if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
        event.preventDefault();
      }

      bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
    } else {
      bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    }
  };

  const fixedHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (props.maxHeight) {
      if (props.showSummary) {
        return {
          bottom: 0
        };
      }

      return {
        bottom: layout.scrollX.value && props.data.length ? `${layout.gutterWidth}px` : ""
      };
    } else {
      if (props.showSummary) {
        return {
          height: layout.tableHeight.value ? `${layout.tableHeight.value}px` : ""
        };
      }

      return {
        height: layout.viewportHeight.value ? `${layout.viewportHeight.value}px` : ""
      };
    }
  });
  const fixedBodyHeight = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (props.height) {
      return {
        height: layout.fixedBodyHeight.value ? `${layout.fixedBodyHeight.value}px` : ""
      };
    } else if (props.maxHeight) {
      let maxHeight = parseHeight(props.maxHeight);

      if (typeof maxHeight === "number") {
        maxHeight = layout.scrollX.value ? maxHeight - layout.gutterWidth : maxHeight;

        if (props.showHeader) {
          maxHeight -= layout.headerHeight.value;
        }

        maxHeight -= layout.footerHeight.value;
        return {
          "max-height": `${maxHeight}px`
        };
      }
    }

    return {};
  });
  return {
    isHidden,
    renderExpanded,
    setDragVisible,
    isGroup,
    handleMouseLeave,
    handleHeaderFooterMousewheel,
    tableSize,
    bodyHeight,
    height,
    emptyBlockStyle,
    handleFixedMousewheel,
    fixedHeight,
    fixedBodyHeight,
    resizeProxyVisible,
    bodyWidth,
    resizeState,
    doLayout,
    tableBodyStyles,
    tableLayout,
    scrollbarViewStyle
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table/defaults2.mjs
var defaults2_defaultProps = {
  data: {
    type: Array,
    default: () => {
      return [];
    }
  },
  size: String,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: true
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: true
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: true
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => {
      return {
        hasChildren: "hasChildren",
        children: "children"
      };
    }
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  }
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/composables/use-scrollbar2.mjs




const useScrollbar = () => {
  const scrollBarRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();

  const scrollTo = (options, yCoord) => {
    const scrollbar = scrollBarRef.value;

    if (scrollbar) {
      scrollbar.scrollTo(options, yCoord);
    }
  };

  const setScrollPosition = (position, offset) => {
    const scrollbar = scrollBarRef.value;

    if (scrollbar && shared_isNumber(offset) && ["Top", "Left"].includes(position)) {
      scrollbar[`setScroll${position}`](offset);
    }
  };

  const setScrollTop = top => setScrollPosition("Top", top);

  const setScrollLeft = left => setScrollPosition("Left", left);

  return {
    scrollBarRef,
    scrollTo,
    setScrollTop,
    setScrollLeft
  };
};


;// CONCATENATED MODULE: ./node_modules/normalize-wheel-es/dist/index.mjs
var v = !1,
    o,
    f,
    s,
    u,
    d,
    dist_N,
    l,
    p,
    m,
    w,
    D,
    x,
    dist_E,
    M,
    F;

function a() {
  if (!v) {
    v = !0;
    var e = navigator.userAgent,
        n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e),
        i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);

    if (x = /\b(iPhone|iP[ao]d)/.exec(e), dist_E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
      o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(e);
      dist_N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
    } else o = f = s = d = u = NaN;

    if (i) {
      if (i[1]) {
        var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        l = t ? parseFloat(t[1].replace("_", ".")) : !0;
      } else l = !1;

      p = !!i[2], m = !!i[3];
    } else l = p = m = !1;
  }
}

var _ = {
  ie: function () {
    return a() || o;
  },
  ieCompatibilityMode: function () {
    return a() || dist_N > o;
  },
  ie64: function () {
    return _.ie() && D;
  },
  firefox: function () {
    return a() || f;
  },
  opera: function () {
    return a() || s;
  },
  webkit: function () {
    return a() || u;
  },
  safari: function () {
    return _.webkit();
  },
  chrome: function () {
    return a() || d;
  },
  windows: function () {
    return a() || p;
  },
  osx: function () {
    return a() || l;
  },
  linux: function () {
    return a() || m;
  },
  iphone: function () {
    return a() || x;
  },
  mobile: function () {
    return a() || x || dist_E || w || F;
  },
  nativeApp: function () {
    return a() || M;
  },
  android: function () {
    return a() || w;
  },
  ipad: function () {
    return a() || dist_E;
  }
},
    A = _;
var c = !!(typeof window < "u" && window.document && window.document.createElement),
    dist_U = {
  canUseDOM: c,
  canUseWorkers: typeof Worker < "u",
  canUseEventListeners: c && !!(window.addEventListener || window.attachEvent),
  canUseViewport: c && !!window.screen,
  isInWorker: !c
},
    h = dist_U;
var dist_X;
h.canUseDOM && (dist_X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);

function S(e, n) {
  if (!h.canUseDOM || n && !("addEventListener" in document)) return !1;
  var i = "on" + e,
      r = (i in document);

  if (!r) {
    var t = document.createElement("div");
    t.setAttribute(i, "return;"), r = typeof t[i] == "function";
  }

  return !r && dist_X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}

var b = S;
var O = 10,
    dist_I = 40,
    dist_P = 800;

function T(e) {
  var n = 0,
      i = 0,
      r = 0,
      t = 0;
  return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= dist_I, t *= dist_I) : (r *= dist_P, t *= dist_P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), {
    spinX: n,
    spinY: i,
    pixelX: r,
    pixelY: t
  };
}

T.getEventType = function () {
  return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
};

var Y = T;

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
;// CONCATENATED MODULE: ./node_modules/element-plus/es/directives/mousewheel/index2.mjs


const mousewheel = function (element, callback) {
  if (element && element.addEventListener) {
    const fn = function (event) {
      const normalized = Y(event);
      callback && Reflect.apply(callback, this, [event, normalized]);
    };

    element.addEventListener("wheel", fn, {
      passive: true
    });
  }
};

const Mousewheel = {
  beforeMount(el, binding) {
    mousewheel(el, binding.value);
  }

};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table2.mjs




















let tableIdSeed = 1;

const table2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTable",
  directives: {
    Mousewheel: Mousewheel
  },
  components: {
    TableHeader: TableHeader,
    TableBody: TableBody,
    TableFooter: TableFooter,
    ElScrollbar: ElScrollbar,
    hColgroup: hColgroup
  },
  props: defaults2_defaultProps,
  emits: ["select", "select-all", "selection-change", "cell-mouse-enter", "cell-mouse-leave", "cell-contextmenu", "cell-click", "cell-dblclick", "row-click", "row-contextmenu", "row-dblclick", "header-click", "header-contextmenu", "sort-change", "filter-change", "current-change", "header-dragend", "expand-change"],

  setup(props) {
    const {
      t
    } = useLocale();
    const ns = useNamespace("table");
    const table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(TABLE_INJECTION_KEY, table);
    const store = helper2_createStore(table, props);
    table.store = store;
    const layout = new TableLayout({
      store: table.store,
      table,
      fit: props.fit,
      showHeader: props.showHeader
    });
    table.layout = layout;
    const isEmpty = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => (store.states.data.value || []).length === 0);
    const {
      setCurrentRow,
      getSelectionRows,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort
    } = utils_helper2_useUtils(store);
    const {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      height,
      emptyBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout,
      tableBodyStyles,
      tableLayout,
      scrollbarViewStyle
    } = table_style_helper2_useStyle(props, layout, store, table);
    const {
      scrollBarRef,
      scrollTo,
      setScrollLeft,
      setScrollTop
    } = useScrollbar();
    const debouncedUpdateLayout = lodash_es_debounce(doLayout, 50);
    const tableId = `el-table_${tableIdSeed++}`;
    table.tableId = tableId;
    table.state = {
      isGroup,
      resizeState,
      doLayout,
      debouncedUpdateLayout
    };
    const computedSumText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.sumText || t("el.table.sumText"));
    const computedEmptyText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.emptyText || t("el.table.emptyText");
    });
    return {
      ns,
      layout,
      store,
      handleHeaderFooterMousewheel,
      handleMouseLeave,
      tableId,
      tableSize,
      isHidden,
      isEmpty,
      renderExpanded,
      resizeProxyVisible,
      resizeState,
      isGroup,
      bodyWidth,
      bodyHeight,
      height,
      tableBodyStyles,
      emptyBlockStyle,
      debouncedUpdateLayout,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      setCurrentRow,
      getSelectionRows,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort,
      t,
      setDragVisible,
      context: table,
      computedSumText,
      computedEmptyText,
      tableLayout,
      scrollbarViewStyle,
      scrollBarRef,
      scrollTo,
      setScrollLeft,
      setScrollTop
    };
  }

});

const table2_hoisted_1 = ["data-prefix"];
const table2_hoisted_2 = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};

function table2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hColgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("hColgroup");

  const _component_table_header = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("table-header");

  const _component_table_body = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("table-body");

  const _component_el_scrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-scrollbar");

  const _component_table_footer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("table-footer");

  const _directive_mousewheel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDirective)("mousewheel");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    ref: "tableWrapper",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      [_ctx.ns.m("fit")]: _ctx.fit,
      [_ctx.ns.m("striped")]: _ctx.stripe,
      [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
      [_ctx.ns.m("hidden")]: _ctx.isHidden,
      [_ctx.ns.m("group")]: _ctx.isGroup,
      [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
      [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
      [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
      [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
      [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
      "has-footer": _ctx.showSummary
    }, _ctx.ns.m(_ctx.tableSize), _ctx.className, _ctx.ns.b(), _ctx.ns.m(`layout-${_ctx.tableLayout}`)]),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.style),
    "data-prefix": _ctx.ns.namespace.value,
    onMouseleave: _cache[0] || (_cache[0] = $event => _ctx.handleMouseLeave())
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("inner-wrapper"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", table2_hoisted_2, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 512), _ctx.showHeader && _ctx.tableLayout === "fixed" ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 0,
    ref: "headerWrapper",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("header-wrapper"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("table", {
    ref: "tableHeader",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("header")),
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.tableBodyStyles),
    border: "0",
    cellpadding: "0",
    cellspacing: "0"
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_hColgroup, {
    columns: _ctx.store.states.columns.value,
    "table-layout": _ctx.tableLayout
  }, null, 8, ["columns", "table-layout"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_table_header, {
    ref: "tableHeaderRef",
    border: _ctx.border,
    "default-sort": _ctx.defaultSort,
    store: _ctx.store,
    onSetDragVisible: _ctx.setDragVisible
  }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])], 6)], 2)), [[_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    ref: "bodyWrapper",
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.bodyHeight),
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("body-wrapper"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_scrollbar, {
    ref: "scrollBarRef",
    height: _ctx.maxHeight ? void 0 : _ctx.height,
    "max-height": _ctx.maxHeight ? _ctx.height : void 0,
    "view-style": _ctx.scrollbarViewStyle,
    always: _ctx.scrollbarAlwaysOn
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("table", {
      ref: "tableBody",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("body")),
      cellspacing: "0",
      cellpadding: "0",
      border: "0",
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)({
        width: _ctx.bodyWidth,
        tableLayout: _ctx.tableLayout
      })
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_hColgroup, {
      columns: _ctx.store.states.columns.value,
      "table-layout": _ctx.tableLayout
    }, null, 8, ["columns", "table-layout"]), _ctx.showHeader && _ctx.tableLayout === "auto" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_table_header, {
      key: 0,
      border: _ctx.border,
      "default-sort": _ctx.defaultSort,
      store: _ctx.store,
      onSetDragVisible: _ctx.setDragVisible
    }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_table_body, {
      context: _ctx.context,
      highlight: _ctx.highlightCurrentRow,
      "row-class-name": _ctx.rowClassName,
      "tooltip-effect": _ctx.tooltipEffect,
      "row-style": _ctx.rowStyle,
      store: _ctx.store,
      stripe: _ctx.stripe
    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe"])], 6), _ctx.isEmpty ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 0,
      ref: "emptyBlock",
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.emptyBlockStyle),
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("empty-block"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("empty-text"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "empty", {}, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.computedEmptyText), 1)])], 2)], 6)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.$slots.append ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 1,
      ref: "appendWrapper",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("append-wrapper"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "append")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
    _: 3
  }, 8, ["height", "max-height", "view-style", "always"])], 6), _ctx.border || _ctx.isGroup ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 1,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("border-left-patch"))
  }, null, 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2), _ctx.showSummary ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    key: 0,
    ref: "footerWrapper",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("footer-wrapper"))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_table_footer, {
    border: _ctx.border,
    "default-sort": _ctx.defaultSort,
    store: _ctx.store,
    style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.tableBodyStyles),
    "sum-text": _ctx.computedSumText,
    "summary-method": _ctx.summaryMethod
  }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])], 2)), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, !_ctx.isEmpty], [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    ref: "resizeProxy",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.e("column-resize-proxy"))
  }, null, 2), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.resizeProxyVisible]])], 46, table2_hoisted_1);
}

var Table = /* @__PURE__ */_export_sfc(table2_sfc_main, [["render", table2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/config2.mjs






const defaultClassNames = {
  selection: "table-column--selection",
  expand: "table__expand-column"
};
const cellStarts = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
};

const getDefaultClassName = type => {
  return defaultClassNames[type] || "";
};

const cellForced = {
  selection: {
    renderHeader({
      store
    }) {
      function isDisabled() {
        return store.states.data.value && store.states.data.value.length === 0;
      }

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ElCheckbox, {
        disabled: isDisabled(),
        size: store.states.tableSize.value,
        indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
        "onUpdate:modelValue": store.toggleAllSelection,
        modelValue: store.states.isAllSelected.value
      });
    },

    renderCell({
      row,
      column,
      store,
      $index
    }) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ElCheckbox, {
        disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
        size: store.states.tableSize.value,
        onChange: () => {
          store.commit("rowSelectedChanged", row);
        },
        onClick: event => event.stopPropagation(),
        modelValue: store.isSelected(row)
      });
    },

    sortable: false,
    resizable: false
  },
  index: {
    renderHeader({
      column
    }) {
      return column.label || "#";
    },

    renderCell({
      column,
      $index
    }) {
      let i = $index + 1;
      const index = column.index;

      if (typeof index === "number") {
        i = $index + index;
      } else if (typeof index === "function") {
        i = index($index);
      }

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {}, [i]);
    },

    sortable: false
  },
  expand: {
    renderHeader({
      column
    }) {
      return column.label || "";
    },

    renderCell({
      row,
      store,
      expanded
    }) {
      const {
        ns
      } = store;
      const classes = [ns.e("expand-icon")];

      if (expanded) {
        classes.push(ns.em("expand-icon", "expanded"));
      }

      const callback = function (e) {
        e.stopPropagation();
        store.toggleRowExpansion(row);
      };

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        class: classes,
        onClick: callback
      }, {
        default: () => {
          return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ElIcon, null, {
            default: () => {
              return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(arrowRight)];
            }
          })];
        }
      });
    },

    sortable: false,
    resizable: false
  }
};

function defaultRenderCell({
  row,
  column,
  $index
}) {
  var _a;

  const property = column.property;
  const value = property && getProp(row, property).value;

  if (column && column.formatter) {
    return column.formatter(row, column, value, $index);
  }

  return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
}

function treeCellPrefix({
  row,
  treeNode,
  store
}, createPlacehoder = false) {
  const {
    ns
  } = store;

  if (!treeNode) {
    if (createPlacehoder) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("span", {
        class: ns.e("placeholder")
      })];
    }

    return null;
  }

  const ele = [];

  const callback = function (e) {
    e.stopPropagation();
    store.loadOrToggle(row);
  };

  if (treeNode.indent) {
    ele.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("span", {
      class: ns.e("indent"),
      style: {
        "padding-left": `${treeNode.indent}px`
      }
    }));
  }

  if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
    const expandClasses = [ns.e("expand-icon"), treeNode.expanded ? ns.em("expand-icon", "expanded") : ""];
    let icon = arrowRight;

    if (treeNode.loading) {
      icon = loading;
    }

    ele.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
      class: expandClasses,
      onClick: callback
    }, {
      default: () => {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(ElIcon, {
          class: {
            [ns.is("loading")]: treeNode.loading
          }
        }, {
          default: () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon)]
        })];
      }
    }));
  } else {
    ele.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("span", {
      class: ns.e("placeholder")
    }));
  }

  return ele;
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-column/watcher-helper2.mjs





function getAllAliases(props, aliases) {
  return props.reduce((prev, cur) => {
    prev[cur] = cur;
    return prev;
  }, aliases);
}

function watcher_helper2_useWatcher(owner, props_) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();

  const registerComplexWatchers = () => {
    const props = ["fixed"];
    const aliases = {
      realWidth: "width",
      realMinWidth: "minWidth"
    };
    const allAliases = getAllAliases(props, aliases);
    Object.keys(allAliases).forEach(key => {
      const columnKey = aliases[key];

      if (shared_esm_bundler_hasOwn(props_, columnKey)) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props_[columnKey], newVal => {
          let value = newVal;

          if (columnKey === "width" && key === "realWidth") {
            value = parseWidth(newVal);
          }

          if (columnKey === "minWidth" && key === "realMinWidth") {
            value = parseMinWidth(newVal);
          }

          instance.columnConfig.value[columnKey] = value;
          instance.columnConfig.value[key] = value;
          const updateColumns = columnKey === "fixed";
          owner.value.store.scheduleLayout(updateColumns);
        });
      }
    });
  };

  const registerNormalWatchers = () => {
    const props = ["label", "filters", "filterMultiple", "sortable", "index", "formatter", "className", "labelClassName", "showOverflowTooltip"];
    const aliases = {
      property: "prop",
      align: "realAlign",
      headerAlign: "realHeaderAlign"
    };
    const allAliases = getAllAliases(props, aliases);
    Object.keys(allAliases).forEach(key => {
      const columnKey = aliases[key];

      if (shared_esm_bundler_hasOwn(props_, columnKey)) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props_[columnKey], newVal => {
          instance.columnConfig.value[key] = newVal;
        });
      }
    });
  };

  return {
    registerComplexWatchers,
    registerNormalWatchers
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-column/render-helper2.mjs








function render_helper2_useRender(props, slots, owner) {
  const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
  const columnId = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
  const isSubColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
  const realAlign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
  const realHeaderAlign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
  const ns = useNamespace("table");
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
    realAlign.value = props.align ? `is-${props.align}` : null;
    realAlign.value;
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watchEffect)(() => {
    realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
    realHeaderAlign.value;
  });
  const columnOrTableParent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    let parent = instance.vnode.vParent || instance.parent;

    while (parent && !parent.tableId && !parent.columnId) {
      parent = parent.vnode.vParent || parent.parent;
    }

    return parent;
  });
  const hasTreeColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    const {
      store
    } = instance.parent;
    if (!store) return false;
    const {
      treeData
    } = store.states;
    const treeDataValue = treeData.value;
    return treeDataValue && Object.keys(treeDataValue).length > 0;
  });
  const realWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(parseWidth(props.width));
  const realMinWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(parseMinWidth(props.minWidth));

  const setColumnWidth = column => {
    if (realWidth.value) column.width = realWidth.value;

    if (realMinWidth.value) {
      column.minWidth = realMinWidth.value;
    }

    if (!column.minWidth) {
      column.minWidth = 80;
    }

    column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
    return column;
  };

  const setColumnForcedProps = column => {
    const type = column.type;
    const source = cellForced[type] || {};
    Object.keys(source).forEach(prop => {
      const value = source[prop];

      if (prop !== "className" && value !== void 0) {
        column[prop] = value;
      }
    });
    const className = getDefaultClassName(type);

    if (className) {
      const forceClass = `${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns.namespace)}-${className}`;
      column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
    }

    return column;
  };

  const checkSubColumn = children => {
    if (Array.isArray(children)) {
      children.forEach(child => check(child));
    } else {
      check(children);
    }

    function check(item) {
      var _a;

      if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") {
        item.vParent = instance;
      }
    }
  };

  const setColumnRenders = column => {
    if (props.renderHeader) {
      error2_debugWarn("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.");
    } else if (column.type !== "selection") {
      column.renderHeader = scope => {
        instance.columnConfig.value["label"];
        const renderHeader = slots.header;
        return renderHeader ? renderHeader(scope) : column.label;
      };
    }

    let originRenderCell = column.renderCell;
    const hasTreeColumnValue = hasTreeColumn.value;

    if (column.type === "expand") {
      column.renderCell = data => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        class: "cell"
      }, [originRenderCell(data)]);

      owner.value.renderExpanded = data => {
        return slots.default ? slots.default(data) : slots.default;
      };
    } else {
      originRenderCell = originRenderCell || defaultRenderCell;

      column.renderCell = data => {
        let children = null;

        if (slots.default) {
          const vnodes = slots.default(data);
          children = vnodes.some(v => v.type !== external_commonjs_vue_commonjs2_vue_root_Vue_.Comment) ? vnodes : originRenderCell(data);
        } else {
          children = originRenderCell(data);
        }

        const shouldCreatePlaceholder = hasTreeColumnValue && data.cellIndex === 0;
        const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
        const props2 = {
          class: "cell",
          style: {}
        };

        if (column.showOverflowTooltip) {
          props2.class = `${props2.class} ${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns.namespace)}-tooltip`;
          props2.style = {
            width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
          };
        }

        checkSubColumn(children);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", props2, [prefix, children]);
      };
    }

    return column;
  };

  const getPropsData = (...propsKey) => {
    return propsKey.reduce((prev, cur) => {
      if (Array.isArray(cur)) {
        cur.forEach(key => {
          prev[key] = props[key];
        });
      }

      return prev;
    }, {});
  };

  const getColumnElIndex = (children, child) => {
    return Array.prototype.indexOf.call(children, child);
  };

  return {
    columnId,
    realAlign,
    isSubColumn,
    realHeaderAlign,
    columnOrTableParent,
    setColumnWidth,
    setColumnForcedProps,
    setColumnRenders,
    getPropsData,
    getColumnElIndex
  };
}


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-column/defaults2.mjs
var table_column_defaults2_defaultProps = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: false
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: true
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showTooltipWhenOverflow: Boolean,
  showOverflowTooltip: Boolean,
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: true
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => {
      return ["ascending", "descending", null];
    },
    validator: val => {
      return val.every(order => ["ascending", "descending", null].includes(order));
    }
  }
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/src/table-column/index2.mjs









let columnIdSeed = 1;
var ElTableColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElTableColumn",
  components: {
    ElCheckbox: ElCheckbox
  },
  props: table_column_defaults2_defaultProps,

  setup(props, {
    slots
  }) {
    const instance = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.getCurrentInstance)();
    const columnConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
    const owner = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let parent2 = instance.parent;

      while (parent2 && !parent2.tableId) {
        parent2 = parent2.parent;
      }

      return parent2;
    });
    const {
      registerNormalWatchers,
      registerComplexWatchers
    } = watcher_helper2_useWatcher(owner, props);
    const {
      columnId,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
      realAlign
    } = render_helper2_useRender(props, slots, owner);
    const parent = columnOrTableParent.value;
    columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeMount)(() => {
      isSubColumn.value = owner.value !== parent;
      const type = props.type || "default";
      const sortable = props.sortable === "" ? true : props.sortable;
      const defaults = { ...cellStarts[type],
        id: columnId.value,
        type,
        property: props.prop || props.property,
        align: realAlign,
        headerAlign: realHeaderAlign,
        showOverflowTooltip: props.showOverflowTooltip || props.showTooltipWhenOverflow,
        filterable: props.filters || props.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: false,
        isSubColumn: false,
        filterOpened: false,
        sortable,
        index: props.index,
        rawColumnKey: instance.vnode.key
      };
      const basicProps = ["columnKey", "label", "className", "labelClassName", "type", "renderHeader", "formatter", "fixed", "resizable"];
      const sortProps = ["sortMethod", "sortBy", "sortOrders"];
      const selectProps = ["selectable", "reserveSelection"];
      const filterProps = ["filterMethod", "filters", "filterMultiple", "filterOpened", "filteredValue", "filterPlacement"];
      let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
      column = mergeOptions(defaults, column);
      const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
      column = chains(column);
      columnConfig.value = column;
      registerNormalWatchers();
      registerComplexWatchers();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      var _a;

      const parent2 = columnOrTableParent.value;
      const children = isSubColumn.value ? parent2.vnode.el.children : (_a = parent2.refs.hiddenColumns) == null ? void 0 : _a.children;

      const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);

      columnConfig.value.getColumnIndex = getColumnIndex;
      const columnIndex = getColumnIndex();
      columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null);
    });
    instance.columnId = columnId.value;
    instance.columnConfig = columnConfig;
    return;
  },

  render() {
    var _a, _b, _c;

    try {
      const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
        row: {},
        column: {},
        $index: -1
      });
      const children = [];

      if (Array.isArray(renderDefault)) {
        for (const childNode of renderDefault) {
          if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
            children.push(childNode);
          } else if (childNode.type === external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment && Array.isArray(childNode.children)) {
            childNode.children.forEach(vnode2 => {
              if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !shared_esm_bundler_isString(vnode2 == null ? void 0 : vnode2.children)) {
                children.push(vnode2);
              }
            });
          }
        }
      }

      const vnode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", children);
      return vnode;
    } catch (e) {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", []);
    }
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/index2.mjs





const ElTable = withInstall(Table, {
  TableColumn: ElTableColumn
});
const index2_ElTableColumn = withNoopInstall(ElTableColumn);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-table.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-checkbox.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/checkbox/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-tooltip.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/tooltip/style/css2.mjs



;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/style/css2.mjs






;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/PageTable.vue?vue&type=template&id=4c4a3aee&scoped=true
/* unplugin-vue-components disabled */




const _withScopeId = n => (_pushScopeId("data-v-4c4a3aee"), n = n(), _popScopeId(), n);

const PageTablevue_type_template_id_4c4a3aee_scoped_true_hoisted_1 = {
  class: "page-table"
};
function PageTablevue_type_template_id_4c4a3aee_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_table = ElTable;

  const _component_el_pagination = ElPagination;

  const _component_el_config_provider = ElConfigProvider;

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", PageTablevue_type_template_id_4c4a3aee_scoped_true_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_config_provider, {
    locale: $setup.locale
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table, {
      ref: "tableRef",
      data: $props.tableData,
      style: {
        "width": "100%"
      },
      "scrollbar-always-on": "",
      size: "large",
      "header-row-class-name": "page-table-header",
      onSelectionChange: $setup.handleSelectionChange,
      "row-key": $props.rowKey,
      "max-height": $props.tableHeight == 1 ? 400 : '100%'
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {}, undefined, true)]),
      _: 3
    }, 8, ["data", "onSelectionChange", "row-key", "max-height"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_pagination, {
      class: "nx-cc-pagination",
      background: "",
      "current-page": $props.currentPage,
      "page-sizes": $props.pageSizes,
      "page-size": $props.pageSize,
      layout: $props.layout,
      total: $props.total,
      onSizeChange: $setup.handleSizeChange,
      onCurrentChange: $setup.handleCurrentChange
    }, null, 8, ["current-page", "page-sizes", "page-size", "layout", "total", "onSizeChange", "onCurrentChange"])]),
    _: 3
  }, 8, ["locale"])]);
}
;// CONCATENATED MODULE: ./src/components/PageTable.vue?vue&type=template&id=4c4a3aee&scoped=true
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./node_modules/element-plus/dist/locale/zh-cn.mjs
/*! Element Plus v2.2.0 */
var zhCn = {
  name: "zh-cn",
  el: {
    colorpicker: {
      confirm: "\u786E\u5B9A",
      clear: "\u6E05\u7A7A"
    },
    datepicker: {
      now: "\u6B64\u523B",
      today: "\u4ECA\u5929",
      cancel: "\u53D6\u6D88",
      clear: "\u6E05\u7A7A",
      confirm: "\u786E\u5B9A",
      selectDate: "\u9009\u62E9\u65E5\u671F",
      selectTime: "\u9009\u62E9\u65F6\u95F4",
      startDate: "\u5F00\u59CB\u65E5\u671F",
      startTime: "\u5F00\u59CB\u65F6\u95F4",
      endDate: "\u7ED3\u675F\u65E5\u671F",
      endTime: "\u7ED3\u675F\u65F6\u95F4",
      prevYear: "\u524D\u4E00\u5E74",
      nextYear: "\u540E\u4E00\u5E74",
      prevMonth: "\u4E0A\u4E2A\u6708",
      nextMonth: "\u4E0B\u4E2A\u6708",
      year: "\u5E74",
      month1: "1 \u6708",
      month2: "2 \u6708",
      month3: "3 \u6708",
      month4: "4 \u6708",
      month5: "5 \u6708",
      month6: "6 \u6708",
      month7: "7 \u6708",
      month8: "8 \u6708",
      month9: "9 \u6708",
      month10: "10 \u6708",
      month11: "11 \u6708",
      month12: "12 \u6708",
      weeks: {
        sun: "\u65E5",
        mon: "\u4E00",
        tue: "\u4E8C",
        wed: "\u4E09",
        thu: "\u56DB",
        fri: "\u4E94",
        sat: "\u516D"
      },
      months: {
        jan: "\u4E00\u6708",
        feb: "\u4E8C\u6708",
        mar: "\u4E09\u6708",
        apr: "\u56DB\u6708",
        may: "\u4E94\u6708",
        jun: "\u516D\u6708",
        jul: "\u4E03\u6708",
        aug: "\u516B\u6708",
        sep: "\u4E5D\u6708",
        oct: "\u5341\u6708",
        nov: "\u5341\u4E00\u6708",
        dec: "\u5341\u4E8C\u6708"
      }
    },
    select: {
      loading: "\u52A0\u8F7D\u4E2D",
      noMatch: "\u65E0\u5339\u914D\u6570\u636E",
      noData: "\u65E0\u6570\u636E",
      placeholder: "\u8BF7\u9009\u62E9"
    },
    cascader: {
      noMatch: "\u65E0\u5339\u914D\u6570\u636E",
      loading: "\u52A0\u8F7D\u4E2D",
      placeholder: "\u8BF7\u9009\u62E9",
      noData: "\u6682\u65E0\u6570\u636E"
    },
    pagination: {
      goto: "\u524D\u5F80",
      pagesize: "\u6761/\u9875",
      total: "\u5171 {total} \u6761",
      pageClassifier: "\u9875",
      deprecationWarning: "\u4F60\u4F7F\u7528\u4E86\u4E00\u4E9B\u5DF2\u88AB\u5E9F\u5F03\u7684\u7528\u6CD5\uFF0C\u8BF7\u53C2\u8003 el-pagination \u7684\u5B98\u65B9\u6587\u6863"
    },
    messagebox: {
      title: "\u63D0\u793A",
      confirm: "\u786E\u5B9A",
      cancel: "\u53D6\u6D88",
      error: "\u8F93\u5165\u7684\u6570\u636E\u4E0D\u5408\u6CD5!"
    },
    upload: {
      deleteTip: "\u6309 delete \u952E\u53EF\u5220\u9664",
      delete: "\u5220\u9664",
      preview: "\u67E5\u770B\u56FE\u7247",
      continue: "\u7EE7\u7EED\u4E0A\u4F20"
    },
    table: {
      emptyText: "\u6682\u65E0\u6570\u636E",
      confirmFilter: "\u7B5B\u9009",
      resetFilter: "\u91CD\u7F6E",
      clearFilter: "\u5168\u90E8",
      sumText: "\u5408\u8BA1"
    },
    tree: {
      emptyText: "\u6682\u65E0\u6570\u636E"
    },
    transfer: {
      noMatch: "\u65E0\u5339\u914D\u6570\u636E",
      noData: "\u65E0\u6570\u636E",
      titles: ["\u5217\u8868 1", "\u5217\u8868 2"],
      filterPlaceholder: "\u8BF7\u8F93\u5165\u641C\u7D22\u5185\u5BB9",
      noCheckedFormat: "\u5171 {total} \u9879",
      hasCheckedFormat: "\u5DF2\u9009 {checked}/{total} \u9879"
    },
    image: {
      error: "\u52A0\u8F7D\u5931\u8D25"
    },
    pageHeader: {
      title: "\u8FD4\u56DE"
    },
    popconfirm: {
      confirmButtonText: "\u786E\u5B9A",
      cancelButtonText: "\u53D6\u6D88"
    }
  }
};

;// CONCATENATED MODULE: ./node_modules/element-plus/dist/locale/en.mjs
/*! Element Plus v2.2.0 */
var en_en = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};

;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/PageTable.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */



/* harmony default export */ var PageTablevue_type_script_lang_js = ({
  props: {
    tableData: Array,
    currentPage: {
      type: Number,
      default: 0
    },
    pageSizes: {
      type: Array,

      default() {
        return [10, 20, 30, 40];
      }

    },
    pageSize: {
      type: Number,

      default() {
        return 10;
      }

    },
    layout: {
      type: String,

      default() {
        return "total, prev, pager, next, sizes";
      }

    },
    total: {
      type: Number,

      default() {
        return 0;
      }

    },
    rowKey: {
      type: Function
    },
    tableHeight: {
      type: Number,

      default() {
        return 0;
      }

    }
  },

  setup(props, context) {
    const language = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("en");
    const locale = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => language.value === "zh-cn" ? zhCn : en_en);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      language.value = js_cookie.get("locale") == "zh-CN" ? 'zh-cn' : 'en';
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => [js_cookie.get("locale")], val => {
      language.value = val[0] == 'zh' ? 'zh-cn' : 'en';
    });
    const tableRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

    const handleSizeChange = val => {
      context.emit("sizeChange", val);
    };

    const handleCurrentChange = val => {
      context.emit("pageChange", val);
    };

    const handleSelectionChange = val => {
      context.emit("selectionChange", val);
    };

    const clearSelection = () => {
      tableRef.value.clearSelection();
    };

    return {
      tableRef,
      handleSizeChange,
      handleCurrentChange,
      handleSelectionChange,
      clearSelection,
      locale
    };
  }

});
;// CONCATENATED MODULE: ./src/components/PageTable.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */ 
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/PageTable.vue?vue&type=style&index=0&id=4c4a3aee&scoped=true&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/PageTable.vue?vue&type=style&index=0&id=4c4a3aee&scoped=true&lang=scss
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/PageTable.vue?vue&type=style&index=1&id=4c4a3aee&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/PageTable.vue?vue&type=style&index=1&id=4c4a3aee&lang=scss
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./src/components/PageTable.vue
/* unplugin-vue-components disabled */



;



const PageTable_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(PageTablevue_type_script_lang_js, [['render',PageTablevue_type_template_id_4c4a3aee_scoped_true_render],['__scopeId',"data-v-4c4a3aee"]])

/* harmony default export */ var PageTable = (PageTable_exports_);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/link/src/link3.mjs



const linkProps = buildProps({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: "default"
  },
  underline: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  href: {
    type: String,
    default: ""
  },
  icon: {
    type: iconPropType,
    default: ""
  }
});
const linkEmits = {
  click: evt => evt instanceof MouseEvent
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/link/src/link4.mjs






const link4_hoisted_1 = ["href"];
const link4_default_ = {
  name: "ElLink"
};

const link4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...link4_default_,
  props: linkProps,
  emits: linkEmits,

  setup(__props, {
    emit
  }) {
    const props = __props;
    const ns = useNamespace("link");

    function handleClick(event) {
      if (!props.disabled) emit("click", event);
    }

    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("a", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).b(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).m(_ctx.type), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("disabled", _ctx.disabled), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).is("underline", _ctx.underline && !_ctx.disabled)]),
        href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
        onClick: handleClick
      }, [_ctx.icon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ElIcon), {
        key: 0
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.icon)))]),
        _: 1
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.$slots.default ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
        key: 1,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("inner"))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.$slots.icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "icon", {
        key: 2
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 10, link4_hoisted_1);
    };
  }

});

var Link = /* @__PURE__ */_export_sfc(link4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/link/index2.mjs




const ElLink = withInstall(Link);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-link.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/link/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/link/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-table-column.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table-column/style/css2.mjs




;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/table-column/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/src/form3.mjs






const formProps = buildProps({
  model: Object,
  rules: {
    type: definePropType(Object)
  },
  labelPosition: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: componentSizes
  },
  disabled: Boolean,
  validateOnRuleChange: {
    type: Boolean,
    default: true
  },
  hideRequiredAsterisk: {
    type: Boolean,
    default: false
  },
  scrollToError: Boolean
});
const formEmits = {
  validate: (prop, isValid, message) => (shared_esm_bundler_isArray(prop) || shared_esm_bundler_isString(prop)) && shared_isBoolean(isValid) && shared_esm_bundler_isString(message)
};

;// CONCATENATED MODULE: ./node_modules/lodash-es/castArray.js

/**
 * Casts `value` as an array if it's not one.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Lang
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast array.
 * @example
 *
 * _.castArray(1);
 * // => [1]
 *
 * _.castArray({ 'a': 1 });
 * // => [{ 'a': 1 }]
 *
 * _.castArray('abc');
 * // => ['abc']
 *
 * _.castArray(null);
 * // => [null]
 *
 * _.castArray(undefined);
 * // => [undefined]
 *
 * _.castArray();
 * // => []
 *
 * var array = [1, 2, 3];
 * console.log(_.castArray(array) === array);
 * // => true
 */

function castArray() {
  if (!arguments.length) {
    return [];
  }

  var value = arguments[0];
  return lodash_es_isArray(value) ? value : [value];
}

/* harmony default export */ var lodash_es_castArray = (castArray);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/src/utils2.mjs




const utils2_SCOPE = "ElForm";

function useFormLabelWidth() {
  const potentialLabelWidthArr = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
  const autoLabelWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    if (!potentialLabelWidthArr.value.length) return "0";
    const max = Math.max(...potentialLabelWidthArr.value);
    return max ? `${max}px` : "";
  });

  function getLabelWidthIndex(width) {
    const index = potentialLabelWidthArr.value.indexOf(width);

    if (index === -1) {
      error2_debugWarn(utils2_SCOPE, `unexpected width ${width}`);
    }

    return index;
  }

  function registerLabelWidth(val, oldVal) {
    if (val && oldVal) {
      const index = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.value.splice(index, 1, val);
    } else if (val) {
      potentialLabelWidthArr.value.push(val);
    }
  }

  function deregisterLabelWidth(val) {
    const index = getLabelWidthIndex(val);

    if (index > -1) {
      potentialLabelWidthArr.value.splice(index, 1);
    }
  }

  return {
    autoLabelWidth,
    registerLabelWidth,
    deregisterLabelWidth
  };
}

const filterFields = (fields, props) => {
  const normalized = lodash_es_castArray(props);
  return normalized.length > 0 ? fields.filter(field => field.prop && normalized.includes(field.prop)) : fields;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/src/form4.mjs












const form4_default_ = {
  name: "ElForm"
};

const form4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...form4_default_,
  props: formProps,
  emits: formEmits,

  setup(__props, {
    expose,
    emit
  }) {
    const props = __props;
    const COMPONENT_NAME = "ElForm";
    const fields = [];
    const formSize = useSize();
    const ns = useNamespace("form");
    const formClasses = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelPosition,
        inline
      } = props;
      return [ns.b(), ns.m(formSize.value || "default"), {
        [ns.m(`label-${labelPosition}`)]: labelPosition,
        [ns.m("inline")]: inline
      }];
    });

    const addField = field => {
      fields.push(field);
    };

    const removeField = field => {
      if (field.prop) {
        fields.splice(fields.indexOf(field), 1);
      }
    };

    const resetFields = (properties = []) => {
      if (!props.model) {
        error2_debugWarn(COMPONENT_NAME, "model is required for resetFields to work.");
        return;
      }

      filterFields(fields, properties).forEach(field => field.resetField());
    };

    const clearValidate = (props2 = []) => {
      filterFields(fields, props2).forEach(field => field.clearValidate());
    };

    const isValidatable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const hasModel = !!props.model;

      if (!hasModel) {
        error2_debugWarn(COMPONENT_NAME, "model is required for validate to work.");
      }

      return hasModel;
    });

    const obtainValidateFields = props2 => {
      if (fields.length === 0) return [];
      const filteredFields = filterFields(fields, props2);

      if (!filteredFields.length) {
        error2_debugWarn(COMPONENT_NAME, "please pass correct props!");
        return [];
      }

      return filteredFields;
    };

    const validate = async callback => validateField(void 0, callback);

    const doValidateField = async (props2 = []) => {
      if (!isValidatable.value) return false;
      const fields2 = obtainValidateFields(props2);
      if (fields2.length === 0) return true;
      let validationErrors = {};

      for (const field of fields2) {
        try {
          await field.validate("");
        } catch (fields3) {
          validationErrors = { ...validationErrors,
            ...fields3
          };
        }
      }

      if (Object.keys(validationErrors).length === 0) return true;
      return Promise.reject(validationErrors);
    };

    const validateField = async (modelProps = [], callback) => {
      const shouldThrow = !shared_esm_bundler_isFunction(callback);

      try {
        const result = await doValidateField(modelProps);

        if (result === true) {
          callback == null ? void 0 : callback(result);
        }

        return result;
      } catch (e) {
        const invalidFields = e;

        if (props.scrollToError) {
          scrollToField(Object.keys(invalidFields)[0]);
        }

        callback == null ? void 0 : callback(false, invalidFields);
        return shouldThrow && Promise.reject(invalidFields);
      }
    };

    const scrollToField = prop => {
      var _a;

      const field = filterFields(fields, prop)[0];

      if (field) {
        (_a = field.$el) == null ? void 0 : _a.scrollIntoView();
      }
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.rules, () => {
      if (props.validateOnRuleChange) validate();
    }, {
      deep: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(formContextKey, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({ ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(props),
      emit,
      resetFields,
      clearValidate,
      validateField,
      addField,
      removeField,
      ...useFormLabelWidth()
    }));
    expose({
      validate,
      validateField,
      resetFields,
      clearValidate,
      scrollToField
    });
    return (_ctx, _cache) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("form", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(formClasses))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default")], 2);
    };
  }

});

var Form = /* @__PURE__ */_export_sfc(form4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);


;// CONCATENATED MODULE: ./node_modules/async-validator/dist-web/index.js


function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}
/* eslint no-console:0 */


var formatRegExp = /%[sdj%]/g;

var warning = function warning() {}; // don't print warning message when in production env or node runtime


if (typeof process !== 'undefined' && ({"NODE_ENV":"production","VUE_APP_BASE_API":"https://cc.nxcloud.com","VUE_APP_SAAS_API":"https://nxlink.nxcloud.com","BASE_URL":""}) && "production" !== 'production' && 0 && 0) {}

function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function (error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}

function dist_web_format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var i = 0;
  var len = args.length;

  if (typeof template === 'function') {
    return template.apply(null, args);
  }

  if (typeof template === 'string') {
    var str = template.replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });
    return str;
  }

  return template;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors || []);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}

var AsyncValidationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncValidationError, _Error);

  function AsyncValidationError(errors, fields) {
    var _this;

    _this = _Error.call(this, 'Async Validation Error') || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }

  return AsyncValidationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };

      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });

    _pending["catch"](function (e) {
      return e;
    });

    return _pending;
  }

  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function (resolve, reject) {
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };

    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }

    objArrKeys.forEach(function (key) {
      var arr = objArr[key];

      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function (e) {
    return e;
  });
  return pending;
}

function isErrorObj(obj) {
  return !!(obj && obj.message !== undefined);
}

function dist_web_getValue(value, path) {
  var v = value;

  for (var i = 0; i < path.length; i++) {
    if (v == undefined) {
      return v;
    }

    v = v[path[i]];
  }

  return v;
}

function complementError(rule, source) {
  return function (oe) {
    var fieldValue;

    if (rule.fullFields) {
      fieldValue = dist_web_getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }

    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }

    return {
      message: typeof oe === 'function' ? oe() : oe,
      fieldValue: fieldValue,
      field: oe.field || rule.fullField
    };
  };
}

function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if (typeof value === 'object' && typeof target[s] === 'object') {
          target[s] = _extends({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}

var required$1 = function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(dist_web_format(options.messages.required, rule.fullField));
  }
};
/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


var whitespace = function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(dist_web_format(options.messages.whitespace, rule.fullField));
  }
}; // https://github.com/kevva/url-regex/blob/master/index.js


var urlReg;

var getUrlRegex = function () {
  if (urlReg) {
    return urlReg;
  }

  var word = '[a-fA-F\\d:]';

  var b = function b(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : '';
  };

  var v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
  var v6seg = '[a-fA-F\\d]{1,4}';
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful

  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");

  var ip = function ip(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", 'g');
  };

  ip.v4 = function (options) {
    return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), 'g');
  };

  ip.v6 = function (options) {
    return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), 'g');
  };

  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = '(?:\\S+(?::\\S*)?@)?';
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = '(?::\\d{2,5})?';
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
  urlReg = new RegExp("(?:^" + regex + "$)", 'i');
  return urlReg;
};
/* eslint max-len:0 */


var pattern$2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return typeof value === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === 'string' && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern$2.hex);
  }
};

var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    required$1(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(dist_web_format(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && typeof value !== rule.type) {
    errors.push(dist_web_format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};

var dist_web_range = function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // U+010000U+10FFFFSupplementary Plane

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // U+010000lengthbug"".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(dist_web_format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(dist_web_format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(dist_web_format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(dist_web_format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};

var ENUM$1 = 'enum';

var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];

  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(dist_web_format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
  }
};

var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(dist_web_format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(dist_web_format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};

var rules = {
  required: required$1,
  whitespace: whitespace,
  type: type$1,
  range: dist_web_range,
  "enum": enumerable$1,
  pattern: pattern$1
};

var string = function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
};

var method = function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var dist_web_number = function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (value === '') {
      value = undefined;
    }

    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var _boolean = function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var regexp = function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var integer = function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var floatFn = function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var array = function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if ((value === undefined || value === null) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'array');

    if (value !== undefined && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var object = function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var ENUM = 'enum';

var enumerable = function enumerable(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var pattern = function pattern(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      rules.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var date = function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value, 'date') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'date')) {
      var dateObject;

      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }

      rules.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
};

var required = function required(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value;
  rules.required(rule, value, source, errors, options, type);
  callback(errors);
};

var type = function type(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var any = function any(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);
  }

  callback(errors);
};

var validators = {
  string: string,
  method: method,
  number: dist_web_number,
  "boolean": _boolean,
  regexp: regexp,
  integer: integer,
  "float": floatFn,
  array: array,
  object: object,
  "enum": enumerable,
  pattern: pattern,
  date: date,
  url: type,
  hex: type,
  email: type,
  required: required,
  any: any
};

function newMessages() {
  return {
    "default": 'Validation error on field %s',
    required: '%s is required',
    "enum": '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}

var dist_web_messages = newMessages();
/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

var Schema = /*#__PURE__*/function () {
  // ========================= Static =========================
  // ======================== Instance ========================
  function Schema(descriptor) {
    this.rules = null;
    this._messages = dist_web_messages;
    this.define(descriptor);
  }

  var _proto = Schema.prototype;

  _proto.define = function define(rules) {
    var _this = this;

    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if (typeof rules !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    Object.keys(rules).forEach(function (name) {
      var item = rules[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };

  _proto.messages = function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  };

  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;

    if (o === void 0) {
      o = {};
    }

    if (oc === void 0) {
      oc = function oc() {};
    }

    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }

      return Promise.resolve(source);
    }

    function complete(results) {
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          var _errors;

          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }

      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }

    if (options.messages) {
      var messages$1 = this.messages();

      if (messages$1 === dist_web_messages) {
        messages$1 = newMessages();
      }

      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }

    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = _extends({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        } // Fill validator. Skip if nothing need to validate


        rule.validator = _this2.getValidationMethod(rule);

        if (!rule.validator) {
          return;
        }

        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }

      function cb(e) {
        if (e === void 0) {
          e = [];
        }

        var errorList = Array.isArray(e) ? e : [e];

        if (!options.suppressWarning && errorList.length) {
          Schema.warning('async-validator:', errorList);
        }

        if (errorList.length && rule.message !== undefined) {
          errorList = [].concat(rule.message);
        } // Fill error info


        var filledErrors = errorList.map(complementError(rule, source));

        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }

        if (!deep) {
          doIt(filledErrors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message !== undefined) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, dist_web_format(options.messages.required, rule.field))];
            }

            return doIt(filledErrors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            Object.keys(data.value).map(function (key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }

          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function (field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema(paredFieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            var finalErrors = [];

            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }

            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }

            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }

      var res;

      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data.value, cb, data.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error); // rethrow to report error

          if (!options.suppressValidatorError) {
            setTimeout(function () {
              throw error;
            }, 0);
          }

          cb(error.message);
        }

        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    }, source);
  };

  _proto.getType = function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(dist_web_format('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  };

  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return validators.required;
    }

    return validators[this.getType(rule)] || undefined;
  };

  return Schema;
}();

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  validators[type] = validator;
};

Schema.warning = warning;
Schema.messages = dist_web_messages;
Schema.validators = validators;

;// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayEach.js
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/* harmony default export */ var _arrayEach = (arrayEach);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_copyObject.js


/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }

  return object;
}

/* harmony default export */ var _copyObject = (copyObject);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssign.js


/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */

function baseAssign(object, source) {
  return object && _copyObject(source, lodash_es_keys(source), object);
}

/* harmony default export */ var _baseAssign = (baseAssign);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeysIn.js
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _nativeKeysIn = (nativeKeysIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeysIn.js



/** Used for built-in method references. */

var _baseKeysIn_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!lodash_es_isObject(object)) {
    return _nativeKeysIn(object);
  }

  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ var _baseKeysIn = (baseKeysIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/keysIn.js



/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

/* harmony default export */ var lodash_es_keysIn = (keysIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignIn.js


/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */

function baseAssignIn(object, source) {
  return object && _copyObject(source, lodash_es_keysIn(source), object);
}

/* harmony default export */ var _baseAssignIn = (baseAssignIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneBuffer.js

/** Detect free variable `exports`. */

var _cloneBuffer_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var _cloneBuffer_freeModule = _cloneBuffer_freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var _cloneBuffer_moduleExports = _cloneBuffer_freeModule && _cloneBuffer_freeModule.exports === _cloneBuffer_freeExports;
/** Built-in value references. */

var _cloneBuffer_Buffer = _cloneBuffer_moduleExports ? _root.Buffer : undefined,
    allocUnsafe = _cloneBuffer_Buffer ? _cloneBuffer_Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/* harmony default export */ var _cloneBuffer = (cloneBuffer);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_copyArray.js
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/* harmony default export */ var _copyArray = (copyArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_copySymbols.js


/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */

function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

/* harmony default export */ var _copySymbols = (copySymbols);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getPrototype.js

/** Built-in value references. */

var getPrototype = _overArg(Object.getPrototypeOf, Object);
/* harmony default export */ var _getPrototype = (getPrototype);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbolsIn.js




/* Built-in method references for those with the same name as other `lodash` methods. */

var _getSymbolsIn_nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !_getSymbolsIn_nativeGetSymbols ? lodash_es_stubArray : function (object) {
  var result = [];

  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }

  return result;
};
/* harmony default export */ var _getSymbolsIn = (getSymbolsIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_copySymbolsIn.js


/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */

function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

/* harmony default export */ var _copySymbolsIn = (copySymbolsIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeysIn.js



/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeysIn(object) {
  return _baseGetAllKeys(object, lodash_es_keysIn, _getSymbolsIn);
}

/* harmony default export */ var _getAllKeysIn = (getAllKeysIn);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneArray.js
/** Used for built-in method references. */
var _initCloneArray_objectProto = Object.prototype;
/** Used to check objects for own properties. */

var _initCloneArray_hasOwnProperty = _initCloneArray_objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && _initCloneArray_hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

/* harmony default export */ var _initCloneArray = (initCloneArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneArrayBuffer.js

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

/* harmony default export */ var _cloneArrayBuffer = (cloneArrayBuffer);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneDataView.js

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */

function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/* harmony default export */ var _cloneDataView = (cloneDataView);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneRegExp.js
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/* harmony default export */ var _cloneRegExp = (cloneRegExp);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneSymbol.js

/** Used to convert symbols to primitives and strings. */

var _cloneSymbol_symbolProto = _Symbol ? _Symbol.prototype : undefined,
    _cloneSymbol_symbolValueOf = _cloneSymbol_symbolProto ? _cloneSymbol_symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return _cloneSymbol_symbolValueOf ? Object(_cloneSymbol_symbolValueOf.call(symbol)) : {};
}

/* harmony default export */ var _cloneSymbol = (cloneSymbol);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneTypedArray.js

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ var _cloneTypedArray = (cloneTypedArray);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneByTag.js





/** `Object#toString` result references. */

var _initCloneByTag_boolTag = '[object Boolean]',
    _initCloneByTag_dateTag = '[object Date]',
    _initCloneByTag_mapTag = '[object Map]',
    _initCloneByTag_numberTag = '[object Number]',
    _initCloneByTag_regexpTag = '[object RegExp]',
    _initCloneByTag_setTag = '[object Set]',
    _initCloneByTag_stringTag = '[object String]',
    _initCloneByTag_symbolTag = '[object Symbol]';
var _initCloneByTag_arrayBufferTag = '[object ArrayBuffer]',
    _initCloneByTag_dataViewTag = '[object DataView]',
    _initCloneByTag_float32Tag = '[object Float32Array]',
    _initCloneByTag_float64Tag = '[object Float64Array]',
    _initCloneByTag_int8Tag = '[object Int8Array]',
    _initCloneByTag_int16Tag = '[object Int16Array]',
    _initCloneByTag_int32Tag = '[object Int32Array]',
    _initCloneByTag_uint8Tag = '[object Uint8Array]',
    _initCloneByTag_uint8ClampedTag = '[object Uint8ClampedArray]',
    _initCloneByTag_uint16Tag = '[object Uint16Array]',
    _initCloneByTag_uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case _initCloneByTag_arrayBufferTag:
      return _cloneArrayBuffer(object);

    case _initCloneByTag_boolTag:
    case _initCloneByTag_dateTag:
      return new Ctor(+object);

    case _initCloneByTag_dataViewTag:
      return _cloneDataView(object, isDeep);

    case _initCloneByTag_float32Tag:
    case _initCloneByTag_float64Tag:
    case _initCloneByTag_int8Tag:
    case _initCloneByTag_int16Tag:
    case _initCloneByTag_int32Tag:
    case _initCloneByTag_uint8Tag:
    case _initCloneByTag_uint8ClampedTag:
    case _initCloneByTag_uint16Tag:
    case _initCloneByTag_uint32Tag:
      return _cloneTypedArray(object, isDeep);

    case _initCloneByTag_mapTag:
      return new Ctor();

    case _initCloneByTag_numberTag:
    case _initCloneByTag_stringTag:
      return new Ctor(object);

    case _initCloneByTag_regexpTag:
      return _cloneRegExp(object);

    case _initCloneByTag_setTag:
      return new Ctor();

    case _initCloneByTag_symbolTag:
      return _cloneSymbol(object);
  }
}

/* harmony default export */ var _initCloneByTag = (initCloneByTag);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseCreate.js

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!lodash_es_isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/* harmony default export */ var _baseCreate = (baseCreate);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneObject.js



/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
}

/* harmony default export */ var _initCloneObject = (initCloneObject);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsMap.js


/** `Object#toString` result references. */

var _baseIsMap_mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsMap_mapTag;
}

/* harmony default export */ var _baseIsMap = (baseIsMap);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isMap.js



/* Node.js helper references. */

var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap_isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
/* harmony default export */ var lodash_es_isMap = (isMap_isMap);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsSet.js


/** `Object#toString` result references. */

var _baseIsSet_setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsSet_setTag;
}

/* harmony default export */ var _baseIsSet = (baseIsSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/isSet.js



/* Node.js helper references. */

var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet_isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
/* harmony default export */ var lodash_es_isSet = (isSet_isSet);
;// CONCATENATED MODULE: ./node_modules/lodash-es/_baseClone.js






















/** Used to compose bitmasks for cloning. */

var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var _baseClone_argsTag = '[object Arguments]',
    _baseClone_arrayTag = '[object Array]',
    _baseClone_boolTag = '[object Boolean]',
    _baseClone_dateTag = '[object Date]',
    _baseClone_errorTag = '[object Error]',
    _baseClone_funcTag = '[object Function]',
    _baseClone_genTag = '[object GeneratorFunction]',
    _baseClone_mapTag = '[object Map]',
    _baseClone_numberTag = '[object Number]',
    _baseClone_objectTag = '[object Object]',
    _baseClone_regexpTag = '[object RegExp]',
    _baseClone_setTag = '[object Set]',
    _baseClone_stringTag = '[object String]',
    _baseClone_symbolTag = '[object Symbol]',
    _baseClone_weakMapTag = '[object WeakMap]';
var _baseClone_arrayBufferTag = '[object ArrayBuffer]',
    _baseClone_dataViewTag = '[object DataView]',
    _baseClone_float32Tag = '[object Float32Array]',
    _baseClone_float64Tag = '[object Float64Array]',
    _baseClone_int8Tag = '[object Int8Array]',
    _baseClone_int16Tag = '[object Int16Array]',
    _baseClone_int32Tag = '[object Int32Array]',
    _baseClone_uint8Tag = '[object Uint8Array]',
    _baseClone_uint8ClampedTag = '[object Uint8ClampedArray]',
    _baseClone_uint16Tag = '[object Uint16Array]',
    _baseClone_uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[_baseClone_argsTag] = cloneableTags[_baseClone_arrayTag] = cloneableTags[_baseClone_arrayBufferTag] = cloneableTags[_baseClone_dataViewTag] = cloneableTags[_baseClone_boolTag] = cloneableTags[_baseClone_dateTag] = cloneableTags[_baseClone_float32Tag] = cloneableTags[_baseClone_float64Tag] = cloneableTags[_baseClone_int8Tag] = cloneableTags[_baseClone_int16Tag] = cloneableTags[_baseClone_int32Tag] = cloneableTags[_baseClone_mapTag] = cloneableTags[_baseClone_numberTag] = cloneableTags[_baseClone_objectTag] = cloneableTags[_baseClone_regexpTag] = cloneableTags[_baseClone_setTag] = cloneableTags[_baseClone_stringTag] = cloneableTags[_baseClone_symbolTag] = cloneableTags[_baseClone_uint8Tag] = cloneableTags[_baseClone_uint8ClampedTag] = cloneableTags[_baseClone_uint16Tag] = cloneableTags[_baseClone_uint32Tag] = true;
cloneableTags[_baseClone_errorTag] = cloneableTags[_baseClone_funcTag] = cloneableTags[_baseClone_weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!lodash_es_isObject(value)) {
    return value;
  }

  var isArr = lodash_es_isArray(value);

  if (isArr) {
    result = _initCloneArray(value);

    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == _baseClone_funcTag || tag == _baseClone_genTag;

    if (lodash_es_isBuffer(value)) {
      return _cloneBuffer(value, isDeep);
    }

    if (tag == _baseClone_objectTag || tag == _baseClone_argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : _initCloneObject(value);

      if (!isDeep) {
        return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = _initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new _Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (lodash_es_isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (lodash_es_isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? lodash_es_keysIn : lodash_es_keys;
  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/* harmony default export */ var _baseClone = (baseClone);
;// CONCATENATED MODULE: ./node_modules/lodash-es/clone.js

/** Used to compose bitmasks for cloning. */

var clone_CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return _baseClone(value, clone_CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ var lodash_es_clone = (clone);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/src/form-item3.mjs




const formItemValidateStates = ["", "error", "validating", "success"];
const formItemProps = buildProps({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: definePropType([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: definePropType([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: formItemValidateStates
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: componentSizes
  }
});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/src/form-label-wrap.mjs








const form_label_wrap_COMPONENT_NAME = "ElLabelWrap";
var FormLabelWrap = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: form_label_wrap_COMPONENT_NAME,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },

  setup(props, {
    slots
  }) {
    const formContext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, void 0);
    const formItemContext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey);
    if (!formItemContext) throwError(form_label_wrap_COMPONENT_NAME, "usage: <el-form-item><label-wrap /></el-form-item>");
    const ns = useNamespace("form");
    const el = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computedWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);

    const getLabelWidth = () => {
      var _a;

      if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
        const width = window.getComputedStyle(el.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(width));
      } else {
        return 0;
      }
    };

    const updateLabelWidth = (action = "update") => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (slots.default && props.isAutoWidth) {
          if (action === "update") {
            computedWidth.value = getLabelWidth();
          } else if (action === "remove") {
            formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
          }
        }
      });
    };

    const updateLabelWidthFn = () => updateLabelWidth("update");

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateLabelWidthFn();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      updateLabelWidth("remove");
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUpdated)(() => updateLabelWidthFn());
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computedWidth, (val, oldVal) => {
      if (props.updateAll) {
        formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
      }
    });
    useResizeObserver((0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b;

      return (_b = (_a = el.value) == null ? void 0 : _a.firstElementChild) != null ? _b : null;
    }), updateLabelWidthFn);
    return () => {
      var _a, _b;

      if (!slots) return null;
      const {
        isAutoWidth
      } = props;

      if (isAutoWidth) {
        const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
        const style = {};

        if (autoLabelWidth && autoLabelWidth !== "auto") {
          const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
          const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";

          if (marginWidth) {
            style[marginPosition] = `${marginWidth}px`;
          }
        }

        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)("div", {
          "ref": el,
          "class": [ns.be("item", "label-wrap")],
          "style": style
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      } else {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
          "ref": el
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
      }
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/src/form-item4.mjs

















const form_item4_hoisted_1 = ["role", "aria-labelledby"];
const form_item4_default_ = {
  name: "ElFormItem"
};

const form_item4_sfc_main = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({ ...form_item4_default_,
  props: formItemProps,

  setup(__props, {
    expose
  }) {
    const props = __props;
    const slots = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.useSlots)();
    const formContext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, void 0);
    const parentFormItemContext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, void 0);

    const _size = useSize(void 0, {
      formItem: false
    });

    const ns = useNamespace("form-item");
    const labelId = useId().value;
    const inputIds = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    const validateState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
    const validateStateDebounced = refDebounced(validateState, 100);
    const validateMessage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
    const formItemRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let initialValue = void 0;
    let isResettingField = false;
    const labelStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
        return {};
      }

      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
      if (labelWidth) return {
        width: labelWidth
      };
      return {};
    });
    const contentStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
        return {};
      }

      if (!props.label && !props.labelWidth && isNested) {
        return {};
      }

      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");

      if (!props.label && !slots.label) {
        return {
          marginLeft: labelWidth
        };
      }

      return {};
    });
    const formItemClasses = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [ns.b(), ns.m(_size.value), ns.is("error", validateState.value === "error"), ns.is("validating", validateState.value === "validating"), ns.is("success", validateState.value === "success"), ns.is("required", isRequired.value || props.required), ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk), {
      [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon
    }]);

    const _inlineMessage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => shared_isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);

    const validateClasses = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => [ns.e("error"), {
      [ns.em("error", "inline")]: _inlineMessage.value
    }]);
    const propString = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (!props.prop) return "";
      return shared_esm_bundler_isString(props.prop) ? props.prop : props.prop.join(".");
    });
    const hasLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return !!(props.label || slots.label);
    });
    const labelFor = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
    });
    const isGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return !labelFor.value && hasLabel.value;
    });
    const isNested = !!parentFormItemContext;
    const fieldValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const model = formContext == null ? void 0 : formContext.model;

      if (!model || !props.prop) {
        return;
      }

      return getProp(model, props.prop).value;
    });

    const _rules = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const rules = props.rules ? lodash_es_castArray(props.rules) : [];
      const formRules = formContext == null ? void 0 : formContext.rules;

      if (formRules && props.prop) {
        const _rules2 = getProp(formRules, props.prop).value;

        if (_rules2) {
          rules.push(...lodash_es_castArray(_rules2));
        }
      }

      if (props.required !== void 0) {
        rules.push({
          required: !!props.required
        });
      }

      return rules;
    });

    const validateEnabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _rules.value.length > 0);

    const getFilteredRule = trigger => {
      const rules = _rules.value;
      return rules.filter(rule => {
        if (!rule.trigger || !trigger) return true;

        if (Array.isArray(rule.trigger)) {
          return rule.trigger.includes(trigger);
        } else {
          return rule.trigger === trigger;
        }
      }).map(({
        trigger: trigger2,
        ...rule
      }) => rule);
    };

    const isRequired = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => _rules.value.some(rule => rule.required === true));
    const shouldShowError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      return validateStateDebounced.value === "error" && props.showMessage && ((_a = formContext == null ? void 0 : formContext.showMessage) != null ? _a : true);
    });
    const currentLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);

    const setValidationState = state => {
      validateState.value = state;
    };

    const onValidationFailed = error => {
      var _a, _b;

      const {
        errors,
        fields
      } = error;

      if (!errors || !fields) {
        console.error(error);
      }

      setValidationState("error");
      validateMessage.value = errors ? (_b = (_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) != null ? _b : `${props.prop} is required` : "";
      formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
    };

    const onValidationSucceeded = () => {
      setValidationState("success");
      formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
    };

    const doValidate = async rules => {
      const modelName = propString.value;
      const validator = new Schema({
        [modelName]: rules
      });
      return validator.validate({
        [modelName]: fieldValue.value
      }, {
        firstFields: true
      }).then(() => {
        onValidationSucceeded();
        return true;
      }).catch(err => {
        onValidationFailed(err);
        return Promise.reject(err);
      });
    };

    const validate = async (trigger, callback) => {
      if (isResettingField) {
        isResettingField = false;
        return false;
      }

      const hasCallback = shared_esm_bundler_isFunction(callback);

      if (!validateEnabled.value) {
        callback == null ? void 0 : callback(false);
        return false;
      }

      const rules = getFilteredRule(trigger);

      if (rules.length === 0) {
        callback == null ? void 0 : callback(true);
        return true;
      }

      setValidationState("validating");
      return doValidate(rules).then(() => {
        callback == null ? void 0 : callback(true);
        return true;
      }).catch(err => {
        const {
          fields
        } = err;
        callback == null ? void 0 : callback(false, fields);
        return hasCallback ? false : Promise.reject(fields);
      });
    };

    const clearValidate = () => {
      setValidationState("");
      validateMessage.value = "";
    };

    const resetField = async () => {
      const model = formContext == null ? void 0 : formContext.model;
      if (!model || !props.prop) return;
      const computedValue = getProp(model, props.prop);

      if (!lodash_es_isEqual(computedValue.value, initialValue)) {
        isResettingField = true;
      }

      computedValue.value = initialValue;
      await (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      clearValidate();
    };

    const addInputId = id => {
      if (!inputIds.value.includes(id)) {
        inputIds.value.push(id);
      }
    };

    const removeInputId = id => {
      inputIds.value = inputIds.value.filter(listId => listId !== id);
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.error, val => {
      validateMessage.value = val || "";
      setValidationState(val ? "error" : "");
    }, {
      immediate: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.validateStatus, val => setValidationState(val || ""));
    const context = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({ ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(props),
      $el: formItemRef,
      size: _size,
      validateState,
      labelId,
      inputIds,
      isGroup,
      addInputId,
      removeInputId,
      resetField,
      clearValidate,
      validate
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(formItemContextKey, context);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.prop) {
        formContext == null ? void 0 : formContext.addField(context);
        initialValue = lodash_es_clone(fieldValue.value);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      formContext == null ? void 0 : formContext.removeField(context);
    });
    expose({
      size: _size,
      validateMessage,
      validateState,
      validate,
      clearValidate,
      resetField
    });
    return (_ctx, _cache) => {
      var _a;

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
        ref_key: "formItemRef",
        ref: formItemRef,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(formItemClasses)),
        role: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(isGroup) ? "group" : void 0,
        "aria-labelledby": (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(isGroup) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(labelId) : void 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(FormLabelWrap), {
        "is-auto-width": (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(labelStyle).width === "auto",
        "update-all": ((_a = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(formContext)) == null ? void 0 : _a.labelWidth) === "auto"
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(hasLabel) ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(labelFor) ? "label" : "div"), {
          key: 0,
          id: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(labelId),
          for: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(labelFor),
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("label")),
          style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(labelStyle))
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "label", {
            label: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(currentLabel)
          }, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(currentLabel)), 1)])]),
          _: 3
        }, 8, ["id", "for", "class", "style"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
        _: 3
      }, 8, ["is-auto-width", "update-all"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).e("content")),
        style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(contentStyle))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default"), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
        name: `${(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(ns).namespace.value}-zoom-in-top`
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(shouldShowError) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "error", {
          key: 0,
          error: validateMessage.value
        }, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(validateClasses))
        }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(validateMessage.value), 3)]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
        _: 3
      }, 8, ["name"])], 6)], 10, form_item4_hoisted_1);
    };
  }

});

var FormItem = /* @__PURE__ */_export_sfc(form_item4_sfc_main, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/index2.mjs







const ElForm = withInstall(Form, {
  FormItem: FormItem
});
const ElFormItem = withNoopInstall(FormItem);

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-form.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form/style/css.mjs

// EXTERNAL MODULE: ./node_modules/dayjs/plugin/customParseFormat.js
var customParseFormat = __webpack_require__(4032);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/advancedFormat.js
var advancedFormat = __webpack_require__(9840);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/localeData.js
var localeData = __webpack_require__(4427);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/weekOfYear.js
var weekOfYear = __webpack_require__(6611);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/weekYear.js
var weekYear = __webpack_require__(9053);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/dayOfYear.js
var dayOfYear = __webpack_require__(6295);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/isSameOrAfter.js
var isSameOrAfter = __webpack_require__(5929);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/isSameOrBefore.js
var isSameOrBefore = __webpack_require__(5444);
;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker.type2.mjs
const ROOT_PICKER_INJECTION_KEY = Symbol();

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-cell-render2.mjs




var ElDatePickerCell = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElDatePickerCell",
  props: buildProps({
    cell: {
      type: definePropType(Object)
    }
  }),

  setup(props) {
    const picker = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(ROOT_PICKER_INJECTION_KEY);
    return () => {
      const cell = props.cell;

      if (picker == null ? void 0 : picker.ctx.slots.default) {
        const list = picker.ctx.slots.default(cell).filter(item => {
          return item.patchFlag !== -2 && item.type.toString() !== "Symbol(Comment)";
        });

        if (list.length) {
          return list;
        }
      }

      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("div", {
        class: "el-date-table-cell"
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)("span", {
        class: "el-date-table-cell__text"
      }, [cell == null ? void 0 : cell.text])]);
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/utils/arrays2.mjs


const unique = arr => [...new Set(arr)];

const arrays2_castArray = arr => {
  if (!arr && arr !== 0) return [];
  return Array.isArray(arr) ? arr : [arr];
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-date-table2.mjs









const basic_date_table2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  components: {
    ElDatePickerCell: ElDatePickerCell
  },
  props: {
    date: {
      type: Object
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    parsedValue: {
      type: [Object, Array]
    },
    selectionMode: {
      type: String,
      default: "day"
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],

  setup(props, ctx) {
    const {
      t,
      lang
    } = useLocale();
    const lastRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const lastColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const tableRows = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([[], [], [], [], [], []]);
    const firstDayOfWeek = props.date.$locale().weekStart || 7;
    const WEEKS_CONSTANT = props.date.locale("en").localeData().weekdaysShort().map(_ => _.toLowerCase());
    const offsetDay = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });
    const startDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const startDayOfMonth = props.date.startOf("month");
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
    });
    const WEEKS = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    const rows = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      const startOfMonth = props.date.startOf("month");
      const startOfMonthDay = startOfMonth.day() || 7;
      const dateCountOfMonth = startOfMonth.daysInMonth();
      const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
      const offset = offsetDay.value;
      const rows_ = tableRows.value;
      let count = 1;
      const selectedDate = props.selectionMode === "dates" ? arrays2_castArray(props.parsedValue) : [];
      const calNow = dayjs_min().locale(lang.value).startOf("day");

      for (let i = 0; i < 6; i++) {
        const row = rows_[i];

        if (props.showWeekNumber) {
          if (!row[0]) {
            row[0] = {
              type: "week",
              text: startDate.value.add(i * 7 + 1, "day").week()
            };
          }
        }

        for (let j = 0; j < 7; j++) {
          let cell = row[props.showWeekNumber ? j + 1 : j];

          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }

          const index = i * 7 + j;
          const calTime = startDate.value.add(index - offset, "day");
          cell.dayjs = calTime;
          cell.date = calTime.toDate();
          cell.timestamp = calTime.valueOf();
          cell.type = "normal";
          const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate;
          cell.inRange = props.minDate && calTime.isSameOrAfter(props.minDate, "day") && calEndDate && calTime.isSameOrBefore(calEndDate, "day") || props.minDate && calTime.isSameOrBefore(props.minDate, "day") && calEndDate && calTime.isSameOrAfter(calEndDate, "day");

          if ((_a = props.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "day");
            cell.end = props.minDate && calTime.isSame(props.minDate, "day");
          } else {
            cell.start = props.minDate && calTime.isSame(props.minDate, "day");
            cell.end = calEndDate && calTime.isSame(calEndDate, "day");
          }

          const isToday = calTime.isSame(calNow, "day");

          if (isToday) {
            cell.type = "today";
          }

          if (i >= 0 && i <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset < 0 ? 7 + startOfMonthDay + offset : startOfMonthDay + offset;

            if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count++;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count++;
            } else {
              cell.text = count++ - dateCountOfMonth;
              cell.type = "next-month";
            }
          }

          const cellDate = calTime.toDate();
          cell.selected = selectedDate.find(_ => _.valueOf() === calTime.valueOf());
          cell.isSelected = !!cell.selected;
          cell.isCurrent = isCurrent(cell);
          cell.disabled = props.disabledDate && props.disabledDate(cellDate);
          cell.customClass = props.cellClassName && props.cellClassName(cellDate);
          row[props.showWeekNumber ? j + 1 : j] = cell;
        }

        if (props.selectionMode === "week") {
          const start = props.showWeekNumber ? 1 : 0;
          const end = props.showWeekNumber ? 7 : 6;
          const isActive = isWeekActive(row[start + 1]);
          row[start].inRange = isActive;
          row[start].start = isActive;
          row[end].inRange = isActive;
          row[end].end = isActive;
        }
      }

      return rows_;
    });

    const isCurrent = cell => {
      return props.selectionMode === "day" && (cell.type === "normal" || cell.type === "today") && cellMatchesDate(cell, props.parsedValue);
    };

    const cellMatchesDate = (cell, date) => {
      if (!date) return false;
      return dayjs_min(date).locale(lang.value).isSame(props.date.date(Number(cell.text)), "day");
    };

    const getCellClasses = cell => {
      const classes = [];

      if ((cell.type === "normal" || cell.type === "today") && !cell.disabled) {
        classes.push("available");

        if (cell.type === "today") {
          classes.push("today");
        }
      } else {
        classes.push(cell.type);
      }

      if (isCurrent(cell)) {
        classes.push("current");
      }

      if (cell.inRange && (cell.type === "normal" || cell.type === "today" || props.selectionMode === "week")) {
        classes.push("in-range");

        if (cell.start) {
          classes.push("start-date");
        }

        if (cell.end) {
          classes.push("end-date");
        }
      }

      if (cell.disabled) {
        classes.push("disabled");
      }

      if (cell.selected) {
        classes.push("selected");
      }

      if (cell.customClass) {
        classes.push(cell.customClass);
      }

      return classes.join(" ");
    };

    const getDateOfCell = (row, column) => {
      const offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, "day");
    };

    const handleMouseMove = event => {
      if (!props.rangeState.selecting) return;
      let target = event.target;

      if (target.tagName === "SPAN") {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === "DIV") {
        target = target.parentNode;
      }

      if (target.tagName !== "TD") return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled) return;

      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit("changerange", {
          selecting: true,
          endDate: getDateOfCell(row, column)
        });
      }
    };

    const handleClick = event => {
      let target = event.target;

      while (target) {
        if (target.tagName === "TD") {
          break;
        }

        target = target.parentNode;
      }

      if (!target || target.tagName !== "TD") return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      const cell = rows.value[row][column];
      if (cell.disabled || cell.type === "week") return;
      const newDate = getDateOfCell(row, column);

      if (props.selectionMode === "range") {
        if (!props.rangeState.selecting) {
          ctx.emit("pick", {
            minDate: newDate,
            maxDate: null
          });
          ctx.emit("select", true);
        } else {
          if (newDate >= props.minDate) {
            ctx.emit("pick", {
              minDate: props.minDate,
              maxDate: newDate
            });
          } else {
            ctx.emit("pick", {
              minDate: newDate,
              maxDate: props.minDate
            });
          }

          ctx.emit("select", false);
        }
      } else if (props.selectionMode === "day") {
        ctx.emit("pick", newDate);
      } else if (props.selectionMode === "week") {
        const weekNumber = newDate.week();
        const value = `${newDate.year()}w${weekNumber}`;
        ctx.emit("pick", {
          year: newDate.year(),
          week: weekNumber,
          value,
          date: newDate.startOf("week")
        });
      } else if (props.selectionMode === "dates") {
        const newValue = cell.selected ? arrays2_castArray(props.parsedValue).filter(_ => _.valueOf() !== newDate.valueOf()) : arrays2_castArray(props.parsedValue).concat([newDate]);
        ctx.emit("pick", newValue);
      }
    };

    const isWeekActive = cell => {
      if (props.selectionMode !== "week") return false;
      let newDate = props.date.startOf("day");

      if (cell.type === "prev-month") {
        newDate = newDate.subtract(1, "month");
      }

      if (cell.type === "next-month") {
        newDate = newDate.add(1, "month");
      }

      newDate = newDate.date(Number.parseInt(cell.text, 10));

      if (props.parsedValue && !Array.isArray(props.parsedValue)) {
        const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        const weekDate = props.parsedValue.subtract(dayOffset, "day");
        return weekDate.isSame(newDate, "day");
      }

      return false;
    };

    return {
      handleMouseMove,
      t,
      rows,
      isWeekActive,
      getCellClasses,
      WEEKS,
      handleClick
    };
  }

});

const basic_date_table2_hoisted_1 = {
  key: 0
};

function basic_date_table2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker_cell = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-date-picker-cell");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("table", {
    cellspacing: "0",
    cellpadding: "0",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-date-table", {
      "is-week-mode": _ctx.selectionMode === "week"
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tbody", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tr", null, [_ctx.showWeekNumber ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("th", basic_date_table2_hoisted_1, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.week")), 1)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.WEEKS, (week, key) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("th", {
      key
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.weeks." + week)), 1);
  }), 128))]), ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.rows, (row, key) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("tr", {
      key,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-date-table__row", {
        current: _ctx.isWeekActive(row[1])
      }])
    }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(row, (cell, key_) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("td", {
        key: key_,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.getCellClasses(cell))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_date_picker_cell, {
        cell
      }, null, 8, ["cell"])], 2);
    }), 128))], 2);
  }), 128))])], 34);
}

var DateTable = /* @__PURE__ */_export_sfc(basic_date_table2_sfc_main, [["render", basic_date_table2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/common/date-utils2.mjs
const rangeArr = n => Array.from(Array.from({
  length: n
}).keys());

const extractDateFormat = format => {
  return format.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};

const extractTimeFormat = format => {
  return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-month-table2.mjs











const datesInMonth = (year, month, lang) => {
  const firstDay = dayjs_min().locale(lang).startOf("month").month(month).year(year);
  const numOfDays = firstDay.daysInMonth();
  return rangeArr(numOfDays).map(n => firstDay.add(n, "day").toDate());
};

const basic_month_table2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    disabledDate: {
      type: Function
    },
    selectionMode: {
      type: String,
      default: "month"
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    date: {
      type: Object
    },
    parsedValue: {
      type: Object
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],

  setup(props, ctx) {
    const {
      t,
      lang
    } = useLocale();
    const months = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(props.date.locale("en").localeData().monthsShort().map(_ => _.toLowerCase()));
    const tableRows = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([[], [], []]);
    const lastRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const lastColumn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const rows = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      const rows2 = tableRows.value;
      const now = dayjs_min().locale(lang.value).startOf("month");

      for (let i = 0; i < 3; i++) {
        const row = rows2[i];

        for (let j = 0; j < 4; j++) {
          let cell = row[j];

          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }

          cell.type = "normal";
          const index = i * 4 + j;
          const calTime = props.date.startOf("year").month(index);
          const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate;
          cell.inRange = props.minDate && calTime.isSameOrAfter(props.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month") || props.minDate && calTime.isSameOrBefore(props.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month");

          if ((_a = props.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "month");
            cell.end = props.minDate && calTime.isSame(props.minDate, "month");
          } else {
            cell.start = props.minDate && calTime.isSame(props.minDate, "month");
            cell.end = calEndDate && calTime.isSame(calEndDate, "month");
          }

          const isToday = now.isSame(calTime);

          if (isToday) {
            cell.type = "today";
          }

          cell.text = index;
          const cellDate = calTime.toDate();
          cell.disabled = props.disabledDate && props.disabledDate(cellDate);
          row[j] = cell;
        }
      }

      return rows2;
    });

    const getCellStyle = cell => {
      const style = {};
      const year = props.date.year();
      const today = new Date();
      const month = cell.text;
      style.disabled = props.disabledDate ? datesInMonth(year, month, lang.value).every(props.disabledDate) : false;
      style.current = arrays2_castArray(props.parsedValue).findIndex(date => date.year() === year && date.month() === month) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;

      if (cell.inRange) {
        style["in-range"] = true;

        if (cell.start) {
          style["start-date"] = true;
        }

        if (cell.end) {
          style["end-date"] = true;
        }
      }

      return style;
    };

    const handleMouseMove = event => {
      if (!props.rangeState.selecting) return;
      let target = event.target;

      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === "DIV") {
        target = target.parentNode;
      }

      if (target.tagName !== "TD") return;
      const row = target.parentNode.rowIndex;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled) return;

      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit("changerange", {
          selecting: true,
          endDate: props.date.startOf("year").month(row * 4 + column)
        });
      }
    };

    const handleMonthTableClick = event => {
      let target = event.target;

      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === "DIV") {
        target = target.parentNode;
      }

      if (target.tagName !== "TD") return;
      if (hasClass(target, "disabled")) return;
      const column = target.cellIndex;
      const row = target.parentNode.rowIndex;
      const month = row * 4 + column;
      const newDate = props.date.startOf("year").month(month);

      if (props.selectionMode === "range") {
        if (!props.rangeState.selecting) {
          ctx.emit("pick", {
            minDate: newDate,
            maxDate: null
          });
          ctx.emit("select", true);
        } else {
          if (newDate >= props.minDate) {
            ctx.emit("pick", {
              minDate: props.minDate,
              maxDate: newDate
            });
          } else {
            ctx.emit("pick", {
              minDate: newDate,
              maxDate: props.minDate
            });
          }

          ctx.emit("select", false);
        }
      } else {
        ctx.emit("pick", month);
      }
    };

    return {
      handleMouseMove,
      handleMonthTableClick,
      rows,
      getCellStyle,
      t,
      months
    };
  }

});

const basic_month_table2_hoisted_1 = {
  class: "cell"
};

function basic_month_table2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("table", {
    class: "el-month-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMonthTableClick && _ctx.handleMonthTableClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tbody", null, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.rows, (row, key) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("tr", {
      key
    }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(row, (cell, key_) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("td", {
        key: key_,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.getCellStyle(cell))
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_month_table2_hoisted_1, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.months." + _ctx.months[cell.text])), 1)])], 2);
    }), 128))]);
  }), 128))])], 32);
}

var MonthTable = /* @__PURE__ */_export_sfc(basic_month_table2_sfc_main, [["render", basic_month_table2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/basic-year-table2.mjs











const datesInYear = (year, lang) => {
  const firstDay = dayjs_min(String(year)).locale(lang).startOf("year");
  const lastDay = firstDay.endOf("year");
  const numOfDays = lastDay.dayOfYear();
  return rangeArr(numOfDays).map(n => firstDay.add(n, "day").toDate());
};

const basic_year_table2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  props: {
    disabledDate: {
      type: Function
    },
    parsedValue: {
      type: Object
    },
    date: {
      type: Object
    }
  },
  emits: ["pick"],

  setup(props, ctx) {
    const {
      lang
    } = useLocale();
    const startYear = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Math.floor(props.date.year() / 10) * 10;
    });

    const getCellStyle = year => {
      const style = {};
      const today = dayjs_min().locale(lang.value);
      style.disabled = props.disabledDate ? datesInYear(year, lang.value).every(props.disabledDate) : false;
      style.current = arrays2_castArray(props.parsedValue).findIndex(_ => _.year() === year) >= 0;
      style.today = today.year() === year;
      return style;
    };

    const handleYearTableClick = event => {
      const target = event.target;

      if (target.tagName === "A") {
        if (hasClass(target.parentNode, "disabled")) return;
        const year = target.textContent || target.innerText;
        ctx.emit("pick", Number(year));
      }
    };

    return {
      startYear,
      getCellStyle,
      handleYearTableClick
    };
  }

});

const basic_year_table2_hoisted_1 = {
  class: "cell"
};
const basic_year_table2_hoisted_2 = {
  class: "cell"
};
const basic_year_table2_hoisted_3 = {
  class: "cell"
};
const basic_year_table2_hoisted_4 = {
  class: "cell"
};
const basic_year_table2_hoisted_5 = {
  class: "cell"
};
const basic_year_table2_hoisted_6 = {
  class: "cell"
};
const basic_year_table2_hoisted_7 = {
  class: "cell"
};
const basic_year_table2_hoisted_8 = {
  class: "cell"
};
const basic_year_table2_hoisted_9 = {
  class: "cell"
};
const basic_year_table2_hoisted_10 = {
  class: "cell"
};

const basic_year_table2_hoisted_11 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", null, null, -1);

const basic_year_table2_hoisted_12 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", null, null, -1);

function basic_year_table2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("table", {
    class: "el-year-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleYearTableClick && _ctx.handleYearTableClick(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tbody", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tr", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 0)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_1, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 1)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_2, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 1), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 2)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_3, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 2), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 3)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_4, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 3), 1)], 2)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tr", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 4)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_5, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 4), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 5)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_6, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 5), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 6)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_7, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 6), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 7)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_8, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 7), 1)], 2)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("tr", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 8)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_9, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 8), 1)], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("td", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["available", _ctx.getCellStyle(_ctx.startYear + 9)])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", basic_year_table2_hoisted_10, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.startYear + 9), 1)], 2), basic_year_table2_hoisted_11, basic_year_table2_hoisted_12])])]);
}

var YearTable = /* @__PURE__ */_export_sfc(basic_year_table2_sfc_main, [["render", basic_year_table2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/time-picker-com/useTimePicker2.mjs


const makeList = (total, method, methodFunc) => {
  const arr = [];
  const disabledArr = method && methodFunc();

  for (let i = 0; i < total; i++) {
    arr[i] = disabledArr ? disabledArr.includes(i) : false;
  }

  return arr;
};

const makeAvailableArr = list => {
  return list.map((_, index) => !_ ? index : _).filter(_ => _ !== true);
};

const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare) => {
    return makeList(24, disabledHours, () => disabledHours(role, compare));
  };

  const getMinutesList = (hour, role, compare) => {
    return makeList(60, disabledMinutes, () => disabledMinutes(hour, role, compare));
  };

  const getSecondsList = (hour, minute, role, compare) => {
    return makeList(60, disabledSeconds, () => disabledSeconds(hour, minute, role, compare));
  };

  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};

const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds) => {
  const {
    getHoursList,
    getMinutesList,
    getSecondsList
  } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);

  const getAvailableHours = (role, compare) => {
    return makeAvailableArr(getHoursList(role, compare));
  };

  const getAvailableMinutes = (hour, role, compare) => {
    return makeAvailableArr(getMinutesList(hour, role, compare));
  };

  const getAvailableSeconds = (hour, minute, role, compare) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare));
  };

  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};

const useOldValue = props => {
  const oldValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(props.parsedValue);
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.visible, val => {
    if (!val) {
      oldValue.value = props.parsedValue;
    }
  });
  return oldValue;
};


;// CONCATENATED MODULE: ./node_modules/element-plus/es/directives/repeat-click/index2.mjs


var RepeatClick = {
  beforeMount(el, binding) {
    let interval = null;
    let startTime;

    const handler = () => binding.value && binding.value();

    const clear = () => {
      if (Date.now() - startTime < 100) {
        handler();
      }

      clearInterval(interval);
      interval = null;
    };

    event2_on(el, "mousedown", e => {
      if (e.button !== 0) return;
      startTime = Date.now();
      once(document, "mouseup", clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }

};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/time-picker-com/basic-time-spinner2.mjs












const basic_time_spinner2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  directives: {
    repeatClick: RepeatClick
  },
  components: {
    ElScrollbar: ElScrollbar,
    ElIcon: ElIcon,
    ArrowUp: arrowUp,
    ArrowDown: arrowDown
  },
  props: {
    role: {
      type: String,
      required: true
    },
    spinnerDate: {
      type: Object,
      required: true
    },
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: Boolean,
    amPmMode: {
      type: String,
      default: ""
    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    }
  },
  emits: ["change", "select-range", "set-option"],

  setup(props, ctx) {
    const ns = useNamespace("time");
    let isScrolling = false;
    const debouncedResetScroll = lodash_es_debounce(type => {
      isScrolling = false;
      adjustCurrentSpinner(type);
    }, 200);
    const currentScrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const listHoursRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const listMinutesRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const listSecondsRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    };
    const spinnerItems = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const arr = ["hours", "minutes", "seconds"];
      return props.showSeconds ? arr : arr.slice(0, 2);
    });
    const hours = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.spinnerDate.hour();
    });
    const minutes = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.spinnerDate.minute();
    });
    const seconds = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.spinnerDate.second();
    });
    const timePartsMap = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ({
      hours,
      minutes,
      seconds
    }));
    const hoursList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getHoursList(props.role);
    });
    const minutesList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getMinutesList(hours.value, props.role);
    });
    const secondsList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getSecondsList(hours.value, minutes.value, props.role);
    });
    const listMap = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ({
      hours: hoursList,
      minutes: minutesList,
      seconds: secondsList
    }));
    const arrowHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const hour = hours.value;
      return [hour > 0 ? hour - 1 : void 0, hour, hour < 23 ? hour + 1 : void 0];
    });
    const arrowMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minute = minutes.value;
      return [minute > 0 ? minute - 1 : void 0, minute, minute < 59 ? minute + 1 : void 0];
    });
    const arrowSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const second = seconds.value;
      return [second > 0 ? second - 1 : void 0, second, second < 59 ? second + 1 : void 0];
    });
    const arrowListMap = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => ({
      hours: arrowHourList,
      minutes: arrowMinuteList,
      seconds: arrowSecondList
    }));

    const getAmPmFlag = hour => {
      const shouldShowAmPm = !!props.amPmMode;
      if (!shouldShowAmPm) return "";
      const isCapital = props.amPmMode === "A";
      let content = hour < 12 ? " am" : " pm";
      if (isCapital) content = content.toUpperCase();
      return content;
    };

    const emitSelectRange = type => {
      if (type === "hours") {
        ctx.emit("select-range", 0, 2);
      } else if (type === "minutes") {
        ctx.emit("select-range", 3, 5);
      } else if (type === "seconds") {
        ctx.emit("select-range", 6, 8);
      }

      currentScrollbar.value = type;
    };

    const adjustCurrentSpinner = type => {
      adjustSpinner(type, timePartsMap.value[type].value);
    };

    const adjustSpinners = () => {
      adjustCurrentSpinner("hours");
      adjustCurrentSpinner("minutes");
      adjustCurrentSpinner("seconds");
    };

    const getScrollbarElement = el => el.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);

    const adjustSpinner = (type, value) => {
      if (props.arrowControl) return;
      const el = listRefsMap[type];

      if (el && el.$el) {
        getScrollbarElement(el.$el).scrollTop = Math.max(0, value * typeItemHeight(type));
      }
    };

    const typeItemHeight = type => {
      const el = listRefsMap[type];
      return el.$el.querySelector("li").offsetHeight;
    };

    const onIncreaseClick = () => {
      scrollDown(1);
    };

    const onDecreaseClick = () => {
      scrollDown(-1);
    };

    const scrollDown = step => {
      if (!currentScrollbar.value) {
        emitSelectRange("hours");
      }

      const label = currentScrollbar.value;
      let now = timePartsMap.value[label].value;
      const total = currentScrollbar.value === "hours" ? 24 : 60;
      now = (now + step + total) % total;
      modifyDateField(label, now);
      adjustSpinner(label, now);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => emitSelectRange(currentScrollbar.value));
    };

    const modifyDateField = (type, value) => {
      const list = listMap.value[type].value;
      const isDisabled = list[value];
      if (isDisabled) return;

      switch (type) {
        case "hours":
          ctx.emit("change", props.spinnerDate.hour(value).minute(minutes.value).second(seconds.value));
          break;

        case "minutes":
          ctx.emit("change", props.spinnerDate.hour(hours.value).minute(value).second(seconds.value));
          break;

        case "seconds":
          ctx.emit("change", props.spinnerDate.hour(hours.value).minute(minutes.value).second(value));
          break;
      }
    };

    const handleClick = (type, {
      value,
      disabled
    }) => {
      if (!disabled) {
        modifyDateField(type, value);
        emitSelectRange(type);
        adjustSpinner(type, value);
      }
    };

    const handleScroll = type => {
      isScrolling = true;
      debouncedResetScroll(type);
      const value = Math.min(Math.round((getScrollbarElement(listRefsMap[type].$el).scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
      modifyDateField(type, value);
    };

    const scrollBarHeight = type => {
      return listRefsMap[type].$el.offsetHeight;
    };

    const bindScrollEvent = () => {
      const bindFunction = type => {
        if (listRefsMap[type] && listRefsMap[type].$el) {
          getScrollbarElement(listRefsMap[type].$el).onscroll = () => {
            handleScroll(type);
          };
        }
      };

      bindFunction("hours");
      bindFunction("minutes");
      bindFunction("seconds");
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        !props.arrowControl && bindScrollEvent();
        adjustSpinners();
        if (props.role === "start") emitSelectRange("hours");
      });
    });

    const setRef = (scrollbar, type) => {
      listRefsMap[type] = scrollbar;
    };

    ctx.emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
    ctx.emit("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
    const {
      getHoursList,
      getMinutesList,
      getSecondsList
    } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.spinnerDate, () => {
      if (isScrolling) return;
      adjustSpinners();
    });
    return {
      ns,
      setRef,
      spinnerItems,
      currentScrollbar,
      hours,
      minutes,
      seconds,
      hoursList,
      minutesList,
      arrowHourList,
      arrowMinuteList,
      arrowSecondList,
      getAmPmFlag,
      emitSelectRange,
      adjustCurrentSpinner,
      typeItemHeight,
      listHoursRef,
      listMinutesRef,
      listSecondsRef,
      onIncreaseClick,
      onDecreaseClick,
      handleClick,
      secondsList,
      timePartsMap,
      arrowListMap,
      listMap
    };
  }

});

const basic_time_spinner2_hoisted_1 = ["onClick"];
const basic_time_spinner2_hoisted_2 = ["onMouseenter"];

function basic_time_spinner2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-scrollbar");

  const _component_arrow_up = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-up");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_arrow_down = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-down");

  const _directive_repeat_click = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDirective)("repeat-click");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.b("spinner"), {
      "has-seconds": _ctx.showSeconds
    }])
  }, [!_ctx.arrowControl ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
    key: 0
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.spinnerItems, item => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_scrollbar, {
      key: item,
      ref_for: true,
      ref: scollbar => _ctx.setRef(scollbar, item),
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("spinner", "wrapper")),
      "wrap-style": "max-height: inherit;",
      "view-class": _ctx.ns.be("spinner", "list"),
      noresize: "",
      tag: "ul",
      onMouseenter: $event => _ctx.emitSelectRange(item),
      onMousemove: $event => _ctx.adjustCurrentSpinner(item)
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.listMap[item].value, (disabled, key) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
          key,
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("spinner", "item"), _ctx.ns.is("active", key === _ctx.timePartsMap[item].value), _ctx.ns.is("disabled", disabled)]),
          onClick: $event => _ctx.handleClick(item, {
            value: key,
            disabled
          })
        }, [item === "hours" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
          key: 0
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.getAmPmFlag(key)), 1)], 2112)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
          key: 1
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(("0" + key).slice(-2)), 1)], 2112))], 10, basic_time_spinner2_hoisted_1);
      }), 128))]),
      _: 2
    }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
  }), 128)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.arrowControl ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
    key: 1
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.spinnerItems, item => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: item,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("spinner", "wrapper"), _ctx.ns.is("arrow")]),
      onMouseenter: $event => _ctx.emitSelectRange(item)
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["arrow-up", _ctx.ns.be("spinner", "arrow")])
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_up)]),
      _: 1
    }, 8, ["class"])), [[_directive_repeat_click, _ctx.onDecreaseClick]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["arrow-down", _ctx.ns.be("spinner", "arrow")])
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_down)]),
      _: 1
    }, 8, ["class"])), [[_directive_repeat_click, _ctx.onIncreaseClick]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("ul", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("spinner", "list"))
    }, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.arrowListMap[item].value, (time, key) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("li", {
        key,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("spinner", "item"), _ctx.ns.is("active", time === _ctx.timePartsMap[item].value), _ctx.ns.is("disabled", _ctx.listMap[item].value[time])])
      }, [typeof time === "number" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [item === "hours" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.getAmPmFlag(time)), 1)], 2112)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, {
        key: 1
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(("0" + time).slice(-2)), 1)], 2112))], 2112)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2);
    }), 128))], 2)], 42, basic_time_spinner2_hoisted_2);
  }), 128)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2);
}

var TimeSpinner = /* @__PURE__ */_export_sfc(basic_time_spinner2_sfc_main, [["render", basic_time_spinner2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/time-picker-com/panel-time-pick2.mjs













const panel_time_pick2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  components: {
    TimeSpinner: TimeSpinner
  },
  props: {
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: void 0
    },
    datetimeRole: {
      type: String
    },
    parsedValue: {
      type: [Object, String]
    },
    format: {
      type: String,
      default: ""
    }
  },
  emits: ["pick", "select-range", "set-picker-option"],

  setup(props, ctx) {
    const ns = useNamespace("time");
    const {
      t,
      lang
    } = useLocale();
    const selectionRange = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([0, 2]);
    const oldValue = useOldValue(props);
    const transitionName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return isUndefined(props.actualVisible) ? `${ns.namespace.value}-zoom-in-top` : "";
    });
    const showSeconds = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.format.includes("ss");
    });
    const amPmMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (props.format.includes("A")) return "A";
      if (props.format.includes("a")) return "a";
      return "";
    });

    const isValidValue = _date => {
      const parsedDate = dayjs_min(_date).locale(lang.value);
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate.isSame(result);
    };

    const handleCancel = () => {
      ctx.emit("pick", oldValue.value, false);
    };

    const handleConfirm = (visible = false, first = false) => {
      if (first) return;
      ctx.emit("pick", props.parsedValue, visible);
    };

    const handleChange = _date => {
      if (!props.visible) {
        return;
      }

      const result = getRangeAvailableTime(_date).millisecond(0);
      ctx.emit("pick", result, true);
    };

    const setSelectionRange = (start, end) => {
      ctx.emit("select-range", start, end);
      selectionRange.value = [start, end];
    };

    const changeSelectionRange = step => {
      const list = [0, 3].concat(showSeconds.value ? [6] : []);
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index = list.indexOf(selectionRange.value[0]);
      const next = (index + step + list.length) % list.length;
      timePickerOptions["start_emitSelectRange"](mapping[next]);
    };

    const handleKeydown = event => {
      const code = event.code;

      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        const step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        const step = code === EVENT_CODE.up ? -1 : 1;
        timePickerOptions["start_scrollDown"](step);
        event.preventDefault();
        return;
      }
    };

    const getRangeAvailableTime = date => {
      const availableMap = {
        hour: getAvailableHours,
        minute: getAvailableMinutes,
        second: getAvailableSeconds
      };
      let result = date;
      ["hour", "minute", "second"].forEach(_ => {
        if (availableMap[_]) {
          let availableArr;
          const method = availableMap[_];

          if (_ === "minute") {
            availableArr = method(result.hour(), props.datetimeRole);
          } else if (_ === "second") {
            availableArr = method(result.hour(), result.minute(), props.datetimeRole);
          } else {
            availableArr = method(props.datetimeRole);
          }

          if (availableArr && availableArr.length && !availableArr.includes(result[_]())) {
            result = result[_](availableArr[0]);
          }
        }
      });
      return result;
    };

    const parseUserInput = value => {
      if (!value) return null;
      return dayjs_min(value, props.format).locale(lang.value);
    };

    const formatToString = value => {
      if (!value) return null;
      return value.format(props.format);
    };

    const getDefaultValue = () => {
      return dayjs_min(defaultValue).locale(lang.value);
    };

    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    ctx.emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
    ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
    const timePickerOptions = {};

    const onSetOption = e => {
      timePickerOptions[e[0]] = e[1];
    };

    const pickerBase = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue
    } = pickerBase.props;
    const {
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    } = getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
    return {
      ns,
      transitionName,
      arrowControl,
      onSetOption,
      t,
      handleConfirm,
      handleChange,
      setSelectionRange,
      amPmMode,
      showSeconds,
      handleCancel,
      disabledHours,
      disabledMinutes,
      disabledSeconds
    };
  }

});

function panel_time_pick2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("time-spinner");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Transition, {
    name: _ctx.transitionName
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.actualVisible || _ctx.visible ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 0,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.b("panel"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("panel", "content"), {
        "has-seconds": _ctx.showSeconds
      }])
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_time_spinner, {
      ref: "spinner",
      role: _ctx.datetimeRole || "start",
      "arrow-control": _ctx.arrowControl,
      "show-seconds": _ctx.showSeconds,
      "am-pm-mode": _ctx.amPmMode,
      "spinner-date": _ctx.parsedValue,
      "disabled-hours": _ctx.disabledHours,
      "disabled-minutes": _ctx.disabledMinutes,
      "disabled-seconds": _ctx.disabledSeconds,
      onChange: _ctx.handleChange,
      onSetOption: _ctx.onSetOption,
      onSelectRange: _ctx.setSelectionRange
    }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])], 2), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.ns.be("panel", "footer"))
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
      type: "button",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("panel", "btn"), "cancel"]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.cancel")), 3), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
      type: "button",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.ns.be("panel", "btn"), "confirm"]),
      onClick: _cache[1] || (_cache[1] = $event => _ctx.handleConfirm())
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.confirm")), 3)], 2)], 2)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
    _: 1
  }, 8, ["name"]);
}

var TimePickPanel = /* @__PURE__ */_export_sfc(panel_time_pick2_sfc_main, [["render", panel_time_pick2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-date-pick2.mjs
























const timeWithinRange = (_, __, ___) => true;

const panel_date_pick2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  components: {
    DateTable: DateTable,
    ElInput: ElInput,
    ElButton: ElButton,
    ElIcon: ElIcon,
    TimePickPanel: TimePickPanel,
    MonthTable: MonthTable,
    YearTable: YearTable,
    DArrowLeft: dArrowLeft,
    ArrowLeft: arrowLeft,
    DArrowRight: dArrowRight,
    ArrowRight: arrowRight
  },
  directives: {
    clickoutside: ClickOutside
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    parsedValue: {
      type: [Object, Array]
    },
    format: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option", "panel-change"],

  setup(props, ctx) {
    const {
      t,
      lang
    } = useLocale();
    const pickerBase = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)("EP_PICKER_BASE");
    const popper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(TOOLTIP_INJECTION_KEY);
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      defaultTime,
      arrowControl
    } = pickerBase.props;
    const defaultValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(pickerBase.props, "defaultValue");
    const innerDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(dayjs_min().locale(lang.value));
    const defaultTimeD = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return dayjs_min(defaultTime).locale(lang.value);
    });
    const month = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return innerDate.value.month();
    });
    const year = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return innerDate.value.year();
    });
    const selectableRange = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)([]);
    const userInputDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const userInputTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

    const checkDateWithinRange = date => {
      return selectableRange.value.length > 0 ? timeWithinRange(date, selectableRange.value, props.format || "HH:mm:ss") : true;
    };

    const formatEmit = emitDayjs => {
      if (defaultTime && !visibleTime.value) {
        return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }

      if (showTime.value) return emitDayjs.millisecond(0);
      return emitDayjs.startOf("day");
    };

    const emit = (value, ...args) => {
      if (!value) {
        ctx.emit("pick", value, ...args);
      } else if (Array.isArray(value)) {
        const dates = value.map(formatEmit);
        ctx.emit("pick", dates, ...args);
      } else {
        ctx.emit("pick", formatEmit(value), ...args);
      }

      userInputDate.value = null;
      userInputTime.value = null;
    };

    const handleDatePick = value => {
      if (selectionMode.value === "day") {
        let newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;

        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
        }

        innerDate.value = newDate;
        emit(newDate, showTime.value);
      } else if (selectionMode.value === "week") {
        emit(value.date);
      } else if (selectionMode.value === "dates") {
        emit(value, true);
      }
    };

    const prevMonth_ = () => {
      innerDate.value = innerDate.value.subtract(1, "month");
      handlePanelChange("month");
    };

    const nextMonth_ = () => {
      innerDate.value = innerDate.value.add(1, "month");
      handlePanelChange("month");
    };

    const prevYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.subtract(10, "year");
      } else {
        innerDate.value = innerDate.value.subtract(1, "year");
      }

      handlePanelChange("year");
    };

    const nextYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.add(10, "year");
      } else {
        innerDate.value = innerDate.value.add(1, "year");
      }

      handlePanelChange("year");
    };

    const currentView = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("date");
    const yearLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearTranslation = t("el.datepicker.year");

      if (currentView.value === "year") {
        const startYear = Math.floor(year.value / 10) * 10;

        if (yearTranslation) {
          return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
        }

        return `${startYear} - ${startYear + 9}`;
      }

      return `${year.value} ${yearTranslation}`;
    });

    const handleShortcutClick = shortcut => {
      const shortcutValue = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;

      if (shortcutValue) {
        emit(dayjs_min(shortcutValue).locale(lang.value));
        return;
      }

      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };

    const selectionMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (["week", "month", "year", "dates"].includes(props.type)) {
        return props.type;
      }

      return "day";
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => selectionMode.value, val => {
      if (["month", "year"].includes(val)) {
        currentView.value = val;
        return;
      }

      currentView.value = "date";
    }, {
      immediate: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => currentView.value, () => {
      popper == null ? void 0 : popper.updatePopper();
    });
    const hasShortcuts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !!shortcuts.length);

    const handleMonthPick = month2 => {
      innerDate.value = innerDate.value.startOf("month").month(month2);

      if (selectionMode.value === "month") {
        emit(innerDate.value);
      } else {
        currentView.value = "date";
      }

      handlePanelChange("month");
    };

    const handleYearPick = year2 => {
      if (selectionMode.value === "year") {
        innerDate.value = innerDate.value.startOf("year").year(year2);
        emit(innerDate.value);
      } else {
        innerDate.value = innerDate.value.year(year2);
        currentView.value = "month";
      }

      handlePanelChange("year");
    };

    const showMonthPicker = () => {
      currentView.value = "month";
    };

    const showYearPicker = () => {
      currentView.value = "year";
    };

    const showTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.type === "datetime" || props.type === "datetimerange");
    const footerVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return showTime.value || selectionMode.value === "dates";
    });

    const onConfirm = () => {
      if (selectionMode.value === "dates") {
        emit(props.parsedValue);
      } else {
        let result = props.parsedValue;

        if (!result) {
          const defaultTimeD2 = dayjs_min(defaultTime).locale(lang.value);
          const defaultValueD = getDefaultValue();
          result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }

        innerDate.value = result;
        emit(result);
      }
    };

    const changeToNow = () => {
      const now = dayjs_min().locale(lang.value);
      const nowDate = now.toDate();

      if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = dayjs_min().locale(lang.value);
        emit(innerDate.value);
      }
    };

    const timeFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return extractTimeFormat(props.format);
    });
    const dateFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return extractDateFormat(props.format);
    });
    const visibleTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (userInputTime.value) return userInputTime.value;
      if (!props.parsedValue && !defaultValue.value) return;
      return (props.parsedValue || innerDate.value).format(timeFormat.value);
    });
    const visibleDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (userInputDate.value) return userInputDate.value;
      if (!props.parsedValue && !defaultValue.value) return;
      return (props.parsedValue || innerDate.value).format(dateFormat.value);
    });
    const timePickerVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);

    const onTimePickerInputFocus = () => {
      timePickerVisible.value = true;
    };

    const handleTimePickClose = () => {
      timePickerVisible.value = false;
    };

    const handleTimePick = (value, visible, first) => {
      const newDate = props.parsedValue ? props.parsedValue.hour(value.hour()).minute(value.minute()).second(value.second()) : value;
      innerDate.value = newDate;
      emit(innerDate.value, true);

      if (!first) {
        timePickerVisible.value = visible;
      }
    };

    const handleVisibleTimeChange = value => {
      const newDate = dayjs_min(value, timeFormat.value).locale(lang.value);

      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit(innerDate.value, true);
      }
    };

    const handleVisibleDateChange = value => {
      const newDate = dayjs_min(value, dateFormat.value).locale(lang.value);

      if (newDate.isValid()) {
        if (disabledDate && disabledDate(newDate.toDate())) {
          return;
        }

        innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
        userInputDate.value = null;
        emit(innerDate.value, true);
      }
    };

    const isValidValue = date => {
      return dayjs_min.isDayjs(date) && date.isValid() && (disabledDate ? !disabledDate(date.toDate()) : true);
    };

    const formatToString = value => {
      if (selectionMode.value === "dates") {
        return value.map(_ => _.format(props.format));
      }

      return value.format(props.format);
    };

    const parseUserInput = value => {
      return dayjs_min(value, props.format).locale(lang.value);
    };

    const getDefaultValue = () => {
      const parseDate = dayjs_min(defaultValue.value).locale(lang.value);

      if (!defaultValue.value) {
        const defaultTimeDValue = defaultTimeD.value;
        return dayjs_min().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
      }

      return parseDate;
    };

    const handleKeydown = event => {
      const {
        code,
        keyCode
      } = event;
      const list = [EVENT_CODE.up, EVENT_CODE.down, EVENT_CODE.left, EVENT_CODE.right];

      if (props.visible && !timePickerVisible.value) {
        if (list.includes(code)) {
          handleKeyControl(keyCode);
          event.stopPropagation();
          event.preventDefault();
        }

        if (code === EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) {
          emit(innerDate, false);
        }
      }
    };

    const handleKeyControl = keyCode => {
      const mapping = {
        year: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date, step) => date.setFullYear(date.getFullYear() + step)
        },
        month: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date, step) => date.setMonth(date.getMonth() + step)
        },
        week: {
          38: -1,
          40: 1,
          37: -1,
          39: 1,
          offset: (date, step) => date.setDate(date.getDate() + step * 7)
        },
        day: {
          38: -7,
          40: 7,
          37: -1,
          39: 1,
          offset: (date, step) => date.setDate(date.getDate() + step)
        }
      };
      const newDate = innerDate.value.toDate();

      while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
        const map = mapping[selectionMode.value];
        map.offset(newDate, map[keyCode]);

        if (disabledDate && disabledDate(newDate)) {
          continue;
        }

        const result = dayjs_min(newDate).locale(lang.value);
        innerDate.value = result;
        ctx.emit("pick", result, true);
        break;
      }
    };

    const handlePanelChange = mode => {
      ctx.emit("panel-change", innerDate.value.toDate(), mode, currentView.value);
    };

    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => defaultValue.value, val => {
      if (val) {
        innerDate.value = getDefaultValue();
      }
    }, {
      immediate: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.parsedValue, val => {
      if (val) {
        if (selectionMode.value === "dates") return;
        if (Array.isArray(val)) return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue();
      }
    }, {
      immediate: true
    });
    return {
      handleTimePick,
      handleTimePickClose,
      onTimePickerInputFocus,
      timePickerVisible,
      visibleTime,
      visibleDate,
      showTime,
      changeToNow,
      onConfirm,
      footerVisible,
      handleYearPick,
      showMonthPicker,
      showYearPicker,
      handleMonthPick,
      hasShortcuts,
      shortcuts,
      arrowControl,
      disabledDate,
      cellClassName,
      selectionMode,
      handleShortcutClick,
      prevYear_,
      nextYear_,
      prevMonth_,
      nextMonth_,
      innerDate,
      t,
      yearLabel,
      currentView,
      month,
      handleDatePick,
      handleVisibleTimeChange,
      handleVisibleDateChange,
      timeFormat,
      userInputTime,
      userInputDate
    };
  }

});

const panel_date_pick2_hoisted_1 = {
  class: "el-picker-panel__body-wrapper"
};
const panel_date_pick2_hoisted_2 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const panel_date_pick2_hoisted_3 = ["onClick"];
const panel_date_pick2_hoisted_4 = {
  class: "el-picker-panel__body"
};
const panel_date_pick2_hoisted_5 = {
  key: 0,
  class: "el-date-picker__time-header"
};
const panel_date_pick2_hoisted_6 = {
  class: "el-date-picker__editor-wrap"
};
const panel_date_pick2_hoisted_7 = {
  class: "el-date-picker__editor-wrap"
};
const panel_date_pick2_hoisted_8 = ["aria-label"];
const panel_date_pick2_hoisted_9 = ["aria-label"];
const panel_date_pick2_hoisted_10 = ["aria-label"];
const panel_date_pick2_hoisted_11 = ["aria-label"];
const panel_date_pick2_hoisted_12 = {
  class: "el-picker-panel__content"
};
const panel_date_pick2_hoisted_13 = {
  class: "el-picker-panel__footer"
};

function panel_date_pick2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-input");

  const _component_time_pick_panel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("time-pick-panel");

  const _component_d_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-left");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-left");

  const _component_d_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-right");

  const _component_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-right");

  const _component_date_table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("date-table");

  const _component_year_table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("year-table");

  const _component_month_table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("month-table");

  const _component_el_button = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-button");

  const _directive_clickoutside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDirective)("clickoutside");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-picker-panel el-date-picker", [{
      "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
      "has-time": _ctx.showTime
    }]])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_pick2_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "sidebar", {
    class: "el-picker-panel__sidebar"
  }), _ctx.hasShortcuts ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", panel_date_pick2_hoisted_2, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.shortcuts, (shortcut, key) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
      key,
      type: "button",
      class: "el-picker-panel__shortcut",
      onClick: $event => _ctx.handleShortcutClick(shortcut)
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(shortcut.text), 9, panel_date_pick2_hoisted_3);
  }), 128))])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_pick2_hoisted_4, [_ctx.showTime ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", panel_date_pick2_hoisted_5, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", panel_date_pick2_hoisted_6, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    placeholder: _ctx.t("el.datepicker.selectDate"),
    "model-value": _ctx.visibleDate,
    size: "small",
    onInput: _cache[0] || (_cache[0] = val => _ctx.userInputDate = val),
    onChange: _ctx.handleVisibleDateChange
  }, null, 8, ["placeholder", "model-value", "onChange"])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", panel_date_pick2_hoisted_7, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    placeholder: _ctx.t("el.datepicker.selectTime"),
    "model-value": _ctx.visibleTime,
    size: "small",
    onFocus: _ctx.onTimePickerInputFocus,
    onInput: _cache[1] || (_cache[1] = val => _ctx.userInputTime = val),
    onChange: _ctx.handleVisibleTimeChange
  }, null, 8, ["placeholder", "model-value", "onFocus", "onChange"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_time_pick_panel, {
    visible: _ctx.timePickerVisible,
    format: _ctx.timeFormat,
    "time-arrow-control": _ctx.arrowControl,
    "parsed-value": _ctx.innerDate,
    onPick: _ctx.handleTimePick
  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])])), [[_directive_clickoutside, _ctx.handleTimePickClose]])])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-date-picker__header", {
      "el-date-picker__header--bordered": _ctx.currentView === "year" || _ctx.currentView === "month"
    }])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    "aria-label": _ctx.t(`el.datepicker.prevYear`),
    class: "el-picker-panel__icon-btn el-date-picker__prev-btn d-arrow-left",
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prevYear_ && _ctx.prevYear_(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_left)]),
    _: 1
  })], 8, panel_date_pick2_hoisted_8), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    "aria-label": _ctx.t(`el.datepicker.prevMonth`),
    class: "el-picker-panel__icon-btn el-date-picker__prev-btn arrow-left",
    onClick: _cache[3] || (_cache[3] = (...args) => _ctx.prevMonth_ && _ctx.prevMonth_(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_left)]),
    _: 1
  })], 8, panel_date_pick2_hoisted_9), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.currentView === "date"]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
    role: "button",
    class: "el-date-picker__header-label",
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showYearPicker && _ctx.showYearPicker(...args))
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.yearLabel), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
    role: "button",
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-date-picker__header-label", {
      active: _ctx.currentView === "month"
    }]),
    onClick: _cache[5] || (_cache[5] = (...args) => _ctx.showMonthPicker && _ctx.showMonthPicker(...args))
  }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t(`el.datepicker.month${_ctx.month + 1}`)), 3), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.currentView === "date"]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    "aria-label": _ctx.t(`el.datepicker.nextYear`),
    class: "el-picker-panel__icon-btn el-date-picker__next-btn d-arrow-right",
    onClick: _cache[6] || (_cache[6] = (...args) => _ctx.nextYear_ && _ctx.nextYear_(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_right)]),
    _: 1
  })], 8, panel_date_pick2_hoisted_10), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    "aria-label": _ctx.t(`el.datepicker.nextMonth`),
    class: "el-picker-panel__icon-btn el-date-picker__next-btn arrow-right",
    onClick: _cache[7] || (_cache[7] = (...args) => _ctx.nextMonth_ && _ctx.nextMonth_(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_right)]),
    _: 1
  })], 8, panel_date_pick2_hoisted_11), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.currentView === "date"]])], 2), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.currentView !== "time"]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_pick2_hoisted_12, [_ctx.currentView === "date" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_date_table, {
    key: 0,
    "selection-mode": _ctx.selectionMode,
    date: _ctx.innerDate,
    "parsed-value": _ctx.parsedValue,
    "disabled-date": _ctx.disabledDate,
    "cell-class-name": _ctx.cellClassName,
    onPick: _ctx.handleDatePick
  }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name", "onPick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.currentView === "year" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_year_table, {
    key: 1,
    date: _ctx.innerDate,
    "disabled-date": _ctx.disabledDate,
    "parsed-value": _ctx.parsedValue,
    onPick: _ctx.handleYearPick
  }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.currentView === "month" ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_month_table, {
    key: 2,
    date: _ctx.innerDate,
    "parsed-value": _ctx.parsedValue,
    "disabled-date": _ctx.disabledDate,
    onPick: _ctx.handleMonthPick
  }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_pick2_hoisted_13, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
    text: "",
    size: "small",
    class: "el-picker-panel__link-btn",
    onClick: _ctx.changeToNow
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.now")), 1)]),
    _: 1
  }, 8, ["onClick"]), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.selectionMode !== "dates"]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
    plain: "",
    size: "small",
    class: "el-picker-panel__link-btn",
    onClick: _ctx.onConfirm
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.confirm")), 1)]),
    _: 1
  }, 8, ["onClick"])], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.footerVisible && _ctx.currentView === "date"]])], 2);
}

var DatePickPanel = /* @__PURE__ */_export_sfc(panel_date_pick2_sfc_main, [["render", panel_date_pick2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-date-range2.mjs


















const panel_date_range2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  directives: {
    clickoutside: ClickOutside
  },
  components: {
    TimePickPanel: TimePickPanel,
    DateTable: DateTable,
    ElInput: ElInput,
    ElButton: ElButton,
    ElIcon: ElIcon,
    DArrowLeft: dArrowLeft,
    ArrowLeft: arrowLeft,
    DArrowRight: dArrowRight,
    ArrowRight: arrowRight
  },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option", "calendar-change", "panel-change"],

  setup(props, ctx) {
    const {
      t,
      lang
    } = useLocale();
    const leftDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(dayjs_min().locale(lang.value));
    const rightDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(dayjs_min().locale(lang.value).add(1, "month"));
    const minDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const maxDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const dateUserInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({
      min: null,
      max: null
    });
    const timeUserInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({
      min: null,
      max: null
    });
    const leftLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
    });
    const rightLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
    });
    const leftYear = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return leftDate.value.year();
    });
    const leftMonth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return leftDate.value.month();
    });
    const rightYear = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return rightDate.value.year();
    });
    const rightMonth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return rightDate.value.month();
    });
    const hasShortcuts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !!shortcuts.length);
    const minVisibleDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (dateUserInput.value.min !== null) return dateUserInput.value.min;
      if (minDate.value) return minDate.value.format(dateFormat.value);
      return "";
    });
    const maxVisibleDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (dateUserInput.value.max !== null) return dateUserInput.value.max;
      if (maxDate.value || minDate.value) return (maxDate.value || minDate.value).format(dateFormat.value);
      return "";
    });
    const minVisibleTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (timeUserInput.value.min !== null) return timeUserInput.value.min;
      if (minDate.value) return minDate.value.format(timeFormat.value);
      return "";
    });
    const maxVisibleTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (timeUserInput.value.max !== null) return timeUserInput.value.max;
      if (maxDate.value || minDate.value) return (maxDate.value || minDate.value).format(timeFormat.value);
      return "";
    });
    const timeFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return extractTimeFormat(format);
    });
    const dateFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return extractDateFormat(format);
    });

    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");

      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }

      handlePanelChange("year");
    };

    const leftPrevMonth = () => {
      leftDate.value = leftDate.value.subtract(1, "month");

      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }

      handlePanelChange("month");
    };

    const rightNextYear = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "year");
      }

      handlePanelChange("year");
    };

    const rightNextMonth = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "month");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "month");
      }

      handlePanelChange("month");
    };

    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
      handlePanelChange("year");
    };

    const leftNextMonth = () => {
      leftDate.value = leftDate.value.add(1, "month");
      handlePanelChange("month");
    };

    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
      handlePanelChange("year");
    };

    const rightPrevMonth = () => {
      rightDate.value = rightDate.value.subtract(1, "month");
      handlePanelChange("month");
    };

    const handlePanelChange = mode => {
      ctx.emit("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
    };

    const enableMonthArrow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nextMonth = (leftMonth.value + 1) % 12;
      const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    const enableYearArrow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });

    const isValidValue = value => {
      return Array.isArray(value) && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };

    const rangeState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({
      endDate: null,
      selecting: false
    });
    const btnDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([minDate.value, maxDate.value]));
    });

    const handleChangeRange = val => {
      rangeState.value = val;
    };

    const onSelect = selecting => {
      rangeState.value.selecting = selecting;

      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };

    const showTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.type === "datetime" || props.type === "datetimerange");

    const handleConfirm = (visible = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      }
    };

    const formatEmit = (emitDayjs, index) => {
      if (!emitDayjs) return;

      if (defaultTime) {
        const defaultTimeD = dayjs_min(defaultTime[index] || defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }

      return emitDayjs;
    };

    const handleRangePick = (val, close = true) => {
      const min_ = val.minDate;
      const max_ = val.maxDate;
      const minDate_ = formatEmit(min_, 0);
      const maxDate_ = formatEmit(max_, 1);

      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }

      ctx.emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close || showTime.value) return;
      handleConfirm();
    };

    const handleShortcutClick = shortcut => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;

      if (shortcutValues) {
        ctx.emit("pick", [dayjs_min(shortcutValues[0]).locale(lang.value), dayjs_min(shortcutValues[1]).locale(lang.value)]);
        return;
      }

      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };

    const minTimePickerVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const maxTimePickerVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);

    const handleMinTimeClose = () => {
      minTimePickerVisible.value = false;
    };

    const handleMaxTimeClose = () => {
      maxTimePickerVisible.value = false;
    };

    const handleDateInput = (value, type) => {
      dateUserInput.value[type] = value;
      const parsedValueD = dayjs_min(value, dateFormat.value).locale(lang.value);

      if (parsedValueD.isValid()) {
        if (disabledDate && disabledDate(parsedValueD.toDate())) {
          return;
        }

        if (type === "min") {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());

          if (!props.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, "month");
            maxDate.value = minDate.value.add(1, "month");
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());

          if (!props.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, "month");
            minDate.value = maxDate.value.subtract(1, "month");
          }
        }
      }
    };

    const handleDateChange = (_, type) => {
      dateUserInput.value[type] = null;
    };

    const handleTimeInput = (value, type) => {
      timeUserInput.value[type] = value;
      const parsedValueD = dayjs_min(value, timeFormat.value).locale(lang.value);

      if (parsedValueD.isValid()) {
        if (type === "min") {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());

          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;

          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };

    const handleTimeChange = (value, type) => {
      timeUserInput.value[type] = null;

      if (type === "min") {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };

    const handleMinTimePick = (value, visible, first) => {
      if (timeUserInput.value.min) return;

      if (value) {
        leftDate.value = value;
        minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }

      if (!first) {
        minTimePickerVisible.value = visible;
      }

      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
        rightDate.value = value;
      }
    };

    const handleMaxTimePick = (value, visible, first) => {
      if (timeUserInput.value.max) return;

      if (value) {
        rightDate.value = value;
        maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }

      if (!first) {
        maxTimePickerVisible.value = visible;
      }

      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };

    const handleClear = () => {
      leftDate.value = getDefaultValue()[0];
      rightDate.value = leftDate.value.add(1, "month");
      ctx.emit("pick", null);
    };

    const formatToString = value => {
      return Array.isArray(value) ? value.map(_ => _.format(format)) : value.format(format);
    };

    const parseUserInput = value => {
      return Array.isArray(value) ? value.map(_ => dayjs_min(_, format).locale(lang.value)) : dayjs_min(value, format).locale(lang.value);
    };

    const getDefaultValue = () => {
      let start;

      if (Array.isArray(defaultValue.value)) {
        const left = dayjs_min(defaultValue.value[0]);
        let right = dayjs_min(defaultValue.value[1]);

        if (!props.unlinkPanels) {
          right = left.add(1, "month");
        }

        return [left, right];
      } else if (defaultValue.value) {
        start = dayjs_min(defaultValue.value);
      } else {
        start = dayjs_min();
      }

      start = start.locale(lang.value);
      return [start, start.add(1, "month")];
    };

    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["handleClear", handleClear]);
    const pickerBase = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)("EP_PICKER_BASE");
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      format,
      defaultTime,
      arrowControl,
      clearable
    } = pickerBase.props;
    const defaultValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(pickerBase.props, "defaultValue");
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => defaultValue.value, val => {
      if (val) {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, {
      immediate: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.parsedValue, newVal => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;

        if (props.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const minDateMonth = minDate.value.month();
          const maxDateYear = maxDate.value.year();
          const maxDateMonth = maxDate.value.month();
          rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, "month") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "month");

          if (maxDate.value) {
            rightDate.value = rightDate.value.hour(maxDate.value.hour()).minute(maxDate.value.minute()).second(maxDate.value.second());
          }
        }
      } else {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, {
      immediate: true
    });
    return {
      shortcuts,
      disabledDate,
      cellClassName,
      minTimePickerVisible,
      maxTimePickerVisible,
      handleMinTimeClose,
      handleMaxTimeClose,
      handleShortcutClick,
      rangeState,
      minDate,
      maxDate,
      handleRangePick,
      onSelect,
      handleChangeRange,
      btnDisabled,
      enableYearArrow,
      enableMonthArrow,
      rightPrevMonth,
      rightPrevYear,
      rightNextMonth,
      rightNextYear,
      leftPrevMonth,
      leftPrevYear,
      leftNextMonth,
      leftNextYear,
      hasShortcuts,
      leftLabel,
      rightLabel,
      leftDate,
      rightDate,
      showTime,
      t,
      minVisibleDate,
      maxVisibleDate,
      minVisibleTime,
      maxVisibleTime,
      arrowControl,
      handleDateInput,
      handleDateChange,
      handleTimeInput,
      handleTimeChange,
      handleMinTimePick,
      handleMaxTimePick,
      handleClear,
      handleConfirm,
      timeFormat,
      clearable
    };
  }

});

const panel_date_range2_hoisted_1 = {
  class: "el-picker-panel__body-wrapper"
};
const panel_date_range2_hoisted_2 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const panel_date_range2_hoisted_3 = ["onClick"];
const panel_date_range2_hoisted_4 = {
  class: "el-picker-panel__body"
};
const panel_date_range2_hoisted_5 = {
  key: 0,
  class: "el-date-range-picker__time-header"
};
const panel_date_range2_hoisted_6 = {
  class: "el-date-range-picker__editors-wrap"
};
const panel_date_range2_hoisted_7 = {
  class: "el-date-range-picker__time-picker-wrap"
};
const panel_date_range2_hoisted_8 = {
  class: "el-date-range-picker__time-picker-wrap"
};
const panel_date_range2_hoisted_9 = {
  class: "el-date-range-picker__editors-wrap is-right"
};
const panel_date_range2_hoisted_10 = {
  class: "el-date-range-picker__time-picker-wrap"
};
const panel_date_range2_hoisted_11 = {
  class: "el-date-range-picker__time-picker-wrap"
};
const panel_date_range2_hoisted_12 = {
  class: "el-picker-panel__content el-date-range-picker__content is-left"
};
const panel_date_range2_hoisted_13 = {
  class: "el-date-range-picker__header"
};
const panel_date_range2_hoisted_14 = ["disabled"];
const panel_date_range2_hoisted_15 = ["disabled"];
const panel_date_range2_hoisted_16 = {
  class: "el-picker-panel__content el-date-range-picker__content is-right"
};
const panel_date_range2_hoisted_17 = {
  class: "el-date-range-picker__header"
};
const panel_date_range2_hoisted_18 = ["disabled"];
const panel_date_range2_hoisted_19 = ["disabled"];
const panel_date_range2_hoisted_20 = {
  key: 0,
  class: "el-picker-panel__footer"
};

function panel_date_range2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-input");

  const _component_time_pick_panel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("time-pick-panel");

  const _component_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-right");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_d_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-left");

  const _component_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("arrow-left");

  const _component_d_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-right");

  const _component_date_table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("date-table");

  const _component_el_button = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-button");

  const _directive_clickoutside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDirective)("clickoutside");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-picker-panel el-date-range-picker", [{
      "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
      "has-time": _ctx.showTime
    }]])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_range2_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "sidebar", {
    class: "el-picker-panel__sidebar"
  }), _ctx.hasShortcuts ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", panel_date_range2_hoisted_2, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.shortcuts, (shortcut, key) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
      key,
      type: "button",
      class: "el-picker-panel__shortcut",
      onClick: $event => _ctx.handleShortcutClick(shortcut)
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(shortcut.text), 9, panel_date_range2_hoisted_3);
  }), 128))])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_range2_hoisted_4, [_ctx.showTime ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", panel_date_range2_hoisted_5, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", panel_date_range2_hoisted_6, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", panel_date_range2_hoisted_7, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    size: "small",
    disabled: _ctx.rangeState.selecting,
    placeholder: _ctx.t("el.datepicker.startDate"),
    class: "el-date-range-picker__editor",
    "model-value": _ctx.minVisibleDate,
    onInput: _cache[0] || (_cache[0] = val => _ctx.handleDateInput(val, "min")),
    onChange: _cache[1] || (_cache[1] = val => _ctx.handleDateChange(val, "min"))
  }, null, 8, ["disabled", "placeholder", "model-value"])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", panel_date_range2_hoisted_8, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    size: "small",
    class: "el-date-range-picker__editor",
    disabled: _ctx.rangeState.selecting,
    placeholder: _ctx.t("el.datepicker.startTime"),
    "model-value": _ctx.minVisibleTime,
    onFocus: _cache[2] || (_cache[2] = $event => _ctx.minTimePickerVisible = true),
    onInput: _cache[3] || (_cache[3] = val => _ctx.handleTimeInput(val, "min")),
    onChange: _cache[4] || (_cache[4] = val => _ctx.handleTimeChange(val, "min"))
  }, null, 8, ["disabled", "placeholder", "model-value"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_time_pick_panel, {
    visible: _ctx.minTimePickerVisible,
    format: _ctx.timeFormat,
    "datetime-role": "start",
    "time-arrow-control": _ctx.arrowControl,
    "parsed-value": _ctx.leftDate,
    onPick: _ctx.handleMinTimePick
  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])])), [[_directive_clickoutside, _ctx.handleMinTimeClose]])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_right)]),
    _: 1
  })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", panel_date_range2_hoisted_9, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", panel_date_range2_hoisted_10, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    size: "small",
    class: "el-date-range-picker__editor",
    disabled: _ctx.rangeState.selecting,
    placeholder: _ctx.t("el.datepicker.endDate"),
    "model-value": _ctx.maxVisibleDate,
    readonly: !_ctx.minDate,
    onInput: _cache[5] || (_cache[5] = val => _ctx.handleDateInput(val, "max")),
    onChange: _cache[6] || (_cache[6] = val => _ctx.handleDateChange(val, "max"))
  }, null, 8, ["disabled", "placeholder", "model-value", "readonly"])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", panel_date_range2_hoisted_11, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
    size: "small",
    class: "el-date-range-picker__editor",
    disabled: _ctx.rangeState.selecting,
    placeholder: _ctx.t("el.datepicker.endTime"),
    "model-value": _ctx.maxVisibleTime,
    readonly: !_ctx.minDate,
    onFocus: _cache[7] || (_cache[7] = $event => _ctx.minDate && (_ctx.maxTimePickerVisible = true)),
    onInput: _cache[8] || (_cache[8] = val => _ctx.handleTimeInput(val, "max")),
    onChange: _cache[9] || (_cache[9] = val => _ctx.handleTimeChange(val, "max"))
  }, null, 8, ["disabled", "placeholder", "model-value", "readonly"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_time_pick_panel, {
    "datetime-role": "end",
    visible: _ctx.maxTimePickerVisible,
    format: _ctx.timeFormat,
    "time-arrow-control": _ctx.arrowControl,
    "parsed-value": _ctx.rightDate,
    onPick: _ctx.handleMaxTimePick
  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])])), [[_directive_clickoutside, _ctx.handleMaxTimeClose]])])])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_range2_hoisted_12, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_range2_hoisted_13, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    class: "el-picker-panel__icon-btn d-arrow-left",
    onClick: _cache[10] || (_cache[10] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_left)]),
    _: 1
  })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    class: "el-picker-panel__icon-btn arrow-left",
    onClick: _cache[11] || (_cache[11] = (...args) => _ctx.leftPrevMonth && _ctx.leftPrevMonth(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_left)]),
    _: 1
  })]), _ctx.unlinkPanels ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    key: 0,
    type: "button",
    disabled: !_ctx.enableYearArrow,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      "is-disabled": !_ctx.enableYearArrow
    }, "el-picker-panel__icon-btn d-arrow-right"]),
    onClick: _cache[12] || (_cache[12] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_right)]),
    _: 1
  })], 10, panel_date_range2_hoisted_14)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.unlinkPanels ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    key: 1,
    type: "button",
    disabled: !_ctx.enableMonthArrow,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      "is-disabled": !_ctx.enableMonthArrow
    }, "el-picker-panel__icon-btn arrow-right"]),
    onClick: _cache[13] || (_cache[13] = (...args) => _ctx.leftNextMonth && _ctx.leftNextMonth(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_right)]),
    _: 1
  })], 10, panel_date_range2_hoisted_15)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.leftLabel), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_date_table, {
    "selection-mode": "range",
    date: _ctx.leftDate,
    "min-date": _ctx.minDate,
    "max-date": _ctx.maxDate,
    "range-state": _ctx.rangeState,
    "disabled-date": _ctx.disabledDate,
    "cell-class-name": _ctx.cellClassName,
    onChangerange: _ctx.handleChangeRange,
    onPick: _ctx.handleRangePick,
    onSelect: _ctx.onSelect
  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_range2_hoisted_16, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_date_range2_hoisted_17, [_ctx.unlinkPanels ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    key: 0,
    type: "button",
    disabled: !_ctx.enableYearArrow,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      "is-disabled": !_ctx.enableYearArrow
    }, "el-picker-panel__icon-btn d-arrow-left"]),
    onClick: _cache[14] || (_cache[14] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_left)]),
    _: 1
  })], 10, panel_date_range2_hoisted_18)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), _ctx.unlinkPanels ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    key: 1,
    type: "button",
    disabled: !_ctx.enableMonthArrow,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      "is-disabled": !_ctx.enableMonthArrow
    }, "el-picker-panel__icon-btn arrow-left"]),
    onClick: _cache[15] || (_cache[15] = (...args) => _ctx.rightPrevMonth && _ctx.rightPrevMonth(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_left)]),
    _: 1
  })], 10, panel_date_range2_hoisted_19)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    class: "el-picker-panel__icon-btn d-arrow-right",
    onClick: _cache[16] || (_cache[16] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_right)]),
    _: 1
  })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    class: "el-picker-panel__icon-btn arrow-right",
    onClick: _cache[17] || (_cache[17] = (...args) => _ctx.rightNextMonth && _ctx.rightNextMonth(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_arrow_right)]),
    _: 1
  })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.rightLabel), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_date_table, {
    "selection-mode": "range",
    date: _ctx.rightDate,
    "min-date": _ctx.minDate,
    "max-date": _ctx.maxDate,
    "range-state": _ctx.rangeState,
    "disabled-date": _ctx.disabledDate,
    "cell-class-name": _ctx.cellClassName,
    onChangerange: _ctx.handleChangeRange,
    onPick: _ctx.handleRangePick,
    onSelect: _ctx.onSelect
  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])])])]), _ctx.showTime ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", panel_date_range2_hoisted_20, [_ctx.clearable ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_button, {
    key: 0,
    text: "",
    size: "small",
    class: "el-picker-panel__link-btn",
    onClick: _ctx.handleClear
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.clear")), 1)]),
    _: 1
  }, 8, ["onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
    plain: "",
    size: "small",
    class: "el-picker-panel__link-btn",
    disabled: _ctx.btnDisabled,
    onClick: _cache[18] || (_cache[18] = $event => _ctx.handleConfirm(false))
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.t("el.datepicker.confirm")), 1)]),
    _: 1
  }, 8, ["disabled"])])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 2);
}

var DateRangePickPanel = /* @__PURE__ */_export_sfc(panel_date_range2_sfc_main, [["render", panel_date_range2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker-com/panel-month-range2.mjs









const panel_month_range2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  components: {
    MonthTable: MonthTable,
    ElIcon: ElIcon,
    DArrowLeft: dArrowLeft,
    DArrowRight: dArrowRight
  },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    }
  },
  emits: ["pick", "set-picker-option"],

  setup(props, ctx) {
    const {
      t,
      lang
    } = useLocale();
    const leftDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(dayjs_min().locale(lang.value));
    const rightDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(dayjs_min().locale(lang.value).add(1, "year"));
    const hasShortcuts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => !!shortcuts.length);

    const handleShortcutClick = shortcut => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;

      if (shortcutValues) {
        ctx.emit("pick", [dayjs_min(shortcutValues[0]).locale(lang.value), dayjs_min(shortcutValues[1]).locale(lang.value)]);
        return;
      }

      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };

    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");

      if (!props.unlinkPanels) {
        rightDate.value = rightDate.value.subtract(1, "year");
      }
    };

    const rightNextYear = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
      }

      rightDate.value = rightDate.value.add(1, "year");
    };

    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
    };

    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
    };

    const leftLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const rightLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const leftYear = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return leftDate.value.year();
    });
    const rightYear = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
    });
    const enableYearArrow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    const minDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const maxDate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const rangeState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({
      endDate: null,
      selecting: false
    });

    const handleChangeRange = val => {
      rangeState.value = val;
    };

    const handleRangePick = (val, close = true) => {
      const minDate_ = val.minDate;
      const maxDate_ = val.maxDate;

      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }

      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close) return;
      handleConfirm();
    };

    const isValidValue = value => {
      return Array.isArray(value) && value && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };

    const handleConfirm = (visible = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      }
    };

    const onSelect = selecting => {
      rangeState.value.selecting = selecting;

      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };

    const formatToString = value => {
      return value.map(_ => _.format(format));
    };

    const getDefaultValue = () => {
      let start;

      if (Array.isArray(defaultValue.value)) {
        const left = dayjs_min(defaultValue.value[0]);
        let right = dayjs_min(defaultValue.value[1]);

        if (!props.unlinkPanels) {
          right = left.add(1, "year");
        }

        return [left, right];
      } else if (defaultValue.value) {
        start = dayjs_min(defaultValue.value);
      } else {
        start = dayjs_min();
      }

      start = start.locale(lang.value);
      return [start, start.add(1, "year")];
    };

    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    const pickerBase = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)("EP_PICKER_BASE");
    const {
      shortcuts,
      disabledDate,
      format
    } = pickerBase.props;
    const defaultValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRef)(pickerBase.props, "defaultValue");
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => defaultValue.value, val => {
      if (val) {
        const defaultArr = getDefaultValue();
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, {
      immediate: true
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.parsedValue, newVal => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;

        if (props.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const maxDateYear = maxDate.value.year();
          rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, "year") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "year");
        }
      } else {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, {
      immediate: true
    });
    return {
      shortcuts,
      disabledDate,
      onSelect,
      handleRangePick,
      rangeState,
      handleChangeRange,
      minDate,
      maxDate,
      enableYearArrow,
      leftLabel,
      rightLabel,
      leftNextYear,
      leftPrevYear,
      rightNextYear,
      rightPrevYear,
      t,
      leftDate,
      rightDate,
      hasShortcuts,
      handleShortcutClick
    };
  }

});

const panel_month_range2_hoisted_1 = {
  class: "el-picker-panel__body-wrapper"
};
const panel_month_range2_hoisted_2 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const panel_month_range2_hoisted_3 = ["onClick"];
const panel_month_range2_hoisted_4 = {
  class: "el-picker-panel__body"
};
const panel_month_range2_hoisted_5 = {
  class: "el-picker-panel__content el-date-range-picker__content is-left"
};
const panel_month_range2_hoisted_6 = {
  class: "el-date-range-picker__header"
};
const panel_month_range2_hoisted_7 = ["disabled"];
const panel_month_range2_hoisted_8 = {
  class: "el-picker-panel__content el-date-range-picker__content is-right"
};
const panel_month_range2_hoisted_9 = {
  class: "el-date-range-picker__header"
};
const panel_month_range2_hoisted_10 = ["disabled"];

function panel_month_range2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_d_arrow_left = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-left");

  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_d_arrow_right = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("d-arrow-right");

  const _component_month_table = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("month-table");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["el-picker-panel el-date-range-picker", [{
      "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts
    }]])
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_month_range2_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "sidebar", {
    class: "el-picker-panel__sidebar"
  }), _ctx.hasShortcuts ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", panel_month_range2_hoisted_2, [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.shortcuts, (shortcut, key) => {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
      key,
      type: "button",
      class: "el-picker-panel__shortcut",
      onClick: $event => _ctx.handleShortcutClick(shortcut)
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(shortcut.text), 9, panel_month_range2_hoisted_3);
  }), 128))])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_month_range2_hoisted_4, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_month_range2_hoisted_5, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_month_range2_hoisted_6, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    class: "el-picker-panel__icon-btn d-arrow-left",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_left)]),
    _: 1
  })]), _ctx.unlinkPanels ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    key: 0,
    type: "button",
    disabled: !_ctx.enableYearArrow,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      "is-disabled": !_ctx.enableYearArrow
    }, "el-picker-panel__icon-btn d-arrow-right"]),
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_right)]),
    _: 1
  })], 10, panel_month_range2_hoisted_7)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.leftLabel), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_month_table, {
    "selection-mode": "range",
    date: _ctx.leftDate,
    "min-date": _ctx.minDate,
    "max-date": _ctx.maxDate,
    "range-state": _ctx.rangeState,
    "disabled-date": _ctx.disabledDate,
    onChangerange: _ctx.handleChangeRange,
    onPick: _ctx.handleRangePick,
    onSelect: _ctx.onSelect
  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_month_range2_hoisted_8, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", panel_month_range2_hoisted_9, [_ctx.unlinkPanels ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("button", {
    key: 0,
    type: "button",
    disabled: !_ctx.enableYearArrow,
    class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([{
      "is-disabled": !_ctx.enableYearArrow
    }, "el-picker-panel__icon-btn d-arrow-left"]),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_left)]),
    _: 1
  })], 10, panel_month_range2_hoisted_10)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
    type: "button",
    class: "el-picker-panel__icon-btn d-arrow-right",
    onClick: _cache[3] || (_cache[3] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_icon, null, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_d_arrow_right)]),
    _: 1
  })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.rightLabel), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_month_table, {
    "selection-mode": "range",
    date: _ctx.rightDate,
    "min-date": _ctx.minDate,
    "max-date": _ctx.maxDate,
    "range-state": _ctx.rangeState,
    "disabled-date": _ctx.disabledDate,
    onChangerange: _ctx.handleChangeRange,
    onPick: _ctx.handleRangePick,
    onSelect: _ctx.onSelect
  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])])])])], 2);
}

var MonthRangePickPanel = /* @__PURE__ */_export_sfc(panel_month_range2_sfc_main, [["render", panel_month_range2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/common/props2.mjs



const timePickerDefaultProps = {
  id: {
    type: [Array, String]
  },
  name: {
    type: [Array, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: {
    type: String
  },
  valueFormat: {
    type: String
  },
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: [String, Object],
    default: circleClose
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: [String, Object],
    default: ""
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  modelValue: {
    type: [Date, Array, String, Number],
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
};

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/common/constant2.mjs
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};

;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/clock.mjs



const clock_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "Clock"
});

const clock_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const clock_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);

const clock_hoisted_3 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
}, null, -1);

const clock_hoisted_4 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
}, null, -1);

const clock_hoisted_5 = [clock_hoisted_2, clock_hoisted_3, clock_hoisted_4];

function clock_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", clock_hoisted_1, clock_hoisted_5);
}

var clock = /* @__PURE__ */plugin_vue_export_helper_export_sfc(clock_sfc_main, [["render", clock_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/node_modules/@element-plus/icons-vue/dist/es/calendar.mjs



const calendar_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "Calendar"
});

const calendar_hoisted_1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

const calendar_hoisted_2 = /* @__PURE__ */(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("path", {
  fill: "currentColor",
  d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
}, null, -1);

const calendar_hoisted_3 = [calendar_hoisted_2];

function calendar_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("svg", calendar_hoisted_1, calendar_hoisted_3);
}

var calendar = /* @__PURE__ */plugin_vue_export_helper_export_sfc(calendar_sfc_main, [["render", calendar_sfc_render]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/time-picker/src/common/picker2.mjs






















const dateEquals = function (a, b) {
  const aIsDate = a instanceof Date;
  const bIsDate = b instanceof Date;

  if (aIsDate && bIsDate) {
    return a.getTime() === b.getTime();
  }

  if (!aIsDate && !bIsDate) {
    return a === b;
  }

  return false;
};

const valueEquals = function (a, b) {
  const aIsArray = Array.isArray(a);
  const bIsArray = Array.isArray(b);

  if (aIsArray && bIsArray) {
    if (a.length !== b.length) {
      return false;
    }

    return a.every((item, index) => dateEquals(item, b[index]));
  }

  if (!aIsArray && !bIsArray) {
    return dateEquals(a, b);
  }

  return false;
};

const parser = function (date, format, lang) {
  const day = isEmpty(format) || format === "x" ? dayjs_min(date).locale(lang) : dayjs_min(date, format).locale(lang);
  return day.isValid() ? day : void 0;
};

const formatter = function (date, format, lang) {
  if (isEmpty(format)) return date;
  if (format === "x") return +date;
  return dayjs_min(date).locale(lang).format(format);
};

const picker2_sfc_main = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "Picker",
  components: {
    ElInput: ElInput,
    ElTooltip: ElTooltip,
    ElIcon: ElIcon
  },
  props: timePickerDefaultProps,
  emits: ["update:modelValue", "change", "focus", "blur", "calendar-change", "panel-change", "visible-change"],

  setup(props, ctx) {
    const {
      lang
    } = useLocale();
    const nsDate = useNamespace("date");
    const nsInput = useNamespace("input");
    const nsRange = useNamespace("range");
    const elForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formContextKey, {});
    const elFormItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)(formItemContextKey, {});
    const elPopperOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)("ElPopperOptions", {});
    const refPopper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const inputRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const pickerVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const pickerActualVisible = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
    const valueOnOpen = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(pickerVisible, val => {
      var _a;

      if (!val) {
        userInput.value = null;
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          emitChange(props.modelValue);
        });
        ctx.emit("blur");
        blurInput();
        props.validateEvent && ((_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "blur").catch(err => error2_debugWarn(err)));
      } else {
        valueOnOpen.value = props.modelValue;
      }
    });

    const emitChange = (val, isClear) => {
      var _a;

      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        ctx.emit("change", val);
        props.validateEvent && ((_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch(err => error2_debugWarn(err)));
      }
    };

    const emitInput = val => {
      if (!valueEquals(props.modelValue, val)) {
        let formatValue;

        if (Array.isArray(val)) {
          formatValue = val.map(_ => formatter(_, props.valueFormat, lang.value));
        } else if (val) {
          formatValue = formatter(val, props.valueFormat, lang.value);
        }

        ctx.emit("update:modelValue", val ? formatValue : val, lang.value);
      }
    };

    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (inputRef.value) {
        const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;

        return Array.from(_r.querySelectorAll("input"));
      }

      return [];
    });
    const refStartInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return refInput == null ? void 0 : refInput.value[0];
    });
    const refEndInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return refInput == null ? void 0 : refInput.value[1];
    });

    const setSelectionRange = (start, end, pos) => {
      const _inputs = refInput.value;
      if (!_inputs.length) return;

      if (!pos || pos === "min") {
        _inputs[0].setSelectionRange(start, end);

        _inputs[0].focus();
      } else if (pos === "max") {
        _inputs[1].setSelectionRange(start, end);

        _inputs[1].focus();
      }
    };

    const onPick = (date = "", visible = false) => {
      pickerVisible.value = visible;
      let result;

      if (Array.isArray(date)) {
        result = date.map(_ => _.toDate());
      } else {
        result = date ? date.toDate() : date;
      }

      userInput.value = null;
      emitInput(result);
    };

    const onBeforeShow = () => {
      pickerActualVisible.value = true;
    };

    const onShow = () => {
      ctx.emit("visible-change", true);
    };

    const onHide = () => {
      pickerActualVisible.value = false;
      ctx.emit("visible-change", false);
    };

    const focus = (focusStartInput = true) => {
      let input = refStartInput.value;

      if (!focusStartInput && isRangeInput.value) {
        input = refEndInput.value;
      }

      if (input) {
        input.focus();
      }
    };

    const handleFocus = e => {
      if (props.readonly || pickerDisabled.value || pickerVisible.value) return;
      pickerVisible.value = true;
      ctx.emit("focus", e);
    };

    const handleBlur = () => {
      var _a;

      (_a = refPopper.value) == null ? void 0 : _a.onClose();
      blurInput();
    };

    const pickerDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.disabled || elForm.disabled;
    });
    const parsedValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let result;

      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          result = pickerOptions.value.getDefaultValue();
        }
      } else {
        if (Array.isArray(props.modelValue)) {
          result = props.modelValue.map(_ => parser(_, props.valueFormat, lang.value));
        } else {
          result = parser(props.modelValue, props.valueFormat, lang.value);
        }
      }

      if (pickerOptions.value.getRangeAvailableTime) {
        const availableResult = pickerOptions.value.getRangeAvailableTime(result);

        if (!lodash_es_isEqual(availableResult, result)) {
          result = availableResult;
          emitInput(Array.isArray(result) ? result.map(_ => _.toDate()) : result.toDate());
        }
      }

      if (Array.isArray(result) && result.some(_ => !_)) {
        result = [];
      }

      return result;
    });
    const displayValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if (!pickerOptions.value.panelReady) return;
      const formattedValue = formatDayjsToString(parsedValue.value);

      if (Array.isArray(userInput.value)) {
        return [userInput.value[0] || formattedValue && formattedValue[0] || "", userInput.value[1] || formattedValue && formattedValue[1] || ""];
      } else if (userInput.value !== null) {
        return userInput.value;
      }

      if (!isTimePicker.value && valueIsEmpty.value) return;
      if (!pickerVisible.value && valueIsEmpty.value) return;

      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
      }

      return "";
    });
    const isTimeLikePicker = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.type.includes("time"));
    const isTimePicker = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.type.startsWith("time"));
    const isDatesPicker = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.type === "dates");
    const triggerIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => props.prefixIcon || (isTimeLikePicker.value ? clock : calendar));
    const showClose = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);

    const onClearIconClick = event => {
      if (props.readonly || pickerDisabled.value) return;

      if (showClose.value) {
        event.stopPropagation();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };

    const valueIsEmpty = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return !props.modelValue || Array.isArray(props.modelValue) && !props.modelValue.length;
    });

    const onMouseEnter = () => {
      if (props.readonly || pickerDisabled.value) return;

      if (!valueIsEmpty.value && props.clearable) {
        showClose.value = true;
      }
    };

    const onMouseLeave = () => {
      showClose.value = false;
    };

    const isRangeInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type.includes("range");
    });
    const pickerSize = useSize();
    const popperPaneRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b;

      return (_b = (_a = refPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
    });
    const popperEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a, _b;

      return (_b = (_a = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(refPopper)) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
    });
    const actualInputRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      var _a;

      if ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(isRangeInput)) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputRef);
      }

      return (_a = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(inputRef)) == null ? void 0 : _a.$el;
    });
    onClickOutside(actualInputRef, e => {
      const unrefedPopperEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(popperEl);
      const inputEl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.unref)(actualInputRef);
      if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl)) return;
      pickerVisible.value = false;
    });
    const userInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

    const handleChange = () => {
      if (userInput.value) {
        const value = parseUserInputToDayjs(displayValue.value);

        if (value) {
          if (isValidValue(value)) {
            emitInput(Array.isArray(value) ? value.map(_ => _.toDate()) : value.toDate());
            userInput.value = null;
          }
        }
      }

      if (userInput.value === "") {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };

    const blurInput = () => {
      refInput.value.forEach(input => input.blur());
    };

    const parseUserInputToDayjs = value => {
      if (!value) return null;
      return pickerOptions.value.parseUserInput(value);
    };

    const formatDayjsToString = value => {
      if (!value) return null;
      return pickerOptions.value.formatToString(value);
    };

    const isValidValue = value => {
      return pickerOptions.value.isValidValue(value);
    };

    const handleKeydown = event => {
      const code = event.code;

      if (code === EVENT_CODE.esc) {
        pickerVisible.value = false;
        event.stopPropagation();
        return;
      }

      if (code === EVENT_CODE.tab) {
        if (!isRangeInput.value) {
          handleChange();
          pickerVisible.value = false;
          event.stopPropagation();
        } else {
          setTimeout(() => {
            if (!refInput.value.includes(document.activeElement)) {
              pickerVisible.value = false;
              blurInput();
            }
          }, 0);
        }

        return;
      }

      if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
        if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }

        event.stopPropagation();
        return;
      }

      if (userInput.value) {
        event.stopPropagation();
        return;
      }

      if (pickerOptions.value.handleKeydown) {
        pickerOptions.value.handleKeydown(event);
      }
    };

    const onUserInput = e => {
      userInput.value = e;
    };

    const handleStartInput = event => {
      if (userInput.value) {
        userInput.value = [event.target.value, userInput.value[1]];
      } else {
        userInput.value = [event.target.value, null];
      }
    };

    const handleEndInput = event => {
      if (userInput.value) {
        userInput.value = [userInput.value[0], event.target.value];
      } else {
        userInput.value = [null, event.target.value];
      }
    };

    const handleStartChange = () => {
      const value = parseUserInputToDayjs(userInput.value && userInput.value[0]);

      if (value && value.isValid()) {
        userInput.value = [formatDayjsToString(value), displayValue.value[1]];
        const newValue = [value, parsedValue.value && parsedValue.value[1]];

        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };

    const handleEndChange = () => {
      const value = parseUserInputToDayjs(userInput.value && userInput.value[1]);

      if (value && value.isValid()) {
        userInput.value = [displayValue.value[0], formatDayjsToString(value)];
        const newValue = [parsedValue.value && parsedValue.value[0], value];

        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };

    const pickerOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});

    const onSetPickerOption = e => {
      pickerOptions.value[e[0]] = e[1];
      pickerOptions.value.panelReady = true;
    };

    const onCalendarChange = e => {
      ctx.emit("calendar-change", e);
    };

    const onPanelChange = (value, mode, view) => {
      ctx.emit("panel-change", value, mode, view);
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)("EP_PICKER_BASE", {
      props
    });
    return {
      nsDate,
      nsInput,
      nsRange,
      elPopperOptions,
      isDatesPicker,
      handleEndChange,
      handleStartChange,
      handleStartInput,
      handleEndInput,
      onUserInput,
      handleChange,
      handleKeydown,
      popperPaneRef,
      onClickOutside: onClickOutside,
      pickerSize,
      isRangeInput,
      onMouseLeave,
      onMouseEnter,
      onClearIconClick,
      showClose,
      triggerIcon,
      onPick,
      handleFocus,
      handleBlur,
      pickerVisible,
      pickerActualVisible,
      displayValue,
      parsedValue,
      setSelectionRange,
      refPopper,
      inputRef,
      pickerDisabled,
      onSetPickerOption,
      onCalendarChange,
      onPanelChange,
      focus,
      onShow,
      onBeforeShow,
      onHide
    };
  }

});

const picker2_hoisted_1 = ["id", "name", "placeholder", "value", "disabled", "readonly"];
const picker2_hoisted_2 = ["id", "name", "placeholder", "value", "disabled", "readonly"];

function picker2_sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-icon");

  const _component_el_input = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-input");

  const _component_el_tooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)("el-tooltip");

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_tooltip, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.mergeProps)({
    ref: "refPopper",
    visible: _ctx.pickerVisible,
    "onUpdate:visible": _cache[17] || (_cache[17] = $event => _ctx.pickerVisible = $event),
    effect: "light",
    pure: "",
    trigger: "click"
  }, _ctx.$attrs, {
    teleported: "",
    transition: `${_ctx.nsDate.namespace.value}-zoom-in-top`,
    "popper-class": [`${_ctx.nsDate.namespace.value}-picker__popper`, _ctx.popperClass],
    "popper-options": _ctx.elPopperOptions,
    "fallback-placements": ["bottom", "top", "right", "left"],
    "gpu-acceleration": false,
    "stop-popper-mouse-event": false,
    "hide-after": 0,
    persistent: "",
    onBeforeShow: _ctx.onBeforeShow,
    onShow: _ctx.onShow,
    onHide: _ctx.onHide
  }), {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [!_ctx.isRangeInput ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_input, {
      key: 0,
      id: _ctx.id,
      ref: "inputRef",
      "model-value": _ctx.displayValue,
      name: _ctx.name,
      size: _ctx.pickerSize,
      disabled: _ctx.pickerDisabled,
      placeholder: _ctx.placeholder,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsDate.b("editor"), _ctx.nsDate.bm("editor", _ctx.type), _ctx.$attrs.class]),
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.$attrs.style),
      readonly: !_ctx.editable || _ctx.readonly || _ctx.isDatesPicker || _ctx.type === "week",
      label: _ctx.label,
      tabindex: _ctx.tabindex,
      onInput: _ctx.onUserInput,
      onFocus: _ctx.handleFocus,
      onKeydown: _ctx.handleKeydown,
      onChange: _ctx.handleChange,
      onMouseenter: _ctx.onMouseEnter,
      onMouseleave: _ctx.onMouseLeave,
      onClick: _cache[0] || (_cache[0] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)(() => {}, ["stop"]))
    }, {
      prefix: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.triggerIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsInput.e("icon")),
        onClick: _ctx.handleFocus
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.triggerIcon)))]),
        _: 1
      }, 8, ["class", "onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      suffix: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [_ctx.showClose && _ctx.clearIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
        key: 0,
        class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(`${_ctx.nsInput.e("icon")} clear-icon`),
        onClick: _ctx.onClearIconClick
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.clearIcon)))]),
        _: 1
      }, 8, ["class", "onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)]),
      _: 1
    }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onInput", "onFocus", "onKeydown", "onChange", "onMouseenter", "onMouseleave"])) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 1,
      ref: "inputRef",
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsDate.b("editor"), _ctx.nsDate.bm("editor", _ctx.type), _ctx.nsInput.e("inner"), _ctx.nsDate.is("disabled", _ctx.pickerDisabled), _ctx.nsDate.is("active", _ctx.pickerVisible), _ctx.nsRange.b("editor"), _ctx.pickerSize ? _ctx.nsRange.bm("editor", _ctx.pickerSize) : "", _ctx.$attrs.class]),
      style: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeStyle)(_ctx.$attrs.style),
      onClick: _cache[7] || (_cache[7] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onMouseenter: _cache[8] || (_cache[8] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[9] || (_cache[9] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
      onKeydown: _cache[10] || (_cache[10] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
    }, [_ctx.triggerIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
      key: 0,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsInput.e("icon"), _ctx.nsRange.e("icon")]),
      onClick: _ctx.handleFocus
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.triggerIcon)))]),
      _: 1
    }, 8, ["class", "onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("input", {
      id: _ctx.id && _ctx.id[0],
      autocomplete: "off",
      name: _ctx.name && _ctx.name[0],
      placeholder: _ctx.startPlaceholder,
      value: _ctx.displayValue && _ctx.displayValue[0],
      disabled: _ctx.pickerDisabled,
      readonly: !_ctx.editable || _ctx.readonly,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsRange.b("input")),
      onInput: _cache[1] || (_cache[1] = (...args) => _ctx.handleStartInput && _ctx.handleStartInput(...args)),
      onChange: _cache[2] || (_cache[2] = (...args) => _ctx.handleStartChange && _ctx.handleStartChange(...args)),
      onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
    }, null, 42, picker2_hoisted_1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "range-separator", {}, () => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsRange.b("separator"))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.rangeSeparator), 3)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("input", {
      id: _ctx.id && _ctx.id[1],
      autocomplete: "off",
      name: _ctx.name && _ctx.name[1],
      placeholder: _ctx.endPlaceholder,
      value: _ctx.displayValue && _ctx.displayValue[1],
      disabled: _ctx.pickerDisabled,
      readonly: !_ctx.editable || _ctx.readonly,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(_ctx.nsRange.b("input")),
      onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onInput: _cache[5] || (_cache[5] = (...args) => _ctx.handleEndInput && _ctx.handleEndInput(...args)),
      onChange: _cache[6] || (_cache[6] = (...args) => _ctx.handleEndChange && _ctx.handleEndChange(...args))
    }, null, 42, picker2_hoisted_2), _ctx.clearIcon ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_icon, {
      key: 1,
      class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.nsInput.e("icon"), _ctx.nsRange.e("close-icon"), {
        [_ctx.nsRange.e("close-icon--hidden")]: !_ctx.showClose
      }]),
      onClick: _ctx.onClearIconClick
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)(_ctx.clearIcon)))]),
      _: 1
    }, 8, ["class", "onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("v-if", true)], 38))]),
    content: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {
      visible: _ctx.pickerVisible,
      actualVisible: _ctx.pickerActualVisible,
      parsedValue: _ctx.parsedValue,
      format: _ctx.format,
      unlinkPanels: _ctx.unlinkPanels,
      type: _ctx.type,
      defaultValue: _ctx.defaultValue,
      onPick: _cache[11] || (_cache[11] = (...args) => _ctx.onPick && _ctx.onPick(...args)),
      onSelectRange: _cache[12] || (_cache[12] = (...args) => _ctx.setSelectionRange && _ctx.setSelectionRange(...args)),
      onSetPickerOption: _cache[13] || (_cache[13] = (...args) => _ctx.onSetPickerOption && _ctx.onSetPickerOption(...args)),
      onCalendarChange: _cache[14] || (_cache[14] = (...args) => _ctx.onCalendarChange && _ctx.onCalendarChange(...args)),
      onPanelChange: _cache[15] || (_cache[15] = (...args) => _ctx.onPanelChange && _ctx.onPanelChange(...args)),
      onMousedown: _cache[16] || (_cache[16] = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withModifiers)(() => {}, ["stop"]))
    })]),
    _: 3
  }, 16, ["visible", "transition", "popper-class", "popper-options", "onBeforeShow", "onShow", "onHide"]);
}

var CommonPicker = /* @__PURE__ */_export_sfc(picker2_sfc_main, [["render", picker2_sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/src/date-picker2.mjs


















dayjs_min.extend(localeData);
dayjs_min.extend(advancedFormat);
dayjs_min.extend(customParseFormat);
dayjs_min.extend(weekOfYear);
dayjs_min.extend(weekYear);
dayjs_min.extend(dayOfYear);
dayjs_min.extend(isSameOrAfter);
dayjs_min.extend(isSameOrBefore);

const getPanel = function (type) {
  if (type === "daterange" || type === "datetimerange") {
    return DateRangePickPanel;
  } else if (type === "monthrange") {
    return MonthRangePickPanel;
  }

  return DatePickPanel;
};

var DatePicker = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "ElDatePicker",
  install: null,
  props: { ...timePickerDefaultProps,
    type: {
      type: String,
      default: "date"
    }
  },
  emits: ["update:modelValue"],

  setup(props, ctx) {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)("ElPopperOptions", props.popperOptions);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)(ROOT_PICKER_INJECTION_KEY, {
      ctx
    });
    const commonPicker = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const refProps = { ...props,
      focus: (focusStartInput = true) => {
        var _a;

        (_a = commonPicker.value) == null ? void 0 : _a.focus(focusStartInput);
      }
    };
    ctx.expose(refProps);
    return () => {
      var _a;

      const format = (_a = props.format) != null ? _a : DEFAULT_FORMATS_DATEPICKER[props.type] || DEFAULT_FORMATS_DATE;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(CommonPicker, { ...props,
        format,
        type: props.type,
        ref: commonPicker,
        "onUpdate:modelValue": value => ctx.emit("update:modelValue", value)
      }, {
        default: scopedProps => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getPanel(props.type), scopedProps),
        "range-separator": () => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(ctx.slots, "range-separator")
      });
    };
  }

});

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/index2.mjs

const _DatePicker = DatePicker;

_DatePicker.install = app => {
  app.component(_DatePicker.name, _DatePicker);
};

const ElDatePicker = _DatePicker;

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-date-picker.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/style/css2.mjs






;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/date-picker/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/element-plus/theme-chalk/el-form-item.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form-item/style/css2.mjs


;// CONCATENATED MODULE: ./node_modules/element-plus/es/components/form-item/style/css.mjs

;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-record/index.vue?vue&type=template&id=1bf6efe7
/* unplugin-vue-components disabled */

















const nx_recordvue_type_template_id_1bf6efe7_hoisted_1 = {
  class: "search-section"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_2 = {
  class: "action-section action-section-sdk"
};

const nx_recordvue_type_template_id_1bf6efe7_hoisted_3 = /*#__PURE__*/(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("img", {
  src: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/download.svg",
  alt: "",
  class: "downLoadLogo downLoadLogos"
}, null, -1);

const nx_recordvue_type_template_id_1bf6efe7_hoisted_4 = {
  class: "table-section"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_5 = {
  key: 0
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_6 = {
  key: 1
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_7 = {
  key: 0
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_8 = {
  key: 1
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_9 = ["onPlay"];
const nx_recordvue_type_template_id_1bf6efe7_hoisted_10 = ["src"];
const nx_recordvue_type_template_id_1bf6efe7_hoisted_11 = {
  class: "recordAct-content"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_12 = {
  class: "recordAct-time"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_13 = {
  class: "recordAct-time-txt"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_14 = {
  class: "recordAct-time-btn"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_15 = {
  key: 1
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_16 = {
  class: "hanldChangeEdit"
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_17 = {
  key: 1,
  style: {
    "color": "#999999",
    "cursor": "not-allowed"
  }
};
const nx_recordvue_type_template_id_1bf6efe7_hoisted_18 = {
  class: "dialog-footer"
};
function nx_recordvue_type_template_id_1bf6efe7_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;

  const _component_el_select = ElSelect;

  const _component_el_form_item = ElFormItem;

  const _component_el_col = ElCol;

  const _component_el_input = ElInput;

  const _component_el_date_picker = ElDatePicker;

  const _component_el_button = ElButton;

  const _component_el_row = ElRow;

  const _component_el_form = ElForm;

  const _component_el_table_column = index2_ElTableColumn;

  const _component_el_link = ElLink;

  const _component_el_space = ElSpace;

  const _component_page_table = PageTable;

  const _component_el_timeline_item = ElTimelineItem;

  const _component_el_timeline = ElTimeline;

  const _component_el_dialog = ElDialog;

  const _directive_loading = vLoading;

  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", null, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_1, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_form, {
    ref: "formRef",
    "label-position": "top",
    model: _ctx.recordSearch
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_row, {
      gutter: 12
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        md: 24,
        lg: 4
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_form_item, {
          prop: "direction"
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_select, {
            modelValue: _ctx.recordSearch.direction,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.recordSearch.direction = $event),
            placeholder: _ctx.i18n.global.t('record.selectType'),
            clearable: "",
            style: {
              "width": "100%"
            }
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)([{
              value: 0,
              label: _ctx.i18n.global.t('record.inboundCall')
            }, {
              value: 1,
              label: _ctx.i18n.global.t('record.outboundCall')
            }], item => {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_option, {
                key: item.value,
                label: item.label,
                value: item.value
              }, null, 8, ["label", "value"]);
            }), 128))]),
            _: 1
          }, 8, ["modelValue", "placeholder"])]),
          _: 1
        })]),
        _: 1
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        md: 24,
        lg: 4
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_form_item, {
          prop: "group"
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_select, {
            modelValue: _ctx.recordSearch.group,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.recordSearch.group = $event),
            filterable: "",
            remote: "",
            clearable: "",
            "reserve-keyword": "",
            placeholder: _ctx.i18n.global.t('record.enterAgentGroupName'),
            "remote-method": _ctx.remoteMethod,
            onClear: _ctx.clearGroup,
            loading: _ctx.queryLoading,
            style: {
              "width": "100%"
            }
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.queryOptions, item => {
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_option, {
                key: item.id,
                label: item.groupName,
                value: item.id
              }, null, 8, ["label", "value"]);
            }), 128))]),
            _: 1
          }, 8, ["modelValue", "placeholder", "remote-method", "onClear", "loading"])]),
          _: 1
        })]),
        _: 1
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        md: 24,
        lg: 4
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_form_item, {
          prop: "name"
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
            clearable: "",
            modelValue: _ctx.recordSearch.name,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.recordSearch.name = $event),
            placeholder: _ctx.i18n.global.t('record.enteAgentAccount')
          }, null, 8, ["modelValue", "placeholder"])]),
          _: 1
        })]),
        _: 1
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        md: 24,
        lg: 4
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_form_item, {
          prop: "number"
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
            clearable: "",
            onInput: _ctx.numberInputChange,
            modelValue: _ctx.recordSearch.number,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.recordSearch.number = $event),
            placeholder: _ctx.i18n.global.t('record.enterCalledId')
          }, null, 8, ["onInput", "modelValue", "placeholder"])]),
          _: 1
        })]),
        _: 1
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        md: 24,
        lg: 8,
        xl: 5
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_form_item, {
          prop: "callTime",
          class: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)(["date-time-picker", _ctx.isMainShow != null ? 'ai-col-time' : ''])
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_date_picker, {
            modelValue: _ctx.recordCallTime,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.recordCallTime = $event),
            type: "datetimerange",
            "start-placeholder": _ctx.i18n.global.t('record.startingTime'),
            "end-placeholder": _ctx.i18n.global.t('record.endTime'),
            style: {
              "height": "32px"
            },
            clearable: false,
            onChange: _ctx.changeCallTime,
            "default-time": _ctx.defaultTime,
            "disabled-date": _ctx.disabledDate,
            onFocus: _ctx.handleFocus,
            onCalendarChange: _ctx.handleChange,
            placeholder: _ctx.i18n.global.t('record.selectCallTime')
          }, null, 8, ["modelValue", "start-placeholder", "end-placeholder", "onChange", "default-time", "disabled-date", "onFocus", "onCalendarChange", "placeholder"])]),
          _: 1
        }, 8, ["class"])]),
        _: 1
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_col, {
        md: 24,
        lg: 8,
        style: {
          "margin-bottom": "24px"
        }
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_2, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
          onClick: _ctx.onSearch,
          color: "#00A062"
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("record.search")), 1)]),
          _: 1
        }, 8, ["onClick"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
          onClick: _ctx.resetForm
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("record.reset")), 1)]),
          _: 1
        }, 8, ["onClick"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
          onClick: _ctx.exportAll,
          loading: _ctx.exportLoading
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [nx_recordvue_type_template_id_1bf6efe7_hoisted_3, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("record.download")), 1)]),
          _: 1
        }, 8, ["onClick", "loading"])])]),
        _: 1
      })]),
      _: 1
    })]),
    _: 1
  }, 8, ["model"])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_4, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_page_table, {
    ref: "tableRef",
    tableData: _ctx.recordList,
    total: _ctx.recordTotal,
    "current-page": _ctx.recordSearch.current,
    "page-size": _ctx.recordSearch.size,
    onSizeChange: _ctx.onSizeChange,
    onPageChange: _ctx.onPageChange,
    tableHeight: !_ctx.isHeight ? null : 1
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "gmtCreate",
      label: _ctx.i18n.global.t('record.time'),
      "min-width": "180"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "direction",
      label: _ctx.i18n.global.t('record.callType'),
      "min-width": "130"
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(scope => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.direction == 0 ? _ctx.i18n.global.t("record.inboundCall") : _ctx.i18n.global.t("record.outboundCall")), 1)]),
      _: 1
    }, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "caller",
      label: _ctx.i18n.global.t('record.callerId'),
      "min-width": "210"
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(scope => [scope.row.direction == 0 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", nx_recordvue_type_template_id_1bf6efe7_hoisted_5, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.caller), 1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", nx_recordvue_type_template_id_1bf6efe7_hoisted_6, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.didNumberId != null && scope.row.didNumberId != 0 ? scope.row.clientSipFrom : _ctx.i18n.global.t("sip.unknown")) + " " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.remark != null && scope.row.remark != "" ? `- ${scope.row.remark}` : ""), 1))]),
      _: 1
    }, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "callee",
      label: _ctx.i18n.global.t('record.calledId'),
      "min-width": "150"
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(scope => [scope.row.direction == 0 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", nx_recordvue_type_template_id_1bf6efe7_hoisted_7, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.callee) + " " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.remark != null && scope.row.remark != "" ? `- ${scope.row.remark}` : ""), 1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", nx_recordvue_type_template_id_1bf6efe7_hoisted_8, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.callee), 1))]),
      _: 1
    }, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "callStatus",
      label: _ctx.$t('record.callStatus'),
      "min-width": "180"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "hangupReason",
      label: _ctx.$t('record.hangupReason'),
      "min-width": "180"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "recordUrl",
      label: _ctx.i18n.global.t('record.audioFiles'),
      "min-width": "300"
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(scope => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("audio", {
        ref: el => {
          _ctx.audiosRef[scope.row.id] = el;
        },
        onPlay: $event => _ctx.onPlay(scope.row.id),
        controls: "",
        class: "audio"
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("source", {
        src: scope.row.recordUrl
      }, null, 8, nx_recordvue_type_template_id_1bf6efe7_hoisted_10), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)(" " + (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("record.notSupportAudio")), 1)], 40, nx_recordvue_type_template_id_1bf6efe7_hoisted_9)]),
      _: 1
    }, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "inQueueTime",
      label: _ctx.i18n.global.t('record.queueStartTime'),
      "min-width": "180"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "answerTime",
      label: _ctx.i18n.global.t('record.callStartTime'),
      "min-width": "180"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "endTime",
      label: _ctx.i18n.global.t('record.callEndTime'),
      "min-width": "180"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "queuingTime",
      label: _ctx.i18n.global.t('record.queueDuration'),
      "min-width": "180"
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(scope => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.outQueueTime && scope.row.inQueueTime ? _ctx.dayjs(scope.row.outQueueTime).diff(_ctx.dayjs(scope.row.inQueueTime), "seconds") : ""), 1)]),
      _: 1
    }, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "callDuration",
      label: _ctx.i18n.global.t('record.callDuration'),
      "min-width": "120"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "agentNickName",
      label: _ctx.i18n.global.t('record.agentUsername'),
      "min-width": "150",
      "show-overflow-tooltip": true
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "agentName",
      label: _ctx.i18n.global.t('record.agentAccount'),
      "min-width": "210"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      prop: "agentGroupName",
      label: _ctx.i18n.global.t('record.agentGroup'),
      "min-width": "150"
    }, null, 8, ["label"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_table_column, {
      fixed: "right",
      label: _ctx.i18n.global.t('record.actions'),
      "min-width": _ctx.lang == 'zh' ? 150 : 200
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(scope => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_space, {
        size: 16
      }, {
        default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_link, {
          style: {
            "color": "#00a062"
          },
          onClick: $event => _ctx.backListCall(scope.row),
          underline: false
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(scope.row.direction == 0 ? _ctx.i18n.global.t("record.callBack") : _ctx.i18n.global.t("record.redialBack")), 1)]),
          _: 2
        }, 1032, ["onClick"])]),
        _: 2
      }, 1024)]),
      _: 1
    }, 8, ["label", "min-width"])]),
    _: 1
  }, 8, ["tableData", "total", "current-page", "page-size", "onSizeChange", "onPageChange", "tableHeight"])), [[_directive_loading, _ctx.tableLoading]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.recordValueVisible,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.recordValueVisible = $event),
    title: _ctx.i18n.global.t('dashboard.revisionHistory'),
    width: "356px",
    onClose: _ctx.handleCloseModeifys,
    "custom-class": "nx-el-dialog"
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)(((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", null, [_ctx.allRecordList.length > 0 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_timeline, {
      key: 0
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)(external_commonjs_vue_commonjs2_vue_root_Vue_.Fragment, null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.renderList)(_ctx.allRecordList, (activity, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_timeline_item, {
          key: index
        }, {
          default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_11, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            class: "recordAct-name"
          }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(activity.agentNickName), 513), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, activity.agentNickName != '' && activity.agentNickName != null]]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(activity.agentName), 1)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_12, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_13, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_space, {
            size: 4
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(activity.gmtCreate), 1), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.edit")), 1)]),
            _: 2
          }, 1024)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_14, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_button, {
            type: "primary",
            text: "",
            onClick: $event => _ctx.handleOpenChangeHis(activity),
            style: {
              "color": "#00a062"
            }
          }, {
            default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.viewCallLogs")), 1)]),
            _: 2
          }, 1032, ["onClick"])])])]),
          _: 2
        }, 1024);
      }), 128))]),
      _: 1
    })) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_15, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.noBusiness")), 1))])), [[_directive_loading, _ctx.recordLoading]])]),
    _: 1
  }, 8, ["modelValue", "title", "onClose"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.recordHistoryVisible,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => _ctx.recordHistoryVisible = $event),
    title: _ctx.i18n.global.t('dashboard.comment'),
    width: "540px",
    onClose: _ctx.handleCloseHistorys,
    "custom-class": "nx-el-dialog"
  }, {
    footer: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", nx_recordvue_type_template_id_1bf6efe7_hoisted_18, [_ctx.isEdit == false ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_button, {
      key: 0,
      onClick: _ctx.handleCloseHistorys
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("head.cancel")), 1)]),
      _: 1
    }, 8, ["onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), _ctx.isEdit == false ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)(_component_el_button, {
      key: 1,
      type: "primary",
      color: "#00A062",
      onClick: _ctx.enterSave
    }, {
      default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("head.confirm")), 1)]),
      _: 1
    }, 8, ["onClick"])) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true)])]),
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
      modelValue: _ctx.editRecordHistory,
      "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => _ctx.editRecordHistory = $event),
      "show-word-limit": true,
      maxlength: "200",
      rows: 4,
      type: "textarea",
      placeholder: _ctx.i18n.global.t('dashboard.enter'),
      disabled: _ctx.isEdit
    }, null, 8, ["modelValue", "placeholder", "disabled"]), _ctx.isEdit == true ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
      key: 0,
      class: "hanldChangeEdit",
      onClick: _cache[7] || (_cache[7] = (...args) => _ctx.enterEdit && _ctx.enterEdit(...args))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.edit")), 1)) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", nx_recordvue_type_template_id_1bf6efe7_hoisted_16, [_ctx.allRecordList.length > 1 ? ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", {
      key: 0,
      onClick: _cache[8] || (_cache[8] = (...args) => _ctx.handleOpenHistorys && _ctx.handleOpenHistorys(...args))
    }, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.revisionHistory")), 1)) : ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("span", nx_recordvue_type_template_id_1bf6efe7_hoisted_17, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.i18n.global.t("dashboard.revisionHistory")), 1))])]),
    _: 1
  }, 8, ["modelValue", "title", "onClose"]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_dialog, {
    modelValue: _ctx.onlyLookVisible,
    "onUpdate:modelValue": _cache[11] || (_cache[11] = $event => _ctx.onlyLookVisible = $event),
    title: _ctx.i18n.global.t('dashboard.comment'),
    width: "540px",
    onClose: _ctx.handleCloseOnly
  }, {
    default: (0,external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.createVNode)(_component_el_input, {
      modelValue: _ctx.onlyRecordHistory,
      "onUpdate:modelValue": _cache[10] || (_cache[10] = $event => _ctx.onlyRecordHistory = $event),
      "show-word-limit": true,
      maxlength: "200",
      rows: 4,
      type: "textarea",
      placeholder: _ctx.i18n.global.t('dashboard.enter'),
      disabled: ""
    }, null, 8, ["modelValue", "placeholder"])]),
    _: 1
  }, 8, ["modelValue", "title", "onClose"])])]);
}
;// CONCATENATED MODULE: ./src/package/nx-record/index.vue?vue&type=template&id=1bf6efe7
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-record/index.vue?vue&type=script&lang=js


/* unplugin-vue-components disabled */






/* harmony default export */ var nx_recordvue_type_script_lang_js = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "nx-record",
  props: ["isHeight"],

  setup() {
    const formRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    const audiosRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)({});
    const {
      t
    } = src_i18n.global;
    const recordState = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      queryGroupList: [],
      queryOptions: [],
      queryLoading: false,
      exportLoading: false,
      recordHistoryVisible: false,
      recordValueVisible: false,
      isEdit: true,
      editRecordHistory: "",
      cdrCcCode: "",
      recordLoading: false,
      onlyLookVisible: false,
      onlyRecordHistory: "",
      lang: ""
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      initDate();
      getRemoteGroup();
      recordState.lang = js_cookie.get("locale") == "zh-CN" ? "zh" : "en";
    });

    const initDate = () => {
      state.tableLoading = true;
      callLogList(state.recordSearch).then(response => {
        if (response.data.code === 0) {
          state.recordList = response.data.data.records;
          state.recordTotal = response.data.data.total;
          state.tableLoading = false;
        } else {
          state.tableLoading = false;
          index2_ElMessage.error(response.data.msg);
        }
      });
    };

    const getRemoteGroup = () => {
      allAgentGroupList({
        name: ""
      }).then(response => {
        if (response.data.code === 0) {
          recordState.queryOptions = response.data.data;
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    };

    const remoteMethod = query => {
      recordState.queryLoading = true;
      allAgentGroupList({
        name: query
      }).then(response => {
        if (response.data.code === 0) {
          recordState.queryLoading = false;
          recordState.queryGroupList = response.data.data;
          recordState.queryOptions = recordState.queryGroupList.filter(item => {
            return item.groupName.toLowerCase().includes(query.toLowerCase());
          });
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      }); // if (query) {
      // } else {
      //   recordState.queryOptions = [];
      // }
    };

    const clearGroup = () => {
      getRemoteGroup();
    };

    const numberInputChange = val => {
      state.recordSearch.number = val.replace(/[^\d]/g, "");
    };

    const defaultTime = [new Date(2000, 1, 1, 0, 0, 0), new Date(2000, 2, 1, 23, 59, 59)];
    const chooseDay = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);

    const handleChange = val => {
      const [pointDay] = val;
      chooseDay.value = pointDay;
    };

    const handleFocus = () => {
      chooseDay.value = null;
    };

    const disabledDate = time => {
      if (!chooseDay.value) {
        return false;
      }

      const timeRange = 30;
      const con1 = new Date(chooseDay.value).getTime() - timeRange * 24 * 60 * 60 * 1000;
      const con2 = new Date(chooseDay.value).getTime() + timeRange * 24 * 60 * 60 * 1000;
      return time < con1 || time > con2;
    };

    const changeCallTime = val => {
      if (val) {
        state.recordSearch.startDate = dayjs_min_default()(val[0]).format("YYYY-MM-DD HH:mm:ss");
        state.recordSearch.endDate = dayjs_min_default()(val[1]).format("YYYY-MM-DD HH:mm:ss");
      } else {
        state.recordSearch.startDate = undefined;
        state.recordSearch.endDate = undefined;
      }
    };

    const resetForm = () => {
      formRef.value.resetFields();
      state.recordCallTime = [dayjs_min_default()().startOf("day"), dayjs_min_default()().endOf("day")];
      state.recordSearch.startDate = dayjs_min_default()().startOf("day").format("YYYY-MM-DD HH:mm:ss");
      state.recordSearch.endDate = dayjs_min_default()().endOf("day").format("YYYY-MM-DD HH:mm:ss");
      state.recordSearch.current = 1;
      state.recordSearch.size = 10;
      getRemoteGroup();
    };

    const onSizeChange = val => {
      state.recordSearch.size = val;
      initDate();
    };

    const onPageChange = val => {
      state.recordSearch.current = val;
      initDate();
    };

    const onSearch = () => {
      state.recordSearch.size = 10;
      state.recordSearch.current = 1;
      initDate();
    };

    const exportAll = () => {
      recordState.exportLoading = true;
      let downLoadForm = {
        group: state.recordSearch.group,
        name: state.recordSearch.name,
        direction: state.recordSearch.direction,
        number: state.recordSearch.number,
        startDate: state.recordSearch.startDate,
        endDate: state.recordSearch.endDate
      };
      downloadHistory(downLoadForm).then(response => {
        exportFile(response);
        recordState.exportLoading = false;
      });
    };

    const onPlay = curIndex => {
      pauseOtherAudios(curIndex);
    };

    const pauseOtherAudios = excludeId => {
      state.recordList.forEach(item => {
        if (item.id !== excludeId) {
          audiosRef.value[item.id].pause();
        }
      });
    };

    const backListCall = row => {
      if (state.callStatus == null) {
        index2_ElMessage.warning(t("sip.dialerInitialization"));
        return;
      }

      if (state.callStatus === 0 || state.callStatus === 1 || state.callStatus === 2) {
        index2_ElMessage.warning(t("sip.inCall"));
        return;
      }

      state.numberVisible = true;
      state.callStatus = 0;
      let numbers = row.direction == 0 ? row.caller : row.callee;
      state.callNumber = numbers;

      if (state.nxwcall) {
        state.externalInfo = row;
        const nxwcallPlace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);

        if (row.didNumberId == null || row.didNumberId == 0) {
          nxwcallPlace.placeCall(numbers);
        } else {
          let hdrs = new Array(`X-NXCC-Out-Caller-Number:  ${row.direction == 0 ? row.callee : row.clientSipFrom}`, `X-NXCC-Out-Callee-Route: <sip:${row.remoteIp}:${row.sipPort}>`, `X-NXCC-Out-Callee-Prefix: ${row.callOutPrefix}`, `X-NXCC-Out-Remark: ${row.remark}`);
          nxwcallPlace.placeCall(numbers, hdrs);
        }
      }
    };

    const handleOpenModeifys = row => {
      // recordState.cdrCcCode = ''
      getCdrbusRecord({
        cdrCallId: row.sipCallId
      }).then(response => {
        if (response.data.code == 0) {
          state.allRecordList = response.data.data;
          recordState.recordHistoryVisible = true;

          if (state.allRecordList.length > 0) {
            state.busRecord.businessRecord = state.allRecordList[0].content;
            recordState.editRecordHistory = state.allRecordList[0].content;
          }

          recordState.cdrCcCode = row.sipCallId;
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    };

    const handleCloseModeifys = () => {
      recordState.recordValueVisible = false; // state.allRecordList = [];
    }; // 


    const handleOpenHistorys = value => {
      recordState.recordValueVisible = true;
    };

    const handleCloseHistorys = () => {
      recordState.recordHistoryVisible = false;
      recordState.isEdit = true;
      recordState.editRecordHistory = "";
    };

    const handleOpenChangeHis = value => {
      recordState.onlyRecordHistory = value.content;
      recordState.onlyLookVisible = true;
    };

    const handleCloseOnly = value => {
      recordState.onlyLookVisible = false;
      recordState.onlyRecordHistory = "";
    };

    const enterEdit = () => {
      recordState.isEdit = false;
    };

    const trimRecord = str => {
      return str.replace(/(^\s*)|(\s*$)/g, "");
    };

    const enterSave = () => {
      let contents = trimRecord(recordState.editRecordHistory);
      const postForm = {
        cdrCallId: recordState.cdrCcCode,
        content: contents
      };
      createCdrbusRecord(postForm).then(response => {
        if (response.data.code == 0) {
          index2_ElMessage.success(t("sip.savedSuccessfully"));
          recordState.isEdit = true;
          getCdrbusRecord({
            cdrCallId: recordState.cdrCcCode
          }).then(response => {
            if (response.data.code == 0) {
              state.allRecordList = response.data.data;

              if (state.allRecordList.length > 0) {
                state.busRecord.businessRecord = state.allRecordList[0].content;
              } else {
                state.busRecord.businessRecord = "";
              }
            } else {
              index2_ElMessage.error(response.data.msg);
            }
          });
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    };

    return { ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(state),
      ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(recordState),
      dayjs: (dayjs_min_default()),
      numberInputChange,
      changeCallTime,
      audiosRef,
      defaultTime,
      handleChange,
      handleFocus,
      disabledDate,
      resetForm,
      onSearch,
      exportAll,
      onSizeChange,
      onPageChange,
      onPlay,
      backListCall,
      formRef,
      remoteMethod,
      clearGroup,
      i18n: src_i18n,
      handleOpenModeifys,
      handleCloseModeifys,
      handleOpenHistorys,
      handleCloseHistorys,
      enterEdit,
      enterSave,
      handleOpenChangeHis,
      handleCloseOnly
    };
  }

}));
;// CONCATENATED MODULE: ./src/package/nx-record/index.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */ 
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-record/index.vue?vue&type=style&index=0&id=1bf6efe7&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/package/nx-record/index.vue?vue&type=style&index=0&id=1bf6efe7&lang=scss
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./src/package/nx-record/index.vue
/* unplugin-vue-components disabled */



;


const nx_record_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(nx_recordvue_type_script_lang_js, [['render',nx_recordvue_type_template_id_1bf6efe7_render]])

/* harmony default export */ var nx_record = (nx_record_exports_);
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-body/index.vue?vue&type=script&lang=js


/* unplugin-vue-components disabled */







/* harmony default export */ var nx_bodyvue_type_script_lang_js = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "nx-body",
  components: {
    NxRecent: nx_recent,
    NxRecord: nx_record
  },

  setup() {
    const {
      t
    } = src_i18n.global;
    const recordStatelang = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      recordStatelang.value = js_cookie.get("locale") == "zh-CN" ? "zh" : "en";
    });

    const isSelect = id => {
      state.isMenu = id;

      if (id === 1) {
        state.dialogWidth = 914;
      } else {
        state.dialogWidth = 1225;
      }
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => [state.isOpenSpeech, state.stopTimeval], val => {
      if (val[1] == true) {
        clearInterval(state.timers);
      } else {
        timeVal(state.statusValue);
      }

      if (val[0] == 1) {
        changeBodyStatus(state.statusValue);
        state.isOpenSpeech = null;
      }
    });

    const openBodyDialog = () => {
      state.bodyVisible = true;
    };

    const closeNarrow = () => {
      state.bodyVisible = false;
    };

    const timeVal = id => {
      clearInterval(state.timers);
      let timeNums = 0;
      state.timers = setInterval(() => {
        timeNums++;

        if (timeNums > 0 && timeNums % 5 == 0) {
          changeBodyStatus(id, -1);
        }
      }, 60000);
    };

    const changeBodyStatus = (value, num) => {
      let dateTime = dayjs_min_default()().utc(8).format("YYYY-MM-DD HH:mm:ss");
      let unixTime = dayjs_min_default()(dateTime).unix();
      let states = value == "Available" ? "Waiting" : "Idle";
      let statusForm = {
        agentName: state.userEmail,
        status: value,
        state: states,
        updateTime: unixTime
      };
      let tokens = state.setToken;
      changeSeatStatus(statusForm, tokens).then(response => {
        if (response.data.code == 0) {
          if (num != -1) {
            index2_ElMessage.success(t("head.successfullyModified"));
          }

          timeVal(value);
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    };

    return { ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(state),
      recordStatelang,
      isSelect,
      openBodyDialog,
      closeNarrow,
      changeBodyStatus,
      i18n: src_i18n
    };
  },

  directives: {
    drag(el) {
      const oDiv = el; // 
      // 

      document.onselectstart = function () {
        return false;
      };

      oDiv.onmousedown = function (e) {
        // 
        const disX = e.clientX - oDiv.offsetLeft;
        const disY = e.clientY - oDiv.offsetTop;

        document.onmousemove = function (e) {
          // 
          const l = e.clientX - disX;
          const t = e.clientY - disY; // 

          oDiv.style.left = l + "px";
          oDiv.style.top = t + "px";
        };

        document.onmouseup = function (e) {
          document.onmousemove = null;
          document.onmouseup = null;
        }; // return falsedivonmouseup
        // v-drag draggable="false"


        return false;
      };
    }

  }
}));
;// CONCATENATED MODULE: ./src/package/nx-body/index.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */ 
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-body/index.vue?vue&type=style&index=0&id=1a6351a2&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/package/nx-body/index.vue?vue&type=style&index=0&id=1a6351a2&lang=scss
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./src/package/nx-body/index.vue
/* unplugin-vue-components disabled */



;


const nx_body_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(nx_bodyvue_type_script_lang_js, [['render',nx_bodyvue_type_template_id_1a6351a2_render]])

/* harmony default export */ var nx_body = (nx_body_exports_);
// EXTERNAL MODULE: ./node_modules/dayjs/plugin/utc.js
var utc = __webpack_require__(2598);
var utc_default = /*#__PURE__*/__webpack_require__.n(utc);
// EXTERNAL MODULE: ./node_modules/js-md5/src/md5.js
var md5 = __webpack_require__(6655);
var md5_default = /*#__PURE__*/__webpack_require__.n(md5);
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-dial/index.vue?vue&type=script&lang=js


/* unplugin-vue-components disabled */










dayjs_min_default().extend((utc_default()));
/* harmony default export */ var nx_dialvue_type_script_lang_js = ((0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
  name: "nx-dial",
  components: {
    NxStatus: nx_status,
    NxBody: nx_body
  },
  props: ["options", "isMainShow", "paramOptions"],

  setup(props, ctx) {
    const numberRef = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const appType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)("");
    const setRemovePop = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(null);
    let currentUser = null;
    const {
      t
    } = src_i18n.global;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      state.isMainShow = props.isMainShow;

      if (localStorage.getItem("ccToken") && localStorage.getItem("ccUser")) {
        getInitApp(localStorage.getItem("ccUser"));
      } else {
        state.callStatus = -1;
      }

      Notification.requestPermission();
      window.addEventListener("beforeunload", e => beforeunloadFn(e));
    }); // watch(
    //   () => [props.options],
    //   (val) => {
    //     if (Object.keys(val[0]).length !== 0) {
    //       state.setToken = val[0].token;
    //       getInitApp();
    //     } else {
    //       ElMessage.warning("");
    //     }
    //   }
    // );

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => [props.paramOptions], val => {
      console.log("props.paramOptions", props.paramOptions);
      state.numberText = val[0].number;
      state.popVisible = val[0].visible;
    });

    const getVerifys = callback => {
      let info = {};
      getVerify().then(response => {
        if (response.code == 0) {
          info = {
            image: response.data.image,
            key: response.data.key
          };
          callback(info);
        } else {
          index2_ElMessage.error(response.message);
        }
      });
    };

    const loginSaas = async info => {
      appType.value = info.type;

      if (info.type == "mkt") {
        localStorage.setItem("ccToken", info.token);
        localStorage.setItem("ccUser", info.account);
        getInitApp(info.account, info.token, info.type);
      } else {
        const loginInfo = {
          email: info.email,
          password: info.password,
          loginMethod: 0,
          key: info.key,
          graphVerificationCode: info.graphVerificationCode
        };
        await saasLogin(loginInfo).then(response => {
          if (response.code == 0) {
            localStorage.setItem("ccToken", response.data.token);
            localStorage.setItem("ccUser", info.email);
            getInitApp(info.email, response.data.token);
            getDidExternal().then(res => {
              if (res.data.code == 0) {
                state.externalList = res.data.data;
                getExterNumber(state.externalList);
              } else {
                index2_ElMessage.error(res.data.msg);
              }
            });
          } else {
            index2_ElMessage.error(response.message);
          }
        });
      }
    };

    const loginOuts = () => {
      loginOut().then(response => {
        localStorage.removeItem("ccToken");
        localStorage.removeItem("ccUser");
        state.stopTimeval = true;
        state.stopTimeval = null;
        state.externalList = [];
        state.external.number = null;
        state.externalInfo = {};
        state.callStatus = -1;
        const disCall = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
        disCall.disconnect();
        setTimeout(() => {
          state.nxwcall = null;
          state.currentUser = null;
        }, 500);
      });
    };

    const loginOutsMkt = () => {
      localStorage.removeItem("ccToken");
      localStorage.removeItem("ccUser");
    };

    const getAudioVideo = constraintsData => {
      if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
      }

      if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function (constraints) {
          // getUserMedia
          var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; //  - errorpromisereject

          if (!getUserMedia) {
            return Promise.reject({
              code: 404
            });
          } // navigator.getUserMediaPromise


          return new Promise(function (resolve, reject) {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        };
      }

      return navigator.mediaDevices.getUserMedia(constraintsData);
    };

    const getInitApp = (username, token, types) => {
      let postForm = {
        agentName: username
      };
      getLogInfo(postForm).then(response => {
        if (response.data.code == 0) {
          let passWord = md5_default()(response.data.data.email + ":" + response.data.data.domain + ":" + response.data.data.utcDate);
          state.userEmail = response.data.data.email;
          state.sipNumber = response.data.data.sipNum;
          let sipFile = {
            nxuser: response.data.data.sipNum,
            nxpass: passWord,
            nxtype: 7,
            logLevel: "debug",
            retries: 0,
            playTone: 255,
            audioElementId: "remoteAudio",
            playElementId: "playAudio",
            audioSrcPath: "https://nxcc-sgp-test-1259196162.cos.ap-singapore.myqcloud.com/static/resource/audio",
            domain: response.data.data.domain,
            wssurl: response.data.data.url,
            ccAgent: response.data.data.email,
            ccToken: localStorage.getItem("ccToken"),
            ccQueue: response.data.data.groupNo
          };
          changeSipStatu("Available", "Waiting");
          state.statusValue = "Available";
          state.stopTimeval = false;
          initApp(sipFile);
          getAudioVideo({
            audio: true
          }).then(res => {
            console.log("");
          }).catch(err => {
            if (err.code && err.code == 404) {
              index2_ElMessage.warning(t("sip.notSupportMic"));
            } else {
              index2_ElMessage({
                showClose: true,
                duration: 10000,
                message: t("sip.isHaveMic"),
                type: "warning"
              });
            }
          });
        } else if (response.data.code === 403) {
          removeItem(1);
          index2_ElMessage.error(response.data.msg);
          return;
        } else if (response.data.code === 407) {
          removeItem(2);

          if (types != "mkt") {
            index2_ElMessage.error(response.data.msg);
          }

          return;
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    }; // token


    const removeItem = type => {
      if (type == 1) {
        ctx.emit("isLogin", {
          islogin: false
        });
      } else {
        ctx.emit("isLogin", {
          isHaveSeat: false
        });
      }
    };

    const loginOk = () => {
      ctx.emit("loginOk", {
        onRegistered: true
      });
    };

    const getExterNumber = externalList => {
      if (externalList.length > 0) {
        if (localStorage.getItem("externalNumber") && parseInt(localStorage.getItem("externalNumber")) != 0) {
          for (let i = 0; i < externalList.length; i++) {
            if (externalList[i].id == parseInt(localStorage.getItem("externalNumber"))) {
              state.external.number = externalList[i].id;
              state.callDidNumber = externalList[i].number;
              state.externalInfo = externalList[i];
              break;
            } else {
              state.external.number = externalList[0].id;
              state.callDidNumber = externalList[0].number;
              state.externalInfo = externalList[0];
            }
          }
        } else {
          for (let i = 0; i < externalList.length; i++) {
            if (externalList[i].id == 0) {
              state.external.number = 0;
              state.callDidNumber = null;
              state.externalInfo = {};
              break;
            } else {
              state.external.number = externalList[0].id;
              state.callDidNumber = externalList[0].number;
              state.externalInfo = externalList[0];
            }
          }
        }
      } else {
        state.external.number = null;
        state.externalInfo = {};
      }
    };

    const showElPopover = () => {
      getDidExternal().then(response => {
        if (response.data.code == 0) {
          state.externalList = response.data.data;
          getExterNumber(state.externalList);
        } else {
          index2_ElMessage.error(response.data.msg);
        }
      });
      state.isMenuAct = 2;
    };

    const hideElPopover = () => {
      state.isMenuAct = 1;
    };

    const changeExternal = val => {
      localStorage.setItem("externalNumber", val);

      if (val != 0) {
        state.externalList.forEach(item => {
          if (val == item.id) {
            state.externalInfo = item;
            state.callDidNumber = item.number;
          }
        });
      } else {
        state.externalInfo = {};
      }
    };

    const initApp = sipFile => {
      console.log("", sipFile);
      const profile = sipFile;
      aegis.setConfig({
        uin: state.sipNumber
      });

      if (currentUser !== state.sipNumber) {
        if (state.nxwcall) {
          state.nxwcall.disconnect(); // delete nxwcall

          state.nxwcall = null;
        }

        currentUser = state.sipNumber;
      } // 


      if (state.nxwcall == null) {
        state.nxwcall = new (nxwebrtc_default())(profile);
        const initNxw = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
        setupEvents(initNxw);
      }
    }; // events


    const list = [];

    const setupEvents = nxwcall => {
      if (nxwcall == null) {
        return;
      }

      const e = nxwcall.myEvents;
      let callTimer;
      e.on("onCallCreated", function (param1) {
        console.log("================", "onCallCreated", param1);
        state.callStatus = 0;
        state.stopTimeval = true;
        changeSipStatu("Available", "Receiving");
        list.push({
          ts: new Date(),
          key: "onCallCreated",
          value: param1
        });
      });
      e.on("onCallAnswered", function (param1) {
        console.log("================", "onCallAnswered", param1); // 

        changeSipStatu("Available", "In a queue call");
        callTimer = setInterval(() => {
          const t = nxwcall.talkingTime / 1000;
          const time = Math.floor(t);
          state.isTimer = parseInt(time);
          state.talkCallTime = common_format(parseInt(time));
        }, 1000);
        state.callStatus = 2;
        state.isReject = 1;
        list.push({
          ts: new Date(),
          key: "onCallAnswered",
          value: param1
        });
      });
      e.on("onCallReceived", function (param1) {
        console.log("================", "onCallReceived", param1);
        changeSipStatu("Available", "Receiving");
        let notification = new Notification("", {
          body: t("sip.newCalleeIn"),
          icon: "https://nxcc-gz-1259196162.cos.ap-guangzhou.myqcloud.com/static/resource/img/logo.svg" // "favicon"

        });

        notification.onclick = function () {
          window.focus(); // 
        };

        state.stopTimeval = true;
        const paramNum = param1.split("@")[0];
        state.callNumber = paramNum;
        state.callStatus = 1;
        state.isCalling = 0;
        state.numberVisible = true;
        state.recordCallId = nxwcall.lastCcCallId;

        if (nxwcall.lastRequest) {
          state.externalInfo.remark = nxwcall.lastRequest.getHeader("X-NXCC-In-Remark");
        }

        state.isCallingList = {
          number: state.callNumber,
          status: t("sip.inCall"),
          sipCallId: nxwcall.lastCcCallId,
          remark: nxwcall.lastRequest ? nxwcall.lastRequest.getHeader("X-NXCC-In-Remark") : ""
        };
        state.recetCallDetail = {
          number: state.callNumber,
          status: t("sip.inCall"),
          remark: nxwcall.lastRequest ? nxwcall.lastRequest.getHeader("X-NXCC-In-Remark") : ""
        };
        list.push({
          ts: new Date(),
          key: "onCallReceived",
          value: param1
        });
      }); // callid

      e.on("onAccept", function (param1) {
        console.log("===========", "onAccept", param1);
        state.stopTimeval = true;
        state.recordCallId = nxwcall.lastCcCallId;
        state.isCallingList = {
          number: state.callNumber,
          status: t("sip.inCall"),
          sipCallId: nxwcall.lastCcCallId,
          remark: Object.keys(state.externalInfo).length != 0 ? state.externalInfo.remark : ""
        };
        state.recetCallDetail = {
          number: state.callNumber,
          status: t("sip.inCall")
        };
      });
      e.on("onCallHangup", function (param1) {
        console.log("===========", "onCallHangup", param1);
        state.isOpenSpeech = 1;
        state.stopTimeval = false;
        clearInterval(callTimer);

        if (state.isTimer > 0) {
          state.callStatus = 5;
          state.isCallingList = {
            number: state.callNumber,
            duration: state.talkCallTime,
            sipCallId: state.recordCallId,
            status: t("dashboard.hangUp"),
            remark: Object.keys(state.externalInfo).length != 0 ? state.externalInfo.remark : ""
          };
        } else {
          state.callStatus = 4;
        }

        aegisEvent();
        state.talkCallTime = "00:00:00";
        state.numberVisible = false;
        state.narrowVisible = false; // visible.value = true
        // state.externalInfo = {};
        // state.numberText = "";

        list.push({
          ts: new Date(),
          key: "onCallHangup",
          value: param1
        });
      }); // 

      e.on("onReject", function (param1) {
        // ,sip
        switch (nxwcall.lastCcCode) {
          case "810":
            index2_ElMessage.error(t("sip.dialerOverdue"));
            break;

          case "811":
            index2_ElMessage.error(t("sip.notCountry"));
            break;

          case "812":
            index2_ElMessage.error(t("sip.errNumber"));
            break;

          case "813":
            index2_ElMessage.error(t("head.tokenExpired"));
            break;

          case "814":
            index2_ElMessage.error(t("seeting.blacklistedNumberTip"));
            break;

          case "815":
            index2_ElMessage.error(t("seeting.callFailureLimit"));
            break;

          case "816":
            index2_ElMessage.error(t("seeting.cannotNumber"));
            break;

          case "800":
            index2_ElMessage.error(t("sip.networkError"));
            break;

          case "801":
            index2_ElMessage.error(t("sip.networkError"));
            break;

          default:
            break;
        }
      });
      e.on("onRegistered", function (param1) {
        console.log("================", "onRegistered", param1);
        index2_ElMessage.success(t("sip.dialer") + " " + param1 + " " + t("sip.registerSuccessfully"));
        state.isSuccess = true;
        state.callStatus = 4;
        state.isLoginSuccess = 1;
        loginOk();
        aegis.reportEvent({
          name: `${param1}-` // 

        });
        list.push({
          ts: new Date(),
          key: "onRegistered",
          value: param1
        });
      });
      e.on("onServerConnect", function (param1) {
        console.log("================", "onServerConnect", param1);
        list.push({
          ts: new Date(),
          key: "onServerConnect",
          value: param1
        });
      });
      e.on("onConnectOK", function (param1) {
        console.log("================", "onConnectOK", param1);
        list.push({
          ts: new Date(),
          key: "onConnectOK",
          value: param1
        });
      });
      e.on("onRegisterOK", function (param1) {
        console.log("================", "onRegisterOK", param1);
        list.push({
          ts: new Date(),
          key: "onRegisterOK",
          value: param1
        });
      });
      e.on("onUnregistered", function (statusCode) {
        // starisLoginSuccess1
        if (state.isLoginSuccess != 1 || statusCode == "403") {
          if (statusCode == "403") {
            index2_ElMessage.error(t("head.tokenExpired"));
            localStorage.removeItem("ccToken");
            localStorage.removeItem("ccUser");
          }

          const disCall = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
          disCall.hangupCall();
          disCall.disconnect();
          state.numberVisible = false;
          state.narrowVisible = false;
          state.isSuccess = false;
          state.callStatus = -1;
          aegis.reportEvent({
            name: `${state.sipNumber}-` // 

          });
        } else {
          initApp();
        }
      });
      e.on("error", function (param1) {
        console.log("================", "error", param1);
        state.isSuccess = false;
        localStorage.setItem("ccToken", response.data.token);
        localStorage.setItem("ccUser", info.email);
        list.push({
          ts: new Date(),
          key: "error",
          value: param1
        });
      });
    }; // 


    const aegisEvent = () => {
      if (state.isTimer > 0) {
        aegis.reportEvent({
          name: `-${state.callNumber}-${state.talkCallTime}` // 

        });
      } else if (state.isReject == 2 && state.isCalling == 0) {
        aegis.reportEvent({
          name: `-${state.callNumber}` // 

        });
      } else if (state.isReject == null && state.isCalling == 0) {
        aegis.reportEvent({
          name: `-${state.callNumber}` // 

        });
      } else {
        aegis.reportEvent({
          name: `-${state.callNumber}` // 

        });
      }

      state.isTimer = null;
      state.isReject = null;
    };

    const callPhone = () => {
      if (state.callStatus == -1) {
        index2_ElMessage.warning(t("sip.noDialerInformation"));
        return;
      }

      if (state.callStatus == null) {
        index2_ElMessage.warning(t("sip.dialerInitialization"));
        return;
      }

      if (state.numberText !== "") {
        if (appType.value == "mkt") {
          setRemovePop.value.hide();
        }

        if (state.callStatus === 0 || state.callStatus === 1 || state.callStatus === 2) {
          index2_ElMessage.warning(t("sip.inCall"));
          return;
        }

        state.numberVisible = true;
        state.popVisible = true;
        state.callNumber = state.numberText;
        state.callStatus = 0;
        state.isCalling = 1;

        if (state.nxwcall) {
          const nxwcallPlace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);

          if (state.externalInfo.type == 0 && state.external.number != 0) {
            let hdrs = new Array(`X-NXCC-Out-Caller-Number:  ${state.callDidNumber}`, `X-NXCC-Out-Callee-Route: <sip:${state.externalInfo.remoteIp}:${state.externalInfo.sipPort}>`, `X-NXCC-Out-Callee-Prefix: ${state.externalInfo.callOutPrefix}`, `X-NXCC-Out-Remark: ${state.externalInfo.remark}`);
            nxwcallPlace.placeCall(state.numberText, hdrs);
          } else {
            nxwcallPlace.placeCall(state.numberText);
          }

          state.numberText = ""; // state.external.number = "";
        }
      } else {
        index2_ElMessage.warning(t("sip.enterNumber"));
      }
    };

    const checkCallTest = value => {
      // setRemovePop.value.hide();
      if (state.callStatus === 0 || state.callStatus === 1 || state.callStatus === 2) {
        index2_ElMessage.warning(t("sip.inCall"));
        return;
      }

      state.numberVisible = true;
      state.callStatus = 0;
      state.callNumber = value;
      state.isCalling = 1;

      if (state.nxwcall) {
        const nxwcallPlace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
        nxwcallPlace.placeCall(value);
      }
    };

    const phoneInputChange = val => {
      state.numberText = val.replace(/[^\d]/g, "");
    };

    const clickKeyBoardNumberKey = num => {
      const nxwcallDtmf = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
      let nums = "";

      if (num == "*") {
        nums = "star";
      } else if (num == "#") {
        nums = "hash";
      } else {
        nums = num;
      }

      nxwcallDtmf.play("start", `${nums}.wav`);

      if (state.callStatus == 2) {
        nxwcallDtmf.sendDTMF(num.toString());
      }

      state.numberText += num;
      numberRef.value.focus();
    };

    const deleteNumber = () => {
      state.numberText = state.numberText.slice(0, -1);
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      window.removeEventListener("beforeunload", e => beforeunloadFn(e));
    });

    const beforeunloadFn = () => {
      const hanups = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);
      hanups.hangupCall();
    }; // 


    const changeSipStatu = (status, states) => {
      let dateTime = dayjs_min_default()().utc(8).format("YYYY-MM-DD HH:mm:ss");
      let unixTime = dayjs_min_default()(dateTime).unix();
      let statusForm = {
        agentName: state.userEmail,
        status: status,
        state: states,
        updateTime: unixTime
      };
      changeSeatStatus(statusForm).then(response => {
        if (response.data.code == 0) {} else {
          index2_ElMessage.error(response.data.msg);
        }
      });
    }; // 


    const getNumToCall = numberOptions => {
      if (state.callStatus == -1) {
        index2_ElMessage.warning(t("sip.noDialerInformation"));
        return;
      }

      if (state.callStatus == null) {
        index2_ElMessage.warning(t("sip.dialerInitialization"));
        return;
      }

      if (numberOptions.callee != null || numberOptions.callee != "") {
        if (state.callStatus === 0 || state.callStatus === 1 || state.callStatus === 2) {
          index2_ElMessage.warning(t("sip.inCall"));
          return;
        }

        state.numberVisible = true;
        state.callNumber = numberOptions.callee;
        state.callStatus = 0;
        state.isCalling = 1;

        if (state.nxwcall) {
          const nxwcallPlace = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRaw)(state.nxwcall);

          if (numberOptions.type == 1) {
            let hdrs = new Array(`X-NXCC-Out-Caller-Number:  ${numberOptions.caller}`, `X-NXCC-Out-Callee-Route: <sip:${state.externalInfo.remoteIp}:${state.externalInfo.sipPort}>`, `X-NXCC-Out-Callee-Prefix: ${state.externalInfo.callOutPrefix}`, `X-NXCC-Out-Remark: ${numberOptions.remark}`);
            nxwcallPlace.placeCall(numberOptions.callee, hdrs);
          } else {
            nxwcallPlace.placeCall(numberOptions.callee);
          }

          state.numberText = ""; // state.external.number = "";
        }
      } else {
        index2_ElMessage.warning(t("sip.enterNumber"));
      }
    };

    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.defineExpose)({
      getVerifys,
      loginSaas,
      loginOuts,
      loginOutsMkt
    });
    return { ...(0,external_commonjs_vue_commonjs2_vue_root_Vue_.toRefs)(state),
      numberRef,
      setRemovePop,
      appType,
      phoneInputChange,
      clickKeyBoardNumberKey,
      deleteNumber,
      callPhone,
      showElPopover,
      checkCallTest,
      md5: (md5_default()),
      getVerifys,
      loginSaas,
      loginOuts,
      changeExternal,
      loginOutsMkt,
      getNumToCall,
      i18n: src_i18n,
      hideElPopover
    };
  }

}));
;// CONCATENATED MODULE: ./src/package/nx-dial/index.vue?vue&type=script&lang=js
/* unplugin-vue-components disabled */ 
;// CONCATENATED MODULE: ./node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-auto-import!./node_modules/unplugin-vue-components/node_modules/unplugin/dist/webpack/loaders/transform.js?unpluginName=unplugin-vue-components!./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-64.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/package/nx-dial/index.vue?vue&type=style&index=0&id=a9601268&lang=scss
/* unplugin-vue-components disabled */// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/package/nx-dial/index.vue?vue&type=style&index=0&id=a9601268&lang=scss
/* unplugin-vue-components disabled */
;// CONCATENATED MODULE: ./src/package/nx-dial/index.vue
/* unplugin-vue-components disabled */



;


const nx_dial_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(nx_dialvue_type_script_lang_js, [['render',render]])

/* harmony default export */ var nx_dial = (nx_dial_exports_);
;// CONCATENATED MODULE: ./src/package/index.js
 // 

 // 

 // 

const coms = [nx_dial, nx_status, nx_body]; // ,
// 

const package_install = function (Vue) {
  coms.forEach(com => {
    Vue.component(com.name, com);
  });
};

/* harmony default export */ var src_package = (package_install); // use
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (src_package);


}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});